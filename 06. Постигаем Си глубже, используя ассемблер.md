


Также читайте:

   structure programm in memory
   Структура памяти C-программ


---

**Перекрестные ссылки** (или просто XREF) — это функция дизассемблеров, позволяющая показать вам, откуда были вызваны определенные функции и объекты или какие функции и объекты используются конкретной функцией. Мы можем упростить его, назвав его XREF-To и XREF-From. Ссылка может быть либо данными, либо кодом.

---

# Вывод строки на экран

Если мы хотим вывести строку на экран на языке ассемблер, то мы используем прерывание в котором указываем номер прерывания с помощью которого система находит нужные данные с определённых регистров. В оновном это регистры общего назначения. Про всё это можно читайте подробнее в интернете и в книгах про ассемблер

В языке Си мы используем стандартные библиотеки в которых уже есть готовые функции такие как `printf`, `puts` и т.д.  для того чтобы вывести строку на экран. 

```
printf("Hello World!\n");
```


В отладчике:

```
lea rax, str.Hello_World_   ; 0x201c ; "Hello World!"  
mov rdi, rax                ; const char *s  
call sym.imp.printf         ; int puts(const char *s)  
```

- **lea rax, str.Hello_World_** - Помещаем в регистр rax адрес строки “Hello World!” ; 0x201c .

- **mov rdi, rax** - Указываем на строку которую хотим вывести . ; const char *s

- **call sym.imp.printf** - Вызываем функцию который должен вывести указанную строку ; int puts(const char *s) . В нашем случае это функция imp.puts – Он выводить что либо.

  
_**Регистр**_ **DI**. Этот регистр является _**индексом назначения**_ и применяется также для строковых операций.

И так, чтобы вывести какую нибудь строку на экран, нам нужно:  поместить его адрес в регистр DI, а потом вызвать функция который выведет нашу строку на экран (printf, puts и т.д.). Функция для вывода строки обращается к нужному регистру и извлекает от туда строку. Сама строка находится в сегменте .data и их аналога.

Если мы в функции printf() закинем строку которую нужно выводить, то на деле это будет звучить где-то так:


1.  Поместить адрес строки в регистр DI
    
2.  Вызвать функцию printf() - или любая другая функция которая будет выводить нашу строку.
    

Всё как мы и сказалт. Строка Hello World! находится по адресу 0x2004, закидываем этот адрес в регистр DI и вызываем функцию для вывода строки. По адресу 0x2004 у нас находится область памяти (в сегменте .data) именированная под .string в которой и находится наша строка Hello World! . Это просто область памяти в которой была записана наша строка.


Если мы создадим переменную и дадим ей значение, а после в функции printf() укажем название переменной для вывода её значение, то на деле это будет звучить так:

  

1.  Освободить место в верхушке стека
    
2.  Именириуем освобожденные места
    
3.  Закидываем строку (по частям) в какой нибудь регистр, а потом в освобожденный область памяти, или же сразу в освобожденный область памяти
    
4.  Записать начальный адрес освобожденного область памяти в регистр DI
    
5.  Вызвать функцию для вывода строки
    


И так мы освободили 0x10 = 22d байт памяти в стеке. Записываем первые 8-байт нашей строки в регистр rax, а с регистра rax в область памяти именируемый под называнием formar. После записываем следующий 4-байт нашей строки в область памяти именируемый под названием var_5h, и область памяти var_1h остается пустым, поэтому заполняем его нулями. Кидаем начальный адрес освобожеденной область памяти, где от-куда началась запись данных в регистр DI, и вызываем функцию для вывода строки.

Можно понять что format - var_1h – это и есть наша освобожденная памяти, разнициа лишь в областе, var_1h продолжение (другая часть) памяти format.

**Заключение**

И так, можно понять что, если мы в функции printf() сразу кидаем строку, то ядро не будет искать эту строку с неба, а это строка будет сначало записан в какой нибудь область памяти (в сегменте .data), после чего его адрес будет вычислятся или (или сама строка будет где-то записан в зависимости от типа инструкции – mov, lea) для дальнейшее операции .

Но если наша строка находится в переменной, а в функции printf() мы кидаем название переменной, то ядро сначало освобождает место в стеке, после чего именирует освобожденное место в стеке, дальше после именированние кидает в память (место которое мы освободили) строку, и начало адрес памяти в который была записана строка (от-куда) будет записывает в регистр DI. После чего будет вызвана функция printf().


Да это всего лишь вывод на экран и функция printf(), но это о многом говорить – откуда процессор берет данные и это конечно же многое обьясняет.

Если вы увидите вот такой код:

```
lea rax, str.String
```

  
То знайте, где-то то там в памяти (в сегменте .data) записана наша строка и нам нужен адрес где наченается наша строка для вывода, после чего значение rax будет записан в регистр DI и вызов функции для работы строк.

  
----

# Условный переход

Код в C:

```
if(key == 1){
    printf("This is test!\n");
}
```

То есть если значение переменной key равняется цыфрой 1, то выводим строку "This is test!".

Код в отладчике:

```
cmp dword [var_4h], 1  
jne 0x121f  
lea rax, str.This_is_test_  ; 0x2029 ; "This is test!"  
mov rdi, rax                ; const char *s  
call sym.imp.puts           ; int puts(const char *s)  
```


**CMP** сравнивает два оперенда путем вычитание, и если оперенды равны то результат будет 0 и флаг ZF устанавливается и перехода не будет.

**cmp dword [var_4h], 1 –** Сравниваем значение область памяти (переменной) var_4h с числом 1 . Если результат равен нулю, то ЧИСЛО1 = ЧИСЛО2. Если числа равны, то есть результат равен 0, то устанавливается флаг ZF.

**jne 0x121f -** Перейти, если не равно (ZF = 0). В нашем случае если true, то блок кода пропускается. По адресу 0x121f стоит конец условии, то есть его завершении, и если результат равен нулю, флаг ZF = 1, то переходим по адресу 0x121f – это означает что условия пропускается.

**lea rax, str.This_is_test_** - Если флаг ZF = 1, то это означает что jne = false (не переходим никуда, а выполняем условие). В этом случае мы помещаем в rax адрес строки. ; 0x2029 ; "This is test!"

**mov rdi, rax** - Помещаем в rdi значение регистра rax, чтобы вывести строку. ; const char *s

**call sym.imp.puts** - Вызываем функцию для вывода строки. ; int puts(const char *s)


Вот граф:
![[e.png]]


Как можно увидеть, если чило1 == число2 (ZF = 1), то в этом случае jne = false - выполняется определённый блок кода, а если число1 != число2 (ZF = 0), то в этом случае jne = true - блок кода пропускается. Простыми словами если наше условия истино (ZF = 1, jne = false) то не переходим никуда, а выполняем блок кода, а если условие ложно (ZF = 0, jne = true), то наш блок кода пропускается.

Да знаю, все немного запутанно, но просто знайте что если:

```
cmp n1, n2

n1 == n2 (ZF = 1, jne = false) ; если jne ложно, то выполняется условия.
n1 != n2 (ZF = 0, jne = true ) ; если jne истино, то блок кода пропускается.
```

Вы заметили что мы использовали для записи данных только два регистра – rax и rdx. Сначало мы переместили данные в эти регистры, а потом с этих регистров копировали их в область памяти.

---

# Вызов функции

**call sym.call_me -** Вызов функции call_me()

Код на C:

```c
call_me();
```

В отладчике:

```c
call sym.call_me  
```


**Загляним что внутри функции call_me().

Код на C:

```
void call_me(){  
  
      int age = 5;  
      char name[10] = "Alex";  
      printf("%s", "This is other function!\n");  
}  
```


В отладчике:

![[p.png]]

var_4h – Это переменная age. Он был занесён в стек самым первым поэтому он в стеке находится в самом внизу.

var_eh – var_6h - Это переменная name. Он был занесён в стек после переменной age, поэтому он стоит с вреху переменной age.
  

Если переменные в стеке кладуться как тарелки, вот иснтрукции будут выполнятся в таком же виде как и в исходном коде. Например – Мы сначало дали значение переменной age, после переменной age мы дали значение переменной name. Хотя в стеке переменная name стоит с верху переменной age.


---



# Доступ к данным в памяти

Когда мы записываем данные, например в размере 10-байт, то инструкция будет выглядить  примерно так:

```
mov qword [данные]
mov word  [данные+8]
```

Напомню, такое ограничение из за регистра. Стек растёт в сторону уменьшение адресов, то есть стек в памяти растет сверху вниз, это значит что **при добавлении значения в него адрес вершины стека уменьшается, а когда вы извлекаете из него, то адрес вершины стека увеличивается**. Теперь кратко рассмотрим что такое регистры. Это ячейки памяти в самом процессоре.  Другими словами ebp ( указатель дно стека) находится на верху, а esp (указатель вершины стека) находиться в самом внизу. 

Допустим у меня переменная name:

```c
char name[] = "Alex";
```

То под дебагером мы можем видет:

```
22: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_5h @ rbp-0x5  
│           ; var int64_t var_1h @ rbp-0x1  
│           0x00001129      55             push rbp  
│           0x0000112a      4889e5         mov rbp, rsp  
│           0x0000112d      c745fb416c65.  mov dword [var_5h], 0x78656c41 ; 'Alex'  
│           0x00001134      c645ff00       mov byte [var_1h], 0  
│           0x00001138      b800000000     mov eax, 0  
│           0x0000113d      5d             pop rbp  
└           0x0000113e      c3             ret
```

Тут

```
x - ebp-2 (5-2) = 0x30
e - ebp-3 (5-3) = 0x29
l - ebp-4 (5-4) = 0x28
A - ebp-5 (5-5) = 0x27
```

var_5h это тоже самое что и rbp-0x5. Это указатель начала стекового кадра (начало адреса от куда должны записаться данные), а -5  значит на 5 байт ниже. Это значить что значение записывается начиная c rbp-0x5 до rbp-0x0. 

![[Pasted image 20230604075346.png]]

![[Pasted image 20230604075520.png]]





---

![[Pasted image 20221210135817.png]]


В левой части находится ассемблерный код (инструкции), в правом верхнем - исходный код, а в правом нижнем наш код был скомпилирован и запущен(результат).




---

## Аргументы командной строки

  

![[acs.png]]

**Исходник**

И так, это простая программа которая требует только 2 аргумента командной строки, если аргумент больше чем 2, то получаем сообщение об ошибке (Error!), а если аргумент командной строки меньше чем 2, тоже самое – получаем сообщение об ошибке (Error!) . Чтобы получить строку об успешной завершении программы (Success!), у нас должен быть ровно 2 аргумента командной строки.

**Отладчик**

На уровни ассемблера всё звучить вот так – Освободить место в стеке, именировать освобожденные места чтобы была проще с ними работать, записать значение регистра edi в память var_4h, записать значение регитра rsi в память var_10h. Суди по всему в регистре edi находился значение argc, а в регистре rsi находился значение argv. Регисты rsi и rdi нам еще понадобиться для работы со строкой, их значение записываются в другом месте чтобы не потерять их. Тем более это регисты общего назначение. Сравнить значение var_4h с числом 2. Как мы помним, в памяти var_4h нaходиться значение argc. Если значение var_4h равен число 2, то программа делает прыжок по адресу 0x1177 - По этому адресу наченается вывод сообщение об успешной завершении программы (Success!) и выходим из программы вызовом функции exit(). Если значение var_4h не равно 2, то наченаем выводить сообщение об ошибке (Error!) после чего выходим из программы вызовом функции exit().

**Графика**

![[Pasted image 20230105135928.png]]


Посмотрите пример выще, там условие и используется инструкция **je** для прыжка. Ну давайте ка всё по порядку. В примере выще в регистр edi кидается число (количество аргументов командной строки). Сравниваем значение регистра edi с числом 2 после чего вызываем инструкция je. 

JE -  переход если условние равно. После сравнение, если условие равно (аргумент командной строки == 2) то переходим по указанному адресу, в противном случае переход не выполняется.

---

# Циклы 

Циклы позволяют выполнять некоторое действие в зависимости от соблюдения некоторого условия. Другими словами, Циклы — управляющая конструкция, которая дает возможность выполнять определенный участок кода многократно.

**Цикл for** 

Цикл for используется для перебора последовательности (то есть списка, кортежа, словарь, набор или строка).

![[Screenshot_20230106_094158.png]]

На скрине выще мы видим исходный код, код программы в отладчике и результат выполнение программы. Это простой цикл который проверяет значение переменной с числом 0xa (10d). Если значение меньше числа то выводим строку "Hello World!". 


---


**Логика работы**

Есть сегментные регистры, которые будут указывать на начало сегментов. Да и в коде можно переключаться с одного сегмента на другой с помощью директивы section или segment, a компилятор сам расставит всё как надо.

Теперь смотрите на фрагмент инструкии:

```
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, len 
```

Теперь на другой фрагмент  инструкции:

```
mov edx,  len
mov ecx,  msg
mov ebx,  1
mov, eax, 4
```

Они оба правильные, но как программа не даёт сбой? Ведь инструкции написаны сверху вниз(

Инструкции будут выполнятся сверху вниз 

А как? Вывод же будет одинаковым - Потому-что у тебя операции взаимодействуют с разными регистрами. Попробуй сделать логику с cmp и условными переходами - всё пойдёт по `пи*де.

Как компилятор понимает что нужно читать снизу вверх? По регистрам что ли ? - Он никак не понимает. Просто у тебя код удачный, и в нём не важен порядок.

Смотрите. У тебя изменяются разные регистры. Теперь попробуй сделать такую штуку: 
  
  Попробуй сделать две строки msg1 с длиной len1 и msg2 с длиной len2. Потом напиши код, который выводит строки поочерёдно. Потом возьми этот же код и напиши в обратном порядке. Строки должны быть разными

В коде не важен порядок, потому что в каждой строке значения перемещаются в разные регистры и не происходит никаких вызовов.

Пример в С:

```
int a = 4;
int b = 1;
char* c = msg;
unsigned d = len;
```

А теперь наоборот:

```
unsigned d = len;
char* c = msg;
int b = 1;
int a = 4;
```

А теперь пойми почему даже при перестановке этот код сделает одно и то же. В коде не важен порядок, потому что в каждой строке значения перемещаются в разные регистры и не происходит никаких вызовов.

Прежде чем вызывать какой нибудь системный вызов или функцию, мы должны поместить в определённые регистры параметры, чтобы функция понял от куда взять данные. Потом функция сама извлекает данные с регистра и начинает операцию над ним.


**Важно понять**

Что картина меняться при оптимизации программы, да и многих других факторов. Например у меня в компиле без оптимизации сначала в стек заносится строка через цикл, а потом число. с оптимизацией строка также заносится, но число в стек не кладется явно как лок. переменная и не выделяется место, а просто пушится перед вызовом принтф (чтоб переменная использовалась). Если эти переменные нигде не используются, то строка все равно заносится в стек через цикл, а число никак не пушится.

