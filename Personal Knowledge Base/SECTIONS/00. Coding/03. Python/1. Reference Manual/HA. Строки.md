# Строки в Python

Строки в Python - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

Строки в Python заключаются либо в одинарные, либо в двойные кавычки.

"Hello" — это то же самое, что 'Hello' .

Вы можете отобразить строковый литерал с помощью `print()` функция:

```
print("Hello")  
print('Hello')
```

**Результат:

`Hello
`Hello

--- 

## Присвоить строку переменной

Присвоение строки переменной выполняется с именем переменной, за которым следует знак равенства и строка:

```
a = "Hello"  
print(a)
```

**Результат:

`Hello 

---

## Многострочные строки

Вы можете назначить многострочную строку переменной, используя три кавычки:

Вы можете использовать три двойных кавычки:

```
a = """Lorem ipsum dolor sit amet,  
consectetur adipiscing elit,  
sed do eiusmod tempor incididunt  
ut labore et dolore magna aliqua."""  
print(a)
```

Или три одинарных кавычки:

```python
a = '''Lorem ipsum dolor sit amet,  
consectetur adipiscing elit,  
sed do eiusmod tempor incididunt  
ut labore et dolore magna aliqua.'''  
print(a)
```

---

## Строки — это массивы

Как и во многих других популярных языках программирования, строки в Python представляют собой массивы байтов (символов), представляющие символы Юникода.

Однако в Python нет символьного типа данных, один символ — это просто строка длиной 1.

Квадратные скобки можно использовать для доступа к элементам строки.

Получить символ в позиции 1 (помните, что первый символ имеет позиция 0):

```python
a = "Hello, World!"  
print(a[1])
```

**Результат:**
`e

---

## Перебор строки

Поскольку строки являются массивами, мы можем перебирать символы в строке с помощью `for`петля.

Перебери буквы в слове «банан»:

```python
for x in "banana":  
  print(x)
```

**Результат:

```python
b  
a  
n  
a  
n  
a
```

Узнайте больше о циклах For в нашей [Python For Loops .](https://www.w3schools.com/python/python_for_loops.asp) главе

---

## Длина строки

Чтобы получить длину строки, используйте `len()`функция.

The `len()` Функция возвращает длину строки:

```python
a = "Hello, World!"  
print(len(a))
```

**Результат:

`13

---

## Проверить строку

Чтобы проверить, присутствует ли в строке определенная фраза или символ, мы можем использовать ключевое слово `in`.

Проверьте, присутствует ли слово «бесплатно» в следующем тексте:

```python
txt = "The best things in life are free!"  
print("free" in txt)  
```

**Результат:

`True

Используйте его в `if` утверждение:

Печатать, только если присутствует «свободно»:

```python
txt = "The best things in life are free!"  
if "free" in txt:  
  print("Yes, 'free' is present.")
```

**Результат:

`Yes, 'free' is present.

Узнайте больше об операторах If в нашем [Python Если...иначе](https://www.w3schools.com/python/python_conditions.asp) глава.

---

## Проверьте, если НЕ

Чтобы проверить, НЕ присутствует ли в строке определенная фраза или символ, мы можем использовать ключевое слово `not in`.

Проверьте, НЕ присутствует ли слово «дорогой» в следующем тексте:

```python
txt = "The best things in life are free!"  
print("expensive" not in txt)
```

**Рузультат:

`True

Используйте его в `if` утверждение:

печатать, только если "дорогой" НЕ присутствует:

```python
txt = "The best things in life are free!"  
if "expensive" not in txt:  
  print("No, 'expensive' is NOT present.")
  ```

**Результат:

`No, 'expensive' is NOT present.


---

# Изменение строки


В Python есть набор встроенных методов, которые можно использовать со строками.


## Верхний регистр

 `upper()` метод возвращает строку в верхнем регистре:

```python
a = "Hello, World!"  
print(a.upper())
```

**Результат:

`HELLO, WORLD!`

---

## Нижний регистр

The `lower()` метод возвращает строку в нижнем регистре:

```python
a = "Hello, World!"  
print(a.lower())
```

`hello, world!`

---

## Удалить пробел

Пробел — это пространство до и/или после фактического текста, и очень часто вы хотите удалить это пространство.

The `strip()` метод удаляет все пробелы в начале или в конце:

```python
a = " Hello, World! "  
print(a.strip()) # returns "Hello, World!"
```

**Результат:

`hello, world!`

---

## Заменить строку

Функция **replace()** в [Python](https://www.geeksforgeeks.org/python-programming-language/) возвращает копию строки, в которой все вхождения подстроки заменены другой подстрокой.

### **Синтаксис замены()**

> **Синтаксис:** string.replace(старый, новый, количество)
> 
> **Параметры:**
> 
> -   **old —** старая подстрока, которую вы хотите заменить.
> -   **new –** новая подстрока, которая заменит старую подстроку.
> -   **count —** ( **необязательно** ) количество раз, которое вы хотите заменить старую подстроку новой подстрокой.
> 
> **Возвращаемое значение:** возвращает копию строки, в которой все вхождения подстроки заменены другой подстрокой.


The `replace()` метод заменяет строку другой строкой:

```python
a = "Hello, World!"  
print(a.replace("H", "J"))
```

**Результат:

Jello, World!

---

В этом примере мы заменяем только один символ из заданной строки. Метод replace() в Python чувствителен к регистру, поэтому он выполняет подстановку подстроки с учетом регистра, т. е. R в FOR не изменяется. 


```python
string = "grrks FOR grrks"
 
new_string = string.replace("r", "e" )
 
print(string)
print(new_string)
```

**Output :** 
`grrks FOR grrks
`geeks FOR geeks

---

Здесь мы заменили всех гиков на GeeksforGeeks с помощью функции replace(). 

```python
string = "geeks for geeks \ngeeks for geeks"
 
print(string)
print(string.replace("geeks", "GeeksforGeeks"))
```

Output : `
```python
geeks for geeks 
geeks for geeks
GeeksforGeeks for GeeksforGeeks 
GeeksforGeeks for GeeksforGeeks
```

---

В этом примере мы заменяем определенное количество слов. т.е. «ek» с «a» с count=3 . 

```python
string = "geeks for geeks geeks geeks geeks"
 
print(string.replace("e", "a"))
print(string.replace("ek", "a", 3))
```

Output:  
`gaaks for gaaks gaaks gaaks gaaks
`geas for geas geas geeks geeks

---

## Разделить строку

split() Метод возвращает список, в котором текст между указанным разделителем становится элементами списка.  The `split()` метод разбивает строку на список.

**Метод Python String split()** в Python разделяет строку на список строк после разбиения данной строки на указанный разделитель.

Вы можете указать разделитель, по умолчанию разделителем является любой пробел.

> **Синтаксис:** str.split(разделитель, maxsplit)
> 
> **Параметры:**
> 
> -   **разделитель :** это разделитель. Строка разделяется по указанному разделителю. Если не указан, то любой пробел является разделителем.
> -   **maxsplit :** это число, которое говорит нам разделить строку на максимальное указанное количество раз. Если он не указан, по умолчанию используется значение -1, что означает отсутствие ограничений.
> 
> **Возвращает:** возвращает список строк после разрыва данной строки указанным разделителем.

`split()` метод разбивает строку на подстроки, если находит экземпляры разделителя:

```python
a = "Hello, World!"  
print(a.split(",")) # returns ['Hello', ' World!']
```

**Результат:**
``['Hello', ' World!']

---

```python
string = "one,two,three"
words = string.split(',')
print(words)
```

**Output:**
``['one', 'two', 'three']

---

Разделите строку, используя запятую и пробел в качестве разделителя:

```python
txt = "hello, my name is Peter, I am 26 years old"  
  
x = txt.split(", ")  
  
print(x)
```

**Результат:**
`['hello', 'my name is Peter', 'I am 26 years old']`

---

Здесь мы используем функцию Python String split() для разделения разных строк в список, разделенный разными символами в каждом случае. 

```python
text = 'geeks for geeks'
 

print(text.split())
 
word = 'geeks, for, geeks'
 
print(word.split(','))
 
word = 'geeks:for:geeks'
 
print(word.split(':'))
 
word = 'CatBatSatFatOr'
 
print(word.split('t'))
```


Output :
```python
['geeks', 'for', 'geeks']
['geeks', ' for', ' geeks']
['geeks', 'for', 'geeks']
['Ca', 'Ba', 'Sa', 'Fa', 'Or']
```

---

Используйте символ решетки в качестве разделителя:

```python
txt = "apple#banana#cherry#orange"  
  
x = txt.split("#")  
  
print(x)
```

**Результат:**
``['apple', 'banana', 'cherry', 'orange']

---

Параметр maxsplit используется для управления количеством разбиений, возвращаемых после анализа строки. Даже если возможно несколько разделений, будет выполнено только максимальное количество разделений, определенное параметром maxsplit.

```python

word = 'geeks, for, geeks, pawan'
 
print(word.split(', ', 0))
print(word.split(', ', 4))
print(word.split(', ', 1))
```

**Output :**
```python
['geeks, for, geeks, pawan']
['geeks', 'for', 'geeks', 'pawan']
['geeks', 'for, geeks, pawan']
```


Разделите строку на список с максимальным количеством элементов 2:

```python
txt = "apple#banana#cherry#orange"  
  
#setting the maxsplit parameter to 1, will return a list with 2 elements!  
x = txt.split("#", 1)  
  
print(x)
```

**Результат:**
`[apple', 'banana#cherry#orange']


Узнайте больше о списках в нашей [«Списки Python» .](https://www.w3schools.com/python/python_lists.asp) главе

---

## Строковые методы

Узнайте больше о строковых методах в нашем [справочнике по строковым методам.](https://www.w3schools.com/python/python_ref_string.asp)

---


# Конкатенация строк

Чтобы соединить или объединить две строки, вы можете использовать оператор + или `,` .

Объединить переменную `a` с переменной `b` в переменную `c` :


```python
a = "Hello"  
b = "World"  
c = a + b  
print(c)
```

Чтобы добавить пробел между ними, добавьте `" "`:

```python
a = "Hello"  
b = "World"  
c = a + " " + b  
print(c)
```


`+` — оператор конкатенации строк. Он возвращает строку, состоящую из других строк, как показано здесь:

```python
>>> s = 'py'
>>> t = 'th'
>>> u = 'on'

>>> s + t
'pyth'
>>> s + t + u
'python'

>>> print('Привет, ' + 'Мир!')
```


```python
>>> S1 = 'spam'
>>> S2 = 'eggs'
>>> print(S1 + S2)
'spameggs'
```


В [[Database/00. Computer/01. Programming/01-03. Python/14-00. Reference work/AA. Введение | python]] функция print()  часто используется для вывода переменных. Чтобы объединить текст и переменную, Python использует + персонаж. Например давайте выведем – Hello ``[значение переменной]:

```python
name = “Alex”
print(“Hello ” + name + “!”)
```

**Результат выполнения программы:

`Hello Alex!

Нельзя обьеденять значения разного типа, например попробуем обьеденить строку с числом:

`print(“ I am ” + 18 + “ years old”)

Или же давайте заберем значение из переменной:

```python
age = 18
print(“I am ” + age + “years old” )
```

Оба примера выдаст ошибку: TypeError: can only concatenate str (not "int") to str. Это означает что мы можем Конкатенировать только чилу с чилом, а строку со строкой, Но есть выход! Мы можем [[GG. Тип кастинг  | переобразовать тип ]]:   

```python
age = 18
print(“I am ” + str(age), “ years old”)
```

Не важно какого типа значения переменной age, ведь фунуция str() преобразует его в тип string. Так можно не тольк со строками, ну и с числами и дургими типами. Для конкатенирования можно использовать не только + ну и запятую:

```python
name = “Alex”
print(“Hello”, name) #Hello Alex
```


## Дублирование строки

`*` — оператор создает несколько копий строки. Если `s` это строка, а `n` целое число, любое из следующих выражений возвращает строку, состоящую из `n` объединенных копий `s`:

```python
s * n  
n * s
```

Вот примеры умножения строк:

```python
>>> s = 'py.'

>>> s * 4
'py.py.py.py.'
>>> 4 * s
'py.py.py.py.'
```


```python
>>> print('spam' * 3)
spamspamspam
```

Значение множителя `n` должно быть целым положительным числом. Оно может быть нулем или отрицательным, но этом случае результатом будет пустая строка:

```python
>>> 'py' * -6
''
```

Если вы создадите строковую переменную и превратите ее в пустую строку, с помощью `'py' * -6`, кто-нибудь будет справедливо считать вас немного глупым. Но это сработает.


---

# Срезы строк



Вы можете вернуть диапазон символов, используя синтаксис среза.

Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;

символ с номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине строки.

```python
>>> s = 'spameggs'
>>> s[3:5]
'me'
>>> s[2:-2]
'ameg'
>>> s[:6]
'spameg'
>>> s[1:]
'pameggs'
>>> s[:]
'spameggs'
```

Кроме того, можно задать шаг, с которым нужно извлекать срез.

```python
>>> s[::-1]
'sggemaps'
>>> s[3:5:-1]
''
>>> s[2::2]
'aeg'
```

Укажите начальный и конечный индексы, разделенные двоеточием, чтобы вернуть часть строки.

Python также допускает возможность извлечения подстроки из строки, известную как ‘‘string slice’’. Если `s` это строка, выражение формы `s[m:n]` возвращает часть `s`, начинающуюся с позиции `m`, и до позиции `n`, но не включая позицию:

```python
>>> s = 'python'
>>> s[2:5]
'tho'
```

> **Помните:** индексы строк в python начинаются с нуля. Первый символ в строке имеет индекс `0`. Это относится и к срезу.

Опять же, второй индекс указывает символ, который не включен в результат. Символ `'n'` в приведенном выше примере. Это может показаться немного не интуитивным, но дает результат: выражение `s[m:n]` вернет подстроку, которая является разницей `n - m`, в данном случае `5 - 2 = 3`.

Если пропустить первый индекс, срез начинается с начала строки. Таким образом, `s[:m]` = `s[0:m]`:

```python
>>> s = 'python'
>>> s[:4]
'pyth'
>>> s[0:4]
'pyth'
```

Аналогично, если опустить второй индекс `s[n:]`, срез длится от первого индекса до конца строки. Это хорошая, лаконичная альтернатива более громоздкой `s[n:len(s)]`:

```python
>>> s = 'python'
>>> s[2:]
'thon'
>>> s[2:len(s)]
'thon'
```

Для любой строки `s` и любого целого `n` числа (`0 ≤ n ≤ len(s)`), `s[:n] + s[n:]`будет `s`:

```python
>>> s = 'python'
>>> s[:4] + s[4:]
'python'
>>> s[:4] + s[4:] == s
True
```

Пропуск обоих индексов возвращает исходную строку. Это не копия, это ссылка на исходную строку:

```python
>>> s = 'python'
>>> t = s[:]
>>> id(s)
59598496
>>> id(t)
59598496
>>> s is t
True
```

Если первый индекс в срезе больше или равен второму индексу, Python возвращает пустую строку. Это еще один не очевидный способ сгенерировать пустую строку, если вы его искали:

  

```python
>>> s[2:2]
''
>>> s[4:2]
''
```

Отрицательные индексы можно использовать и со срезами. Вот пример кода Python:

```python
>>> s = 'python'
>>> s[-5:-2]
'yth'
>>> s[1:4]
'yth'
>>> s[-5:-2] == s[1:4]
True
```





Получить символы из позиции 2 в позицию 5 (не включены):

```python
b = "Hello, World!"  
print(b[2:5])
```

**Результат:

`llo

## Нарезка с самого начала

Если исключить начальный индекс, диапазон будет начинаться с первого символа:

Получить символы от начала до позиции 5 (не включены):

```python
b = "Hello, World!"  
print(b[:5])
```

**Результат:

`Hello

## Разрезать до конца

Если исключить _конечный_ индекс, диапазон будет доведен до конца:

Получите символы с позиции 2 и до конца:

```python
b = "Hello, World!"  
print(b[2:])
```

**Результат:

`llo, World!`

## Отрицательное индексирование

Используйте отрицательные индексы, чтобы начать срез с конца строки:

Получить символы:

Откуда: "о" в "Мире!" (позиция -5)

Чтобы, но не включено: "д" в "Мир!" (позиция -2):

```python
b = "Hello, World!"  
print(b[-5:-2])
```

**Результат:

`orl`

## Шаг для среза строки

Существует еще один вариант синтаксиса среза, о котором стоит упомянуть. Добавление дополнительного `:` и третьего индекса означает шаг, который указывает, сколько символов следует пропустить после извлечения каждого символа в срезе.

Например , для строки `'python'` срез `0:6:2` начинается с первого символа и заканчивается последним символом (всей строкой), каждый второй символ пропускается. Это показано на следующей схеме:

![[Pasted image 20221113055349.png]]

Иллюстративный код показан здесь:

```python
>>> s = 'foobar'
>>> s[0:6:2]
'foa'
>>> s[1:6:2]
'obr'
```

Как и в случае с простым срезом, первый и второй индексы могут быть пропущены:

```python
>>> s = '12345' * 5
>>> s
'1234512345123451234512345'
>>> s[::5]
'11111'
>>> s[4::5]
'55555'
```

Вы также можете указать отрицательное значение шага, в этом случае Python идет с конца строки. Начальный/первый индекс должен быть больше конечного/второго индекса:

```python
>>> s = 'python'
>>> s[5:0:-2]
'nhy'
```

В приведенном выше примере, `5:0:-2` означает «начать с последнего символа и делать два шага назад, но не включая первый символ.”

Когда вы идете назад, если первый и второй индексы пропущены, значения по умолчанию применяются так: первый индекс — конец строки, а второй индекс — начало. Вот пример:

```python
>>> s = '12345' * 5
>>> s
'1234512345123451234512345'
>>> s[::-5]
'55555'
```

Это общая парадигма для разворота (reverse) строки:

```python
>>> s = 'Если так говорит товарищ Наполеон, значит, так оно и есть.'
>>> s[::-1]
'.ьтсе и оно кат ,тичанз ,ноелопаН щиравот тировог кат илсЕ'
```

---


# Форматирование строк

При работе со строками часто возникают ситуации, когда в шаблон строки надо подставить разные данные. 

Форматирование строк – это **приведение строк к той форме, которая вам нужна**.

Это можно делать объединяя, части строки и данные, но в Python есть более удобный способ — форматирование строк.

Форматирование строк может помочь, например, в таких ситуациях:

-   необходимо подставить значения в строку по определенному шаблону
    
-   необходимо отформатировать вывод столбцами
    
-   надо конвертировать числа в двоичный формат
    

Существует несколько вариантов форматирования строк:

-   с оператором `%` — более старый вариант
    
-   метод `format()` — относительно новый вариант
    
-   f-строки — новый вариант, который появился в Python 3.6.
    

Несмотря на то, что рекомендуется использовать метод `format`, часто можно встретить форматирование строк и через оператор `%`.

---

## Форматирование методом %

Щас рассмотрим пример использовании оператора %:

```python
name = "Alex"
age = 21

print("Hello my name is %s, I am %d years old! " %(name, age))
```

**Результат:

`Hello my name is Alex, I am 21 years old!

Так же другой синтаксис:


```python
print("Hello my name is %s, I am %d years old! " %("Alex", 21))
```

То есть мы параметры передали напрямую без использовании переменных.


Если для подстановки требуется только один аргумент, то значение - сам аргумент: **>>>>>> 'Hello, %s!' % 'Vasya'**

'Hello, Vasya!'

А если несколько, то значением будет являться кортеж со строками подстановки:

**>>>>>> '%d %s, %d %s' % (6, 'bananas', 10, 'lemons')** '6 bananas, 10 lemons'

Теперь, а почему я пишу то %d, то %s? А всё зависит от того, что мы используем в качестве подстановки и что мы хотим получить в итоге.


Формат                             Что получится

'%d', '%i', '%u'                   Десятичное число.

'%o'                                   Число в восьмеричной системе счисления.

'%x'                                   Число в шестнадцатеричной системе счисления (буквы в нижнем регистре).

'%X'                                  Число в шестнадцатеричной системе счисления (буквы в верхнем регистре).

'%e'                                   Число с плавающей точкой с экспонентой (экспонента в нижнем регистре).

'%E'                                  Число с плавающей точкой с экспонентой (экспонента в верхнем регистре).

'%f', '%F'                          Число с плавающей точкой (обычный формат).

'%g'                                  Число с плавающей точкой. с экспонентой (экспонента в нижнем регистре), если она меньше, чем -4 или точности, иначе обычный формат.

'%G'                                 Число с плавающей точкой. с экспонентой (экспонента в верхнем регистре), если она меньше, чем -4 или точности, иначе обычный формат.

'%c'                                  Символ (строка из одного символа или число - код символа).

'%r'                                  Строка (литерал python).

'%s'                                  Строка (как обычно воспринимается пользователем).    

'\%%'                                Знак '%'.


Давайте приступим к делу, работы много! Чтобы иметь в распоряжении простой пример для эксперимента, представим, что у вас есть следующие переменные (или константы, не важно) для работы:

**errno = 50159747054
name = 'Bob'**

Основываясь на этих переменных, вы хотите создать строку вывода, содержащую простое уведомление об ошибке: **'Hey Bob, there is a 0xbadc0ffee error!'**

``print('Hello, %s' % name) 

**Вывод:**
``"Hello, Bob"

Cинтаксис  форматирования  строки  немного  меняется,  если  вы  хотите  сделать  несколько  замен  в  одной  строке.  Так  как  оператор  % принимает только один аргумент, вам нужно обернуть правую часть в кортеж, вот так:


```python
errno  =  50159747054
name  =  'Bob'

print('Hey %s, there is a 0x%x error!' % (name, errno))
```

Output:

``Hey Bob, there is a 0xbadc0ffee error!

Хочу напомнить, что этот способ форматирование немного старый);

---
## Форматирование методом format()

Метод `format()` позволяет форматировать выбранные части строки. Иногда есть части текста, которые вы не контролируете, может быть, они поступают из базы данных или пользовательского ввода? Чтобы контролировать такие значения, добавить заполнители (фигурные скобки `{}`) в тексте и пропустите значения через `format()` метод:

Пример использования метода format:

``"interface FastEthernet0/{}".format('1')

**Output:**
`'interface FastEthernet0/1'

Пример2 использовании метода format:

```python
name = “Alex”
error = 404
print(“Hi {0}, here’s error: {1}”.format(name, error))
```

**Output:

`Hi Alex, here’s error: 404

---

Добавьте местозаполнитель, где вы хотите отобразить цену:

```python
price = 49  
txt = "The price is {} dollars"  
print(txt.format(price))
```

**Результат:**
`The price is 49 dollars`

---

Вы можете добавить параметры внутри фигурных скобок, чтобы указать, как конвертировать Значение.

Отформатируйте отображаемую цену как число с двумя десятичными знаками:

`txt = "The price is {:.2f} dollars"

**Результат:**
`The price is 49.00 dollars

---
Если вы хотите использовать больше значений, просто добавьте больше значений в метод format():

`print(txt.format(price, itemno, count))

И добавьте больше заполнителей:

```python
quantity = 3  
itemno = 567  
price = 49  
myorder = "I want {} pieces of item number {} for {:.2f} dollars."  
print(myorder.format(quantity, itemno, price))
```

**Результат:**
`I want 3 pieces of item number 567 for 49.00 dollars.

---
Вы можете использовать порядковые номера (число внутри фигурных скобок). `{0}`), чтобы убедиться, что значения размещены в правильных заполнителях:

```python
quantity = 3  
itemno = 567  
price = 49  
myorder = "I want {0} pieces of item number {1} for {2:.2f} dollars."  
print(myorder.format(quantity, itemno, price))
```

**Результат:**
`I want 3 pieces of item number 567 for 49.00 dollars.


---


Кроме того, если вы хотите ссылаться на одно и то же значение более одного раза, используйте порядковый номер:

```python
age = 36  
name = "John"  
txt = "His name is {1}. {1} is {0} years old."  
print(txt.format(age, name))
```

**Результат:**
`His name is John. John is 36 years old.

 ---

Вы также можете использовать именованные индексы, введя имя в фигурных скобках. `{carname}`, но тогда вы должны использовать имена при передаче значений параметров `txt.format(carname = "Ford")`:

```python
myorder = "I have a {carname}, it is a {model}."  
print(myorder.format(carname = "Ford", model = "Mustang"))
```

**Результат:**
`I have a Ford, it is a Mustang.

---

Специальный символ `{}` указывает, что сюда подставится значение, которое передается методу format. При этом каждая пара фигурных
скобок обозначает одно место для подстановки. 

Либо вы можете обращаться к подстановкам переменных по имени и использовать их в любом порядке, в котором вы захотите. Это довольномощное функциональное средство языка, поскольку оно позволяет изменять порядок следования отображаемых элементов, не зменяя аргументы, переданные в функцию форматирования:

`print('Hi {name}, here’s error: {error}.format( name=name, errno=errno))

Значения, которые подставляются в фигурные скобки, могут быть разного типа. Например, это может быть строка, число или список:

`print('{}'.format('10.1.1.1'))

**Output:**
`10.1.1.1

---

`print('{}'.format(100))

**Output:**
`100

---


`print('{}'.format([10, 1, 1,1]))

**Output:**
``[10, 1, 1, 1]

---

С помощью форматирования строк можно выводить результат столбцами. В форматировании строк можно указывать, какое количество символов выделено на данные. Если количество символов в данных меньше, чем выделенное количество символов, недостающие символы заполняются пробелами.

Например, таким образом можно вывести данные столбцами одинаковой ширины по 15 символов с выравниванием по правой стороне:

`vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']

`print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
  
**Output:**
       `100  aabb.cc80.7000           Gi0/1

Выравнивание по левой стороне:

`print("{:15} {:15} {:15}".format(vlan, mac, intf))

**Output:**
`100             aabb.cc80.7000  Gi0/1

Примеры выравнивания

![[Pasted image 20221113100035.png]]

![[Pasted image 20221113100044.png]]

![[Pasted image 20221113100052.png]]

---
Шаблон для вывода может быть и многострочным:

```python
ip_template = '''
IP address:
{}
'''

print(ip_template.format('10.1.1.1'))
```

**Output:**
`IP address:
`10.1.1.1

---

С помощью форматирования строк можно также влиять на отображение чисел.

Например, можно указать, сколько цифр или букв после запятой выводить:

```python
text = "Hello This is Idirs"
print("{:.8s}".format(text))
```

**Output:**

`Hello Th` 

-8 букв как мы и хотели. 

---

С помощью форматирования строк можно конвертировать числа в двоичный формат:

`'{:b} {:b} {:b} {:b}'.format(192, 100, 1, 1)

**Output:** 
`'11000000 1100100 1 1'

---

При этом по-прежнему можно указывать дополнительные параметры, например, ширину столбца:

``'{:8b} {:8b} {:8b} {:8b}'.format(192, 100, 1, 1)

**Output:** 
``'11000000  1100100        1        1'

---
А также можно указать, что надо дополнить числа нулями, вместо пробелов:

`'{:08b} {:08b} {:08b} {:08b}'.format(192, 100, 1, 1)

**Output:**: 
``'11000000 01100100 00000001 00000001'

---
В фигурных скобках можно указывать имена. Это позволяет передавать аргументы в любом порядке, а также делает шаблон более понятным:

``'{ip}/{mask}'.format(mask=24, ip='10.1.1.1')

**Output:**
``'10.1.1.1/24'

---

Еще одна полезная возможность форматирования строк - указание номера аргумента:

`'{1}/{0}'.format(24, '10.1.1.1')

**Output:**
``'10.1.1.1/24'

---

```python
text = "Hello, {first_name}.".format(first_name="Tom")
print(text)     # Hello, Tom.
 
info = "Name: {name}\t Age: {age}".format(name="Bob", age=23)
print(info)     # Name: Bob  Age: 23
```

---

По итогу у нас три основных метода форматирование с п.м. функции format():

```python
txt1 = "My name is {fname}, I'm {age}".format(fname = "John", age = 36)  
txt2 = "My name is {0}, I'm {1}".format("John",36)  
txt3 = "My name is {}, I'm {}".format("John",36)
```

Как мы и сказали, Мы также можем последовательно передавать в метод format набор аргументов, а в самой форматируемой строке вставлять эти аргумента, указывая в фигурных скобках их номер (нумерация начинается с нуля):

```python
info = "Name: {0}\t Age: {1}".format("Bob", 23)
print(info)     # Name: Bob  Age: 23
```

При этом аргументы можно вставлять в строку множество раз:

`text = "Hello, {0} {0} {0}.".format("Tom")


---

## Форматирование методом f-строк


В Python 3.6 добавился новый вариант форматирования строк - f-строки или интерполяция строк. F-строки позволяют не только подставлять какие-то значения в шаблон, но и позволяют выполнять вызовы функций, методов и т.п. То есть  Этот новый способ форматирования строк позволяет использовать выражения Python, которые встраиваются
в строковые константы. 

Во многих ситуациях f-строки удобней и проще использовать, чем format, кроме того, f-строки работают быстрее, чем format и другие методы форматирования строк. 


F-строки - это литерал строки с буквой `f` перед ним. Внутри f-строки в паре фигурных скобок указываются имена переменных, которые надо подставить:

```python
name = “Alex”
print(f“Hello {name}”)
```

**Output:**
`Hello Alex

В новом синтаксисе форматирования заложена большая мощь. Поскольку он позволяет встраивать произвольные выражения Python, вы даже може-
те выполнять локальные арифметические действия, как показано ниже:

```python
>>> a = 5
>>> b = 10
>>> f'Пять плюс десять равняется {a + b}, а не {2 * (a + b)}.'

'Пять плюс десять равняется 15, а не 30.'
```


```python
 ip = '10.1.1.1'
 mask = 24

 print(f"IP: {ip}, mask: {mask}")
```

**Output:**

``'IP: 10.1.1.1, mask: 24'

Аналогичный результат с format можно получить так: `"IP: {ip}, mask: {mask}".format(ip=ip, mask=mask)`.

После двоеточия в f-строках можно указывать те же значения, что и при использовании format:

```python
In [9]: oct1, oct2, oct3, oct4 = [10, 1, 1, 1]

In [10]: print(f'''
    ...: IP address:
    ...: {oct1:<8} {oct2:<8} {oct3:<8} {oct4:<8}
    ...: {oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}''')
```

**Output:**

```python
IP address:
10       1        1        1
00001010 00000001 00000001 00000001
```


Другой пример:

```python
first_name="Tom"
text = f"Hello, {first_name}."
print(text)     # Hello, Tom.
 
name="Bob"
age=23
info = f"Name: {name}\t Age: {age}"
print(info)     # Name: Bob  Age: 23
```

---

# Экранирование 


```python
print(“I “python” programmer!”)
```

На примере выше мы пытаемся взять строку python в кавычки, но из за этого мы получим ошибку, потому что строкой считается буква I ведь у него начало и конец кавычки, а у самого слова python нет кавычки, если быть более внимательным то мы поймем что тут две строки – “I”, “programmer” , а python интерпретатор видит как команду или переменную которого у нас нет, именно поэтому мы получаем ошибку.
Решать проблему можно так:

```python
print(“I \“python\” programmer!”) #1
print(‘I “python” programmer!’) #2
```


Чтобы вставить недопустимые символы в строку, используйте escape-символ. Экранирующий символ — это обратная косая черта `\` за которым следует символ, который вы хотите вставить.

Примером недопустимого символа является двойная кавычка внутри строки, заключенной в двойные кавычки:

Вы получите ошибку, если используете двойные кавычки внутри строки, которая в двойных кавычках:

```python
txt = "We are the so-called "Vikings" from the north."
```

**Output:**

```python
File "demo_string_escape_error.py", line 1  
    txt = "We are the so-called "Vikings" from the north."  
                                       ^  
SyntaxError: invalid syntax

```

Чтобы решить эту проблему, используйте escape-символ `\"` :

Экранирующий символ позволяет вам использовать двойные кавычки, когда обычно это запрещено:


```python
txt = "We are the so-called \"Vikings\" from the north."
```

Экранированные последовательности, также называемые escape-последовательности, могут состоять из одного или нескольких символов после обратной косой черты:

| \ в самом конце строки | Игнорируется, строка продолжается на новой строке   |
|:---------------------- |:--------------------------------------------------- |
| \\                     | Сам символ обратного слеша (остается один символ \) |
| \'                     | Апостроф (остается один ‘)                          |
| \"                     | Кавычка (остается один символ ")                    |
| \n                     | Новая строка (перевод строки)                       |
| \r                     | Возврат каретки                                     |
| \t                     | Горизонтальная табуляция                            |
| \u…                    | 16-битовый символ Юникода в 16-ричном представлении |
| \U…                    | 32-битовый символ Юникода в 32-ричном представлении |
| \x…                    | 16-ричное значение                                  |
| \o…                    | 8-ричное значение                                   |
| \0                     | Символ Null (не признак конца строки)               |

Коротко об управляющих символах, которые можно встретить в программах на Python. Время от времени в коде вы можете встретить символы типа `\n`, `\r`, `\t` и прочие.  
  
Например, посмотрите что будет, если исполнить следующий код:  
  

```python
print('раз\tдва\tтри\nuno\tdos\ttres')
# раз	два	три# uno	dos	tres
```

  
Можно заметить, что вместо `\t` у нас появился отступ, а вместо `\n` переход на новую строку. Символы вроде `\t` и `\n` — это управляющие символы, они управляют выводом, например модифицируют его.  
  
Вот некоторые управляющие символы и их смысл:

| \n  | (newline) перевод каретки на следующую строку       |
| --- | --------------------------------------------------- |
| \r  | (return) перевод каретки на в начало текущей строки |
| \t  | (tab) табуляция (отступ, красная строка)            |
| \b  | (backspace) перевод каретки на один символ назад    |

**Перевод строки

```python
print(“Hello, my name is Alex!”)
```

Теперь надо сделать перевод строки “my name is Alex!”. Перевод строки делается с помошью специального
символа ``\n. 


```python
print(“Hello\nmy name is Alex!”)
```

**Результат выполнения программы:**

```python
Hello
my name is Alex!
```

Например, представьте, что вы инициализировали строку одинарными кавычками:

```py
s = 'Hey, whats up?'
print(s)
```

**Выход:**

```sh
Hey, whats up?
```

Но если вы включите апостроф, не экранируя его, вы получите ошибку:

```py
s = 'Hey, what's up?'
print(s)
```

**Выход:**

```sh
  File "main.py", line 1
    s = 'Hey, what's up?'
                   ^
SyntaxError: invalid syntax
```

Чтобы исправить это, просто избегайте апострофа:

```python
s = 'Hey, what\'s up?'
print(s)
```

Чтобы добавить новые строки в вашу строку, используйте `\n`:

```python
print("Multiline strings\ncan be created\nusing escape sequences.")
```

**Выход:**

```
Multiline strings
can be created
using escape sequences.
```

Вы можете указать несколько строк с `print` оператором . Просто разделите их запятой ',' , и они будут напечатаны с пробелом между ними:

```python
>>> print 'apple', 'orange', 'pear'
apple orange pear
```

В строках Python **обратная косая черта «\»** является **специальным символом** , также называемым « **экранирующим** » символом. Он используется для представления определенных пробельных символов: «\t» — табуляция, «\n» — новая строка, а «\r» — возврат каретки.

```python
>>> print 'apple', 'orange', 'pear'
apple orange pear
```

И наоборот, добавление префикса «\» к специальному символу превращает его в обычный символ. Это называется "сбежать". Например, «\'» — это одинарная кавычка. Таким образом, строка «Идет дождь» является допустимой строкой и эквивалентна строке «Идет дождь» . Аналогично, '"' можно экранировать: "\"hello\"" – это строка, начинающаяся и заканчивающаяся литеральным символом двойной кавычки. Наконец, "\" можно использовать для экранирования самого себя: ``\\``  – буквальный символ обратной косой черты. .

```python
>>> print 'It\'s raining'
It's raining 
>>> 'It\'s raining'          # Same string specified differently
"It's raining" 
>>> print "\"hello\""
"hello" 
>>> print '"\\" is the backslash'   # Try with "\" instead of "\\"
"\" is the backslash
```

Существует множество удобных функций, определенных для строк, называемых строковыми _методами_ . Узнайте о [подстроках, а также о манипуляциях с регистром](https://sites.pitt.edu/~naraehan/python2/string_methods1.html) в этом руководстве. [В этом учебнике, часть 2](https://sites.pitt.edu/~naraehan/python2/string_methods2.html) , рассматриваются строковые методы для определения местоположения конкретной подстроки, а также для проверки того, выполняется ли определенное условие для каждого символа.

Как только вы освоитесь со списками (ожидается), вы также должны проверить [Разделение и объединение строк](https://sites.pitt.edu/~naraehan/python2/split_join.html) .

