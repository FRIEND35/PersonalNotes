
Структуры данных – это, по сути, и есть структуры, которые могут хранить некоторые данные вместе. Другими словами, они используются для хранения связанных данных. 

В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и множество. Посмотрим, как ими пользоваться, и как они могут облегчить нам жизнь.

Массивы используются для хранения нескольких значений в одной переменной:


# Списки

Списки в Python представляют собой упорядоченные изменяемые наборы объектов, пронумерованных от 0. При этом объекты могут быть разными — от целых чисел до строк. Списки могут также хранить в себе списки.

Списки используются для хранения нескольких элементов в одной переменной. Списки — это один из 4 встроенных типов данных в Python, используемых для хранения коллекций. data, остальные 3 [Tuple](https://www.w3schools.com/python/python_tuples.asp) , [Set](https://www.w3schools.com/python/python_sets.asp) и [Dictionary](https://www.w3schools.com/python/python_dictionaries.asp) , все с разными качествами и использованием.

Списки создаются с помощью квадратных скобок:

```python
thislist = ["apple", "banana", "cherry"]  
print(thislist)
```

**Output:**

```python
['apple', 'banana', 'cherry']
```

```python
car1 = "Ford"  
car2 = "Volvo"  
car3 = "BMW"

x = cars[0] #Ford
cars[0] = "Toyota" #car1 = "Toyota"
```




## Хранение в памяти

При создании списка, в памяти резервируется пустая область. С одной стороны, это ничем не отличается от создания любого другого типа данных, но разница в том, что содержимое list может меняться:

```clike
numbers = [1, 2]
numbers[1] = 3
# обновлённый список: [1, 3]
```

До замены элемента последовательности `print(numbers[1])` выведет 2, а после замены — 3.

## Создание списка в Python

Это можно сделать несколькими способами, например перечислением элементов списка в квадратных скобках:

```clike
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

При этом единица будет на позиции 0, то есть `print(numbers[0])` выведет 1.

Также можно использовать обработку итерируемого объекта функцией `list()`. Пусть у нас будет некоторая строка, тогда:

```clike
list('tproger')
# ['t', 'p', 'r', 'o', 'g', 'e', 'r']
```

Также существуют генераторы списков, которые позволяют применить заданное выражение к каждому элементу последовательности. Допустим, необходимо создать list, состоящий из чисел от 1 до 5 включительно:

```clike
numbers = [i for i in range(1,6)]
# [1, 2, 3, 4, 5]
```

---

## Доступ к элементам

Элементы списка проиндексированы, и вы можете получить к ним доступ, обратившись к номеру индекса. 

А раз это индексированная последовательность, значит, каждый элемент списка имеет свой индекс, к которому можно обратиться.  
По традиции, индексы начинаются с 0.

 +---+---+---+---+
 | p | y | t | h | o | n |
 +---+---+---+---+
   0   1   2   3   4   5
 -6  -5 -4 -3 -2  -1


```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

print(my_list[0])
print(my_list[2])
print(my_list[-1])

#один
#три
#пять!
```

Выведем вложенный список и элемент вложенного списка:


```python
my_list3 = [1, 'два', 3.5, [4, 'четыре'], 'пять!']

print(my_list3[3])
print(my_list3[3][1])

#[4, 'четыре']
#четыре
```

Распечатайте второй элемент списка:

```python
thislist = ["apple", "banana", "cherry"]  
print(thislist[1])
```

**Примечание** . Первый элемент имеет индекс 0.

### Отрицательное индексирование

Отрицательная индексация означает начало с конца

`-1` относится к последнему элементу, `-2` относится к предпоследнему элементу и т. д.

Распечатайте последний элемент списка:

```python
thislist = ["apple", "banana", "cherry"]  
print(thislist[-1])
```



## Срезы (slice) списка

Вы можете указать диапазон индексов, указав, где начать и где закончить диапазон.

При указании диапазона возвращаемым значением будет новый список с указанные предметы.

Срезы позволяют получить некое подмножество значений. Следующий код вернёт список с элементами, начиная индексом 0 и не включая при этом индекс 2 и выше:

```clike
numbers = [1, 5, 9, 6]
print(numbers[0:2])
# вывод [1, 5]
```

Далее выведем всё, за исключением элемента на позиции 3:

```clike
print(numbers[:3])
# вывод [1, 5, 9]
```

А теперь начиная с индекса 1 и до конца:

```clike
print(numbers[1:])
# вывод [5, 9, 6]
```

Вернуть третий, четвертый и пятый элемент:

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]  
print(thislist[2:5])
```


```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

print(my_list[1:4])
print(my_list[1:])
print(my_list[:3])
print(my_list[::2])

#['два', 'три', 'четыре']
#['два', 'три', 'четыре', 'пять!']
#['один', 'два', 'три']
#['один', 'три', 'пять!']
```

Если использовать -1 в качестве шага, то можно получить список в обратном порядке:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

print(my_list[::-1])
#['пять!', 'четыре', 'три', 'два', 'один']
```


**Примечание** . Поиск начнется с индекса 2 (включительно) и закончится с индексом 5 (не включено).

Помните, что первый элемент имеет индекс 0.

Если не указывать начальное значение, диапазон будет начинаться с первого элемента.

В этом примере возвращаются элементы с самого начала, но НЕ включая «киви»:

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]  
print(thislist[:4])
```

Если исключить конечное значение, диапазон будет продолжаться до конца списка:

В этом примере возвращаются элементы из "вишни" в конец:

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]  
print(thislist[2:])
```

---

### Диапазон отрицательных индексов

Укажите отрицательные индексы, если хотите начать поиск с конца список.

В этом примере возвращаются элементы от "оранжевого" (-4) до, но НЕ включая "манго" (-1):

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]  
print(thislist[-4:-1])
```

---

## Изменение значений в списке

Так как это изменяемая последовательность, то мы можем напрямую менять значения в списках:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

my_list[0] = 1
my_list[2] = 3
my_list[-1] = 5

print(my_list)
#[1, 'два', 3, 'четыре', 5]

```

Чтобы изменить значение определенного элемента, обратитесь к номеру индекса. Измените второй элемент:

```python
thislist = ["apple", "banana", "cherry"]  
thislist[1] = "blackcurrant"  
print(thislist)
```

Чтобы изменить значение элементов в определенном диапазоне, определите список с новыми значениями и обратитесь к диапазону номеров индексов, в которые вы хотите вставить новые значения.

Замените значения «банан» и «вишня» на значения «черная смородина» и «арбуз»:

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "mango"]  
thislist[1:3] = ["blackcurrant", "watermelon"]  
print(thislist)
```

Если вы вставите _больше_ элементов, чем замените, новые элементы будут вставлены где вы указали, а остальные элементы будут перемещаться соответственно.

Измените второе значение, заменив его _двумя_ новыми ценности:

```python
thislist = ["apple", "banana", "cherry"]  
thislist[1:2] = ["blackcurrant", "watermelon"]  
print(thislist)
```

Если вы вставите _меньше_ элементов, чем замените, новые элементы будут вставлены где вы указали, а остальные элементы будут перемещаться соответственно.

Измените второе и третье значение, заменив его на _единицу_ ценность:

```python
thislist = ["apple", "banana", "cherry"]  
thislist[1:3] = ["watermelon"]  
print(thislist)
```

## Проверить, существует ли элемент

Чтобы определить, присутствует ли указанный элемент в списке, используйте `in` ключевое слово.

Проверьте, присутствует ли «яблоко» в списке:

```python
thislist = ["apple", "banana", "cherry"]  
if "apple" in thislist:  
  print("Yes, 'apple' is in the fruits list")
```

---

### Диапазон отрицательных индексов

Укажите отрицательные индексы, если хотите начать поиск с конца список:

В этом примере возвращаются элементы от "оранжевого" (-4) до, но НЕ включая "манго" (-1):

```python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]  
print(thislist[-4:-1])
```

## Операции над списками Python

-   `x in l` — `true`, если элемент `x` есть в списке `l`;
-   `x not in l` — `true`, если элемент `x` отсутствует в `l`;
-   `l1 + l2` — объединение двух списков;
-   `l * n , n * l` — копирует список `n` раз;
-   `len(l)` — количество элементов в `l`;
-   `min(l)` — наименьший элемент;
-   `max(l)` — наибольший элемент;
-   `sum(l)` — сумма чисел списка;
-   `for i in list()` — перебирает элементы слева направо.



## Список элементов

Элементы списка упорядочены, изменяемы и допускают дублирование значений.

Элементы списка проиндексированы, первый элемент имеет индекс `[0]`, второй элемент имеет индекс `[1]`и т.п.

---

## Упорядоченный

Когда мы говорим, что списки упорядочены, это означает, что элементы имеют определенный порядок, и этот порядок не изменится.

Если вы добавляете новые элементы в список, новые элементы будут помещены в конец списка.

**Примечание.** Есть некоторые [методы списка](https://www.w3schools.com/python/python_lists_methods.asp) , которые изменяют порядок, но в целом: порядок элементов не изменится.

## Сменный

Список можно изменить, что означает, что мы можем изменять, добавлять и удалять элементы в списке после его создания.

---

## Разрешить дубликаты

Поскольку списки индексируются, списки могут иметь элементы с одинаковым значением:

Списки допускают повторяющиеся значения:

```python
thislist = ["apple", "banana", "cherry", "apple", "cherry"]  
print(thislist)
```

---

## Длина списка

Чтобы определить количество элементов в списке, используйте `len()`функция:

```python
thislist = ["apple", "banana", "cherry"]  
print(len(thislist))
```



---

## Элементы списка — типы данных

Элементы списка могут иметь любой тип данных:

Типы данных String, int и boolean:

```python
list1 = ["apple", "banana", "cherry"]  
list2 = [1, 5, 7, 9, 3]  
list3 = [True, False, False]
```

Список может содержать разные типы данных. Список со строками, целыми числами и логическими значениями:

```python
list1 = ["abc", 34, True, 40, "male"]
```

## Конструктор list()

Также возможно использовать конструктор list() при создании новый список.

С использованием `list()`конструктор для создания списка:

```python
thislist = list(("apple", "banana", "cherry")) # note the double round-brackets  
print(thislist)
```


## Методы списков 

### reverse()

Список в обратном порядке:  ```python list.reverse()```

```python
my_list_1 = [4, 5, 3, 1, 2]
my_list_1.reverse()
print(my_list_1)

#[2, 1, 3, 5, 4]
```

---

### index()


Найти индекс элемента: ```python list.index(x[, start[, end]]) ```
  
Необязательные аргументы start и end, указывают на промежуток поиска:

```python
my_list = [1, 2, 3, 4, 5]
print(my_list.index(4))

#3
```


```python
my_list = ['один', 'два', 'три', 'четыре', 'пять']
print(my_list.index('три', 1, 3))

#2
```

Если элемента нет в списке:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять']
print(my_list.index('шесть'))

#builtins.ValueError: 'шесть' is not in list
```


Возвращает положение первого совпавшего элемента. Поиск совпадения происходит слева направо. Пример:

```pythonclike
numbers = [1, 5, 9, 6, 1, 2, 1]
print(numbers.index(1))
# вывод 0: первая найденная единица на позиции 0
```
---

### count()

Количество элементов х в строке:  ```pythonlist.count(x)

```
my_list = ['один', 'два', 'три', 'четыре', 'пять', 'три']
print(my_list.count('три'))

#2
```


```
my_list = [1, 2, 3, 4, 5, 4]
print(my_list.count(4))

#2
```


Данный метод считает, сколько раз указанное значение появляется в списке Python:

```clike
numbers = [1, 5, 9, 6, 1, 2, 1]
print(numbers.count(1))
# вывод 3, потому что единица встречается 3 раза
```

---

### copy()

Вы не можете скопировать список, просто набрав `list2 = list1`, потому что: `list2`будет только _ссылка_ на `list1`, и изменения, внесенные в `list1` автоматически также будет сделано в `list2`.

Есть способы сделать копию, один из способов — использовать встроенный список метод `copy()`.

Сделайте копию списка с `copy()` метод:

```
thislist = ["apple", "banana", "cherry"]  
mylist = thislist.copy()  
print(mylist)
```python

Копирование списка: ``` list.copy() 

```python
my_list = [1, 2, 3, 4, 5]
my_list_2 = my_list.copy()
print(my_list_2)

#[1, 2, 3, 4, 5]
```

Другой способ сделать копию — использовать встроенный метод `list()`.

Сделайте копию списка с `list()`метод:

```python
thislist = ["apple", "banana", "cherry"]  
mylist = list(thislist)  
print(mylist)
```

---

### clear()

Удалить все элементы из списка: ``` list.clear()```

The `clear()` метод очищает список.

Список все еще остается, но в нем нет содержания.

Очистите содержимое списка:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.clear()  
print(thislist)
```

```python
my_list = [1, 2, 3, 4, 5]
my_list.clear()
print(my_list)

#[]
```

---

### append()

Добавить элемент в конец списка. Чтобы добавить элемент в конец списка, используйте функцию append().


```python
my_list = [1, 2, 3, 4, 4]
my_list.append('new')

print(my_list)

#[1, 2, 3, 4, 4, 'new']
```

Работа этого метода эквивалентна такому срезу с добавлением:

```python
my_list = [1, 2, 3, 4, 4]
my_list[len(my_list):] = ['new']
print(my_list)

#[1, 2, 3, 4, 4, 'new']
```

Добавляет указанное значение в конец:

```clike
numbers = [1, 5, 9, 6]
numbers.append(3)
# обновлённый список: [1, 5, 9, 6, 3]
```

С использованием `append()`метод добавления элемента:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.append("orange")  
print(thislist)
```

---

### sort()

Объекты списка имеют `sort()`метод, который будет сортировать список в алфавитно-цифровом порядке по возрастанию по умолчанию.

Сортировка списка: ``` list.sort(*, key=None, reverse=False)```

```python
my_list_1 = [4, 5, 3, 1, 2]
my_list_1.sort()
print(my_list_1)

#[1, 2, 3, 4, 5]
```

Отсортируйте список по алфавиту:

```python
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]  
thislist.sort()  
print(thislist)
```

Отсортируйте список по цифрам:

```python
thislist = [100, 50, 65, 82, 23]  
thislist.sort()  
print(thislist)
```


```python
my_list_1 = [4, 5, 3, 1, 2]
my_list_1.sort(reverse=True)
print(my_list_1)

#[5, 4, 3, 2, 1]
```


Сортирует список в Пайтоне. По умолчанию от меньшего к большему:

```clike
numbers = [1, 5, 9, 6]
numbers.sort()
# обновлённый список: [1, 5, 6, 9]
```

Также можно сортировать последовательность элементов от большего к меньшему. Чтобы отсортировать по убыванию, используйте аргумент ключевого слова `reverse = True`:

Отсортируйте список по убыванию:

```python
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]  
thislist.sort(reverse = True)  
print(thislist)
```

```clike
numbers = [1, 5, 9, 6]
numbers.sort(reverse = true)
# обновлённый список: [9, 6, 5, 1]
```

По умолчанию `sort()`метод чувствителен к регистру, в результате все заглавные буквы сортируются перед строчными буквами:

Сортировка с учетом регистра может дать неожиданный результат:
`
```python
thislist = ["banana", "Orange", "Kiwi", "cherry"]  
thislist.sort()  
print(thislist)
```

К счастью, мы можем использовать встроенные функции в качестве ключевых при сортировке списка.

Поэтому, если вам нужна функция сортировки без учета регистра, используйте str.lower в качестве ключевой функции:



Выполните сортировку списка без учета регистра:

```python
thislist = ["banana", "Orange", "Kiwi", "cherry"]  
thislist.sort(key = str.lower)  
print(thislist)
```


Что делать, если вы хотите изменить порядок списка, независимо от алфавита?

The `reverse()` Метод меняет текущий порядок сортировки элементов на противоположный.

Обратный порядок элементов списка:

```python
thislist = ["banana", "Orange", "Kiwi", "cherry"]  
thislist.reverse()  
print(thislist)
```

---

### insert()

Вставить элемент в список:  `list.insert(i, x)

Добавит элемент x в позицию i списка:

```python
my_list = [1, 2, 3, 4, 4]
my_list.insert(1, 'new')
print(my_list)

#[1, 'new', 2, 3, 4, 4]
```


Чтобы вставить новый элемент списка, не заменяя ни одно из существующих значений, мы можем использовать `insert()`метод. The `insert()` метод вставляет элемент по указанному индексу.

Вставляет элемент перед указанным индексом:

```clike
numbers = [1, 5, 9, 6]
numbers.insert(3, [2, 3])
# обновлённый список: [1, 5, 9, [2, 3], 6]
```

Вставьте «арбуз» в качестве третьего элемента:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.insert(2, "watermelon")  
print(thislist)
```

---

### del 

Работа этого метода идентична конструкции: `del a[:]` :

```python
my_list = [1, 2, 3, 4, 5]
del my_list[:]
print(my_list)

#[]
```

The `del` ключевое слово также удаляет указанное индекс:

Удалить первый элемент:

```python
thislist = ["apple", "banana", "cherry"]  
del thislist[0]  
print(thislist)
```

The `del` ключевое слово также может полностью удалить список.

Удалить весь список:

```python
thislist = ["apple", "banana", "cherry"]  
del thislist
```

---

### remove()

Удалить элемент из списка (только первое вхождение)**:  ``` list.remove(x) ```

The `remove()`метод удаляет указанный элемент.

**Удалить «банан»:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.remove("banana")  
print(thislist)
```



```python
my_list = [1, 2, 3, 'четыре', 'четрые']
my_list.remove('четыре')
print(my_list)

#[1, 2, 3, 'четрые']
```

Удаляет первое попавшееся вхождение элемента в списке Python:

```clike
numbers = [1, 5, 9, 6, 1, 2, 1]
numbers.remove(1)
# обновлённый список: [5, 9, 6, 1, 2, 1]
```

---

### extend()

Сложение списков:  ``` list1.extend(list2)```

```python
my_list_1 = ['один', 'два', 'три', 'четыре', 'пять']
my_list_2 = [1, 2, 3, 4, 5]
my_list_1.extend(my_list_2)
print(my_list_1)

#['один', 'два', 'три', 'четыре', 'пять', 1, 2, 3, 4, 5]
```


Чтобы добавить элементы из _другого списка_ в текущий список, используйте `extend()` метод.

Подобно методу `append()`, добавляет элементы, но преимущество метода `extend()` в том, что он также позволяет добавлять списки:

```clike
numbers = [1, 5, 9, 6]
numbers.extend([2, 3])
# обновлённый список: [1, 5, 9, 6, 2, 3]
```

Добавьте элементы из `tropical`к `thislist`:

```python
thislist = ["apple", "banana", "cherry"]  
tropical = ["mango", "pineapple", "papaya"]  
thislist.extend(tropical)  
print(thislist)
```

---

### pop()

Удалить элемент из списка по индексу:  ``` list.pop([i])```

The `pop()`метод удаляет указанный индекс.

```python
my_list = [1, 2, 3, 4, 5]
my_list.pop(0)
print(my_list)

#[2, 3, 4, 5]
```

**Удалить второй элемент:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.pop(1)  
print(thislist)
```

Если не указать индекс, то будет удален последний элемент в списке:

```python
my_list = [1, 2, 3, 4, 5]
my_list.pop()
print(my_list)

#[1, 2, 3, 4]
```

Также этот метод не просто удаляет элемент, но и возвращает его:

```python
my_list = [1, 2, 3, 4, 5]
del_item = my_list.pop(1)
print(my_list)
print(del_item)

#[1, 3, 4, 5]
#2
```

Удалить последний элемент:

```python
thislist = ["apple", "banana", "cherry"]  
thislist.pop()  
print(thislist)
```

А данный метод (`pop()`) удаляет элемент в конкретно указанном индексе, а также выводит удалённый элемент. Если индекс не указан, метод по умолчанию удалит последний элемент:

```python
numbers = [1, 5, 9, 6]
numbers.pop(1)
# получаем:
# 5
# [1, 9, 6]
```

---

### join()

Объединение элементов списка в строку: ``` str.join(list)

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять']
delimiter = ' '
s = delimiter.join(my_list)
print(s)

#один два три четыре пять
```


```python
my_list = ['один', 'два', 'три', 'четыре', 'пять']
delimiter = '-'
s = delimiter.join(my_list)
print(s)

#один-два-три-четыре-пять
```

Преобразовывает список в строку. Разделитель элементов пишут в кавычках перед методом, а сам список Питона должен состоять из строк:

```clike
mylist = ['сайт', 'типичный', 'программист']
print(', '.join(mylist))
# вывод 'сайт, типичный, программист'
```
---

## Основные операции со списками

### Объединение списков:

```python
my_list_1 = [1, 2, 3]
my_list_2 = [4, 5, 6]
my_list_3 = my_list_1 + my_list_2

print(my_list_3)
#[1, 2, 3, 4, 5, 6]
```


```python
my_list_1 = ['один', 'два', 'три']
my_list_2 = ['четыре', 'пять', 'шесть']
my_list_3 = my_list_1 + my_list_2

print(my_list_3)
#['один', 'два', 'три', 'четыре', 'пять', 'шесть']

```

Другой способ соединить два списка — добавить все элементы из list2 в список. list1, один за другим:


Добавить список2 в список1:

```python
list1 = ["a", "b" , "c"]  
list2 = [1, 2, 3]  
  
for x in list2:  
  list1.append(x)  
  
print(list1)
```

Или вы можете использовать `extend()`метод, целью которого является добавление элементов из одного списка в другой список:

Использовать `extend()` метод добавления списка2 в конец списка1:

```python
list1 = ["a", "b" , "c"]  
list2 = [1, 2, 3]  
  
list1.extend(list2)  
print(list1)
```

---

### Повторение списка:

```python
my_list_1 = ['один', 'два', 'три']
my_list_1 = my_list_1 * 3
my_list_2 = [1, 2, 3]
my_list_2 *= 3 #Короткая запись

print(my_list_1)
print(my_list_2)
#['один', 'два', 'три', 'один', 'два', 'три', 'один', 'два', 'три']
#[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

---

### Сравнение списков:

```python
my_list_1 = ['один', 'два', 'три']
my_list_2 = ['четыре', 'пять', 'шесть']

if my_list_1 == my_list_2:
    print('Совпдают')

else:
    print('Не совпадают')

#Не совпадают
```

---

### Узнать длину списка:

```python
my_list = ['один', 'два', 'три']
print(len(my_list))
#3
```

---

### Сумма элементов списка (только числовые значения):

```python
my_list = [1, 2, 3]
print(sum(my_list))
```

---

### Максимальное и минимальное значение элементов в списке:

```python
my_list = [1, 2, 3]

print(min(my_list))
print(max(my_list))

#1
#3

```

---

### Строковые значения сравниваются в алфавитном порядке:

```python
my_list = ['один', 'два', 'три', 'ааааа']

print(min(my_list))
print(max(my_list))

#ааааа
#три
```

---

### Перебор списков с помощью циклов

#### Циклом for:

Вы можете просмотреть элементы списка, используя `for` петля:

Распечатайте все элементы в списке, один за другим:

```python
thislist = ["apple", "banana", "cherry"]  
for x in thislist:  
  print(x)

```

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

for i in range(len(my_list)):
    print(my_list[i])

#один
#два
#три
#четыре
#пять!
```

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

for item in my_list:
    print(item)

#один
#два
#три
#четыре
#пять!
```

#### Циклом while:

Вы можете просмотреть элементы списка, используя  цикл `while`.

Использовать `len()` функция для определения длины списка, затем начните с 0 и прокручивайте элементы списка, обращаясь к их индексам.

Не забывайте увеличивать индекс на 1 после каждой итерации.

Распечатайте все элементы, используя `while`петля, чтобы идти по всем порядковым номерам

```python
thislist = ["apple", "banana", "cherry"]  
i = 0  
while i < len(thislist):  
  print(thislist[i])  
  i = i + 1
```


```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']
i = 0

while i < len(my_list):

    print(my_list[i])
    i += 1

#один
#два
#три
#четыре
#пять!
```

---

### Удаление элемента из списка

Возможны несколько способов удаления элементов из списка, рассмотрим оператор de.

Конструкция выглядит так:  

`del list[i]`, где list — список, i — индекс (позиция) элемента в списке:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

del my_list[0]
del my_list[-1]

print(my_list)

#['два', 'три', 'четыре']
```

Если нужно удалить более 1 элемента, можно использовать срезы:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять!']

del my_list[1:3]
print(my_list)

#['один', 'четыре', 'пять!']
```


### Понимание списка

Понимание списков предлагает более короткий синтаксис, когда вы хотите создать новый список на основе значений существующий список.

Например: На основе списка фруктов вам нужен новый список, содержащий только фрукты с буквой «а» в названии.

Без понимания списка вам придется написать `for`утверждение с условным тестом внутри:

```python
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]  
newlist = []  
  
for x in fruits:  
  if "a" in x:  
    newlist.append(x)  
  
print(newlist)
```


## Заключение

Список — индексированная последовательность значений любого типа, а также смешанных типов. Причем в отличии от [[HH. Строки | строки]] это изменяемая последовательность элементов.


# Кортежи


Кортежи используются для хранения нескольких элементов в одной переменной. Кортеж (tuple) представляет последовательность элементов, которая во многом похожа на список за тем исключением, что кортеж является неизменяемым (immutable) типом. Поэтому мы не можем добавлять или удалять элементы в кортеже, изменять его.

Tuple — это один из 4 встроенных типов данных в Python, используемых для хранения коллекций data, остальные 3 — [List](https://www.w3schools.com/python/python_lists.asp) , [Set](https://www.w3schools.com/python/python_sets.asp) и [Dictionary](https://www.w3schools.com/python/python_dictionaries.asp) , все с разными качествами и использованием.

Кортеж — это упорядоченная и **неизменяемая** коллекция.

Кортеж, по сути - неизменяемый [[#Списки | список]]

## Зачем нужны кортежи, если есть списки?

-   Защита от дурака. То есть кортеж защищен от изменений, как намеренных (что плохо), так и случайных (что хорошо).
-   Неизменяемость. Если вам нужно, чтобы значения были всегда постоянными.
-   Скорость. Кортежи работают быстрее списков (как раз по причине неизменяемости).
-   Безопасность. Т.к. в Python нет констант, то использование кортежей в роли констант, дадут требуемую неизменяемость констант.
-   Кортежи можно использовать в качестве ключей у словарей.
-   Меньший размер. Дабы не быть голословным:

```python
>>> a = (1, 2, 3, 4, 5, 6)
>>> b = [1, 2, 3, 4, 5, 6]
>>> a.__sizeof__()
36
>>> b.__sizeof__()
44
```


## Создание кортежа в Python

Кортежи пишутся с круглыми скобками.

Создайте кортеж:

```python
thistuple = ("apple", "banana", "cherry")  
print(thistuple)
```

Для создания кортежа используются круглые скобки, в которые помещаются его значения, разделенные запятыми:
 
```python
tom = ("Tom", 23)
print(tom)   #("Tom", 23)
```

Также для определения кортежа мы можем просто перечислить значения через запятую без применения скобок:

```python
tom = "Tom", 23
print(tom)     #("Tom", 23)
```

Если вдруг кортеж состоит из одного элемента, то после единственного элемента кортежа необходимо поставить запятую:

```python
tom = ("Tom",)
```

Тип данных:

```python
my_tuple = (1, 2, 3, 4, 5)
print(type(my_tuple))

#<class 'tuple'>
```

Так, как кортеж не изменяемая последовательность, то если попытаться изменить значение в кортеже, то будет ошибка:

```python
my_tuple = (1, 2, 3, 4, 5)
my_tuple[1] = 10

#builtins.TypeError: 'tuple' object does not support item assignment
```

## Индексация и срезы кортежей

Здесь все аналогично спискам.

Элементы кортежа упорядочены, неизменны и допускают дублирование значений.

Элементы кортежа индексируются, первый элемент имеет индекс `[0]`, второй элемент имеет индекс `[1]` и т.п.

Когда мы говорим, что кортежи упорядочены, это означает, что элементы имеют определенный порядок, и этот порядок не изменится.

Кортежи неизменяемы, что означает, что мы не можем изменять, добавлять или удалять элементы после того, как кортеж был создан.

Индексация элементов начинается с 0:

+---+---+---+---+---+---+

|  p  |  y  |  t  |   h  |  o  |  n  |

+---+---+---+---+---+---+

 0     1     2      3     4      5

-6    -5   -4    -3    -2     -1


```python
my_tuple = ('один', 'два', 'три', 'четыре', 'пять!')

print(my_tuple[0])
print(my_tuple[2])
print(my_tuple[-1])

#один
#три
#пять!
```

### Срезы кортежей

Формула среза в кортежах, такая же, как и в списках X[I:J:Step]. Извлечь все содержимое кортежа Х , начиная со смещения I до смещения J, не включая его, с шагом Step.

```python
my_tuple = ('один', 'два', 'три', 'четыре', 'пять!')

print(my_tuple[1:4])
print(my_tuple[1:])
print(my_tuple[:3])
print(my_tuple[::2])

#('два', 'три', 'четыре')
#('два', 'три', 'четыре', 'пять!')
#('один', 'два', 'три')
#('один', 'три', 'пять!')
```

```python
my_tuple = ('один', 'два', 'три', 'четыре', 'пять!')

print(my_tuple[::-1])

#('пять!', 'четыре', 'три', 'два', 'один')
```


## Работа с кортежами

Создаем пустой кортеж:

```python
>>>

>>> a = tuple() # С помощью встроенной функции tuple()
>>> a
()
>>> a = () # С помощью литерала кортежа
>>> a
()
>>>
```
Создаем кортеж из одного элемента:

```python
>>>

>>> a = ('s')
>>> a
's'
```

Стоп. Получилась строка. Но как же так? Мы же кортеж хотели! Как же нам кортеж получить?

```python
>>>

>>> a = ('s', )
>>> a
('s',)
```

Ура! Заработало! Все дело - в запятой. Сами по себе скобки ничего не значат, точнее, значат то, что внутри них находится одна инструкция, которая может быть отделена пробелами, переносом строк и прочим мусором. Кстати, кортеж можно создать и так:

```python
>>>

>>> a = 's',
>>> a
('s',)
```

Но все же не увлекайтесь, и ставьте скобки, тем более, что бывают случаи, когда скобки необходимы.

Ну и создать кортеж из итерируемого объекта можно с помощью все той же пресловутой функции tuple()

```python
>>>

>>> a = tuple('hello, world!')
>>> a
('h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!')
```

Все [операции над списками](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html), не изменяющие список (сложение, умножение на число, методы index() и count() и некоторые другие операции). Можно также по-разному менять элементы местами и так далее.

Например, гордость программистов на python - поменять местами значения двух переменных:

a, b = b, a

### Объединение кортежей

```python
my_tuple_1 = (1,2,3,4)
my_tuple_2 = (5,6,7,8)

my_tuple_3 = my_tuple_1 + my_tuple_2

print(my_tuple_3)

#(1, 2, 3, 4, 5, 6, 7, 8)
```

```python
my_tuple_1 = ('один', 'два', 'три')
my_tuple_2 = ('четыре', 'пять')
my_tuple_3 = my_tuple_1 + my_tuple_2

print(my_tuple_3)

#('один', 'два', 'три', 'четыре', 'пять')
```

### Повторение кортежей

```python
my_tuple_1 = (1, 2, 3)
my_tuple_2 = my_tuple_1 * 2

print(my_tuple_2)

#(1, 2, 3, 1, 2, 3)

```


```python
my_tuple_1 = ('один', 'два', 'три')
my_tuple_2 = my_tuple_1 * 3

print(my_tuple_2)

#('один', 'два', 'три', 'один', 'два', 'три', 'один', 'два', 'три')
```


### Присвоение значений переменным с помощью кортежей

```python
my_tuple = (1, 2, 3)
(a, b, c) = my_tuple

print(a)
print(b)
print(c)

#1
#2
#3
```

Здесь два кортежа, один с переменными, второй со значениями переменных. Переменным из кортежа присваиваем значения из значения из первого кортежа my_tuple.

## Основные методы кортежей

Т.к. кортежи неизменяемы, то у них нет многих методов, которые есть у списков. Рассмотрим наиболее часто употребляемые методы кортежей.

### Длина кортежа: len(t)

Чтобы определить, сколько элементов содержит кортеж, используйте `len()`функция:

```python
my_tuple_1 = (1, 2, 3)
print(len(my_tuple_1))

#3
```

Выведите количество элементов в кортеже:

```python
thistuple = ("apple", "banana", "cherry")  
print(len(thistuple))
```

### Количество элементов х в кортеже: tuple.count(x)

Возвращает количество раз, когда указанное значение встречается в кортеже

```python
my_tuple_1 = (1, 2, 3, 1)
print(my_tuple_1.count(1))

#2
```


### Найти индекс элемента x:  tuple.index(x[, start[, end]])

Ищет в кортеже указанное значение и возвращает позицию, в которой оно было найдено.
Необязательные аргументы start и end, указывают на промежуток поиска:

```python
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple.index(4))

#3

```


```python
my_tuple = ('один', 'два', 'три', 'четыре', 'пять')
print(my_tuple.index('три', 1, 3))

#2
```

Если элемента нет в списке:

```python
my_tuple = ('один', 'два', 'три', 'четыре', 'пять')
print(my_tuple.index('шесть'))

#builtins.ValueError: tuple.index(x): x not in tuple
```

## Основные функции кортежей

### Преобразование данных в кортеж: tuple()

Преобразуем список в кортеж:

```python
my_list = ['один', 'два', 'три', 'четыре', 'пять']
my_tuple = tuple(my_list)

print(my_tuple)
print(type(my_tuple))

#('один', 'два', 'три', 'четыре', 'пять')
#<class 'tuple'>
```

### Максимальное значение в кортеже: max()

```python
my_tuple = (1, 2, 3, 4, 5)
print(max(my_tuple))

#5
```

### Минимальное значение в кортеже: min()

```python
my_tuple = (1, 2, 3, 4, 5)
print(min(my_tuple))

#1
```

### Сумма элементов кортежа: sum()

Работает только для числовых данных:

```python
my_tuple = (1, 2, 3, 4, 5)
print(sum(my_tuple))

#15
```

### Сортировка элементов кортежа: sorted()

```python
my_tuple = (3, 1, 2, 4, 5)
sort = sorted(my_tuple)

print(sort)
print(type(sort))

#[1, 2, 3, 4, 5]
#<class 'list'>
```

Но важно заметить, что после сортировки тип будет уже list , т.е. список, а не кортеж.

Кортежи неизменяемы, что означает, что вы не можете изменять, добавлять или удалять элементы после создания кортежа.

Но есть некоторые обходные пути.

---

## Изменить значения кортежа

После создания кортежа вы не можете изменить его значения. Кортежи **неизменны** , или **неизменяемый** , как его еще называют.

Но есть обходной путь. Вы можете преобразовать кортеж в список, изменить list и преобразовать список обратно в кортеж.

Преобразуйте кортеж в список, чтобы иметь возможность его изменить:

```python
x = ("apple", "banana", "cherry")  
y = list(x)  
y[1] = "kiwi"  
x = tuple(y)  
  
print(x)
```

## Распаковка кортежа

Когда мы создаем кортеж, мы обычно присваиваем ему значения. Это называется "упаковкой" кортежа:

Упаковка кортежа:

```python
fruits = ("apple", "banana", "cherry")  
```

Но в Python нам также разрешено извлекать значения обратно в переменные. Это называется "распаковка":

Распаковка кортежа:

```python
fruits = ("apple", "banana", "cherry")    
(green, yellow, red) = fruits  
  
print(green)  
print(yellow)  
print(red)
```

### Использование звездочки `*`

Если количество переменных меньше количества значений, вы можете добавить `*`к имени переменной и значения будут присвоены переменной в виде списка:

Назначьте остальные значения в виде списка под названием «красный»:

```python
fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")    
(green, yellow, *red) = fruits  
  
print(green)  
print(yellow)  
print(red)
```

Если звездочка добавлена к другому имени переменной, чем последнее, Python будет присваивать значения переменной до тех пор, пока количество оставшихся значений не совпадет с количеством оставшихся переменных.

Добавьте список значений переменной "tropic":

```python
fruits = ("apple", "mango", "papaya", "pineapple", "cherry")    
(green, *tropic, red) = fruits  
  
print(green)  
print(tropic)  
print(red)
```


## Цикл через кортеж

Вы можете перебрать элементы кортежа, используя `for`петля.


Переберите элементы и распечатайте значения:

```python
thistuple = ("apple", "banana", "cherry")  
for x in thistuple:  
  print(x)
```

Узнать больше о `for`циклы в нашей [Python For Loops .](https://www.w3schools.com/python/python_for_loops.asp) главе

---

## Цикл по номерам индексов

Вы также можете прокручивать элементы кортежа, обращаясь к их порядковому номеру.

Использовать `range()`а также `len()`функции для создания подходящего итерируемого объекта.

Распечатайте все элементы, ссылаясь на их порядковый номер:

```python
thistuple = ("apple", "banana", "cherry")  
for i in range(len(thistuple)):  
  print(thistuple[i])
```

---

## Использование цикла while

Вы можете просмотреть элементы списка, используя `while`петля.

Использовать `len()`функция для определения длины кортежа, затем начните с 0 и пройдитесь по элементам кортежа, ссылаясь на их индексы.

Не забывайте увеличивать индекс на 1 после каждой итерации.

Распечатайте все элементы, используя `while`цикл для просмотра всех индексов:

```python
thistuple = ("apple", "banana", "cherry")  
i = 0  
while i < len(thistuple):  
  print(thistuple[i])  
  i = i + 1
```

Узнать больше о `while`петли в нашем [о циклах в Python .](https://www.w3schools.com/python/python_while_loops.asp) Глава

---

# Наборы 

Python Set похож на словарь, неупорядоченный набор ключей, который хранится без каких-либо значений. Тип набор изменяемый , содержание может быть изменено с помощью методов , как Add() и удалить() . Наборы или же множество не содержат дубликатов, каждый элемент в наборе Python может иметь только одно вхождение в этом конкретном наборе, допускать множественные вхождения.


Наборы используются для хранения нескольких элементов в одной переменной.

Set — один из 4 встроенных типов данных в Python, используемых для хранения коллекций data, остальные 3 — [List](https://www.w3schools.com/python/python_lists.asp) , [Tuple](https://www.w3schools.com/python/python_tuples.asp) и [Dictionary](https://www.w3schools.com/python/python_dictionaries.asp) , все с разными качествами и использованием.

Набор — это коллекция, которая является _неупорядоченной_ , _неизменной*_ и _неиндексированной_ .

Множество (set) представляют еще один вид набора, который хранит только уникальные элементы. Для определения множества используются фигурные скобки, в которых перечисляются элементы:


```python	
users = {"Tom", "Bob", "Alice", "Tom"}
print(users)    # {"Alice", "Bob", "Tom"}
```

Обратите внимание, что несмотря на то, что функция print вывела один раз элемент "Tom", хотя в определении множества этот элемент содержится два раза. Все потому что множество содержит только уникальные значения.

Также для определения множества может применяться функция set(), в которую передается список или кортеж элементов:
```python
people = ["Mike", "Bill", "Ted"]
users = set(people)
print(users)    # {"Mike", "Bill", "Ted"}
```

Функцию set удобно применять для создания пустого множества:

```python
users = set()
```

Для получения длины множества применяется встроенная функция len():

```python
users = {"Tom", "Bob", "Alice"}
print(len(users))       # 3
```

Добавление элементов

Для добавления одиночного элемента вызывается метод add():
```python	
users = set()
users.add("Sam")
print(users)
```

Удаление элементов

Для удаления одного элемента вызывается метод remove(), в который передается удаляемый элемент. Но следует учитывать, что если такого элемента не окажется в множестве, то будет сгенерирована ошибка. Поэтому перед удалением следует проверять на наличие элемента с помощью оператора in:


```python	
users = {"Tom", "Bob", "Alice"}
 
user = "Tom"
if user in users: 
    users.remove(user)
print(users)    # {"Bob", "Alice"}
```

Также для удаления можно использовать метод discard(), который не будет генерировать исключения при отсутствии элемента:

```python	
users = {"Tom", "Bob", "Alice"}
 
users.discard("Tim")    # элемент "Tim" отсутствует, и метод ничего не делает
print(users)    #  {"Tom", "Bob", "Alice"}
 
users.discard("Tom")    # элемент "Tom" есть, и метод удаляет элемент
print(users)    #  {"Bob", "Alice"}
```

Для удаления всех элементов вызывается метод clear():

```python
users.clear()
```

Перебор множества

Для перебора элементов можно использовать цикл for:

```python	
users = {"Tom", "Bob", "Alice"}
 
for user in users:
    print(user)
```

При переборе каждый элемент помещается в переменную user.

Операции с множествами

С помощью метода copy() можно скопировать содержимое одного множества в другую переменную:
```python
users = {"Tom", "Bob", "Alice"}
students = users.copy()
print(students)     # {"Tom", "Bob", "Alice"}
```

Метод union() объединяет два множества и возвращает новое множество:

```python
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
 
users3 = users.union(users2)

print(users3)   # {"Bob", "Alice", "Sam", "Kate", "Tom"}
```

Пересечение множеств позволяет получить только те элементы, которые есть одновременно в обоих множествах. Метод intersection() производит операцию пересечения множеств и возвращает новое множество:

```python
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
 
users3 = users.intersection(users2)
print(users3)   # {"Bob"}
```

Вместо метода intersection мы могли бы использовать операцию логического умножения:

```python	
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
 
print(users & users2)   # {"Bob"}
```

В этом случае мы получили бы тот же результат.

Еще одна операция - разность множеств возвращает те элементы, которые есть в первом множестве, но отсутствуют во втором. Для получения разности множеств можно использовать метод difference или операцию вычитания:

```python
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
 
users3 = users.difference(users2)
print(users3)           # {"Tom", "Alice"}
print(users - users2)   # {"Tom", "Alice"}
```

Отдельная разновидность разности множеств - симметрическая разность производится с помощью метода symmetric_difference(). Она возвращает все элементы обоих множеств за исключением общих:

```python
users = {"Tom", "Bob", "Alice"}
users2 = {"Sam", "Kate", "Bob"}
 
users3 = users.symmetric_difference(users2)
print(users3)   # {"Tom", "Alice", "Sam", "Kate"}
```

Отношения между множествами

Метод issubset позволяет выяснить, является ли текущее множество подмножеством (то есть частью) другого множества:

```python
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
 
print(users.issubset(superusers))   # True
print(superusers.issubset(users))   # False
```

Метод issuperset, наоборот, возвращает True, если текущее множество является надмножеством (то есть содержит) для другого множества:

```python
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
 
print(users.issuperset(superusers))   # False
print(superusers.issuperset(users))   # True
```

frozen set

Тип frozen set является видом множеств, которое не может быть изменено. Для его создания используется функция frozenset:

```python
users = frozenset({"Tom", "Bob", "Alice"})
```

В функцию frozenset передается набор элементов - список, кортеж, другое множество.

В такое множество мы не можем добавить новые элементы, как и удалить из него уже имеющиеся. Собственно поэтому frozen set поддерживает ограниченный набор операций:

- len(s): возвращает длину множества

- x in s: возвращает True, если элемент x присутствует в множестве s

- x not in s: возвращает True, если элемент x отсутствует в множестве s

- s.issubset(t): возвращает True, если t содержит множество s

- s.issuperset(t): возвращает True, если t содержится в множестве s

- s.union(t) : возвращает объединение множеств s и t

- s.intersection(t): возвращает пересечение множеств s и t

- s.difference(t): возвращает разность множеств s и t

- s.copy(): возвращает копию множества s


# Словари


Словари также называют ассоциативными массивами или хеш-таблицами.

В словарях данные хранятся в виде пар ключ-значение {key:value}. Синтаксис словаря

Словари в Python выглядят следующим образом:

```python
my_dict = { ключ1:значение1, ключ2:значение2, ....}
```

Ключи — всегда уникальные, они должны быть неизменяемого типа (строки, числа)
Значения — могут быть любыми и необязательно уникальными.

```python
my_dict = {'ru': 'Россия', 'au': 'Австралия', 'is': 'Исландия'}
print(type(my_dict))
#<class 'dict'>
```

Применение словаря

Основное применение словаря — это хранение в нем значений с ключами и получение доступа к этим значениям по заданным ключам.
Создание словаря

Способ 1. Создание словаря с помощью фигурных скобок

```python
my_dict = {'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
print(my_dict)
#{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
```

Словари могу быть вложенными (т.е. словари внутри словарей):

```python
my_dict = {
    1: {'Sasha': 35},
    2: {'Maxim': 30}
    }
print(my_dict)
#{1: {'Sasha': 35}, 2: {'Maxim': 30}}
```

Способ 2. Создание словаря с помощью функции dict()

Функция принимает переменные со значениями и создает из них словарь:

```python
my_dict = dict(Sasha=35, Maxim=30, Ivan=20)
print(my_dict)
#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
```

Также эта функция работает и со списком кортежей из двух элементов (которые будут преобразованы в ключ:значение):

```python
my_list = [('Sasha', 35), ('Maxim', 30), ('Ivan', 20)]
my_dict = dict(my_list)
print(my_dict)
#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
```

Или со вложенными списками:

```python
my_list = [['Sasha', 35], ['Maxim', 30], ['Ivan', 20]]
my_dict = dict(my_list)
print(my_dict)
#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
```

Способ 3. Создание словаря с помощью метода dict.fromkeys(list, value)

В этом случае каждый ключ будет иметь одно и то же заданное значение:

```python
my_list = ['key1', 'key2', 'key3']
my_dict = dict.fromkeys(my_list, 555)
print(my_dict)

#{'key1': 555, 'key2': 555, 'key3': 555}
```

Из списка берутся элементы, далее этот метод делает их ключами словаря, а значениями будут аргумент value.

Если его не указать, то получится такой словарь:

```python
my_list = ['key1', 'key2', 'key3']
my_dict = dict.fromkeys(my_list)
print(my_dict)

#{'key1': None, 'key2': None, 'key3': None}
```

Способ 4. Создание словаря с помощью функции zip() вызванной внутри функции dict()

Для этого нужно два списка, один будет ключами словаря, а второй список — значениями. Если длина списков не совпадет, лишнее просто 
не будет использоваться для создания словаря.

```python
key_list = ['key1', 'key2', 'key3']
value_list = ['value1', 'value2', 'value3']
my_dict = dict(zip(key_list, value_list))
print(my_dict)

#{'key1': 'value1', 'key2': 'value2', 'key3': 'value3'}
```

Способ 5. Создание словаря с помощью генератора словарей

Создадим простой словарь в цикле:

```python
my_dict = {a: a for a in range(5)}
print(my_dict)

#{0: 0, 1: 1, 2: 2, 3: 3, 4: 4}
```

Мы создали числовой диапазон range от 0 до 4 и в словарь добавили ключи и значения от 0 до 4 циклом.

```python
my_dict = {a: a+1 for a in range(5)}
print(my_dict)

#{0: 1, 1: 2, 2: 3, 3: 4, 4: 5}
```

Здесь ключами словаря мы сделали числа из range , а значениям добавили +1. Работа со словарями в Python Получение значений словаря

Для того, чтобы получить значение словаря необходимо обратиться к ключу. Просто указать ключ в квадратных скобках.

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict['Maxim'])

#30
```

Если обратиться к словарю по несуществующему ключу, то получим ошибку:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict['Petr'])

#builtins.KeyError: 'Petr'
```

Чтобы не получать таких ошибок при обращении по несуществующему ключу можно использовать метод dict.get(key[, default]).
Если запрошенного ключа не будет в словаре, то метод вернет default , если он не указан, то вернет None:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.get('Petr', 'Not found'))

#Not found
```

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.get('Petr'))

#None
```

Добавление нового элемента в словарь

Чтобы добавить одиночный элемент в словарь нужно просто добавить новую пару ключ:значение:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict['Petr'] = 25
print(my_dict)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Petr': 25}
```

Чтобы добавить сразу несколько элементов в словарь можно использовать метода dict.update([other]):

В other передаем словарь, которые нужно добавить в существующий словарь:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.update({'Nikita': 33, 'Roma': 18})
print(my_dict)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Nikita': 33, 'Roma': 18}
```

Или именованные аргументы:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.update(Nikita=33, Roma=18)
print(my_dict)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Nikita': 33, 'Roma': 18}
```

Или список кортежей:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.update([('Nikita', 33), ('Roma', 18)])
print(my_dict)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Nikita': 33, 'Roma': 18}
```

Обновление существующего значения в словаре

Для этого обращаемся к значению по ключу и передаем новое значение:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict['Ivan'] = 40
print(my_dict)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 40}
```

Чтобы обновить сразу несколько значений в словаре, используем метод dict.update([other]):

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.update({'Sasha': 45, 'Maxim': 40})
print(my_dict)

#{'Sasha': 45, 'Maxim': 40, 'Ivan': 20}
```

Удаление элементов словаря

Есть несколько способов удаления элементов из словаря.

Способ 1. Удаление элемента с помощью оператора del

Указываем оператор del, далее имя словаря и в квадратных скобках ключ, после выполнения запись с этим ключем будет удалена:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
del my_dict['Ivan']
print(my_dict)

#{'Sasha': 35, 'Maxim': 30}
```

Способ 2. Удаление элемента с помощью метода dict.pop(key[, default])

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.pop('Ivan')
print(my_dict)

#{'Sasha': 35, 'Maxim': 30}
```

Если удаляемого ключа нет в словаре, получим default , а если default не задан, то будет ошибка KeyError:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.pop('Petr')
print(my_dict)

#builtins.KeyError: 'Petr'
```

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
item = my_dict.pop('Petr', 'Not found')
print(my_dict)
print(item)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
#Not found
```

Также этот метод возвращает значение, которое было удалено из словаря:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
item = my_dict.pop('Ivan')
print(my_dict)
print(item)

#{'Sasha': 35, 'Maxim': 30}
#20
```

Способ 3. Удаление последнего элемента словаря методом dict.popitem()

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.popitem()
print(my_dict)

#{'Sasha': 35, 'Maxim': 30}
```

Очистить и удалить словарь целиком 

Для того, чтобы полностью удалить весь словарь используется оператор del:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
del my_dict
print(my_dict)

#builtins.NameError: name 'my_dict' is not defined
```

Чтобы удалить все значения словаря используется метод dict.clear():

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict.clear()
print(my_dict)

#{}
```

Проверка наличия ключа в словаре

Для того, чтобы узнать есть ли нужный ключ в словаре используется оператор in:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print('Maxim' in my_dict)
#True
```

Если ключа в словаре нет, то вернется False:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print('Roma' in my_dict)

#False
```

Другие методы словарей

Получить список кортежей пар словаря ключ:значение: dict.items()

``` python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.items())

#dict_items([('Sasha', 35), ('Maxim', 30), ('Ivan', 20)])
```

Получить список ключей словаря: dict.keys()

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.keys())

#dict_keys(['Sasha', 'Maxim', 'Ivan'])
```

Получить список значений словаря: dict.values()

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.values())

#dict_values([35, 30, 20])
```

Создание копии словаря: dict.copy()

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
my_dict_2 = my_dict.copy()
print(my_dict_2)

#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
```

Получить значение ключа и если его нет, то создать: dict.setdefault(key[, default])

Метод проверяет, есть ли значение у ключа, если есть то возвращает его, если нет, то создает новый элемент словаря с ключом key
и значением default (по умолчанию None):

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.setdefault('Petr'))
print(my_dict)

#None
#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Petr': None}
```

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(my_dict.setdefault('Petr', 50))
print(my_dict)

#50
#{'Sasha': 35, 'Maxim': 30, 'Ivan': 20, 'Petr': 50}
```

Основные функции словарей

Длина словаря: len(dict)

Под длиной словаря в Python подразумевается количество пар ключ:значение:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(len(my_dict))

#3
```

Сортировка словаря: sorted(dict)

Получим сортированный список ключей словаря:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
print(sorted(my_dict))

#['Ivan', 'Maxim', 'Sasha']
```

Перебор словаря

Перебор ключей словаря с помощью цикла for:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
for key in my_dict:
    print(key)

#Sasha
#Maxim
#Ivan
```

Перебор словаря с помощью цикла for и метода dict.items()

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
for k, v in my_dict.items():
    print(k, v)

#Sasha 35
#Maxim 30
#Ivan 20
```

Перебор словаря с помощью цикла for и метода dict.keys()

Получим ключи словаря:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
for key in my_dict.keys():
    print(key)

#Sasha
#Maxim
#Ivan
```

Перебор словаря с помощью цикла for и метода dict.values()

Получим значения словаря:

```python
my_dict = {'Sasha': 35, 'Maxim': 30, 'Ivan': 20}
for values in my_dict.values():
    print(values)
#35
#30
#20
```

**Словари в Python** - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Чтобы работать со словарём, его нужно создать. Сделать это можно несколькими способами. Во-первых, с помощью литерала:

```python
>>>

>>> d = {}
>>> d
{}
>>> d = {'dict': 1, 'dictionary': 2}
>>> d
{'dict': 1, 'dictionary': 2}
```

Во-вторых, с помощью функции **dict**:

```python
>>>

>>> d = dict(short='dict', long='dictionary')
>>> d
{'short': 'dict', 'long': 'dictionary'}
>>> d = dict([(1, 1), (2, 4)])
>>> d
{1: 1, 2: 4}
```

В-третьих, с помощью метода fromkeys:

```python
>>>

>>> d = dict.fromkeys(['a', 'b'])
>>> d
{'a': None, 'b': None}
>>> d = dict.fromkeys(['a', 'b'], 100)
>>> d
{'a': 100, 'b': 100}
```

В-четвертых, с помощью генераторов словарей, которые очень похожи на [генераторы списков](https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html).

```python
>>>

>>> d = {a: a ** 2 for a in range(7)}
>>> d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

Теперь попробуем добавить записей в словарь и извлечь значения ключей:

```python
>>>

>>> d = {1: 2, 2: 4, 3: 9}
>>> d[1]
2
>>> d[4] = 4 ** 2
>>> d
{1: 2, 2: 4, 3: 9, 4: 16}
>>> d['1']
Traceback (most recent call last):
  File "", line 1, in
    d['1']
KeyError: '1'
```

Как видно из примера, присвоение по новому ключу расширяет словарь, присвоение по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение. Для избежания исключения есть специальный метод (см. ниже), или можно [перехватывать исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html).

Что же можно еще делать со словарями? Да то же самое, что и с другими объектами: [встроенные функции](https://pythonworld.ru/osnovy/vstroennye-funkcii.html), [ключевые слова](https://pythonworld.ru/osnovy/klyuchevye-slova-modul-keyword.html) (например, [циклы for и while](https://pythonworld.ru/osnovy/cikly-for-i-while-operatory-break-i-continue-volshebnoe-slovo-else.html)), а также специальные методы словарей.

## Методы словарей

- **dict.clear**() - очищает словарь.

- **dict.copy**() - возвращает копию словаря.

- classmethod **dict.fromkeys**(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).

- **dict.get**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).

- **dict.items**() - возвращает пары (ключ, значение).

- **dict.keys**() - возвращает ключи в словаре.

- **dict.pop**(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).

- **dict.popitem**() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.

- **dict.setdefault**(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).

- **dict.update**([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).

- **dict.values**() - возвращает значения в словаре.