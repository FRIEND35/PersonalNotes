# Описание 


**stdlib.h** (расшифровывается как _standard library_ — стандартная библиотека ) — [заголовочный файл](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB) [стандартной библиотеки](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F_%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0_%D0%A1%D0%B8) языка [Си](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)), который содержит в себе функции, занимающиеся выделением памяти, контролем процесса выполнения программы, преобразованием типов, сортировка, поиск, математика и другие. Заголовок stdlib.h определяет четыре типа переменных, несколько макросов и различные функции для выполнения общих функций. Простыми словами, при подключеия данного библиотека, у вас будет много возможности.


# Библиотечные переменные

Ниже приведены типы переменных, определенные в заголовке stdlib.h.

- **size_t**  - Это целочисленный тип без знака, который является результатом  sizeof .
- **wchar_t** - Это целочисленный тип размера **широкосимвольной** константы.
- **div_t** - Это структура, возвращаемая **div** функцией
- **ldiv_t** - Это структура, возвращаемая **ldiv** .

# Библиотечные макросы

Ниже приведены макросы, определенные в заголовке stdlib.h.

-  **NULL** - Этот макрос является значением константы нулевого указателя.

-  **EXIT_FAILURE** - Это значение, которое функция выхода возвращает в случае сбоя.

- **EXIT_SUCCESS** - Это значение, которое функция выхода возвращает в случае успеха.

-  **RAND_MAX** - Этот макрос является максимальным значением, возвращаемым функцией rand.

- **MB_CUR_MAX** - Этот макрос представляет собой максимальное количество байтов в многобайтовом наборе символов, которое не может превышать MB_LEN_MAX.


# Функции stdlib.h

Ниже приведены функции, определенные в заголовке stlib.h 


|Имя                   | Описание                                                               ||
|-----------------------|------------------------------------------------------------------------|
|                           |                           **Преобразование типов**                                            |                     |
| atof                  | строка в число двойной точности (double; НЕ float)                     | 
| atoi                  | строка в целое число (integer)                                         | 
| atol                  | строка в длинное целое число (long integer)                            | 
| atoll                 | строка в длинное целое число (long long integer)                       | 
| strtod                | строка в число двойной точности (double)                               |
| strtof                | строка в число одиночной точности (float)                              | 
| strtol                | строка в длинное целое число (long integer)                            | 
| strtold               | строка в длинное двойной точности (long double)                        | 
| strtoll               | строка в длинное целое число (long long integer)                       | 
| strtoul               | строка в беззнаковое длинное целое число (unsigned long integer)       ||
| strtoull              | строка в беззнаковое длинное целое число (unsigned long long integer)  ||



|                                   | Генерация псевдослучайных последовательностей                     |    
| --------------------------------- | ----------------------------------------------------------------- | 
| rand                              | генерирует псевдослучайное значение                               | 
| srand                             | устанавливает начальное значение генератора псевдослучайных чисел |   


|                         | Выделение и освобождение памяти   |
| ----------------------- | --------------------------------- |
| malloc, calloc, realloc | выделяет память из кучи           |
| free                    | освобождает память обратно в кучу |

|         | Сортировка и поиск       |
| ------- | ------------------------ |
| bsearch | двоичный поиск в массиве |
| qsort   | сортировка массива       |


|      |         Математика                          |     |     |
| -------------- | -------------------------------- |
| abs, labs      | абсолютная величина целого числа | 
| llabs, imaxabs | Нет                              | 
| div            |                                  |  
| ldiv           | деление целых чисел              |

|  |                 Многобайтовые операции/ широкие символы                                   |   
| --------------------------------------- | -------------------------------------------------- | 
| mblen                                   | размер многобайтовых символов                  |
| mbtowc, wctomb, mbstowcs, wcstombs      | преобразование многобайтовых и широких символов| 

|        | Контроль процесса выполнения программы                                                                |
| ------ | ----------------------------------------------------------------------------------------------------- |
| abort  | некорректное завершение выполнения                                                                    |
| atexit | регистрирует обратный вызов функции, которую нужно будет выполнить перед завершением работы программы |
| exit   | завершает выполнение программы                                                                        |
| getenv | извлекает переменные окружения                                                                        |
| system | выполняет внешнюю команду                                                                             |

### NULL

Заголовочные файлы `stdlib.h` и `stddef.h` определяют [макрос](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BA%D1%80%D0%BE%D1%81 "Макрос") [NULL](https://ru.wikipedia.org/wiki/NULL_(%D0%A1%D0%B8) "NULL (Си)"), являющийся константным [нуль-указателем](https://ru.wikipedia.org/wiki/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) "Указатель (тип данных)"), который гарантированно указывает на некорректный адрес памяти.

#### Варианты

NULL может быть определен как константное выражение, равное целому нулевому числу (нулю), длинному целому нулю, или нуль приводится к указателю типа void *:

#define NULL  0

#define NULL  0L

#define NULL  ((void *) 0)

Несмотря на то, что константа нуль-указателя всегда представляется в Си символьной константой 0 или 0, приведённым к void-указателю, реальное битовое представление подобного указателя зависит от системы и может содержать однобитовые значения.

## Типы

### size_t

Заголовочные файлы `stdlib.h` и `stddef.h` определяют [тип данных](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Тип данных"), называемый `size_t`[[2]](https://ru.wikipedia.org/wiki/Stdlib.h#cite_note-2), который используется для представления размера объекта. Библиотечные функции, использующие размеры, принимают на вход значения именно этого типа. Значения типа `size_t` возвращает оператор `sizeof`.

Настоящий тип `size_t` платформо-независим; распространенной ошибкой является подразумевать под `size_t` беззнаковое целое (`unsigned int`), что может привести к ошибкам программирования,[[3]](https://ru.wikipedia.org/wiki/Stdlib.h#cite_note-3) причём в первую очередь это касается 64-битных архитектур.

### div_t, ldiv_t

Также определены два менее широко используемых типа данных — `div_t` и `ldiv_t`. Они являются возвращаемыми типами функций `div` и `ldiv`. Стандарт определяет их следующим образом:

>
typedef struct {
    int quot, rem;
} div_t;

>typedef struct {
>    long int quot, rem;
>} ldiv_t;


## Нестандартные функции

### itoa

 
[itoa](https://ru.wikipedia.org/wiki/Itoa_(%D0%A1%D0%B8) "Itoa (Си)") — общая функция, входящая во множество реализаций stdlib.h, но не определяемая стандартом. Возможно, её так часто включают в библиотеки благодаря её описанию в книге «[Язык программирования Си](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8_(%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0) "Язык программирования Си (книга)")». Аналогичного эффекта можно добиться при помощи функции [sprintf](https://ru.wikipedia.org/wiki/Sprintf "Sprintf"), которая определена в стандарте.



# Пример использование некоторых функции библиотеки stdlib.h:

**system()** **-** используется для вызова команды операционной системы из программы C/C++. Функция system() передает имя команды или имя программы, указанное командой, в среду хоста для выполнения командным процессором и возвращается после завершения команды.

  
  

**Примечание.** Для вызова system необходимо подключить stdlib.h

## Возвращаемое значение

В случае ошибки возвращается значение -1, а в противном случае возвращается статус команды.

### Прототип функции system:


> `**int**` `**system( const**` `**char**` `***command );**`

Следующая программа выводит содержимое текущего рабочего каталога:

  
``
>
**#include <stdlib.h>  
int main(void)  
{  
system("dir");  
return 0;  
}**  
  >

Или можно немного иначе:

  
>
**#include <stdio.h>**
**#include <stdlib.h>**
**#include <string.h>**
>
>**int main () {**
   **char command[50];**
>
   **strcpy( command, "dir" );**
   **system(command);**
>
   >**return(0);**
**}**
>

В следующем примере показано использование функции system() для вывода списка всех файлов и каталогов в текущем каталоге на машине unix.

```

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main () {
   char command[50];

   strcpy( command, "ls -l" );
   system(command);

   return(0);
}
```

**exit() —** это основная функция языка программирования C/C++, которая используется для мгновенного завершения вызывающего процесса. При вызове функции exit() любые открытые файловые дескрипторы, принадлежащие процессу, закрываются, а любые дочерние процессы наследуются процессом 1, init, а родительскому процессу отправляется сигнал SIGCHLD,  файловые буферы очищаются, потоки закрываются, а временные файлы удаляются.  Функция выхода указана в **< stdlib.h >** и включена в стандартные библиотеки C.

## Синтаксис

Синтаксис функции выхода на языке C:

  **void exit(int status);**

## Параметры

-   **status** — это значение статуса, возвращаемое родительскому процессу.
    

Параметр (status) может принимать один из двух значение, которая обозначает статус программы, то есть указывает, завершилась ли программа нормально. Это может быть одно из следующих:

-   0 – EXIT_SUCCESS
    
-   1 - EXIT_FAILURE
    

В качестве параметра мы можем писать как и 0, так и EXIT_SUCCESS. Они имеют одинаковые значение. Мы так же можем писать либо 1 или EXIT_FAILURE, они тоже имеют одинаковые значение.

**положение дел:**

| **Стоимость** | **Описание**         |     |
| ------------- | -------------------- | 
| EXIT_SUCCESS  | Успешное завершение  |     
| 0             | Успешное завершение  |    
| EXIT_FAILURE  | Неудачное завершение |     
| 1             | Неудачное завершение |     


### EXIT_SUCCESS

Если переданный аргумент состояния равен нулю или **int** : EXIT_SUCCESS, описанный в **<stdlib.h>** , успешное состояние должно быть передано в хост-среду, и, таким образом, форма успешного выполнения, определенная выполнением, возвращается к среда хостинга, которой передается управление. Exit(0) обычно используется для завершения программы, указывая, что операция выполнена. EXIT_SUCCESS имеет значение 0.

В результате вместо выхода мы могли бы использовать exit(EXIT_SUCCESS). EXIT_SUCCESS — это префикс, расширяющийся до целочисленных выражений, которые можно передать в выход метода в качестве аргумента. А выход(0) означает чистый выход из программы без ошибок.



### EXIT_FAILURE

Если предоставленный аргумент состояния представляет собой макрос EXIT_FAILURE с целочисленным значением, указанный в **<stdlib.h>** , функция выхода вернет версию выполнения результата сбоя в среду размещения, для которой указано управление. Его также можно использовать для нормального завершения программы, но при условии, что операция не удалась. EXIT_FAILURE имеет значение 1.

В результате вместо выхода мы можем использовать выход EXIT_FAILURE. EXIT_FAILURE — это фраза, которую можно использовать для различных целей. Статус выхода 1 означает, что возникла проблема во время выполнения, которая могла быть вызвана ошибкой программирования.

#### Пример  

В следующем примере показано использование функции exit().
[](http://tpcg.io/CxuyMt)  
  
>
**#include <stdio.h>**
**#include <stdlib.h>**
>
**int main () {**
   **printf("Start of the program....\n");**
   >
   **printf("Exiting the program....\n");**
   **exit(0);**
>
   **printf("End of the program....\n");**
>
   **return(0);**
**}**
>
  
  
  
**Давайте скомпилируем и запустим вышеуказанную программу, которая даст следующий результат:**

Start of the program....
Exiting the program.…

### Пример 2:
>
**FILE *file**
>
**file = fopen("test.txt", "r");**
>
**if (file == NULL){**
>
**exit(1);**
>
**}**



# Динамическое выделение памяти

Теперь вы научитесь динамически выделять память в своей программе на C, используя стандартные библиотечные функции: malloc(), calloc(), free() и realloc().

Поскольку C — структурированный язык, в нем есть определенные правила программирования. Один из них включает изменение размера массива. Массив — это набор элементов, хранящихся в смежных ячейках памяти.

Как известно, массив — это набор фиксированного количества значений. Как только размер массива объявлен, вы не можете его изменить.

![[Pasted image 20220821032659.png]]


Иногда размер объявленного вами массива может оказаться недостаточным. Чтобы решить эту проблему, вы можете выделить память вручную во время выполнения. Это известно как динамическое выделение памяти в программировании на C. Для динамического выделения памяти библиотечные функции `malloc()`, `calloc()`, `realloc()`и `free()`используются. Эти функции определены в `<stdlib.h>` заголовочный файл.

  
  

## malloc()

Имя «malloc» означает выделение памяти. В `malloc()`функция резервирует блок памяти указанного количества байтов. И он [указатель](https://www.programiz.com/c-programming/c-pointers) возвращает `void` которые могут быть преобразованы в указатели любой формы. Простыми словами, функция malloc() используется для динамического выделения одного большого блока памяти заданного размера. Он не инициализирует память во время выполнения, поэтому изначально он инициализирует каждый блок значением мусора по умолчанию

### Синтаксис malloc()

```
ptr = (castType*) malloc(size);
```

**Пример**

```
ptr = (float*) malloc(100 * sizeof(float));
```

Приведенный выше оператор выделяет 400 байт памяти. Это потому, что размер `float`составляет 4 байта. И указатель ptr содержит адрес первого байта в выделенной памяти.

![[Pasted image 20220821032816.png]]


Выражение возвращает указатель `NULL`, если память не может быть выделена.

## calloc()

Название «calloc» означает непрерывное выделение.

В `malloc()`выделяет память и оставляет память неинициализированной, тогда как `calloc()`функция выделяет память и инициализирует все биты нулями.

  
### Синтаксис calloc()

```
ptr = (castType*)calloc(n, size);
```

**Пример:**

```
ptr = (float*) calloc(25, sizeof(float));
```

Приведенный выше оператор выделяет непрерывное пространство в памяти для 25 элементов типа `float`.

## free()

Динамически выделяемая память, созданная с помощью `calloc()`или `malloc()`не освобождается самостоятельно. Вы должны явно использовать `free()`чтобы освободить пространство.

---

### Синтаксис free()

![[Pasted image 20220821032905.png]]


```
free(ptr);
```

Этот оператор освобождает пространство, выделенное в памяти, на которое указывает `ptr`.

**Пример:**

>  
#include <stdio.h>			
#include <stdlib.h> 
>
int main(){
    int *ptr, *ptr1;
    int n, i;
    n = 5;
    printf("Enter number of elements: %d\n", n);
>
    ptr = (int*)malloc(n * sizeof(int));
    ptr1 = (int*)calloc(n, sizeof(int));
 >
    if (ptr == NULL || ptr1 == NULL) {
        printf("Memory not allocated.\n");
        exit(0);
    }
    else { 
        printf("Memory successfully allocated using malloc.\n");
        free(ptr);
        printf("Malloc Memory successfully freed.\n");
        printf("\nMemory successfully allocated using calloc.\n");
        free(ptr1);
        printf("Calloc Memory successfully freed.\n");
    } 
    return 0;
}
>

**Вывод:**

**Enter number of elements: 5**
Memory successfully allocated using malloc.
Malloc Memory successfully freed.

Memory successfully allocated using calloc.
Calloc Memory successfully freed.

## realloc()

Если динамически выделенной памяти недостаточно или больше, чем требуется, вы можете изменить размер ранее выделенной памяти с помощью `realloc()`функция. Не поняли? **«realloc»** или **«перераспределение»** в языке C используется для динамического изменения выделения ранее выделенной памяти. Другими словами, если памяти, ранее выделенной с помощью malloc или calloc, недостаточно, для **динамического перераспределения памяти** . перераспределение памяти сохраняет уже существующее значение, а новые блоки будут инициализированы со значением мусора по умолчанию.

###   
  

### Синтаксис realloc()

```
ptr = realloc(ptr, x);Если места недостаточно, выделение завершается ошибкой и возвращает указатель NULL. 
Пример: 
#include <stdio.h>					                      	        #include <stdlib.h>
int main(){
    int* ptr;											                                                                                                                                                                                                                                                                                                                                                                                                  
    int n, i;
    n = 5;
    printf("Enter number of elements: %d\n", n);
    ptr = (int*)calloc(n, sizeof(int));
    if (ptr == NULL) {
        printf("Memory not allocated.\n");
        exit(0);
    }
    else { 
        printf("Memory successfully allocated using calloc.\n");
        for (i = 0; i < n; ++i) {
            ptr[i] = i + 1;
        }
        printf("The elements of the array are: ");
        for (i = 0; i < n; ++i) {
            printf("%d, ", ptr[i]);
        }
        n = 10;
        printf("\n\nEnter the new size of the array: %d\n", n);
        ptr = realloc(ptr, n * sizeof(int));
        printf("Memory successfully re-allocated using realloc.\n");
        for (i = 5; i < n; ++i) {
            ptr[i] = i + 1;
        }
        printf("The elements of the array are: ");
        for (i = 0; i < n; ++i) {
            printf("%d, ", ptr[i]);
        } 
        free(ptr);
    }

```

Здесь ptr перераспределяется с новым размером x .


![[Pasted image 20220821033213.png]]





Если места недостаточно, выделение завершается ошибкой и возвращает указатель NULL. 

#### Пример: 

>
#include <stdio.h>			
#include <stdlib.h>
>
int main(){
    int* ptr;											                                                                                                                                                                                                                                                                                                                                                                                                  
    int n, i;
    n = 5;
    printf("Enter number of elements: %d\n", n);
    ptr = (int*)calloc(n, sizeof(int));
    if (ptr == NULL) {
        printf("Memory not allocated.\n");
        exit(0);
    }
    else { 
        printf("Memory successfully allocated using calloc.\n");
        for (i = 0; i < n; ++i) {
            ptr[i] = i + 1;
        }
        printf("The elements of the array are: ");
        for (i = 0; i < n; ++i) {
            printf("%d, ", ptr[i]);
        }
        n = 10;
        printf("\n\nEnter the new size of the array: %d\n", n);
        ptr = realloc(ptr, n * sizeof(int));
        printf("Memory successfully re-allocated using realloc.\n");
        for (i = 5; i < n; ++i) {
            ptr[i] = i + 1;
        }
        printf("The elements of the array are: ");
        for (i = 0; i < n; ++i) {
            printf("%d, ", ptr[i]);
        } 
        free(ptr);
    }


**Вывод:** 

Enter number of elements: 5
Memory successfully allocated using calloc.
The elements of the array are: 1, 2, 3, 4, 5, 

Enter the new size of the array: 10
Memory successfully re-allocated using realloc.
The elements of the array are: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,

### Пример2:

>
#include <stdio.h>
#include <stdlib.h>
>
int main() {
  int *ptr, i , n1, n2;
  printf("Enter size: ");
  scanf("%d", &n1);
>
  ptr = (int*) malloc(n1 * sizeof(int));
>
  printf("Addresses of previously allocated memory:\n");
  for(i = 0; i < n1; ++i)
    printf("%pc\n",ptr + i);
>
  printf("\nEnter the new size: ");
  scanf("%d", &n2);
>
  ptr = realloc(ptr, n2 * sizeof(int));
>
  printf("Addresses of newly allocated memory:\n");
  for(i = 0; i < n2; ++i)
    printf("%pc\n", ptr + i);
  >
  free(ptr);
>
  return 0;
}


**Вывод:**

Enter size: 2									
Addresses of previously allocated memory: 
26855472
26855476

Enter the new size: 4
Addresses of newly allocated memory:
26855472
26855476
26855480
26855484


**Итог**:

Функция free() освобождает место в памяти. Блок памяти, ранее выделенный с помощью вызова malloc, calloc или realloc освобождается. То есть освобожденная память может дальше использоваться программами или ОС.