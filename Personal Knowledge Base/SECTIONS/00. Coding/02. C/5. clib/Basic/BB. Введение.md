
# Введение

**Стандартной библиотекой языка Си** (также известная как **libc**, **crt**) называется часть стандарта [ANSI C](https://ru.wikipedia.org/wiki/ANSI_C), посвященная [заголовочным файлам](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB) и [библиотечным подпрограммам](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Является описанием реализации общих операций, таких как обработка [ввода-вывода](https://ru.wikipedia.org/wiki/%D0%92%D0%B2%D0%BE%D0%B4-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4) и [строк](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF), в [языке программирования Си](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8). Стандартная библиотека языка Си— это описание [программного интерфейса](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81), а не настоящая библиотека, пригодная для использования в процессе [компиляции](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Протсыми словами, Стандартная библиотека языка Си – это набор отдельных файлов, которые расширяют возможности языка Си. Например, как мы уже отмечали ранее, добавление к нашей программе файла math.h позволяет использовать различные математические функции. Добавление stdio.h позволяет взаимодействовать программе с внешним миром (читать/выводить данные).

  
  

## Структура

Имя и характеристики каждой функции указываются в файле, именуемом [заголовочным файлом](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB), но текущая реализация функций описана отдельно в [библиотечном файле](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)). Наименование и возможности заголовочных файлов становятся общими, но организация библиотек по-прежнему остается разнотипной. Стандартная библиотека обычно поставляется вместе с [компилятором](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80). Так как компиляторы языка Си часто обеспечивают расширенную функциональность, не определенную стандартом [ANSI C](https://ru.wikipedia.org/wiki/ANSI_C), стандартная библиотека одного компилятора несовместима со стандартными библиотеками других компиляторов.

По факту язык Си самостоятельно, без функций стандартной библиотеки, почти ничего не может. Даже вывести значение переменной на экран. Но благодаря дополнительным модулям (стандартным заголовочным файлам) возможности языка могут быть существенно расширены. А если какие-то возможности не нужны, то они не будут включены в итоговую версию программы.

Модули могут быть реализованы, например, в виде отдельных заголовочных файлов или отдельных файлов с кодом. Каждый модуль должен решать какие-то свои задачи. Модуль можно представить себе как «чёрный ящик». У него есть две основных части: интерфейс взаимодействия с модулем (сколько и каких данных поступает в чёрный ящик и какие данные им возвращаются) и внутренняя реализация модуля (содержимое чёрного ящика).

  
  
Если рассматривать отедельную функцию языка Си как модуль, то интерфейсом является заголовок или прототип функции. Он полностью описывает, что необходимо функции для работы: какого типа данные нужны, 

в каком порядке их надо передавать, в каком количестве и т.д., а также какие данные функция возвращает. Тело функции при этом является реализацией модуля.

Кстати, что касается стандартной библиотеки языка Си. Если вы ещё не пробовали искать у себя на компьютере заголовочные файлы, то попробуйте. Внутри них только прототипы функций, а самой реализации нет. Т.е. по факту в заголовочных файлах содержится только интерфейс модуля или по-другому [[NN. Что такое API | API]] (Application Programming Interface, чит. эй-пи-ай, иногда по-русски произносят апи), а сами реализации от программиста скрыты и находятся уже в отдельных, скомпилированных библиотечных файлах.

  
  

**Прототипом функции** в [языке Си](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8) или [C++](https://ru.wikipedia.org/wiki/C%2B%2B) называется [объявление](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)) [функции](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), не содержащее тела функции, но указывающее имя функции, [арность](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C), [типы](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) аргументов и возвращаемый тип данных. В то время как определение функции описывает, что именно делает функция, прототип функции может восприниматься как описание её интерфейса.

Прототипы функций служат двум целям: во-первых, они определяют тип возвращаемого функцией значений, чтобы компилятор мог генерировать корректный код для возвращаемых данных; во-вторых, они определяют тип и число аргументов, используемых функциями. Прототип имеет следующий вид:

_**тип имя_функции (список параметров);**_

Прототип обычно помещается в начало программы и должен появляться перед любым вызовом функции.


## Пример

В качестве примера, рассмотрим следующий прототип функции:

**int foo(int n);**

Этот прототип объявляет функцию с именем «foo», которая принимает один аргумент «n» [целого типа](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE) и возвращает целое число. Определение функции может располагаться где угодно в программе, но объявление требуется только в случае её использования.

## Использование

### Уведомление компилятора

Если функция предварительно не была объявлена, а её имя встречается в выражении, сразу за которым следует открывающая скобка, то она неявно объявляется как функция, возвращающая результат типа `int` и ничего не предполагается о её аргументах. В этом случае компилятор не сможет выполнить проверку типов аргументов и [арность](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C), когда функция вызывается с некоторыми аргументами. Это потенциальный источник проблем. Следующий код иллюстрирует ситуацию, в которой поведение неявно объявленной функции не определено.

  

```
#include <stdio.h>

*/
  При реализации этого прототипа компилятор выдаст сообщение об ошибке
  в main(). Если он будет пропущен, то и сообщения об ошибке не будет.
 */

int foo(int n);              /* Прототип функции */
 
int main(void) /* Вызов функции */
{                
    printf("%d\n", foo());   /* ОШИБКА: у  функции foo() отсутствует аргумент! */
    
    return 0;
}

```

Функция «foo» ожидает аргумент целого типа, находящийся в [стеке](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2) при вызове. Если прототип пропущен, [компилятор](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80) не может это обработать и «foo» завершит операцию на некоторых других данных [стека](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA) (вероятно, это будет [обратный адрес](https://ru.wikipedia.org/w/index.php?title=%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B4%D1%80%D0%B5%D1%81&action=edit&redlink=1) или значение переменной, не входящей в [область допустимых значений](https://ru.wikipedia.org/w/index.php?title=%D0%94%D0%BE%D0%BF%D1%83%D1%81%D1%82%D0%B8%D0%BC%D1%8B%D0%B5_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)&action=edit&redlink=1)). Включением прототипа функции вы информируете компилятор о том, что функция «foo» принимает один аргумент целого типа и вы тем самым позволяете компилятору обрабатывать подобные виды ошибок.

В каком порядке их надо передавать, в каком количестве и т.д., а также какие данные функция возвращает. Тело функции при этом является реализацией модуля.

Кстати, что касается стандартной библиотеки языка Си. Если вы ещё не пробовали искать у себя на компьютере заголовочные файлы, то попробуйте. Внутри них только прототипы функций, а самой реализации нет. Т.е. по факту в заголовочных файлах содержится только интерфейс модуля или по-другому [[NN. Что такое API | API ]] (Application Programming Interface, чит. эй-пи-ай, иногда по-русски произносят апи), а сами реализации от программиста скрыты и находятся уже в отдельных, скомпилированных библиотечных файлах.

