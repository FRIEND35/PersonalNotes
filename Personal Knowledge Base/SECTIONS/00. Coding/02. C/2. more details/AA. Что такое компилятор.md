# Компилятор
  
Процессор — самая важная часть компьютера. Он обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. Но процессор может  разобрать только машинный код — набор 0 и 1, которые записаны в определённом порядке.   

Почему именно 0 и 1? В процессор поступают электрические сигналы. Сильный сигнал обозначается цифрой 1, а слабый — 0. Набор таких цифр обозначает какую - то команду . Процессор ее распознает и выполняет.
  

Программы для первых компьютеров выглядели как огромные наборы 0 и 1. Чтобы записать такую программу, инженеры пользовались гибкими картонными карточками — перфокартами. Цифры на перфокарте записывались поочередно, в несколько строк. Чтобы записать 1, программист делал отверстие в карте. Места без отверстия обозначали 0.

![](file:///tmp/lu23427pgn.tmp/lu23427ph2_tmp_5d7304a75cb723ea.jpg)  

  

  

  Компьтер считывал перфокарту специальным устройством и выполнял записанную команду. Для одной программы составляли сотни перфокарт. Писать их было долго и сложно, поэтому инженеры стали создавать языки программирования, обозначая команды словами знаками. Для того, чтобы процессор понимал, какие команды записаны в программе, программисты создали **компилятор**  - программу, которая преобразует программный код в машинный.

  

Компилятор — это не что иное, как переводчик исходного кода.

  

Задача компилятора — перевести исходный код с одного языка на другой. В нашем случае, процессор не понимает исходный код языка Си, поэтому после написания кода мы его компилируем, компилятор переводит исходный код языка Си в двоичный код, а процессор будет понимать что ему нужно делать ( какие инструкции выполнять ). Простыми словами, **Компиляторы** — это программы, которые преобразуют исходные тексты программ, написанные на языке программирования высокого уровня, в программу на машинном языке, «понятную» компьютеру.

![[Pasted image 20220920062319.png]]




Компиляторов много, и они бывают разными.Некоторые компиляторы непосредственно преобразуют высокоуровневый исходный код в машинный код, а некоторые — сначала преобразуют высокоуровневый исходный код в промежуточное представление перед преобразованием в машинный код.
  
Таким образом, в соответствии с этой классификацией можно выделить три типа компиляторов:

- Однопроходной компилятор.

- Двухпроходной компилятор.

- Многопроходной компилятор.






## Классификация компиляторов в соответствии с исходным кодом и целевым кодом

Для преобразования исходного кода в целевой применяются разные подходы. Некоторые компиляторы преобразуют код на высокоуровневом языке в машинный. Некоторые компиляторы преобразуют с одного языка высокого уровня на другой язык высокого уровня. Таким образом, здесь выделяются следующие типы:

  

Кросс-компиляторы — такие компиляторы работают на одной платформе и производят код для запуска на другой платформе. Например, компилятор работает на платформе X и создает код для запуска на платформе Y. Такими компиляторами пользуются разработчики встроенных систем.
  
Традиционные компиляторы — нам лучше всего знаком именно этот тип компиляторов. Такие компиляторы преобразуют исходный код языка высокого уровня в исходный код машинного языка. Набор компиляторов GCC преобразует эти языки в низкоуровневые, которые выполняются на этих платформах.  

Транспилеры — они преобразуют исходный код языка высокого уровня в исходный код другого языка высокого уровня. Например: Babel transpiler преобразует ECMAScript 2015+ в JavaScript.

Декомпиляторы — они принимают низкоуровневый исходный код в качестве входных данных и пытаются создать высокоуровневый исходный код, который может быть успешно перекомпилирован.


## Как работает компилятор?

Преобразование программного кода в машинный называется _компиляцией_. Компиляция только преобразует код. Она не запускает его на исполнение. В этот момент он “статически” (то есть без запуска) транслируется в машинный код. Это сложный процесс, в котором сначала текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.
  

Когда компилятор компилирует (переводит) исходный код, он проходит несколько этапов:

  

1.  Исходный код.  


2.  Лексический анализ.  


3.  Синтаксический анализ.  


4.  Семантический анализ.
    

5.  Промежуточная генерация кода.
    

6.  Оптимизация кода.
    

7.  Генерация кода.
    
8.  Целевой код.

  

Мы можем разделить все эти этапы на две фазы, примерно как фронтенд и бэкенд. Эти фазы включают в себя следующие этапы:

  

  

**Фронтенд:**

- Лексический анализ.

- Синтаксический анализ. Семантический анализ.

- Генерация промежуточного кода.

  

**Бэкенд:**

- Оптимизация кода. Генерация кода.



### Лексический анализ

Теперь вы знаете , что компилятор — это программа , которая преобразует исходный код в другой исходный код. Компилятор получает исходный код в виде файла . Этот файл содержит код в текстовом формате, но компилятор не может работать с этим текстом. Необходимо преобразовать этот текст в некоторый другой формат, понятный компилятору. Для этого компилятор разбивает текст по маркерам. Помните, что эти маркеры заранее определены в грамматике языка. Маркеры пригодятся на следующих этапах процесса компиляции:

![[Pasted image 20230801013430.png]]
  

KEYWORD, BRACKET, IDENTIFIER, OPERATOR, NUMBER на приведенной выше диаграмме

— это и есть маркеры. Компилятор использует лексический анализ для идентификации маркеров , и если он получает маркер, который не определен заранее в грамматике языка, то это будет считаться ошибкой.

  

Разберём этапы компиляции на примере вычисления периметра прямоугольника:


```
#include <iostream>

int main()

{


double a=2.5, b=5, P;

P = 2 * (a + b);

  

printf("Width of the rectangle - %4.1f", a);// => Width of the rectangle - 2.5 printf("\nLength of the rectangle - %4.1f", b);// => Length of the rectangle - 5.0

  

printf("\nPerimeter of the rectangle is %4.1f", P);// => Perimeter of the rectangle is 15.0

  
return 0;

}

```
  

После запуска программы компилятору нужно определить, какие команды в ней записаны. Сначала компилятор разделяет программу на слова и знаки — _токены_, и записывает их в список. Такой процесс называется **лексическим анализом**. Его главная задача — получить токены. Затем компилятор читает список и ищет токен-операторы. Это могут быть оператор присваивания(=), арифметические операторы(+,-,*,/), оператор вывода(printf()) и  другие операторы языка программирования. Такие операторы работают с числами, текстом и переменными.
    

  
### Синтаксический анализ (парсинг)
  
На этом этапе компилятор проверяет, расположены ли идентифицированные ранее маркеры в правильном порядке. Для этого в каждом языке есть набор правил, называемый **грамматикой**. Во-первых, компилятор пытается построить структуру данных — дерево синтаксического анализа. Если компилятор смог успешно построить дерево синтаксического анализа в соответствии с заранее определенными правилами грамматики, то в исходном коде нет синтаксических ошибок. В  противном случае возникают ошибки и компилятор их покажет.
  

Компилятор должен понять, какие токены в списке связаны с токен-оператором. Чтобы сделать это правильно, для каждого оператора строится специальная структура — **логическое дерево** или **дерево разбора**.

Так операция P = 2*(a + b) будет преобразована в логическое дерево:

![](file:///tmp/lu23427pgn.tmp/lu23427phl_tmp_c2d2babadbe400c5.jpg)  

  

  Теперь каждое дерево нужно разобрать на команды, и каждую команду преобразовать в **машинный код**. Компилятор начинает читать дерево снизу вверх и составляет список команд:  

- Взять переменную a, взять переменную b, сложить их. Взять результат сложения, взять число 2 и найти их произведение. Результат произведения присвоить (записать) в переменную P




### Семантический анализ

Просто потому, что программа не содержит синтаксических ошибок , код еще не может считаться правильным. Рассмотрим предложение ниже.

**I love compilers**

Теперь предположим , что все слова в этом предложении — правильные лексемы, идентифицированные на этапе лексического анализа.

Компилятор при анализе синтаксиса может решить, что в этом предложении нет синтаксических ошибок, потому что маркеры (слова) расположены в правильном порядке. Простыми словами, на этом этапе компилятор проверяет в правильном ли порядке все написано.
  



### Генерация промежуточного кода

Любой компилятор может непосредственно генерировать машинный код из исходного. Так зачем же тогда нужна фаза генерации промежуточного кода? Существуют различные типы машин. Таким образом, машинный код зависит от системы, а высокоуровневый исходный код — нет. Если компилятор непосредственно генерирует машинный код из исходного кода, то каждая машина нуждается в полной компиляции от фронта к бэку . Но когда компилятор генерирует промежуточный код (промежуточное представление), он уже может генерировать машинный код для каждой машины с его помощью, без повторения лексического анализа и парсинга для каждой машины. Если компилятор переводит исходный язык на свой целевой машинный язык , не имея возможности генерировать промежуточный код , то для каждой новой машины требуется полный собственный компилятор.Промежуточный код устраняет необходимость в новом полном компиляторе для каждой уникальной машины, сохраняя часть анализа одинаковой для всех компиляторов.



### Оптимизация кода
  
Этап оптимизации кода выполняет две основные задачи: минимизация **времени** или минимизация **ресурсов**. Что все это значит? Когда пользователь пишет код, нет ничего, кроме инструкций. Когда процессор выполняет эти инструкции, требуют время и ресурсы памяти . Таким образом , целью этапа оптимизации кода становится сокращение времени выполнения и  ресурсов, потребляемых программой. Оптимизатор кода всегда следует трем правилам:


1.  Выходной код никоим образом не должен изменять значение исходного кода.
  

2.  Минимизируйте либо время , либо ресурсы , либо и то и другое вместе.
  

3.  Фаза оптимизации кода сама по себе не должна занимать много времени и замедлять весь процесс компиляции.

  

Существует два способа оптимизации кода:
  

 1. Машинно-независимая оптимизация. Машинно-зависимая оптимизация.

2. Машинно-независимая оптимизация принимает промежуточное представление относительно входных данных и не заботится ни о каких регистрах процессора и ячейках памяти. Она происходит после генерации промежуточного кода.

  

При машинно-зависимой оптимизации кода компилятор заботится о регистрах процессора, расположениях памяти и архитектуре машины. Она происходит после генерации машинного кода.



### Генерация кода 

Генерация кода — это последний этап процесса компиляции. Да, после может следовать машинно-зависимая оптимизация кода. Но мы можем рассматривать и то, и другое вместе как генерацию кода. На этом этапе компилятор генерирует машинно-зависимый код. Генератор кода должен иметь представление о среде выполнения целевой машины и ее наборе команд.  

На этом этапе компилятор выполняет несколько основных задач:

  

- Выбор инструкций — какую инструкцию использовать.

- Создание расписания инструкций — в каком порядке должны быть упорядочены инструкции.

- Распределение регистров — выделение переменных в регистры процессора.

- Отладка данных — отладка кода с помощью отладочных данных.

Итоговый машинный код, сгенерированный генератором кода, может быть выполнен на целевой машине. Именно так высокоуровневый исходный код, который мы пишем в нашем любимом редакторе кода, преобразуется в формат, который можно запустить на любой целевой машине. Простыми словами, компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. При успешном завершении этого этапа, компилятор переводит каждую команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор. 

10111011 00010001 00000001 10111001 00001101 00000000
10110100 00001110 10001010 00000111 01000011 1

