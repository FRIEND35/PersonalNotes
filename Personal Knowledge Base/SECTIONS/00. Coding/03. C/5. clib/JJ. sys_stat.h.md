# Описание

Заголовок _<sys/stat.h>_ должен определять структуру данных. 
        возвращаемый _fstat_(), _lstat_() и _stat_(). 

```

		Заголовок _<sys/stat.h>_ должен определять **статистики** , которая 
        должен включать как минимум следующих членов: 

            dev_t st_dev Идентификатор устройства, содержащего файл. 
            ino_t st_ino Серийный номер файла. 
            mode_t st_mode Режим файла (см. ниже). 
            nlink_t st_nlink Количество жестких ссылок на файл. 
            uid_t st_uid Идентификатор пользователя файла. 
            gid_t st_gid Идентификатор группы файла. 
            dev_t st_rdev Идентификатор устройства (если файл является символьным или блочным). 
            off_t st_size Для обычных файлов размер файла в байтах. 
                                    Для символических ссылок длина в байтах 
                                    путь, содержащийся в символической ссылке. 
                                    Для объекта общей памяти длина в байтах. 
                                    Для типизированного объекта памяти длина в байтах. 
                                    Для других типов файлов использование этого поля 
                                    неопределенные. 
            struct timespec st_atim Отметка времени последнего доступа к данным. 
            struct timespec st_mtim Отметка времени последней модификации данных. 
            struct timespec st_ctim Отметка времени последнего изменения состояния файла. 
            blksize_t st_blksize Предпочтительный размер блока ввода-вывода для конкретной файловой системы. 
                                    для этого объекта. В некоторых типах файловых систем это 
                                    может варьироваться от файла к файлу. 
            blkcnt_t st_blocks Количество блоков, выделенных для этого объекта. 

         _Поля st_ino_ и _st_dev_ , взятые вместе, однозначно идентифицируют 
        файл внутри системы. 

        Заголовок _<sys/stat.h>_ должен определять **blkcnt_t** , **blksize_t** , 
        **dev_t** , **ino_t** , **mode_t** , **nlink_t** , **uid_t** , **gid_t** , **off_t** и **time_t** типы, как описано в _<sys/types.h>_ . 

        Заголовок _<sys/stat.h>_ должен определять **времени** как 
        описано в _<time.h>_ . Время указывается в секундах с момента 
        Эпоха. 

        Какие элементы структуры имеют значимые значения, зависит от 
        тип файла. Для получения дополнительной информации см. описания 
        _fstat_ (), _lstat_ () и _stat_ () в томе System Interfaces 
        POSIX.1-2017. 

        Для совместимости с более ранними версиями этого стандарта 
        _st_atime_ должен быть определен со значением _st_atim.tv_sec_ . 
        Точно так же _st_ctime_ и _st_mtime_ должны быть определены как макросы с 
        значения _st_ctim.tv_sec_ и _st_mtim.tv_sec_ соответственно. 

        Заголовок _<sys/stat.h>_ должен определять следующие символические 
        константы для типов файлов, закодированных в type **режим_t** . Ценности 
        должны быть пригодны для использования в **#if** : 

        S_IFMT Тип файла. 

                    S_IFBLK Специальный блок. 

                    S_IFCHR Специальный символ. 

                    S_IFIFO Специальный FIFO. 

                    S_IFREG Обычный. 

                    S_IFDIR Каталог. 

                    S_IFLNK Символическая ссылка. 

                    S_IFSOCK Сокет. 

        Заголовок _<sys/stat.h>_ должен определять следующие символические 
        константы для битов режима файла, закодированные в типе **mode_t** , с 
        указаны числовые значения. Эти макросы должны расширяться до 
        выражение, которое имеет тип, который позволяет их использовать, либо 
        по отдельности или вместе, как третий аргумент для _open_ () без 
        необходимость приведения **mode_t** . Значения должны быть пригодны для использования 
        в **#if** .
    ┌────────┬───────────────┬──────────────────────────────────────────────┐
    │ Name   │ Numeric Value │                 Description                  │
    ├────────┼───────────────┼──────────────────────────────────────────────┤
    │S_IRWXU │      0700     │ Read, write, execute/search by owner.        │
    │S_IRUSR │      0400     │ Read permission, owner.                      │
    │S_IWUSR │      0200     │ Write permission, owner.                     │
    │S_IXUSR │      0100     │ Execute/search permission, owner.            │
    ├────────┼───────────────┼──────────────────────────────────────────────┤
    │S_IRWXG │       070     │ Read, write, execute/search by group.        │
    │S_IRGRP │       040     │ Read permission, group.                      │
    │S_IWGRP │       020     │ Write permission, group.                     │
    │S_IXGRP │       010     │ Execute/search permission, group.            │
    ├────────┼───────────────┼──────────────────────────────────────────────┤
    │S_IRWXO │        07     │ Read, write, execute/search by others.       │
    │S_IROTH │        04     │ Read permission, others.                     │
    │S_IWOTH │        02     │ Write permission, others.                    │
    │S_IXOTH │        01     │ Execute/search permission, others.           │
    ├────────┼───────────────┼──────────────────────────────────────────────┤
    │S_ISUID │     04000     │ Set-user-ID on execution.                    │
    │S_ISGID │     02000     │ Set-group-ID on execution.                   │
    │S_ISVTX │     01000     │ On directories, restricted deletion flag.    │
    └────────┴───────────────┴──────────────────────────────────────────────┘

    Следующие макросы должны быть предоставлены для проверки того, является ли файл 
        указанного типа. Значение _m_ , поставляемый в макрос, является 
        значение _st_mode_ из **статистики** . Макрос должен оценивать 
        к ненулевому значению, если тест верен; 0, если тест ложный. 

        S_ISBLK( _m_ ) Проверка специального файла блока. 

        S_ISCHR( _m_ ) Проверка специального символьного файла. 

        S_ISDIR( _m_ ) Проверка каталога. 

        S_ISFIFO( _m_ ) Проверка канала или специального файла FIFO. 

        S_ISREG( _m_ ) Проверка обычного файла. 

        S_ISLNK( _m_ ) Проверка символической ссылки. 

        S_ISSOCK( _m_ ) Проверка сокета. | Поле      | Описание                                                                                                 


```
| ----------- | ---------------------------------------------------------------------------------------------------------- |
| ----------- | ---------------------------------------------------------------------------------------------------------- |
| st_dev      | Номер диска, указанный в пути, или диск по умолчанию, если он не указан.                                   |
| st_mode     | Битовая карта, содержащая информацию о режиме открытого файла, составленная из значений, указанных ниже.   |
| st_nlink    | Всегда 1.                                                                                                  |
| st_rdev     | То же, что и st_dev.                                                                                       |
| st_size     | Размер файла в байтах.                                                                                     |
| st_mtime    | Время последнего изменения.                                                                                |
| st_atime    | Для NT время последнего доступа; или то же, что и st_mtime.                                                |
| st_ctime    | Для NT время создания; в остальном то же, что и st_mtime.                                                  |
| st_ino      | Всегда 0. (только структура статистики)                                                                    |
| st_uid      | Всегда 0. (только структура статистики)                                                                    |
| st_gid      | Всегда 0. (только структура статистики)                                                                    |


```


        Реализация может реализовывать очереди сообщений, семафоры или 
        объекты общей памяти как отдельные типы файлов. Следующее 
        макросы должны быть предоставлены для проверки того, является ли файл 
        указанный тип. Значение _buf_ аргумента 
        macros — это указатель на **статистики** . Макрос должен оценивать 
        в ненулевое значение, если указанный объект реализован как 
        отдельный тип файла, и указанный тип файла содержится в 
        в **статистики** , на которую ссылается _buf_ . В противном случае макрос должен 
        оценить в ноль. 

        S_TYPEISMQ( _бафф_ ) 
                      Проверка очереди сообщений. 

        S_TYPEISSEM( _бафф_ ) 
                      Тест на семафор. 

        S_TYPEISSHM( _бафф_ ) 
                      Проверка объекта общей памяти. 

        Реализация может реализовывать типизированные объекты памяти как отдельные 
        типы файлов, и следующий макрос должен проверить, является ли файл 
        указанного типа. Значение _buf_ , предоставленного 
        макрос является указателем на **статистики** . Макрос должен 
        оценить ненулевое значение, если указанный объект 
        реализован как отдельный тип файла и указанный тип файла 
        содержится в **stat** которую ссылается _buf_ . В противном случае, 
        макрос должен оцениваться как ноль. 

        S_TYPEISTMO( _буфер_ ) 
                      Тестовый макрос для типизированного объекта памяти. 

        Заголовок _<sys/stat.h>_ должен определять следующие символические 
        константы как отдельные целочисленные значения вне диапазона 
        [0,999999999], для использования с _футименс_ () и _утименсат_ () 
        функции: UTIME_NOW UTIME_OMIT 

        Следующее должно быть объявлено как функции, а также может быть 
        определены как макросы. Должны быть предоставлены прототипы функций. 

            int chmod (const char *, mode_t); 
            int fchmod(целое, mode_t); 
            int fchmodat(int, const char *, mode_t, int); 
            int fstat(int, struct stat *); 
            int fstatat(int, const char *restrict, struct stat *restrict, int); 
            int futimens(int, const struct timespec [2]); 
            int lstat (const char *restrict, struct stat *restrict); 
            int mkdir(const char *, mode_t); 
            int mkdirat(int, const char *, mode_t); 
            int mkfifo (const char *, mode_t); 
            int mkfifoat(int, const char *, mode_t); 
            int mknod(const char *, mode_t, dev_t); 
            int mknodat(int, const char *, mode_t, dev_t); 
            int stat (const char *restrict, struct stat *restrict); 
            mode_t umask(mode_t); 
            int utimensat(int, const char *, const struct timespec [2], int); 

        Включение _<sys/stat.h>_ может сделать видимыми все символы 
        из _<time.h>_ заголовка 

        _Следующие разделы информативны._






```


# Разбор

**<sys/stat.h>** — это заголовок в [библиотеке C POSIX](https://en.wikibooks.org/w/index.php?title=C_POSIX_library&action=edit&redlink=1 "Библиотека C POSIX (не существует)") для [языка программирования C](https://en.wikibooks.org/wiki/C_programming_language "язык программирования С") , который содержит конструкции, облегчающие получение информации об атрибутах файлов.



## Обзор функции
 


int` `[**stat**](https://en.wikibooks.org/wiki/C_Programming/POSIX_Reference/sys/stat.h/stat)` `(const char *filename, struct stat *buf)`

    Функция stat возвращает информацию об атрибутах файла, названного `filename`в структуре, на которую указывает `buf`. Если 
    `filename`— это имя символической ссылки, полученные атрибуты описывают файл, на который указывает ссылка. Если ссылка 
    указывает на несуществующее имя файла, то stat не сообщает о несуществующем файле. Возвращаемое значение равно 0 в случае 
    успешного выполнения операции или -1 в случае сбоя. Когда исходники скомпилированы с _FILE_OFFSET_BITS == 64, эта функция на 
    самом деле является stat64, поскольку интерфейс LFS прозрачно заменяет обычную реализацию.
    
	errno Ошибки: ENOENT означает файл, названный `filename`не существует.


int` `**stat64**` `(const char *filename, struct stat64 *buf)`

    Эта функция похожа на stat, но она также может работать с файлами размером более 2^31 байт в 32-битных системах. Для этого 
    результат сохраняется в переменной типа struct stat64, к которой `buf`должен указывать. Когда исходники скомпилированы с 
    _FILE_OFFSET_BITS == 64, эта функция доступна под именем stat и поэтому прозрачно заменяет интерфейс для небольших файлов на 
     32-битных машинах.

	errno Ошибки: ENOENT означает файл, названный `filename`не существует.

int` `**fstat**` `(int filedes, struct stat *buf)`

    Функция fstat аналогична stat, за исключением того, что она принимает дескриптор открытого файла ( `filedes`) в качестве 
    аргумента вместо имени файла. Как и stat, fstat возвращает 0 в случае успеха и -1 в случае неудачи. Когда исходники 
    скомпилированы с _FILE_OFFSET_BITS == 64, эта функция на самом деле является fstat64, поскольку интерфейс LFS прозрачно 
    заменяет обычную реализацию.

    errno Ошибки: EBADF означает `filedes`аргумент не является допустимым файловым дескриптором.

int  **fstat64**` `(int filedes, struct stat64 *buf)`

    Эта функция похожа на fstat, но может работать с большими файлами на 32-битных платформах. Для больших файлов файловый 
    дескриптор filedes должен быть получен с помощью open64 или creat64. `buf`указатель указывает на переменную типа struct 
    stat64, которая может представлять большие значения. Когда исходники скомпилированы с _FILE_OFFSET_BITS == 64, эта функция 
    доступна под именем fstat и таким образом прозрачно заменяет интерфейс для небольших файлов на 32-битных машинах.

    errno Ошибки: EBADF означает `filedes`аргумент не является допустимым файловым дескриптором.

int` `**lstat**` `(const char *filename, struct stat *buf)`

    Функция lstat аналогична stat, за исключением того, что она не переходит по символическим ссылкам. Если `filename`имя 
    символической ссылки, lstat возвращает информацию о самой ссылке; в противном случае lstat работает как stat. См. 
    Символические ссылки. Когда исходники скомпилированы с _FILE_OFFSET_BITS == 64, эта функция на самом деле является lstat64, 
    поскольку интерфейс LFS прозрачно заменяет обычную реализацию.

int **lstat64** (const char *filename, struct stat64 *buf)

    Функция lstat аналогична stat, за исключением того, что она не переходит по символическим ссылкам. Если `filename`имя 
    символической ссылки, lstat возвращает информацию о самой ссылке; в противном случае lstat работает как stat. См. 
    Символические ссылки. Когда исходники скомпилированы с _FILE_OFFSET_BITS == 64, эта функция на самом деле является lstat64, 
    поскольку интерфейс LFS прозрачно заменяет обычную реализацию.




## Константы

**S_ISREG(m)**

    это обычный файл?

**S_ISDIR(m)**

    это каталог?

**S_ISCHR(m)**

    это символьное устройство?

**S_ISBLK(m)**

    это блочное устройство?

**S_ISFIFO(m)**

    это FIFO (именованный канал)?

**S_ISLNK(m)**
￼￼Описание 2

**stat**
    Функция ￼￼fstat получает информацию об открытом файле fd и сохраняет ее в структуре, на которую указывает buf. Вот некоторые из полей в структуре _stat:
    это символическая ссылка? (Нет в POSIX.1-1996.)

**S_ISSOCK(m)**

    это розетка? (Нет в POSIX.1-1996.)




## Типы

Типы данных, определенные в `<sys/stat.h>`заголовок включает:

>
struct  stat { 
  dev_t           st_dev ;          /* ID устройства, содержащего файл */ 
  ino_t            st_ino ;          /* номер инода */ 
  mode_t       st_mode ;      /* защита */ 
  nlink_t         st_nlink ;       /* количество жестких ссылок */ 
  uid_t           st_uid ;          /* идентификатор пользователя-владельца */ 
  gid_t           st_gid ;          /* идентификатор группы владельца */ 
  dev_t          st_rdev ;       /* ID устройства (если специальный файл) */ 
  off_t           st_size ;         / *общий размер в байтах */ 
  blksize_t    st_blksize ;    /* размер блока для ввода/вывода файловой системы */ 
  blkcnt_t     st_blocks ;     /* количество выделенных блоков */ 
  time_t        st_atime ;      /* время последнего доступа */ 
  time_t        st_mtime ;    /* время последней модификации */ 
  time_t        st_ctime ;     /* время последнего изменения статуса */ 
};


## Пример

Краткий пример использования <sys/stat.h>:

>
#include <stdio.h>
#include <sys/stat.h>
#include <string.h>
#include <errno.h>
>
int main(int argc, char **argv)
{
  struct stat  file_stat;
>
  while (argc-- > 1)
    {
      if (lstat(argv[argc], &file_stat) == -1)
        fprintf(stderr, "%s\n", strerror(errno));
      else
        {
          fprintf(stdout, "Links\tUid\tGid\tSize\tName\n");
          fprintf(stdout, "%u\t%u\t%u\t%u\t%s\n", file_stat.st_nlink,
                  file_stat.st_uid, file_stat.st_gid, file_stat.st_size,
                  argv[argc]);
        }
    }
  return 0;
}

Поместите исходный код в файл (main.c) и скомпилируйте это:

 gcc main.c -o test

Теперь для запуска введите:

 ./test main.c
 ./test *





# Описание 2

## _ fstat

**Header**
     sys/stat.h

**Prototype**
    int _fstat(int fd, struct stat *buf);


Функция _fstat получает информацию об открытом файле fd и сохраняет ее в структуре, на которую указывает buf. Вот некоторые из полей в структуре _stat:

| Поле     | Описание                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------ |
| st_dev   | Номер диска, содержащего файл fd, или значение fd, если fd — это устройство.                                 |
| st_mode  | Битовая карта, содержащая информацию о режиме в открытом файле. Биты этой маски описаны в следующей таблице. |
| st_nlink | Количество ссылок (всегда 1).                                                                                |
| st_rdev  | То же, что и st_dev.                                                                                         |
| st_size  | Размер открытого файла в байтах.                                                                             |
| st_mtime | Время последнего изменения.                                                                                  |
| st_atime | То же, что и st_mtime                                                                                        |
| st_ctime | То же, что и st_mtime                                                                                        |
st_mode будет комбинацией этих значений:

Ценность              Устанавливается, если fd ссылается на...

_S_IFCHR 	               символьное устройство.
_S_IFREG          	   обычный файл, а не устройство.
_S_IREAD 	           читаемый файл или устройство.
_S_IWRITE 	            записываемый файл или устройство. 


**Возвращаемое значение**

Значение 0, если информация о файле получена успешно. Если возврат значение равно -1, для errno установлено значение EBADF, указывающее на неверный дескриптор файла.

## Пример 
>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
>
void main()
{
 char filen[_MAX_PATH];
 char *date;
 int res;
 struct _stat fstat;
 int fh;
>
 printf("Enter a filename: ");
 gets(filen);
>
 fh = _open(filen, _O_RDONLY);
 if (fh < 0)
 {
    perror("Error opening file");
    exit(EXIT_FAILURE);
 }
>
 res = _fstat(fh, &fstat);
 if (res != 0)
 {
    perror("Failure calling _fstat");
    exit(EXIT_FAILURE);
 }
>
 date = asctime(localtime(&fstat.st_ctime));
 printf("\nDate: %s", date);
 printf("Mode: %d\n", fstat.st_mode);
 printf("Size: %ld\n", fstat.st_size);
}

**Output**

Enter a filename: _fstat.c

Date: Tue Jun 28 14: 11: 56 1994
Mode: -32330
Size: 760





##  _ stat

**Header**
    sys/stat.h  
    sys/types.h

**Prototype**
    int _stat(char *path, struct _stat *buf);


Функция _stat получает информацию о файле или каталоге, указанном путем, и сохраняет информацию в структуре, на которую указывает buf. Структура содержит следующие поля:

| Поле     | Описание                                                                                                 |
| -------- | -------------------------------------------------------------------------------------------------------- |
| st_dev   | Номер диска, указанный в пути, или диск по умолчанию, если он не указан.                                 |
| st_mode  | Битовая карта, содержащая информацию о режиме открытого файла, составленная из значений, указанных ниже. |
| st_nlink | Всегда 1.                                                                                                |
| st_rdev  | То же, что и st_dev.                                                                                     |
| st_size  | Размер файла в байтах.                                                                                   |
| st_mtime | Время последнего изменения.                                                                              |
| st_atime | Для NT время последнего доступа; или то же, что и st_mtime.                                              |
| st_ctime | Для NT время создания; в остальном то же, что и st_mtime.                                                |
| st_ino   | Всегда 0. (только структура статистики)                                                                  |
| st_uid   | Всегда 0. (только структура статистики)                                                                  |
| st_gid   | Всегда 0. (только структура статистики)                                                                  |

Используйте следующие значения для st_mode:

 _S_IFREG 	       Установите, если путь относится к обычному файлу, а не к каталогу.
_S_IREAD 	   Установите, относится ли путь к читаемому файлу или каталогу.
_S_IWRITE 	   Установите, указывает ли путь на доступный для записи файл или каталог.
_S_IFDIR 	       Установите, если путь относится к каталогу.
_S_IEXEC 	   Установите, относится ли путь к исполняемому файлу или каталогу. 

**Синоним**

   Функция: стат  
   Значения: S_IFREG, S_IREAD, S_IWRITE, S_IFDIR, S_IEXEC.

**Возвращаемое значение**

   stat возвращает 0, если информация о состоянии получена. При ошибке функция возвращает -1 и устанавливается значение errno.


## Пример

>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <sys/stat.h>
>
void main()
{
 char filen[_MAX_PATH];
 char *date;
 int res;
 struct _stat fstat;
>
 printf("Enter a filename: ");
 gets(filen);
 res = _stat(filen, &fstat);
 if (res != 0)
 {
   perror("Failure calling _stat");
   exit(EXIT_FAILURE);
 }
 date = asctime(localtime(&fstat.st_ctime));
 printf("\nDate: %s", date);
 printf("Mode: %d\n", fstat. st_mode);
 printf("Size: %ld\n", fstat. st_size);
}

**Output**

Enter a filename: _stat.c
Date: Thu Jun 23 09:42:04 1994
Mode: -32330
Size: 585