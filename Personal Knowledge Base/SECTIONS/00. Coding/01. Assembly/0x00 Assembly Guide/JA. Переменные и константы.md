NASM предоставляет различные директивы определения резервирования места для хранения переменных. В ассемблере директива определения используется для выделения дискового пространства. Она может использоваться для резервирования или инициализации одного/нескольких байт.





# Хранения инициализированных данных

Синтаксис стейтмента выделения памяти для инициализированных данных следующий: [имя_переменной] директива_определения начальное_значение [,начальное_значение]… Например:

>**Hello db “Hello” ; Hello – названия переменной, db – тип данных (char), “Hello” - значения**

Где имя_переменной является идентификатором для каждого пространства хранения данных. Ассемблер связывает значение смещения с именем каждой переменной, определенной в сегменте данных.

  
Есть 5 основных форм директивы определения:

| Директива | Цель                  | Пространство для хранения |
| --------- | --------------------- | ------------------------- |
| DB        | Определяет Byte       | Выделяет 1 байт           |
| DW        | Определяет Word       | Выделяет 2 байта          |
| DD        | Определяет Doubleword | Выделяет 4 байта          |
| DQ        | Определяет Quadword   | Выделяет 8 байт           |
| DT        | Определяет 10 Byte    | Выделяет 10 байт          |




Ниже приведены примеры использования директив определения:

  
```
choice    DB   'y'
number    DW  12345
neg_number   DW -12345
big_number   DQ   123456789
real_number1 DD   1.234
real_number2 DQ  123.456
 ``` 

Обратите внимание, что:
 
 - каждый байт символа хранится как его ASCII-значение в шестнадцатеричном формате;

- каждое десятичное значение автоматически конвертируется в 16-битный двоичный эквивалент и сохраняется в виде шестнадцатеричного числа;

- процессор использует прямой порядок байтов;  

- отрицательные числа конвертируются в форму «two’s complement»;

- короткие и длинные числа типа с плавающей точкой представлены с использованием 32 или 64 бит, соответственно.

  

**Следующая программа показывает использование директивы определения:


```
section .text
  global _start ; должно быть объявлено для линкера (gcc)

_start:  ; сообщаем линкеру входную точку

mov edx,1   ; длина сообщения
mov ecx,choice ; сообщение для вывода на экран
mov ebx,1   ; файловый дескриптор (stdout)
mov eax,4  ; номер системного вызова (sys_write)
int 0x80     ; вызов ядра

mov eax,1  ; номер системного вызова (sys_exit)
int 0x80    ; вызов ядра

section .data
  choice DB 'y'

```

**Результат выполнения программы:
`y


Например у нас есть вот такая переменная:
>
Msg db “Hello World!”, 0x00, 0xA
LenMsg equ $ - Msg
>

Мы можем вывести его так:

>
MOV EAX, 4
MOV EBX, 1
MOV ECX, Msg
MOV EDX, LenMsg
>

А вы заметили символы 0x0 и 0xA на конец строки? Мы его используем в качестве части строк. Точнее говоря, в качестве окончания строк. Как можно догадаться, это шестнадцатеричные цифры. При выводе на экран эти шестнадцатеричные цифры трактуются как коды символов ASCII. То есть, чтобы понять их значение, нужно заглянуть в таблицу ASCII символов, например в статье «ASCII и шестнадцатеричное представление строк. Побитовые операции со строками».

0xA = новая строка
0x0 = нуль окончания строки

Что касается 0xD (там в таблице он обозначен как 0D) и означает enter / carriage return — возврат каретки. Во многих языках
программирования — символ «CR» обозначается как «\r». Ядро должен знать размер данных которых должен выводить. Напримере выше если вместо MOV ECX,LenMsg укажем число 3, на выводе получим Hel. Поэтому мы должны либо указать точную длинну – в нашем случае это 12-13 или через переменную указать ( что мы и сделали).



# Хранение неинициализированных данных

Директивы резервирования используются для резервирования пространства неинициализированных данных. Директивы резервирования принимают один операнд, который определяет количество единиц пространства, которое будет зарезервировано. Каждая директива определения имеет связанную директиву резервирования.

Есть 5 основных форм директив резервирования:

| Директива | Цель                   |
| --------- | ---------------------- |
| RESB      | Резервирует Byte       |
| RESW      | Резервирует Word       |
| RESD      | Резервирует Doubleword |
| RESQ      | Резервирует Quadword   |
| REST      | Резервирует 10 Byte    |



То есть resb. resw, resd, resq, rest - Они используются в разделе .bss и обьявляют неинициализированные переменные. Представляют собой байт, слово или что либо зарезервировать.

  

Например:  
>
**section .bss**
  **num resb 5**

И так у нас тут переменная num неинициализировання, и может принимать в себе 5 байт (занчения) информации.

**Пример использовании:


```
section .data	;Сегмент Data
  userMsg db 'Пожалуйста, введите любые цифры: ',0x00,0xA	;Просим пользователя ввести число
  lenUserMsg equ $ - userMsg	;Длина сообщения
  dispMsg db 'Вы ввели: '

  lenDispMsg equ $ - dispMsg

section .bss
  num resb 5

;Неинициализированные данные
section .text
  global _start

;Сегмент Code
_start:
mov eax, 4
mov ebx, 1

;Запрос пользователю на ввод
mov ecx, userMsg
mov edx, lenUserMsg
int 80h

;Считываем и сохраняем пользовательский ввод
mov eax, 3
mov ebx, 0
mov ecx, num
mov edx, 5	;5 байт (числовой, 1 для знака) этой информации
int 80h

;Вывод сообщения 'Вы ввели: '
mov eax, 4
mov ebx, 1
mov ecx, dispMsg
mov edx, lenDispMsg
int 80h

;Вывод введёного числа
mov eax, 4
mov ebx, 1
mov ecx, num
mov edx, 5
int 80h

;Код выхода
mov eax, 1
mov ebx, 0 
int 80h

```

Если после печати идёт режим чтение, то наша программа будет ждать пока польхователь нажмет на ENTER, а если пользователь ввел
какие небудь данные и нажал на ENTER, то мы легко можем перенапрвить данные пользователя на неинициализировнную переменную, а после при необходимости можем производть над ними какие небудь операции. На примере выше мы просто вывеле данные.

**Например у нас есть вот такая переменная: 

>
Msg db “Hello World!”, 0x00, 0xA
LenMsg equ $ - Msg

И мы можем вывести его так:
>
MOV EAX, 4
MOV EBX, 1
MOV ECX, Msg
MOV EDX, LenMsg

А вы заметили символы 0x0 и 0xA на конец строки? Мы его используем в качестве части строк. Точнее говоря, в качестве окончания строк. Как можно догадаться, это шестнадцатеричные цифры. При выводе на экран эти шестнадцатеричные цифры трактуются как коды символов ASCII. То есть, чтобы понять их значение,нужно заглянуть в таблицу ASCII символов, например в статье «ASCII и шестнадцатеричное представление строк. Побитовые операции со строками».

0xA = новая строка
0x0 = нуль окончания строки

Что касается 0xD (там в таблице он обозначен как 0D) и означает enter / carriage return — возврат каретки. Во многих языках
программирования — символ «CR» обозначается как «\r». 

[[AA. Ядро linux | Ядро]]  должен знать размер данных которых должен выводить. Напримере выше если вместо MOV ECX,LenMsg укажем число 3,  на выводе получим Hel. Поэтому мы должны либо указать точную длинну – в нашем случае это 12-13 или через переменную   указать             ( что мы и сделали).



# Несколько определений

Вы можете иметь несколько стейтментов определения данных в программе. Например:


```
choice     DB 'Y'    ; ASCII-значение для y = 79H
number1    DW 12345    ; 12345D = 3039H
number2    DD   123456789   ; 123456789D = 75BCD15H

```
Ассемблер выделяет смежную память для нескольких определений переменных.


# Несколько инициализаций  

**Директива TIMES** позволяет выполнить несколько инициализаций одного значения. Например, [**массив**](https://ravesli.com/urok-74-massivy-chast-1/) с именем `marks` длиной `9` может быть определен и инициализирован нулем следующим образом:

>marks  TIMES  9  DW  0

Директива TIMES полезна при определении массивов и таблиц. Следующая программа выводит на экран 9 звёздочек:


```
section .text

   global _start        ; должно быть объявлено для линкера (ld)

_start:                 ; сообщаем линкеру входную точку

   mov edx,9          ; длина сообщения
   mov ecx, stars     ; сообщение для вывода на экран
   mov ebx,1          ; файловый дескриптор (stdout)

   mov eax,4     ; номер системного вызова (sys_write)
   int 0x80      ; вызов ядра

   mov eax,1     ; номер системного вызова (sys_exit)
   int 0x80      ; вызов ядра

section .data

stars   times 9 db '*'

```

Результат выполнения программы:

`*********`

# Определение констант

NASM предоставляет несколько директив, определяющих константы:

   - **директива EQU**;

   - **директива %assign**;

   - **директива %define**.


# Директива EQU
  

**Директива EQU** используется для определения констант. Её синтаксис следующий:

> ИМЯ_КОНСТАНТЫ EQU-выражение`

Например:

>TOTAL_STUDENTS equ 50

Затем вы можете использовать эту константу в программе:

```
mov  ecx,  TOTAL_STUDENTS
cmp  eax,  TOTAL_STUDENTS

```

Операндом стейтмента EQU может быть выражение:


```
LENGTH equ 20

WIDTH  equ 10

AREA   equ length * width

```

Вышеприведенный фрагмент кода определит `AREA` как `200`.

Так мы можем сделать свой код легче и понятнее:


```
system_exit equ 4
stdout equ 1
system_exit equ 1
exit_code equ 0
....
mov eax, system_write
mov ebx, stdout
mov ecx, message
mov edx, len
int 0x80

mov eax, system_exit
mov ebx, exit_exit
  ```

Это пожоже на макросы в Си. Пример использования:


>system_exit equ 1 ; теперь число 1 и слово system_exit имеют одинаковы значения 

теперь мы можем так выходит и программы так:


```
Exit:
  mov eax, system_exit
  Mov ebx, 0

```
Еще один простой пример:

>system_write equ 4 ; теперь слово system_exit означает число 4

Например:

>
TOTAL_STUDENTS equ 50

Затем вы можете использовать эту константу в программе:


```
mov ecx, TOTAL_STUDENTS
cmp eax, TOTAL_STUDENTS

```

**Еще один пример:


```
SYS_EXIT  equ 1
SYS_WRITE equ 4
STDIN     equ 0
STDOUT    equ 1

section .text

   global _start          ; должно быть объявлено для линкера (gcc)

_start:                   ; сообщаем линкеру входную точку

   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg1        
   mov edx, len1
   int 0x80                
   
   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg2        
   mov edx, len2
   int 0x80

   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg3        
   mov edx, len3
   int 0x80

   mov eax,SYS_EXIT       ; номер системного вызова (sys_exit)
   int 0x80               ; вызов ядра

section .data

msg1 db 'Hello, programmers!',0xA,0xD
len1 equ $ - msg1
msg2 db 'Welcome to the world of,', 0xA,0xD
len2 equ $ - msg2
msg3 db 'Linux assembly programming! '
len3 equ $- msg3

```

Результат выполнения программы:

`Hello, programmers!   Welcome to the world of,   Linux assembly programming!`

# Директива %assign

**Директива %assign** может быть использована для определения числовых констант. Эта директива допускает переопределение. Например, вы можете определить константу `TOTAL` следующим образом:

%assign TOTAL 10

Затем в коде вы можете переопределить её:

%assign  TOTAL  20

Эта директива является чувствительной к регистру.

# Директива %define

**Директива %define** позволяет определять как числовые, так и строковые константы. Эта директива похожа на директиву `#define` в языке С. Например, вы можете определить константу `PTR` следующим образом:

>%define PTR [EBP+4]

Вышеприведенный код заменяет `PTR` на `[EBP+4]`.

Эта директива также допускает переопределение и является чувствительной к регистру.
  


