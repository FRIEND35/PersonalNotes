К условиям в [**ассемблере**](https://ravesli.com/assembler-vstuplenie/) относятся инструкции циклов и ветвления. Эти инструкции могут изменять поток выполнения кода в программе.

# Типы прыжков

Есть 2 типа выполнения условий в ассемблере:

   - **Прыжок без условия** (или _«**безусловный прыжок**»_) — выполняется инструкцией JMP. Выполнение данной инструкции часто включает в себя передачу управления в адрес инструкции, которая не следует за выполняемой в настоящее время инструкцией. Результатом передачи управления может быть выполнение нового набора инструкций или повторное выполнение текущих инструкций.

   - **Прыжок с условием** (или _«**условный прыжок**»_) — выполняется с помощью инструкций типа `J<условие>` и зависит от самого условия. Условные инструкции, изменяя значение смещения в [**регистре**](https://ravesli.com/assembler-segmenty-pamyati-i-registry/) IP, передают управление, прерывая последовательный поток выполнения кода.

Прежде чем разбираться с этими двумя типами инструкций детально, давайте рассмотрим инструкцию CMP.  


# Инструкция CMP

**Инструкция CMP** (от англ. _«**C**O**MP**ARE»_) сравнивает два операнда. Фактически, она выполняет операцию вычитания между двумя операндами для проверки того, равны ли эти операнды или нет. Используется вместе с инструкцией условного прыжка.

Синтаксис инструкции CMP:

>`CMP назначение, источник`

Инструкция CMP сравнивает два числовых поля. Операнд назначения может находиться либо в регистре, либо в памяти. Исходным операндом (`источник`) могут быть [**константы**](https://ravesli.com/assembler-peremennye-i-konstanty/), регистры или память. Например:


```
CMP DX, 00  ; сравниваем значение регистра DX с нулем
JE  L7      ; если true, то переходим к метке L7
.
.
L7: ...

```


Инструкция CMP сравнивает два числовых поля. Операнд назначения может находиться либо в регистре, либо в памяти. Исходным
операндом (источник) могут быть константы, регистры или память.

Сравнение чисел в Ассемблере с помощью инструкции CMP выполняется по следующему алгоритму:

 - Из ЧИСЛА1 вычитается ЧИСЛО2 (ЧИСЛО1 - ЧИСЛО2)
 - Если результат равен нулю, то ЧИСЛО1 = ЧИСЛО2
 - Если числа равны, то есть результат равен 0, то устанавливается флаг ZF

Остальные флаги также устанавливаются или сбрасываются в зависимости от результата. Но нас больше всего интересует флаг ZF.
Итак, чтобы сравнить два числа в Ассемблере нам надо выполнить следующие действия:

 - Выполнить команду CPM
 - Прочитать флаг ZF
 - Если ZF = 1, то числа равны
 - Если ZF = 0, то числа НЕ равны


Пример участка программы сравнения чисел на Ассемблере приведён ниже:

```
MOV AL, 5  ; AL = 5
MOV AH, 5  ; AH = 5
CMP AL, AH ; AL = AH, ZF = 1

CMP AL, 6  ; AL <> 6, ZF = 0
   ```

Здесь мы сначала помещаем в регистры AL и AH два одинаковых числа (5), а затем выполняем команду CMP -
сравниваем значения в регистрах AL и AH. Так как эти значения равны, то после выполнения команды CMP флаг ZF будет установлен, то есть равен 1. Например:

```
CMP DX, 00 ; сравниваем значение регистра DX с нулем
JE L7      ; если true, то переходим к метке L7
.
.
L7: ...

  ```


Инструкция CMP часто используется для проверки того, достигла ли переменная-счетчик максимального количества раз выполнения цикла или нет. Например:


```
INC EDX
CMP EDX, 10 ; сравниваем, достиг ли счетчик значения 10 или нет
JLE LP1     ; если его значение меньше или равно 10, то тогда переходим к LP1

```




# Прыжок без условия

Как мы уже говорили, безусловный прыжок выполняется инструкцией JMP, которая включает в себя имя метки, куда следует перебросить точку выполнения программы:

> `JMP    label`



JMP принимает один оперенд и этоим оперендом может быть: непосредственным адресом, меткой, регистром или ячейкой памяти,
содержащей адрес куда следует перебросить точку выполнения программы.
Примеры безусловных переходов:

```
jmp metka    ;Переход на метку
jmp bx       ;Переход по адресу в BX
jmp word[bx] ;Переход по адресу, содержащемуся в памяти по адресу в
  ```

В следующем примере мы рассмотрим использование инструкции JMP:


```
MOV  AX, 00    ; инициализируем регистр AX значением 0
MOV  BX, 00    ; инициализируем регистр BX значением 0
MOV  CX, 01    ; инициализируем регистр CX значением 1
L20:
ADD  AX, 01    ; выполняем инкремент регистра AX
ADD  BX, AX    ; добавляем AX к BX
SHL  CX, 1     ; сдвиг влево регистра CX, что, в свою очередь, удваивает его значение
JMP  L20       ; повторно выполняем стейтменты
  ```


# Прыжок с условием  
Условный переход осуществляется, если выполняется определённое условие, заданное флагами процессора. Cостояние флагов изменяется после выполнения арифметических, сравнительные, логических и некоторых других команд. Если условие не выполняется, то управление переходит к следующей команде.

Если при выполнении операции условного прыжка выполняется обозначенное условие, то точка выполнения программы переносится в указанную инструкцию. Существует множество инструкций условного прыжка, в зависимости от условия и данных.

Существует много команд для различных условных переходов. Ниже приведены инструкции условного прыжка, используемые для [**данных со знаком**](https://ravesli.com/urok-31-tselochislennyj-tip-dannyh-integer/#toc-2) **в арифметических операциях**:

| Инструкция | Описание                                                        | Тестируемые флаги |
| ---------- | --------------------------------------------------------------- | ----------------- |
| JE/JZ      | Jump Equal (равно) или Jump Zero (ноль)                         | ZF                |
| JNE/JNZ    | Jump Not Equal (не равно) или Jump Not Zero (не ноль)           | ZF                |
| JG/JNLE    | Jump Greater (больше) или Jump Not Less/Equal (не меньше/равно) | OF, SF, ZF        |
| JGE/JNL    | Jump Greater/Equal (больше/равно) или Jump Not Less (не меньше) | OF, SF            |
| JL/JNGE    | Jump Less (меньше) или Jump Not Greater/Equal (не больше/равно) | OF, SF            |
| JLE/JNG    | Jump Less/Equal (меньше/равно) или Jump Not Greater (не больше) | OF, SF, ZF        |

В следующей таблице приведены инструкции условного прыжка, используемые для данных _без знака_ **в логических операциях**:

| Инструкция  | Описание                                                        | Тестируемые флаги |
|-------------|-----------------------------------------------------------------|-------------------|
| JE/JZ       | Jump Equal (равно) или Jump Zero (ноль)                         | ZF                |
| JNE/JNZ     | Jump Not Equal (не равно) или Jump Not Zero (не ноль)           | ZF                |
| JA/JNBE     | Jump Above (больше) или Jump Not Below/Equal (не меньше/равно)  | CF, ZF            |
| JAE/JNB     | Jump Above/Equal (больше/равно) или Jump Not Below (не меньше)  | CF                |
| JB/JNAE     | Jump Below (меньше) или Jump Not Above/Equal (не больше/равно)  | CF                |
| JBE/JNA     | Jump Below/Equal (меньше/равно) или Jump Not Above (не больше)  | AF, CF            |


Следующие инструкции условного прыжка имеют специальное использование и **проверяют значение флагов**:

| Инструкция  | Описание                                              | Тестируемые флаги |
|-------------|-------------------------------------------------------|-------------------|
| JCXZ        | Jump если CX равно Zero                               | none              |
| JC          | Jump если Carry (перенос)                             | CF                |
| JNC         | Jump если No Carry (нет переноса)                     | CF                |
| JO          | Jump если Overflow (переполнение)                     | OF                |
| JNO         | Jump если No Overflow (нет переполнения)              | OF                |
| JP/JPE      | Jump Parity или Jump Parity Even (если чётность)      | PF                |
| JNP/JPO     | Jump No Parity или Jump Parity Odd (если нечётность)  | PF                |
| JS          | Jump Sign (отрицательное значение)                    | SF                |
| JNS         | Jump No Sign (положительное значение)                 | SF                |



![[Pasted image 20221005144810.png]]




Пример синтаксиса набора инструкций типа `J<условие>`:

```
CMP AL, BL
JE EQUAL
CMP AL, BH
JE EQUAL
CMP AL, CL
JE EQUAL
NON_EQUAL: ...
EQUAL: ...

```



В качестве примера рассмотрим следующую программу, которая определяет и выводит на экран наибольшую из 3 целочисленных переменных:



```
section .text

   global _start         ; должно быть объявлено для использования gcc

_start:                  ; сообщаем линкеру входную точку

   mov   ecx, [num1]
   cmp   ecx, [num2]
   jg    check_third_num
   mov   ecx, [num2]

check_third_num:

   cmp   ecx, [num3]
   jg    _exit
   mov   ecx, [num3]

_exit:

   mov   [largest], ecx
   mov   ecx,msg
   mov   edx, len
   mov   ebx,1 ; файловый дескриптор (stdout)
   mov   eax,4 ; номер системного вызова (sys_write)
   int   0x80 ; вызов ядра

   mov   ecx,largest
   mov   edx, 2
   mov   ebx,1 ; файловый дескриптор (stdout)
   mov   eax,4 ; номер системного вызова (sys_write)
   int   0x80 ; вызов ядра

   mov   eax, 1
   int   80h

section .data

   msg db "The largest number is: ", 0xA,0xD
   len equ $- msg

   num1 dd '47'
   num2 dd '22'
   num3 dd '31'

segment .bss

   largest resb 2


```

**Результат выполнения программы:

`The largest number is:   47`

Еще пример с условием:

```
cmp al, bl ; сравниваем al и bl
jz write_1 ; если al равно bl, то переходим на эту метку
...
write_1:

```

Инструкция JG выполняет короткий переход, если первый операнд БОЛЬШЕ второго операнда при выполнении операции сравнения с
помощью команды CMP.

Синтаксис команды JG:

> JG МЕТКА

О метках я рассказывал в статье о команде JMP. Инструкция JG проверяет флаги ZF, SF и OF. Переход выполняется, если:
 - ZF = 0
 - SF = OF

Сама же инструкция JG при работе никакие флаги не изменяет. Инструкция JG входит в список команд условного перехода, но, в отличие от большинства этих команд, может сравнивать и отрицательные числа. Пример использования команды JG приведён ниже:


```
.model tiny
.code
 ORG 100h

start:

 MOV AL, 0  ; AL = 0
 MOV AH, -5  ; AH = -5
 CMP AL, AH  ; AL > AH, ZF = 0, SF = OF
 JG lblJG
 ;Так как AL > AH, то УСЛОВИЕ ПЕРЕХОДА ВЫПОЛНЯЕТСЯ,
 ;а следующие инструкции НЕ выполняются,
 ;так как программа переходит к метке lblJG
 MOV AL, 5  ; AL = 5
 MOV AH, 6  ; AH = 6
 CMP AL, AH  ; AL < AH, ZF = 0, CF = 1
 JBE lblJG

lblJG:
 MOV AH, 15
 END  start

  ```

В комментариях всё подробно расписано, поэтому что-то ещё добавлять нет смысла. Если нужно более
подробно, то см. видео выше.

В конце, как всегда, расскажу, почему эта команда ассемблера называется JG. Буква J - это первая
буква слова слова JUMP (прыжок, переход). А буква G - это первая буква слова GREATER (больше). Таким
образом набор слов, от которых взяты первые буквы имени команды JG, можно перевести как “переход,
если больше”.