# Описание


Системные вызовы — это программные интерфейсы между пользователем и ядром. Мы уже использовали следующие системные вызовы:

  - sys_write — для вывода на экран;
  - sys_exit — для выхода из программы.

# Системные вызовы Linux

В своих программах на ассемблере вы можете использовать системные вызовы Linux. Для этого нужно:

  - поместить номер системного вызова в регистр EAX;
  - сохранить аргументы системного вызова в регистрах EBX, ECX и т.д.;
  - вызвать соответствующее прерывание (80h);
  - результат обычно возвращается в регистр EAX.

Есть шесть регистров, в которых хранятся и используются аргументы необходимого системного вызова:

  - **EBX
  - **ECX
  - **EDX
  - **ESI
  - **EDI
  - **EBP

Эти регистры принимают последовательные аргументы. Если есть более шести аргументов, то ячейка памяти, содержащая первый
аргумент, сохраняется в регистре EBX.

В следующем примере мы будем использовать системный вызов sys_exit:

`mov eax,1 ; номер системного вызова (sys_exit)int 0x80 ; вызов ядра

**А в следующем — sys_write:

```
mov edx,4    ; длина сообщения
mov ecx,msg  ; сообщение для вывода на экран
mov ebx,1    ; файловый дескриптор (stdout)
mov eax,4    ; номер системного вызова (sys_write)
int  0x80    ; вызов ядра
  ```

**В следующем примере мы будем использовать системный вызов sys_exit:


```
mov eax,1  ; номер системного вызова (sys_exit)
int 0x80   ; вызов ядра

```

В ассемблере, инструкция int 0x80 обычно используется для вызова системного вызова в операционной системе Linux. Номер 0x80 указывает на системный вызов sys_call_table, который представляет из себя таблицу адресов функций системных вызовов в ядре Linux. Когда происходит выполнение инструкции int 0x80, процессор передает управление операционной системе для выполнения необходимого системного вызова.

Различные значения в регистрах процессора и параметры, передаваемые через регистры или стек, могут определить, какой именно системный вызов будет выполнен и какие операции будут выполнены операционной системой.

int означает прерывание, а число 0x80 -номер прерывания. Прерывание передает поток программы тому, кто обрабатывает это прерывание, что в данном случае является прерыванием 0x80 . В Linux обработчик прерываний 0x80 является kernel и используется для выполнения системных вызовов kernel другими программами. То есть с помощью прерывания процессор прекращает работу других программ (прерывается) и начинает выполнять конкретную програмуу – наш поток инструкции (для обработки этого события). После прерывании процессор вернётся к прерванной программе.

0x80 – этот номер прерывании используется для обработки системных вызовов. Номера системных вызовов – это просто идентификаторы. Например:


```
4 – write()
1 - exit()
3 – read()
```


Все системные вызовы перечислены в /usr/include/asm/unistd.h вместе с их номерами (значение, которое помещается в EAX перед вызовом int 80h).

В следующей таблице приведены некоторые системные вызовы, которые мы будем использовать:

| %eax  | Название   | %ebx            | %ecx          | %edx    | %esx  | %edi |
|-------|------------|-----------------|---------------|---------|-------|------|
| 1     | sys_exit   | int             | —             | —       | —     | —    |
| 2     | sys_fork   | struct pt_regs  | —             | —       | —     | —    |
| 3     | sys_read   | unsigned int    | char *        | size_t  | —     | —    |
| 4     | sys_write  | unsigned int    | const char *  | size_t  | —     | —    |
| 5     | sys_open   | const char *    | int           | int     | —     | —    |
| 6     | sys_close  | unsigned int    | —             | —       | —     | —    |

int означает прерывание, а число 0x80 -номер прерывания. Прерывание передает поток программы тому, кто обрабатывает это прерывание, что в данном случае является прерыванием 0x80 . В Linux обработчик прерываний 0x80 является kernel и используется для выполнения системных вызовов kernel другими программами. То есть с помощью прерывания процессор прекращает работу других программ (прерывается) и начинает выполнять конкретную програмуу – наш поток инструкции (для обработки этого события). После прерывании процессор вернётся к прерванной программе.

0x80 – этот номер прерывании используется для обработки системных вызовов.

Номера системных вызовов – это просто идентификаторы:

4 – write()
1- exit()
3 – read()


```
;Define variables in the data section

SECTION .DATA

  hello:db 'Hello world!',10
  helloLen:  equ $-hello

;Code goes in the text section

SECTION .TEXT 
  GLOBAL  _start

_start:

mov eax,4          ; 'write' system call = 4
mov ebx,1          ; file descriptor (1 = STDOUT)
mov ecx,hello      ; string to write

mov edx, helloLen   ; length of string to write
int 80h             ; call the kernel

; Terminate program
mov eax,1   ; 'exit' system call
mov ebx,0   ; exit with error code = 0 (success)
int 80h     ; call the kernel

```

И так для полной понимании, сейчас польностью разберём наш код.

1) Сегмент данных (data segment) - представлен секциями .data и .bss. Секция .data – содержит инициализированные данные. Секция .data используется для объявления области памяти, где хранятся элементы данных для программы. Эта секция не может быть расширена после объявления элементов данных, и она остается статической во всей программе.

2) Секция .text – представлен секцией .text. Он определяет область в памяти, в которой хранятся коды инструкций. Это также фиксированная область.

MOV EAX, 4 – Как мы и сказали чтоб работать с системными вызовами, нужно сначало поместить его номер в регисте EAX, а после сохранить его аргументы в регистрах EBX,ECX,EDX И Т.Д. 4 – write(), нужен для того чтоб что небудь выводить на экран.

MOV EBX, 1 ; 1 - Это файловый дескриптор.
MOV EDX, hello ; hello – Это названия нашй переменной, в нашем случае это говорить что имено выводить (то есть выводить переменную hello).

MOV EAX, helloLen ; helloLen – Говорить процессору размер выводимой данных.
INT 80 – прерывания.



В следующей программе мы запрашиваем число, а затем выводим его на экран:


```
section .data                           ; сегмент данных

   userMsg db 'Please enter a number: ' ; сообщение с просьбой ввести число
   lenUserMsg equ $-userMsg             ; длина сообщения
   dispMsg db 'You have entered: '
   lenDispMsg equ $-dispMsg                

section .bss           ; неинициализированные данные

   num resb 5

section .text          ; сегмент кода

   global _start

_start:                ; запрашиваем пользовательский ввод

   mov eax, 4
   mov ebx, 1
   mov ecx, userMsg
   mov edx, lenUserMsg
   int 80h

   ; Считываем и сохраняем пользовательский ввод
   mov eax, 3
   mov ebx, 2
   mov ecx, num  
   mov edx, 5          ; 5 байт информации
   int 80h

   ; Выводим сообщение 'You have entered: '
   mov eax, 4
   mov ebx, 1
   mov ecx, dispMsg
   mov edx, lenDispMsg
   int 80h  

   ; Выводим число пользователя
   mov eax, 4
   mov ebx, 1
   mov ecx, num
   mov edx, 5
   int 80h  

   ; Код выхода
   mov eax, 1
   mov ebx, 0
   int 80h

```

Результат выполнения программы:

`Please enter a number: 
`1234 
`You have entered:1234`


