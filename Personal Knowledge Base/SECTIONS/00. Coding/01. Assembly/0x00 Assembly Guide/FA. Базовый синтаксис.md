# Оперенды
1) Операнд – объект, над которым выполняется машинная команда.

2) Данные, которые обрабатываются командами, называются операндами. Операнды в языке ассемблера записываются непосредственно после команды; если их несколько, то через запятую. Одни команды вообще не имеют никаких операндов, другие имеют один или два операнда. В качестве операнда можно указать непосредственное значение (например, 0х123), имя регистра или ссылку на ячейку памяти (так называемые косвенные операнды).

Что же касается разрядности, имеются 32-разрядные, 16-разрядные, и 8-разрядные операнды. Почти каждая команда требует, чтобы операнды были одинакового размера (разрядности). Команда МОV АХ, 0х1234 имеет два операнда: операнд регистра и непосредственное значение, и оба они 16-битные.

Последний тип операнда — косвенный тип — адресует данные, находящиеся в памяти, получает их из памяти и использует в качестве значения. Узнать этот операнд очень просто — по наличию в записи квадратных скобок. Адресация памяти будет рассмотрена в следующем параграфе.


# Секция

Программы на ассемблере могут быть разделены на три секции:

  -  секция data;

  -  секция bss;

  -  секция text.



# Секции ассемблера

**Секция data** используется для объявления инициализированных данных или [**констант**](https://ravesli.com/urok-37-simvolnye-konstanty-const-constexpr/). Данные в этой секции НЕ могут быть изменены во время выполнения программы. Вы можете хранить константные значения и названия файлов в этой секции. Синтаксис объявления:

>section .data

**Секция bss** используется для объявления переменных. Синтаксис объявления:

>section .bss

**Секция text** используется для хранения кода программы. Данная секция должна начинаться с объявления `global_start`, которое сообщает ядру, откуда нужно начинать выполнение программы. Синтаксис объявления:


```
section.text

     global _start

_start:

```

# Комментарии

Комментарии в ассемблере должны начинаться с точки с запятой (`;`). Они могут содержать любой печатный символ, включая пробел. Комментарий может находиться как на отдельной строке:

>; эта программа выводит сообщение на экран

Так и на строке со стейтментом:

>add eax, ebx     ; добавляет ebx к eax



# Стейтменты

В ассемблере есть **три вида стейтментов**:

  -  **Выполняемые инструкции** (или просто _**«инструкции»**_) — сообщают процессору, что нужно делать. Каждая инструкция хранит в себе **код операции** (или **_«опкод»_**) и генерирует одну инструкцию на машинном языке.

  - **Директивы ассемблера** — сообщают программе об аспектах компиляции. Они не генерируют инструкции на машинном языке.

  -  **Макросы** — являются простым механизмом вставки кода.

В ассемблере на одну строку приходится один стейтмент, который должен соответствовать следующему формату:

> [метка]   mnemonic   [операнды]   [; комментарий]

Базовая инструкция состоит из названия инструкции (`mnemonic`) и операндов (они же _«параметры»_). Вот примеры типичных стейтментов ассемблера:

```
INC COUNT        ; выполняем инкремент переменной памяти COUNT

MOV TOTAL, 48    ; перемещаем значение 48 в переменную памяти TOTAL

ADD AH, BH       ; добавляем содержимое регистра BH к регистру AH

AND MASK1, 128   ; выполняем операцию AND с переменной MASK1 и 128

ADD MARKS, 10    ; добавляем 10 к переменной MARKS

MOV AL, 10       ; перемещаем значение 10 в регистр AL

```

## Первая программа

Следующая программа на языке ассемблера выведет строку `Hello, world!` на экран:

```

section .text

   global _start    ; необходимо для линкера (ld)

_start:             ; сообщает линкеру стартовую точку

   mov edx,len     ; длина строки
   mov ecx,msg     ; строка
   mov ebx,1       ; дескриптор файла (stdout)
   mov eax,4       ; номер системного вызова (sys_write)
   int 0x80        ; вызов ядра
   
   mov eax,1       ; номер системного вызова (sys_exit)
   int 0x80        ; вызов ядра

section .data

msg db 'Hello, world!', 0xa  ; содержимое строки для вывода
len equ $ - msg              ; длина строки


```

Результат выполнения программы:

`Hello, world!`  

Метка `_start` - говорить ОС где можно найти и выполнить нашу программу, адрес команды нашей программы ( начальный адрес выполняемого кода). А после осуществляется последоватлеьность т.е. определяет следующий адрес команды которую нужно выполнить и выполняет. Важно указать ядру Ос где наченается выполнение кода ( начальный адрес ) , а где останавливается ваша программа ( код выхода). Если мы не укажем ядру адрес где дожна заканчиваться наша программа, то он будет выполнять последовательность, т.е. команды не относящееся к нашей программы и это может быть что угодно, но мы не узнаем что пытался выполнить [[AA. Ядро linux | ядро]] , вместо этого [[AA. Ядро linux | ядро]] завершает процесс за нас, оставив нам ошибку (ошибка сегментации). Чтобы этого не случилось, после завершении операции вызовите sys_exit чтоб [[AA. Ядро linux | ядро]] точно понял где завершается процесс:

```
... //Процесс
Exit:
  mov eax, 1 ; sys_exit()
  mov ebx, 0 ; code 0

```

Код 0 - говорить о том, что программа завершился успешно и без ошибок.

Конечно, мы можем использовать оперативную память и для хранения данных, а не только команд. Области памяти, предназначенные для данных, мы обычно называем переменными, и даём им имена почти так же, как и в привычных нам языках программирования высокого уровня. Естественно, нам требуется знать, какой адрес имеет начало области памяти, отведённой под переменную. Адрес, как мы уже говорили, задаётся! числом из восьми шестнадцатеричных цифр, например, 18b4a0f0. Запоминать такие числа нам неудобно, к тому же на момент написания программы мы ещё не знаем, в каком именно месте памяти в итоге окажется размещена та или иная команда или переменная. И здесь нам на помощь как раз и приходят метки. Метка — это вводимое программистом слово (идентификатор), с которым ассемблер ассоциирует некоторое число, чаще всего — адрес в памяти. В данном случае _start как раз и есть такая метка. Если ассемблер видит метку перед командой (или, как мы увидим позже, директивой, выделяющей память под переменную), он воспринимает это как указание завести в своих внутренних таблицах новую метку и связать с ней соответствующий адрес, если же метка встречается в параметрах команды, то ассемблер «вспоминает», какой именно адрес (или просто число) связано с данной меткой и подставляет этот адрес (число) вместо метки в команду.Таким образом, с меткой _start в нашей программе будет связано число, представляющее собой адрес ячейки, начиная с которой в оперативной памяти будет размещён машинный код, соответствующий команде mov еах,0 (код b8 00 00 00 00). Важно понимать, что метки существуют только в памяти самого ассемблера и только во время трансляции программы. Готовая к исполнению программа на
машинном коде не будет содержать никаких меток, а только подставленные вместо них адреса.

## Сборка программ

Убедитесь, что у вас [**установлен NASM**](https://ravesli.com/assembler-nastrojka-sredy-razrabotki/). Запишите вашу программу в текстовом редакторе и сохраните её как _hello.asm_. Затем:

   - откройте терминал;

   - убедитесь, что вы находитесь в той же директории, в которой вы сохранили _hello.asm_;

   - чтобы собрать программу, введите команду `nasm -f elf hello.asm`;

   - если не было ошибок, то создастся объектный файл вашей программы под названием _hello.o_;

   - чтобы ваш объектный файл прошел линкинг и создался исполняемый файл под названием _hello_, введите команду `ld -m elf_i386 -s -o hello hello.o`;

   - запустите программу командой `./hello`.

Если всё прошло успешно, то вам выведется `Hello, world!`.

Если у вас нет возможности скомпилировать программу, например, у вас нет Linux и вы пока не хотите на него переходить, то можете использовать одну из следующих онлайн-IDE:

   [**TutorialsPoint**](http://tutorialspoint.com/compile_asm_online.php)

   [**JDoodle**](https://www.jdoodle.com/compile-assembler-nasm-online/)

**_Примечание_:** Запоминать две вышеприведенные команды для сборки программы на ассемблере для некоторых может быть несколько затруднительно, поэтому вы можете написать скрипт для сборки программ на ассемблере. Для этого создайте файл под названием _Makefile_ со следующим содержимым:

```
all:

   nasm –f elf $(source)
   ld –m elf_i386 –s –o $(source) $(source).o
   rm $(source).o
```

Для сборки _hello.asm_ выполните следующие действия:

   - откройте терминал;

   - убедитесь, что вы находитесь в той же директории, в которой вы сохранили _hello.asm_ и _Makefile_;

   - введите команду `make source=hello`.