Подсказка - указывает компилятору требуемый размер оперенда для операции. Операнды мы только что рассмотрели, осталась одна «темная лошадка» — подсказка. Необязательная подсказка указывает компилятору требуемый размер операнда. Ее значением может быть:

 - BYTE = 1 байт ( 8 бит ).
 - WORD = 2 байта ( 16 бит).
 - DWORD = 4 байта ( 32 бит).
 - QWORD = 8 байт (64 бит)

Есть еще подскази, но нам этого достаточно. Представим инициализацию некоторой «переменной» нулем, то есть запись нулей по
адресу переменной. Подсказка сообщит компилятору размер операнда, то есть сколько именно нулевых байтов должно быть записано
по этому адресу. Пока мы не знаем правильной инструкции для записи значения, поэтому будем считать, что записать значение
можно так:


```
MOV BYTE [0x12345678], 0  ; записываем 1 нулевой байтa в област памяти у которого адрес - 0x12345678
MOV WORD [0x12345678], 0  ; записываем 2 нулевых байта в област памяти у которого адрес - 0x12345678
MOV DWORD [0x12345678], 0 ; записываем 4 нулевых байта в област памяти у которого адрес – 0x12345678
  ```

1 нулевой байт = 00000000
2 нулевых байта = 00000000 00000000
4 нулевых байта = 00000000 00000000 00000000 00000000

Простыми словами, подсказка говорить размер данных, независимо от его предопределенного размера.

# Выбор размера данных
-----------------------------------------------------------------

В языке Ассемблера с помощью инструкции MOV можно копировать байты  или  значения  размером в слово. Давайте рассмотрим, каким образом Турбо Ассемблер определяет, с каким размером данных нужно
работать.

Во многих случаях операнды явным образом указывают Турбо Ассемблеру,  каким должен быть размер данных. Если в инструкции ис-
пользуется регистр, то размер данных должен соответствовать  размеру этого регистра. Например, размер данных в следующих инструкциях ясен:


```
          .
          .
          .
          mov   al,1             ; байт
          mov   dx,si            ; слово
          mov   bx,[dl]          ; слово
          mov   [bp+si+2],al     ; байт
          .
          .
          .


```
	 
Аналогично, именованные ячейки памяти имеют заданные  размеры,  поэтому  размер данных в следующих инструкциях для Турбо Ас-
семблера ясен:


```
          .
          .
          .
          .DATA
 TestChar           DB   ?
 TempPointer        DW   TestChar
          .
          .
          .
          .CODE
          .
          .
          .
          mov   [TestChar],'A'
          mov   [TempPointer],0
          .
          .
          .

```

Однако, иногда приходится иметь дело с инструкциями  MOV,  в которых  размер данных не определен. Например, Турбо Ассемблер не
может сделать вывод о том, следует ли в следующей инструкции  записать значение размером в слово или в байт:


```
         mov   [bx],1

```

Фактически, Турбо Ассемблер не будет знать, как такую  инструкцию нужно ассемблировать.  Было бы  удобно  иметь  возможность
временного доступа к переменой размером в слово,  как к байту,  и наоборот.

Турбо Ассемблер дает вам способ гибкого определения  размера данных  в  виде  операций  WORD PTR и BYTE PTR. Операция WORD PTR указывает Турбо Ассемблеру, что данный операнд в памяти нужно интерпретировать, как операнд размером в слово, а операция BYTE PTR указывает Турбо Ассемблеру, что данный операнд в памяти нужно интерпретировать,  как  операнд  размером в байт, независимо от его предопределенного размера. Например, можно  сделать  так,  что  в последнем  примере значение 1 размером в слово будет записываться в слово, на которое указывает регистр BX:


```
		 mov   WORD PTR  [bx],1

```

или же можно сделать так, что в данном примере значение 1  размером  в  байт  будет записываться в байт, на который указывает ре-
гистр BX:

```
         mov   BYTE PTR  [bx],1
```


Заметим, что операции WORD PTR и BYTE PTR, если их применять к  регистрам, не имеют смысла, так как регистры всегда имеют фик-
сированный размер. В таком случае операции BYTE PTR  и  WORD  PTR игнорируются.  Аналогично, эти операции игнорируются при применении к константам, поскольку они всегда имеют тот же размер, что и операнд-приемник.

Операции WORD PTR и BYTE PTR  имеют  другое  назначение:  их можно  использовать для временного выбора размера данных для именованной  переменной  в  памяти.  Почему  это   может   оказаться полезным? Рассмотрим следующий пример:


```
          .
          .
          .
          .DATA
 Source1  DD    12345h
 Source2  DD    54321h
 Sum      DD    ?
          .
          .
          .
          .CODE
          .
          .
          .
          mov   ax,WORD PTR [Source1]      ; получить младшее
                                           ; слово Source1
          mov   dx,WORD PTR [Source1+2]    ; получить старшее
                                           ; слово Source1
          add   ax,WORD PTR [Source2]      ; прибавить к Source2
                                           ; младшее слово
          adc   dx,WORD PTR [Source2+2]    ; прибавить к Source2
                                           ; старшее слово
          mov   WORD PTR [Sum],ax          ; сохранить младшее
                                           ; слово суммы
          mov   WORD PTR [Sum+2],dx        ; сохранить старшее
                                           ; слово суммы
          .
          .
          .


```

Все переменные,   которые  используются  в  данном  примере, представляют собой длинные целые или двойные слова.  Однако, про-
цессор  8086  не может выполнять сложение двойных слов непосредственно, поэтому такое сложение приходится разбивать на ряд операций  со словами.  Операция WORD PTR позволяет обращаться к частям переменных Source1,  Source2 и Sum,  как к словам,  хотя сами эти переменные представляют собой двойные слова.

Операции FAR PTR и NEAR PTR хотя и не влияют непосредственно на  размер  данных, они аналогичны операциям WORD PTR и BYTE PTR. Операция FAR PTR приводит к тому, что  целевая  метка  инструкции перехода  или вызова будет интерпретироваться, как дальняя метка, и при этом будут загружаться оба регистра CS и IP. С другой  стороны,  операция NEAR PTR вынуждает интерпретировать соответствующую метку, как метку ближнего типа,  переход  на  которую  осуществляется путем загрузки одного регистра IP.


