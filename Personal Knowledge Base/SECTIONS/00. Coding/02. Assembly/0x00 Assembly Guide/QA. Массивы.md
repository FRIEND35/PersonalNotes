Мы уже обсуждали, что в [**Ассемблере**](https://ravesli.com/assembler-vstuplenie/) директивы определения данных используются для выделения памяти переменным. Переменная также может быть инициализирована определенным значением. Инициализированное значение может быть указано в шестнадцатеричной, десятичной или двоичной форме.

Например, мы можем определить переменную `months` [**типа word**](https://ravesli.com/assembler-peremennye-i-konstanty/) любым из следующих способов:

>
MONTHS DW 12
MONTHS DW 0CH
MONTHS DW 0110B
>

Директивы определения данных также могут использоваться для определения **одномерного** [**массива**](https://ravesli.com/urok-74-massivy-chast-1/). Например, давайте определим одномерный массив чисел: 

>NUMBERS DW  34,  45,  56,  67,  75, 89

Здесь мы объявили массив из шести значений типа word, каждое из которых инициализировано числами `34`, `45`, `56`, `67`, `75`, `89` (соответственно). Таким образом, мы выделили 12 байт (2 * 6 = 12) памяти. Символьный адрес первого числа будет `NUMBERS`, второго числа — `NUMBERS + 2` и так далее.

Давайте рассмотрим другой пример. Вы можете определить массив с именем `INVENTORY` из 8 элементов и инициализировать все значения нулем:

```
INVENTORY   DW  0
            DW  0
            DW  0
            DW  0
            DW  0
            DW  0
            DW  0
            DW  0

```

Можно сократить и написать следующим образом:

>INVENTORY&nbsp;&nbsp; DW&nbsp; 0, 0 , 0 , 0 , 0 , 0 , 0 , 0

Директива `TIMES` также может использоваться для нескольких инициализаций одним и тем же значением. Используя `TIMES`, массив `INVENTORY` можно определить как:

>&nbsp;INVENTORY TIMES 8 DW 0

В следующем примере мы определим массив `x`, состоящий из трех элементов: `2`, `3` и `4`. Затем мы сложим эти значения и выведем их сумму:


```
section .text

   global _start   ; должно быть объявлено для линкера (ld)

_start:

   mov  eax,3      ; количество значений типа byte для выполнения операции сложения
   mov  ebx,0      ; EBX будет хранить сумму
   mov  ecx, x     ; ECX будет указывать на текущий элемент для выполнения операции сложения

top:  add  ebx, [ecx]

   add  ecx,1      ; перемещаем указатель на следующий элемент
   dec  eax        ; выполняем декремент счетчика
   jnz  top        ; если счетчик не равен 0, то тогда выполняем цикл еще раз

done:

   add   ebx, '0'
   mov  [sum], ebx ; готово, сохраняем результат в переменной sum

display:

   mov  edx,1      ; длина сообщения
   mov  ecx, sum   ; сообщение для вывода на экран
   mov  ebx, 1     ; файловый дескриптор (stdout)
   mov  eax, 4     ; номер системного вызова (sys_write)
   int  0x80       ; вызов ядра

   mov  eax, 1     ; номер системного вызова (sys_exit)
   int  0x80       ; вызов ядра

section .data

global x

x:    

   db  2
   db  4
   db  3

sum:

   db  0

```

**Результат выполнения программы:

`9`