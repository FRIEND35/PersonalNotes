# Что такое смещение 

Offset ( Смещение ) - Это целое число, указывающий на расстояние (смещение) между начало обьекта и данным элементом или точкой. Например – В строке “ABCDEF”, D – имеет смещение в 3 от начало A (0). В компьютерной инженерии и низкоуровневом программировании (например, языке ассемблера) смещение обычно обозначает количество адресов, которые нужно добавить к базовому адресу, чтобы получить конкретный абсолютный адрес. В этом значении для указания размера смещения используется только базовый адресный блок, обычно 8-битный байт. В этом контексте смещение иногд называют «относительным адресом».То есть:

  - Адрес - идентификатор ячейки памяти.
  - Базовы адрес - Адрес в роли начальной точкой для вычисления других адресов.
  - Смещения - Это количество адресов котовый добавляется к базовому адресу для вычисления конкретной ячейки памяти.
 
 Где БАЗА - это базовый адрес, находящийся в регистре (при 16-разрядной адресации могут использоваться только регистры BX или BP); СМЕЩЕНИЕ (или ОТКЛОНЕНИЕ - displacement) - это константа (число со знаком), заданная в команде; ИНДЕКС - значение индексного регистра (при 16-разрядной адресации могут использоваться только регистры SI или DI).

Любая из частей эффективного адреса может отсутствовать (например, необязательно указывать СМЕЩЕНИЕ или ИНДЕКС), но обязательно должна присутствовать хотя бы одна часть (например, только БАЗА).

Адрес операнда указывает место, где хранятся обрабатываемые данные. Некоторым инструкциям не нужен операнд, тогда как другим инструкциям может потребоваться один, два или три операнда. Адресация — осуществление ссылки (обращение) к устройству или элементу данных по его адресу. Адрес операнда указывает место, где хранятся обрабатываемые данные ( в каком ячейки памяти
Адрес операнда (англ. source address) — адрес ячейки или области памяти, откуда извлекаются обрабатываемые данные. Адрес регистра (англ. register adress) — порядковый номер либо символическое имя регистра, эквивалентное его номеру. Предопределенный идентификатор $ представляет текущий счетчик адреса. Счетчик адреса состоит из двух частей: сегмента и смещения. При ассемблировании счетчик адреса представляет собой смещение в текущем сегменте.

Мы уже знаем, что адрес, как и сама команда, — это число. Чтобы не запоминать адреса всех «переменных», используемых в программе, этим адресам присваивают символические обозначения, которые называются переменными (иногда их также называют указателями). Фактически, переменная – это адрес области памяти в символическом виде, чтобы человеку было легко его запомнить.

При использовании косвенного операнда адрес в памяти, по которому находится нужное значение, записывается в квадратных скобках:
[адрес]. Если мы используем указатель, то есть символическое представление адреса, например, [ЕSI], то в листинге машинного кода мы увидим, что указатель был заменен реальным значением адреса. Можно также указать точный адрес памяти, например, [0х594Е]. Как было сказано, символические элементы сохраняются реальным адресом нашей программы. Например – мы указали название нашей пеменной:


```
mov ebp, 0x12345
mov [counter], ebp
```


А отладчик видит его так:


```
mov ebp, 0x12345
mov dword[+8040c0], ebp
```


И как мы и сказали, мы можем указать сам адрес:

```
mov ebp, [0x594e]
```

Чаще всего мы будем адресовать память по значению адреса, занесенному в регистр процессора. Чтобы записать такой косвенный операнл, нужно просто написать имя регистра в квадратных скобках. Например, если адрес загружен в регистр ESI, вы можете получить данные, расположенные по этому адресу, используя выражение [ESI].

Теперь рассмотрим фрагмент программы, в которой регистр ЕSI содержит адрес первого элемента (нумерация начинается с 0) в массиве байтов. Как получить доступ, например, ко второму элементу (элементу, адрес которого на 1 байт больше) массива? Процессор поддерживает сложные способы адресации, которые очень нам пригодятся в дальнейшем. В нашем случае, чтобы получить доступ ко
второму элементу массива, нужно записать косвенный операнд [ЕSI + 1].               

Имеются даже более сложные типы адресации: [адрес + ЕВХ + 4]. В этом случае процессор складывает адрес, значение 4 и значение, содержащесся в регистре ЕВХ. Результат этого выражения называется эффективным адресом (EA, Effective Address) и используется в качестве адреса, по которому фактически находится операнд (мы пока не рассматриваем сегментные регистры). При вычислении эффективного адреса процессор 80386 также позволяет умножать один член выражения на константу, являющуюся степенью двойки:

```
[адрес + ЕВХ * 4]. 
```

Корректным считается даже следующее «сумасшедшее» выражение:

```
[число — 6 + ЕВХ * 8 + ЕSI]
```

На практике мы будем довольствоваться только одним регистром [ЕSI] или суммой регистра и константы, например, [ЕBX + 4]. В
зависимости от режима процессора, мы можем использовать любой 16-разрядный или 32-разрядный регистр общего назначения [EАХ], [ЕВХ],... [ЕВР]. Процессор предыдущего поколения 80286 позволял записывать адрес в виде суммы содержимого регистра и константы только для регистров ВР, SI, DI, и ВХ. Выше мы упомянули, что в адресации памяти участвуют сегментные регистры. Их функция зависит от режима процессора. Каждый способ адресации предполагает, что при вычислении реального (фактического) адреса используется сегментный регистр по умолчанию.
Сменить регистр по умолчанию можно так:

```
ES: [ESI]
```

Некоторые ассемблеры требуют указания регистра внутри скобок:

```
ES:[ESI]
```

В наших примерах мы будем считать, что все сегментные регистры содержат одно и то же значение, поэтому мы не будем
использовать их при адресации.

Большинство инструкций на языке ассемблера требуют обработки операндов. Адрес операнда предоставляет место, где хранятся данные, подлежащие обработке. Некоторые инструкции не требуют операнда, в то время как другие могут требовать один, два или три операнда. В тех случаях, когда инструкции требуется два операнда, первый операнд обычно является местом назначения, содержащий данные в регистре или в ячейке памяти, а второй — источником. Источник содержит либо данные для доставки (немедленная адресация), либо адрес (в регистре или в памяти) данных. Как правило, исходные данные остаются неизменными после операции.

Режимы адресации — это различные способы указания местоположения операндов.

Есть **три основных режима адресации**:

   - **регистровая адресация**;

   - **прямая** (или **_«непосредственная»_**) **адресация**;

   - **адресация памяти**.
   
# Адресация памяти

Когда в режиме адресации памяти операнды определены, то требуется прямой доступ к основной памяти (обычно к сегменту данных) — этот вариант является медленным. Чтобы обнаружить точное местоположение данных в памяти, нам нужен начальный адрес сегмента, который обычно находится в регистре DS, и значение смещения. Это значение смещения также называется **эффективным адресом**.

В режиме прямой адресации значение смещения указывается как часть инструкции (например, имя переменной). Ассемблер вычисляет значение смещения и поддерживает таблицу символов, в которой хранятся значения смещения всех переменных, используемых в программе.

При прямой адресации памяти один из операндов ссылается на ячейку памяти, а другой — на регистр. Например:


```
ADD BYTE_VALUE, DL      ; добавляем регистр в ячейку памяти
MOV BX, WORD_VALUE    ; операнд из памяти скопирован в регистр
```

## Регистровая адресация

В режиме регистровой адресации регистр содержит операнд. В зависимости от инструкции регистр может быть первым операндом, вторым или и тем, и другим сразу. Другими словами, операнд находится в регистре. Например:


```
MOV DX, TAX_RATE ; регистр в первом операнде
MOV COUNT, CX    ; регистр во втором операнде
MOV EAX, EBX     ; оба операнда являются регистрами

```

Так как обработка данных между регистрами не требует памяти, то она обеспечивает самую быструю обработку данных.  


## Прямая (непосредственная) адресация

Прямой операнд имеет константное значение или выражение. Когда инструкция с двумя операндами использует прямую адресацию, то первый операнд может быть регистром или ячейкой памяти, а второй — непосредственной константой. Первый операнд определяет длину данных. другими словами, при непосредственной адресации значение операнда является частью машинной команды. Понятно, что в этом случае операнд представляет собой константу.  Например:


```
BYTE_VALUE  DB  150    ; определение значения типа byte
WORD_VALUE  DW  300    ; определение значения типа word
ADD  BYTE_VALUE, 65    ; добавлен непосредственный операнд 65
MOV  AX, 45H           ; непосредственная константа 45H перемещена в AX

```

Или же:

```
mov al, 5
add bx, 1234h

```
  
Число 5 и 1234h – это непосредственный оперенд, и он находится прямо в машинном коде.

## Адресация прямого смещения

Этот режим адресации использует арифметические операторы для изменения адреса. Например, следующие определения определяют таблицы данных:


```
BYTE_TABLE DB  14, 15, 22, 45      ; таблица байтов
WORD_TABLE DW  134, 345, 564, 123  ; таблица слов

```

Следующие операции копируют данные из таблиц в памяти в регистры:


```
MOV CL, BYTE_TABLE[2] ; получаем 3-й элемент из BYTE_TABLE
MOV CL, BYTE_TABLE + 2 ; получаем 3-й элемент из BYTE_TABLE
MOV CX, WORD_TABLE[3] ; получаем 4-й элемент из WORD_TABLE
MOV CX, WORD_TABLE + 3 ; получаем 4-й элемент из WORD_TABLE

```
 

## Непрямая адресация памяти

Обычно для этой цели используются базовые регистры EBX, EBP (или BX, BP) и индексные регистры (DI, SI), используемые в квадратных скобках для [**ссылок**](https://ravesli.com/urok-88-ssylki/) на память.

Непрямая адресация обычно используется для переменных, содержащих несколько элементов, таких как [**массивы**](https://ravesli.com/urok-74-massivy-chast-1/). Начальный адрес массива хранится, например, в регистре EBX.

В следующем примере мы получаем доступ к разным элементам переменной:


```
MY_TABLE TIMES 10 DW 0  ; выделяем 10 слов (2 байта), каждое из которых инициализируем значением 0
MOV EBX, [MY_TABLE]     ; помещаем эффективный адрес MY_TABLE в EBX
MOV [EBX], 110          ; MY_TABLE[0] = 110
ADD EBX, 2              ; EBX = EBX +2
MOV [EBX], 123          ; MY_TABLE[1] = 123

```

## Абсолютная прямая адресация

Каждый элемент стека имеет свой физический адрес в памяти. Однако прямое использование абсолютных адресов для доступа к данным в стеке не является удобным из-за динамики его изменения во время выполнения программы. В машинной команде содержится адрес операнда, находящегося в памяти. Другими словами, оперенд находится в оперативно памяти, а его адрес в магинной команде, В команде указывается символическое обозначение ячейки памяти, над содержимым которой требуется выполнить операцию. Пример:

```
mov dx,  [a]
mov eax, [0x12345]

```
  
Вот тут уже в DX помещается значение из памяти по адресу a. Квадратные скобки обозначают обращение по адресу, указанному внутри этих скобок.

## Относительная адресация

 - **Относительно указателя стека (SP)**: адресация данных осуществляется относительно текущего положения указателя стека. Например, `SP + 4` может указывать на данные, находящиеся на четыре байта выше текущей вершины стека.
 
- **Относительно базового указателя фрейма (BP)**: используется для доступа к локальным переменным и параметрам функции. Например, `BP - 8` может указывать на локальную переменную, расположенную на восемь байт ниже базового указателя.

## Относительная прямая адресация

Этот режим используется в командах передачи управления. В машинной команде содержится смещение, которое прибавляется к значению указателя команд IP. То есть указывается не сам адрес перехода, а на сколько байтов вперёд или назад надо перейти. Другими словами, мы просто указываем место куда надо перейти, и вместо адреса мы используем метку. 

Пример:
`
```
Metka:

...

loop metka

 ``` 

У такого режима адресации два преимущества. Во-первых, машинная команда становится короче, так она содержит не полный адрес, а только смещение. Во-вторых, такой код не зависит от адреса, по которому он размещается в памяти.

## Косвенная регистровая (базовая) адресаци

Косвенная адресация - это такая адресация, при которой в адресном поле команды указан адрес ячейки памяти или регистра, в которых хранится не сам операнд, а его адрес. При необходимости многократного обращения к какой-либо ячейке памяти ее адрес удобнее хранить во внутренних регистрах микропроцессора. 

Для адресации к ячейке в этом случае необходимо указать номер внутреннего регистра, в котором хранится адрес. Такая адресация называется косвенной. При такой адресации эффективный адрес операнда может находиться в любом из регистров общего назначения, кроме sp/esp и bp/ebp. Синтаксически в команде указывается регистр в квадратных скобках [ ], в котором находится адрес операнда. 

Пример 1:

```
mov rax, [rax]
```

Команда `mov rax, [rax]` в ассемблере x86-64 (или x86 с соответствующими регистрами) означает следующее:

1. **`rax`**: Это регистр общего назначения в 64-битной архитектуре x86-64.
2. **`[rax]`**: Это указание на память, адрес которой содержится в регистре `rax`.

Подробное объяснение

- **`rax`**: Регистр `rax` может содержать некоторое значение, которое является адресом в памяти.
- **`[rax]`**: Это значение интерпретируется как адрес, и команда обращается к содержимому памяти по этому адресу.

Что делает команда?

Команда `mov rax, [rax]` выполняет следующее:

1. Берет значение, которое хранится в регистре `rax`.
2. Использует это значение как адрес памяти.
3. Загружает 64-битное значение из этой адресуемой памяти.
4. Записывает это значение обратно в регистр `rax`.

Рассмотрим конкретный пример:

1. Предположим, регистр `rax` содержит значение `0x1000`.
2. Память по адресу `0x1000` содержит значение `0x2000`.

Когда выполняется команда `mov rax, [rax]`:

- Процессор берет значение `0x1000` из `rax`.
- Переходит по адресу `0x1000` в памяти и извлекает значение `0x2000`.
- Записывает это значение `0x2000` обратно в регистр `rax`.

Графическая иллюстрация

```
Память:
0x1000: 0x2000  <-- содержимое по адресу 0x1000

Регистр:
rax: 0x1000

Команда:
mov rax, [rax]

Результат после выполнения команды:
rax: 0x2000
```

Пример 2:
  
```
mov ax, [bx] ; Занесли в ах значение по адресу который лежит в bx
```

  
Допустим в регистре bx лежит адрес 0x3332, а в памяти по адресу 0x3332 лежит значение 10, то мы берём значение 10 из памяти и заносим его в регистр ax. Простыми словами, это можно называть указателями.Пример 2:


```
add ax,[bx]
mov dl,[si]
```


Размер операнда в памяти здесь определяется размером первого операнда. Так как AX — 16-разрядный регистр, то из памяти берётся слово по адресу в BX. Так как DL — 8-разрядный регистр, то из памяти берётся байт по адресу в SI. Это правило верно и для других режимов адресации.Пример 3:

```  
mov ах, [есх] ; Тут можно проще сказать, что читается 2 байта (word, слово) из адреса, который лежит в ECX, в регистр AX
```
 

## Косвенная регистровая (базовая) адресация со смещением

Косвенная базовая (регистровая) адресация со смещением является дополнением предыдущего вида адресации и предназначена для доступа к данным с известным смещением относительно некоторого базового адреса. Этот вбыстрее пулиид адресации удобно использовать дл доступа к элементам структур данных, когда смещение элемен- тов известно заранее на стадии разработки программы, а базовый (начальный) адрес структуры должен вычисляться динамически на стадии выполнения программы. Модификация содержимого базового регистра позволяет обращаться к одноимен- ным элементам различных экземпляров однотипных структур данных. К примеру, команда mov ax,[edx+3h] пересылает в регистр АХ слово из области памяти по адресу, определяемому содержимым EDX + 3h. Команда mov ax,mas[dx] пересылает в регистр АХ слово по адресу, определяемому содержимым DX плюс значение идентификатора mas. Например: если bx = 0x000A  

```
mov ax, [bx+2]
```

AX = значения по адресу 0x000C
## Косвенная базовая индексная адресация

При косвенной базовой индексной адресации эффективный адрес формируется как сумма содержимого двух регистров общего назначения: базового и индексного. В качестве этих регистров могут применяться любые регистры общего назначения, при этом часто содержимое индексного регистра масштабируется. Например:

```
mov еах , [ esi ] [ edx ]
```
  

В данном примере эффективный адрес второго операнда формируется из двух компонентов, (ESI) + (EDX). Например, в одном из регистров может находиться адрес начала массива в памяти, а в другом — смещение какого-то элемента относительно начала. А вообще, всё зависит от вашей фантазии.

# Инструкция MOV

Мы уже использовали инструкцию MOV для перемещения данных из одного пространства хранения в другое. Инструкция MOV принимает два операнда.

Синтаксис инструкции MOV:

>MOV destination, source

Инструкция MOV может иметь одну из следующих пяти форм:


```
MOV  register, register
MOV  register, immediate
MOV  memory, immediate
MOV  register, memory
MOV  memory, register

```

Обратите внимание, оба операнда в операции MOV должны быть одинакового размера, а значение исходного операнда остается неизменным. Порой инструкция MOV может вызывать двусмысленность. Например:


```
MOV  EBX, [MY_TABLE]  ; помещаем эффективный адрес MY_TABLE в EBX
MOV  [EBX], 110       ; MY_TABLE[0] = 110

```
Непонятно, хотите ли вы переместить байтовый или словесный эквивалент числа 110? В таких случаях целесообразно использовать **спецификатор типа**.

В следующей таблице приведены некоторые из общих спецификаторов типа:

| Спецификатор типа  | Байт |
|--------------------|------|
| BYTE               | 1    |
| WORD               | 2    |
| DWORD              | 4    |
| QWORD              | 8    |
| TBYTE              | 10   |
Следующая программа иллюстрирует некоторые из концепций, которые обсуждались выше: в секции данных памяти сохраняется имя `Zara Ali`, затем оно программным образом изменяется на `Nuha Ali`, и выводятся уже оба имени:


```
section .text

   global _start     ; должно быть объявлено для линкера

_start:             ; сообщаем линкеру входную точку

   ; Пишем имя 'Zara Ali'
   mov edx,9       ; длина сообщения
   mov ecx, name   ; сообщение для написания
   mov ebx,1       ; файловый дескриптор (stdout)
   mov eax,4       ; номер системного вызова (sys_write)
   int 0x80        ; вызов ядра

   mov [name],  dword 'Nuha'    ; изменяем имя на 'Nuha Ali'
   ; Пишем имя 'Nuha Ali'
   mov edx,8       ; длина сообщения
   mov ecx,name    ; сообщение для написания
   mov ebx,1       ; файловый дескриптор (stdout)
   mov eax,4       ; номер системного вызова (sys_write)
   int 80h         ; вызов ядра

   mov eax,1       ; номер системного вызова (sys_exit)
   int 80h         ; вызов ядра

section .data

name db 'Zara Ali '

```

Результат выполнения программы:

`Zara Ali Nuha Ali`

Прежде чем проводить операции с данными их нужно переместить в регистр, и так в жтом нам паможет иструкция mov. Пожалуй, инструкция MOV в ассемблере самая простая и требует два оперенда. Синтаксис этой команды такой:

>MOV ПРИЁМНИК, ИСТОЧНИК

C помощью этой команды можно переместить значение из ИСТОЧНИКА в ПРИЁМНИК, источник не изменяется. То есть по сути команда MOV копирует содержимое ИСТОЧНИКА и помещает это содержимое в ПРИЁМНИК. Никакие флаги при этом НЕ изменяются.

ИСТОЧНИКОМ может быть один из следующих:


- Область памяти (MEM)
- Регистр общего назначения (REG)
- Непосредственное значение (например, число) (IMM)
- Сегментный регистр (SREG)

ПРИЁМНИКОМ может быть один из следующих:

- Область памяти (MEM)
- Регистр общего назначения (REG)
- Сегментный регистр (SREG)


При использовании этой команды следует учитывать, что имеются некоторые ограничения. А именно, инструкция MOV не может:


- Записывать данные в регистры CS и IP.
- Копировать данные из одного сегментного регистра в другой сегментный регистр (сначала нужно скопировать данные в регистр общего назначения).
- Копировать непосредственное значение в сегментный регистр (сначала нужно скопировать данные в регистр общего назначения).

Пример использования инструкции MOV:

```
MOV AX, 0B800h	; установить AX = B800h (память VGA).
MOV DS, AX	; копировать значение из AX в DS.
MOV CL, 'A'	; CL = 41h (ASCII-код).
MOV [BX], CX	; [0B800h:015Eh] = CX.
MOV r16, r0	; Копировать r0 в r16
MOV AX, [number]	; заносить значение переменной number в регистр AX
MOV BX, CX	; заносим в регистр BX значение регистра CX
MOV AL, 34	; заносим в регистр AL число 34
  ```

### Примеры Адресации

#### Использование Указателя Стека (SP)

- При выполнении команды `push` (добавление данных в стек), указатель стека (SP) уменьшается на размер добавляемых данных (в архитектурах с растущим вниз стеком) или увеличивается (в архитектурах с растущим вверх стеком).
- При выполнении команды `pop` (извлечение данных из стека), указатель стека (SP) увеличивается или уменьшается.

Например, на архитектуре x86:

- Если `SP` равен `0x1000` и выполняется `push eax` (добавление регистра `eax` в стек), `SP` будет уменьшен на 4 байта и станет `0x0FFC`.
- Данные из регистра `eax` будут записаны по адресу `0x0FFC`.

#### Использование Базового Указателя (BP)

- Базовый указатель (BP) часто используется для организации стека вызовов функций.
- Локальные переменные адресуются относительно BP с отрицательным смещением.
- Параметры функции адресуются относительно BP с положительным смещением.

Например, в функции на архитектуре x86:

- Допустим, базовый указатель (`BP`) установлен на `0x1000`.
- Локальная переменная может быть доступна по адресу `BP - 4` (`0x0FFC`).
- Первый параметр функции может быть доступен по адресу `BP + 4` (`0x1004`).

### Пример Кода на Ассемблере x86

```
; Пример вызова функции и работы с локальными переменными и параметрами

section .text
    global _start

_start:
    ; Вызов функции с двумя параметрами
    push dword 10 ; Параметр 2
    push dword 20 ; Параметр 1
    call func
    add esp, 8   ; Очистка параметров из стека

    ; Завершение программы
    mov eax, 1
    int 0x80

func:
    ; Пролог функции
    push ebp            ; Сохранение старого EBP
    mov ebp, esp        ; Установка нового EBP
    sub esp, 4          ; Резервирование места для локальной переменной

    ; Локальная переменная доступна по адресу [ebp-4]
    ; Параметры доступны по адресам [ebp+8] и [ebp+12]

    ; Эпилог функции
    mov esp, ebp        ; Восстановление старого ESP
    pop ebp             ; Восстановление старого EBP
    ret

```
### Адресация на Разных Архитектурах

- **x86 (32-bit)**: обычно использует указатели `esp` (stack pointer) и `ebp` (base pointer).
- **x86_64 (64-bit)**: использует указатели `rsp` (stack pointer) и `rbp` (base pointer).
- **ARM**: использует указатели `sp` и `fp` (frame pointer), если он не отключен.

### Ключевые Соображения

- **Стек растет вниз**: Во многих архитектурах, таких как x86, стек растет от больших адресов к меньшим. В других архитектурах стек может расти вверх.
- **Учет размера данных**: Обращение к данным в стеке всегда должно учитывать размер данных (байты, слова, двойные слова и т.д.).
- **Безопасность**: Некорректная работа со стеком может привести к ошибкам переполнения стека (stack overflow) или недоступности нужных данных.

Понимание этих принципов критически важно для эффективной работы с данными в стеке, особенно в контексте низкоуровневого программирования и анализа безопасности.

# Сегментная адресация памяти

Сегментация - это деление памяти на сегменты.

Оперативное запоминающее устройство (ОЗУ) состоит из множества упорядоченных ячеек. Каждая ячейка имеет уникальный номер (адрес). Минимальной адресуемой "порцией" памяти является байт - ячейка, содержащая 8-разрядный двоичный код. 16-разрядные процессоры фирмы Intel имеют 20-разрядную адресную шину. Так как при всем желании мы не сможем "запихнуть" 20-разрядное число в
16-разрядный регистр, то для адресации приходится использовать два регистра. Один из них называется базовым или сегментным и хранит номер сегмента памяти. А второй - регистр кода команды IP (Instruction Pointer) - хранит смещение относительно начала данного сегмента. 

Таким образом, сегмент - это начальный адрес блока памяти, размер которого не может превышать 65536 байтов (64К). Смещение - это адрес конкретного байта в пределах данного сегмента (от 0000 до FFFF). Процессор может поддерживать не более 65536 различны сегментов памяти. Обычно их записывают через двоеточие. Например: CS:IP, DS:offset и так далее.
Если вы все еще не поняли можно и по подробнее:

  Почему программа должна обязательно состоять из сегментов? Причина этого кроется в архитектурных особенностях микропроцессоров корпорации Intel, которые нам придется здесь коротко рассмотреть. Важнейшей характеристикой любого микропроцессора (МП) является разрядность его внутренних регистров, а также внешних шин адресов и данных. МП Intel 8086 имеет 16-разрядную внутреннюю архитектуру и такой же разрядности шину данных. Таким образом, максимальное целое число (данное или адрес), с которым может работать микропроцессор, составляет 216–1 = 65535 (64К–1). Однако адресная шина МП 8086 содержит 20 линий, что соответствует адресному пространству 220 = 1 Мбайт. Для того, чтобы с помощью 16-разрядных адресов можно было обращаться в любую точку 20-разрядного адресного пространства, в микропроцессоре предусмотрена сегментная адресация памяти, реализуемая с помощью четырех сегментных регистров.

  Суть сегментной адресации заключается в следующем. Физический 20-разрядный адрес любой ячейки памяти вычисляется процессором путем сложения начального адреса сегмента памяти, в котором располагается эта ячейка, со смещением к ней (в байтах) от начала сегмента, которое иногда называют относительным адресом (рис. 5.1). Сегментный адрес без четырех младших битов, т.е. деленый на 16, хранится в одном из сегментных регистров. При вычислении физического адреса процессор умножает содержимое сегментного регистра на 16 и прибавляет к полученному 20-разрядному адресу относительный адрес. Умножение базового адреса на 16 увеличивает диапазон адресуемых ячеек до величины 64 Кбайт * 16 = 1 Мбайт.


Основная  идея сегментной адресации в том, что адрес состоит из двух частей — сегментной и смещения. Суть сегментной адресаци заключается в следующем. Физический 20-разрядный адрес любой ячейки памяти вычисляется процессором путем сложения начального адреса сегмента памяти, в котором располагается эта ячейка, со смещением к ней (в байтах) от начала сегмента, которое иногда называют
относительным адресом. 

>Segment (сегмент) : Offset (смещение) 

Пример:

>13DF:0100 

Где Segment – адрес сегмента, а Offset – смещение от начала этого сегмента. Но постойте! Два 16-разрядных регистра дают 32 разряда. Как же из этого получается 20 битный адрес? Давайте разбираться где собака порылась. Для определения начала сегментов памяти процессор 8086 использует четыре 16-битных сегментных регистра (CS, DS, SS, ES). Смещение внутри сегмента выбирается из регистров-указателей SP, BP, SI, DI или регистра IP (указателя команд - Instructions Pointer). Для получения 20-битного физического адреса, процессор размещает на адресной шине значение сегментного регистра и сдвигает в влево на четыре бита, заполняя младшие четыре бита адресной шины нулями (умножение на десятичное 16 или шестнадцатеричное 10 ), затем к этому значению прибавляется смещение и адрес сформирован.

Инструкции хранятся в ОЗУ в последовательном порядке. У процессора есть механизм сохранения инструкций в кэш. Как мы выяснили ранее, за секунду процессор может выполнить миллиарды инструкций. Поэтому если бы каждая инструкция хранилась в ОЗУ, то есть изъятие оттуда занимало бы больше времени, чем её обработка. Поэтому для ускорения работы процессор хранит часть инструкций и данных в кэше.




# Инструкция LEA

Команда LEA в Ассемблере вычисляет эффективный адрес второго оперенда и помещает его в первый оперенд. LEA - Load Effective Address (загрузить эффективный адрес). Синтаксис:

```
LEA первый_оперенд, второй оперенд
```


После выполнения этой команды флаги не изменяются.

Первым оперендом может быть только регистр (но не сегментный), а вторым оперендом может быть только переменная (ячейка памяти),

**Понятие адресов**

эффективный (текущий) адрес – это:

БАЗА + СМЕЩЕНИЕ + ИНДЕКС

Базовый адрес является адрес выступающим качестве опорной точки ( «базовой») для других адресов. Доступ к связанным адрес можно получить с помощью схемы адресации. В схеме относительной адресации для получения абсолютного адреса берется соответствующий базовый адрес и к нему добавляется смещение (также известное как смещение). Другими словами, Адрес, которы служит точкой отсчета для других адресов. Например, базовый адрес может указывать на начало программы . Затем адрес каждой инструкции в программе можно было бы указать, добавив смещение к базовому адресу. Например, адрес пятой инструкции будет базовым адресом плюс 5.

![[Pasted image 20221010052453.png]]

В компьютерной инженерии и низкоуровневом программировании (например, языке ассемблера) смещение обычно обозначает количество адресов, которые нужно добавить к базовому адресу, чтобы получить конкретный абсолютный адрес. В этом значении для указания размера смещения используется только базовый адресный блок, обычно 8-битный байт. В этом контексте смещение иногд называют «относительным адресом».То есть:

- Адрес - идентификатор ячейки памяти.

- Базовы адрес - Адрес в роли начальной точкой для вычисления других адресов.

- Смещения - Это количество адресов котовый добавляется к базовому адресу для вычисления конкретной ячейки памяти.

Где БАЗА - это базовый адрес, находящийся в регистре (при 16-разрядной адресации могут использоваться только регистры BX или BP); СМЕЩЕНИЕ (или ОТКЛОНЕНИЕ - displacement) - это константа (число со знаком), заданная в команде; ИНДЕКС - значение индексного регистра (при 16-разрядной адресации могут использоваться только регистры SI или DI).  

Любая из частей эффективного адреса может отсутствовать (например, необязательно указывать СМЕЩЕНИЕ или ИНДЕКС), но обязательно должна присутствовать хотя бы одна часть (например, только БАЗА).

Простыми словами, то это инструкция вычисляет адрес область памяти ( переменной ) и помещает его в какой небудь регистр общего назначания. Ну а теперь чуть подробнее о самой команде LEA. Как уже было сказано, она выполняет вычисление адреса в Ассемблере. В итоге в ПРИЁМНИК записывается адрес памяти (точнее, только смещение).

Команда lea только вычиляет адрес, не обращаясь к памяти. С помощью команды LEA можно вычислить адрес переменной, которая описана сложным способом адресации (например, по базе с индексированием, что часто используется при работе с массивами и строками).  

Оператор OFFSET позволяет определить смещение только при компиляции, и в отличие от него команда LEA может сделать это во время выполнения программы. Хотя в остальных случаях обычно вместо LEA используют MOV и OFFSET, то есть:  

**LEA ПРИЁМНИК, ИСТОЧНИК**  - это то же самое, что и  - **MOV ПРИЁМНИК, offset ИСТОЧНИК**

Если ebx = 0x000003:

```
lea eax, [ebx+3] ;eax = 0x000006
lea eax, message ; Загружаем адрес переменной message в регистр eax

```
  

### Команда LEA в арифметических операциях

Инструкция LEA часто используется для арифметических операций, таких как умножение и сложение. Преимущество такого способа в том, что команда LEA занимает меньше места, чем команды арифметических операций. Кроме того, в отличие от последних, она не изменяет флаги.Инструкция LEA даёт нам 2 возможности которые не может дать команда add -возможность выполнять сложение с двумя или тремя операндами, и возможность хранить результать в любом оперенде. Примеры:  

```
;Умножение с помощью LEA  

MOV BX, 8
LEA BX, [BX + BX * 4] ;Сложение с помощью LEA, не поддерживается emu8086,
MOV BX, 8
LEA BX,[BX+16] ;BX=BX+16=8+16
LEA EAX, [1000+EBX+8*ECX] ;Возьмём значения регистра ecx, умножаем его на 8, прибавить к этому

  ; значение регистра ebx,и число 1000, а полученный результат занесёт в регистр eax.

```

Простыми словами, то это инструкция вычисляет адрес область памяти ( переменной ) и помещает его в какой небудь регистр общего назначания. Ну а теперь чуть подробнее о самой команде LEA. Как уже было сказано, она выполняет вычисление адреса в Ассемблере. В итоге в ПРИЁМНИК записывается адрес памяти (точнее, только смещение). Команда lea только вычиляет адрес, не обращаясь к памяти.


# Относительный, эффективный  и фактический адрес памяти

Разница между относительным смещением и фактическим адресом памяти в контексте ассемблерного программирования и работы с отладчиком заключается в способе адресации и интерпретации памяти. Давайте подробно разберёмся, что означает каждое из этих понятий и в чём их отличие.

### Определения

1. **Фактический адрес памяти (Physical or Absolute Memory Address)**:
    
    - Это конкретное местоположение в оперативной памяти, на которое указывает указатель или регистр.
    - Адрес представлен в виде числа, обычно в шестнадцатеричном формате, и является абсолютным указанием на конкретное место в памяти.
    - Например, адрес `0xbffff2e0` указывает на определённую ячейку памяти.

1. **Относительное смещение (Relative Offset)**:
    
    - Это значение, которое указывает на местоположение в памяти относительно какого-то базового адреса (например, значения указателя стека или регистра).
    - Используется для доступа к данным в структуре данных или в стеке функций, где точное местоположение относительно изменяющегося базового адреса имеет значение.
    - Например, `+8` от указателя `ebp` (базовый указатель кадра стека) указывает на местоположение памяти относительно `ebp`.


### Примеры из контекста

#### Фактический адрес 

Фактический адрес — это абсолютное местоположение в памяти. В контексте вашего примера из `gdb`:

```
(gdb) x $ebp+8 
0xbffff2e0:    0xdeadbeef
```

Здесь `0xbffff2e0` — это фактический адрес в памяти, на который указывает вычисление `$ebp + 8`.

#### Эффективный адрес

**Эффективный адрес** — это конкретный адрес в памяти, который используется для доступа к данным. В контексте машинного кода или ассемблерных программ, эффективный адрес представляет собой окончательный адрес, по которому будет производиться операция загрузки или записи данных. Эффективный адрес может быть рассчитан на основе различных компонентов, таких как регистры, смещения и базовые адреса. То есть, это адрес, который используется для определения местоположения данных в памяти во время выполнения команды. Он может быть результатом сложения базового адреса, смещения и значений регистров. Эффективный адрес указывает на место в виртуальной памяти, и его вычисление происходит во время выполнения программы.

**Примеры использования эффективного адреса**

1. **Прямая адресация**:
    
    - Команда `MOV AX, [1234h]` указывает, что данные будут считаны из адреса 0x1234 в памяти.
    - `MOV AX, [1234h] ; Чтение данных из адреса 0x1234`.
2. **Косвенная адресация**:
    
    - Команда `MOV AX, [BX]` использует содержимое регистра BX в качестве адреса для доступа к памяти.
    - `MOV AX, [BX] ; Чтение данных по адресу, хранящемуся в регистре BX`
3. **Комбинированная адресация**:
    
    - Команда `MOV AX, [BX + SI + 10h]` вычисляет адрес как сумму значений регистров BX и SI с добавлением смещения 0x10.
    - `MOV AX, [BX + SI + 10h] ; Адрес вычисляется как сумма значений регистров BX, SI и смещения 0x10`

Если BX = 0x1000 и SI = 0x0020, то эффективный адрес будет 0x1030. 

Эффективный адрес — это фактическое место в памяти, которое используется для доступа к данным при выполнении команды.


#### Относительное смещение

**Относительный адрес** — это адрес, выраженный как смещение относительно другого адреса. Обычно он используется для определения адресов в инструкциях, связанных с переходами или вызовами функций, где целевой адрес вычисляется на основе текущего адреса исполнения или начальной точки.

**Примеры использования относительного адреса**

1. **Переходы (Jumps)**:
    
    - Команда `JMP SHORT LABEL` перемещает выполнение на адрес, указанный как смещение от текущей позиции инструкции. Это смещение называется относительным адресом.
2. **Вызовы функций (Calls)**:
    
    - Команда `CALL OFFSET` вызывает функцию, используя смещение от текущего положения инструкций.
3. **Обратные переходы**:
    
    - Команда `JMP -10` указывает на переход на 10 байт назад от текущего адреса выполнения.

Относительный адрес используется для определения нового адреса относительно текущей позиции, что удобно для выполнения переходов в пределах небольшого диапазона адресов.

1. **Относительное смещение** используется для доступа к данным относительно какого-либо базового адреса. Например, смещение `+8` от указателя `ebp`:

    - `$ebp` указывает на определённое место в стеке функции.
    
	- `$ebp + 8` указывает на местоположение, которое находится на 8 байт дальше в памяти относительно значения `ebp`. Это смещение используется, чтобы получить доступ к первому параметру функции, если рассматривать стандартное соглашение вызова `cdecl` на архитектуре x86.

2. **Относительный адрес** — это адрес, выраженный как смещение относительно другого адреса. Обычно он используется для   определения адресов в инструкциях, связанных с переходами или вызовами функций, где целевой адрес вычисляется на основе текущего адреса исполнения или начальной точки.

Использование относительных адресов вместо абсолютных адресов имеет ряд преимуществ:

* **Переносимость:** Относительные адреса не привязаны к конкретному физическому адресу в памяти. Это позволяет программе легко переноситься на разные платформы и среды исполнения без необходимости перекомпилирования. Относительные адреса позволяют программам легко переноситься на разные платформы и среды исполнения без необходимости перекомпилирования.

* **Модульность:** Относительные адреса облегчают разделение больших программ на более мелкие модули. Каждый модуль может содержать свои собственные относительные адреса, что позволяет им работать независимо друг от друга. Это упрощает разработку и обслуживание кода.

* **Повторное использование кода:** Относительные адреса позволяют повторно использовать код в разных местах программы. Код можно перемещать или копировать, а относительные адреса будут автоматически скорректированы, чтобы соответствовать новому расположению.Относительные адреса позволяют повторно использовать код в разных местах программы. Код можно перемещать или копировать, а относительные адреса будут автоматически скорректированы, чтобы соответствовать новому расположению.

* **Динамическое выделение памяти:** Относительные адреса хорошо подходят для динамического выделения памяти, когда адрес объекта в памяти неизвестен во время компиляции. Это позволяет программам гибко управлять памятью во время выполнения.  Относительные адреса хорошо подходят для динамического выделения памяти, когда адрес объекта в памяти неизвестен во время компиляции. Это позволяет программам гибко управлять памятью во время выполнения.

* **Эффективность:** Относительные адреса могут быть более эффективными, поскольку им требуется меньше битов для хранения, что приводит к более компактному коду. Относительные адреса могут быть более эффективными, поскольку им требуется меньше битов для хранения, что приводит к более компактному коду.

Кроме того, использование относительных адресов в ассемблере имеет некоторые дополнительные преимущества:

* **Сниженная сложность кода:** Относительные адреса могут упростить код ассемблера, поскольку программисту не нужно заботиться об абсолютных адресах в памяти.

* **Улучшенная читаемость:** Использование относительных адресов может сделать код ассемблера более читаемым и понятным.

В целом, использование относительных адресов в ассемблере делает код более переносимым, модульным, легко повторно используемым и эффективным. Это также упрощает написание и обслуживание кода ассемблера.

В целом, использование относительных адресов делает код более переносимым, модульным, легко повторно используемым и эффективным.
### Различия

- **Смысл и применение**:
    
    - **Эффективный адрес**: Указывает на конкретное место в памяти для доступа к данным.
    - **Относительный адрес**: Указывает на смещение относительно текущего адреса инструкции или другого базового адреса.
- **Использование**:
    
    - **Эффективный адрес**: Применяется для доступа к операндам в командах загрузки, хранения и арифметических операций.
    - **Относительный адрес**: Применяется в инструкциях перехода и вызова, где нужно перемещаться по коду относительно текущей позиции.
- **Вычисление**:
    
    - **Эффективный адрес**: Может включать базовые адреса, регистры и смещения, чтобы указать точный адрес в памяти.
    - **Относительный адрес**: Выражается как смещение и обычно используется для изменения текущей позиции выполнения.

1. **Природа адресации**:
    
    - **Фактический адрес**: Абсолютный и независимый от других адресов. Это конкретное местоположение в памяти, которое не зависит от текущего состояния стека или регистров.
    - **Относительное смещение**: Зависит от базового адреса и изменяется в зависимости от него. Оно указывает на местоположение относительно другого адреса, например, относительно указателя стека `ebp`.
2. **Использование в коде**:
    
    - **Фактический адрес**: Используется для указания конкретных местоположений в памяти, к которым нужно обращаться независимо от текущего контекста.
    - **Относительное смещение**: Используется для удобного доступа к локальным переменным, параметрам функций и другим данным, которые располагаются в памяти относительно других данных.
3. **Гибкость**:
    
    - **Фактический адрес**: Меньше гибкости, так как указывает на фиксированное место в памяти.
    - **Относительное смещение**: Более гибкий, так как позволяет обращаться к данным независимо от того, где находится базовый адрес в памяти.

Эффективный адрес и относительный адрес представляют собой два разных способа определения местоположения данных или инструкций в памяти. Эффективный адрес непосредственно указывает на конкретный адрес в памяти, тогда как относительный адрес указывает на смещение относительно текущего адреса выполнения. Эти концепции являются фундаментальными в программировании на ассемблере и играют ключевую роль в управлении памятью и управлении потоком выполнения программ. **Эффективный адрес** — это адрес, используемый в программах для вычисления местоположения данных, а **фактический адрес** — это конкретный адрес в физической памяти, получаемый после преобразования виртуального адреса. Эффективный адрес может включать вычисления и смещения, тогда как фактический адрес — это конечный адрес, к которому обращается оборудование для доступа к памяти.

### Применение в отладке

В отладке часто используют относительные смещения, чтобы понять, как параметры функции или локальные переменные располагаются в стеке:

- **Фактический адрес** предоставляет прямую информацию о расположении данных в памяти, что полезно для анализа текущего состояния программы.
- **Относительное смещение** позволяет отслеживать, как данные связаны с текущим контекстом выполнения функции, помогая анализировать, например, параметры, передаваемые в функции.

### Примеры использования

#### Доступ к параметрам функции

```

mov eax, [ebp+8] ; доступ к первому параметру функции
mov ebx, [ebp+12] ; доступ ко второму параметру функции
```

Здесь `+8` и `+12` — это относительные смещения от базового указателя стека `ebp`.
#### Просмотр содержимого памяти

```
(gdb) x $ebp-0x2c 0xffffcd7c: "AAAAAAAAAAAAA"
```

Здесь `$ebp-0x2c` используется для вычисления адреса относительно `ebp`. `0xffffcd7c` — фактический адрес, по которому находится содержимое.

### Заключение

**Фактический адрес** — это конкретное местоположение в памяти, в то время как **относительное смещение** указывает на местоположение относительно другого базового адреса. Они используются для различных целей и предоставляют разные возможности при программировании и отладке.