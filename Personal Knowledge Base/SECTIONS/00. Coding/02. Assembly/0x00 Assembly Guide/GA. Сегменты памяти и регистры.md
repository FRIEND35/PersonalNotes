Мы уже рассматривали на предыдущем уроке [**3 секции**](https://ravesli.com/assembler-bazovyj-sintaksis/), из которых состоят программы на ассемблере. Эти секции также представляют различные сегменты памяти. Что интересно, если вы замените ключевое слово `section` на `segment`, то получите тот же результат. Например:



```
segment .text    ; сегмент кода

   global _start    ; должно быть объявлено для линкера

_start:            ; сообщаем линкеру точку входа

   mov edx,len  ; длина сообщения
   mov ecx,msg  ; сообщение для вывода на экран
   mov ebx,1    ; файловый дескриптор (stdout)
   mov eax,4    ; номер системного вызова (sys_write)
   int 0x80     ; вызов ядра

   mov eax,1       ; номер системного вызова (sys_exit)
   int 0x80        ; вызов ядра

segment .data      ; сегмент данных

msg db 'Hello, world!',0xa   ; наша строка
len equ $ - msg              ; длина нашей строки
```

Результат выполнения программы:

`Hello, world!`


# Сегменты памяти

Сегмент (от лат. segmentum — отрезок, полоса, от seco — режу, рассекаю) — часть чего-либо.

Модель сегментированной памяти разбивает системную память на группы независимых сегментов, на которые указывают указатели, расположенные в регистрах сегментов. Каждый сегмент используется для хранения данных определенного типа. Первый сегмент используется для хранения кода инструкций, второй — для хранения элементов данных, а третий — для программного [[ZE. Стек и куча | стека]]. Другими словами, Cегменты - это определенные области, определенные в программе для хранения данных, кода и [[ZE. Стек и куча | стека]].

-  Секции - это непрерывная диапазон адресов.
-  Сегмент - это разные части программы.


Cегменты — это специфические части программы, которые содержат данные, код и стек. Есть три основных сегмента:


**Сегменты памяти:**

   - **Сегмент данных (****data** **segment****)** — представлен секциями _.data_ и _.bss_. Секция _.data_ используется для объявления области памяти, где хранятся элементы данных для программы. Эта секция не может быть расширена после объявления элементов данных, и она остается статической во всей программе. Секция _.bss_ также является секцией статической памяти, содержащей буферы для данных, которые будут объявлены в программе позже. Эта буферная память заполнена нулями.

   - **Сегмент кода (****code** **segment****)** — представлен секцией _.text_. Он определяет область в памяти, в которой хранятся коды инструкций. Это также фиксированная область. Другими словами, он содержит все инструкции, которые необходимо выполнить. В 16-битном регистре сегмента кода или регистре CS хранится начальный адрес сегмента кода.

   - **Стек (****stack****)** — это сегмент, который содержит значения данных, передаваемые в функции и процедуры в программе. Другими словами,  он содержит данные и адреса возврата процедур или подпрограмм. Он реализован в виде «стековой» структуры данных. Регистр сегмента [[ZE. Стек и куча | стека]] или регистр SS хранит начальный адрес [[ZE. Стек и куча | стека]].

  
Давайте у нас будет простой код:


```
segment .text ; сегмент кода
  global_start  ; должно быть объявлено для линкера

_start:     ; сообщаем линкеру точку входа

  mov edx,len ; длина сообщения
  mov ecx,msg ; сообщение для вывода на экран
  mov ebx,1 ; файловый дескриптор (stdout)
  mov eax,4 ; номер системного вызова (sys_write)
  int 0x80  ; вызов ядра
 
  mov eax,1  ; номер системного вызова (sys_exit)
  int 0x80   ; вызов ядра

segment .data  ; сегмент данных
  msg db 'Hello, world!',0xa ; наша строка
  len equ $ - msg  ; длина нашей строки

```

Этот простой код выводить на экран строку Hello World!. Но давайте разберёмся. И так видим что наша программа имеет несколько сегментов, это разные части нашей программы, в RAM наша программа будет лежать по частям ( Сенмемнтам ), а адреса сегмента находятся в сегментных регистрах. 

И так процессор вычисляет адрес ячеки памяти где находится наша переменная и выводить его. Мы видим что наша строка находится в сегменте данных, процессор просто из RAM вычисляет адрес из сегмента данных со смещением (CS:offset). Все работает примерно так, но на самом деле всё намного сложнее, ведь есть еще и кэш память. Сначало строчка находится в RAM, потом попадает в кэш, а после процессоре выводить его выполняя инструкции, которые тоже берёт с RAM.   

![[Pasted image 20221010044338.png]]

### Конечный итог

Все части нашей программы разбиты на части (сегменты), и каждый сегмент со свои содержанимеи находятся в разных частях оперативной памяти. Например: инструкции нашей программы будут в одной мести RAM, а в регистре сегмент кода (CS) будет содержать адрес той ячейки памяти, которой в RAM наченаетя инструкции нашей программы, когда мы хотим выполнить коды ( инструкции ), то мы их извлекаем с RAM ( начало инструкции: cs:0000) тот участок памяти где находятся нужные нам инструкции в кэш процессора, а после выполняются процессором. Также и с нашими данными ( переменными если говорить по более понятным языком ). Они находятся в другом месте оперативной памяти, и когда нужно выполнять операции над ними процессор может их найти с RAM по адресу DS:offset. DS говорить что мы обращаемся к области памяти где находяться данные ( переменные ), а offset - это смещение определённой переменной. Внимательно присмотритесь к изображением которые приведены выше или ниже.

![[Pasted image 20221010044420.png]]


# Регистры

Регистром называют электронное устройство в составе центрального процессора, способное содержать в себе определённое количество данных в виде двоичных разрядов. В большинстве случаев (но не всегда) содержимое регистра трактуется как целое число, записанное в двоичной системе счисления. Регистры процессора i386 можно условно разделить на регистры общего назначения, сегментиные регистры и специальные регистры. Каждый регистр имеет своё название, состоящее из двух-трёх латинских букв. 


## Регистры процессора

В архитектуре IA-32 есть десять 32-битных и шесть 16-битных процессорных регистров. **Регистры делятся на три категории**:

   - Общие регистры (General Registers);

   - Регистры управления (Control Registers);

   - Сегментные регистры (Segment Registers).

В свою очередь, **общие регистры** делятся на следующие:

   - Регистры данных (Data Registers);

   - Регистры-указатели (Pointer Registers);

   - Индексные регистры (Index Registers).



## Регистры данных

**Регистры данных** — это четыре 32-битных регистра, которые используются для арифметических, логических и других операций. Эти 32-битные регистры могут быть использованы следующими тремя способами:

   как полные 32-битные регистры данных: EAX, EBX, ECX, EDX;

   нижние половины 32-битных регистров могут использоваться как четыре 16-битных регистра данных: AX, BX, CX и DX;

   нижняя и верхняя половины вышеупомянутых четырех 16-битных регистров могут использоваться как восемь 8-битных регистров данных: AH, AL, BH, BL, CH, CL, DH и DL.


![[Pasted image 20220928101420.png]]


Некоторые из этих регистров данных имеют специфическое применение в арифметических операциях:

   - **AX** **(primary accumulator)** — используется для ввода/вывода и в большинстве арифметических операций. Например, в операции умножения один операнд сохраняется в регистре EAX/AX/AL в соответствии с размером операнда.

   - **BX** **(base register)** — используется при индексированной адресации.

   - **CX (****count register)** — хранит количество циклов в повторяющихся операциях (также, как и регистры ECX и CX).

   - **DX (data register)** — используется в операциях ввода/вывода, а также с регистрами AX и DX для выполнения операций умножения и деления, связанных с большими значениями.

Сегментные регистры (СS, DS, SS, ES, GS и FS) в «плоской» модели памяти не используются. Точнее говоря, перед передачей управления пользовательской задаче операционная система заносит в эти регистры некоторые значения, которые задача теоретически может изменить, но ничего хорошего из этого всё равно не выйдет — скорее всего, произойдёт аварийное завершение. Таким образом, мы принимаем во внимание существование этих регистров, но более к ним возвращаться не будем.



Регстры общего назначения процессора 1386 — это 32-битные регистры ЕАХ, ЕВХ, ЕСХ, ЕDХ, ESI, ЕDI, ЕВР и ЕSР. Буква Е в названии этих регистров означает слово «ех{епаеа», подчёркивая тот факт, что в их современном виде эти регистры появились только в процессоре 1386. Для совместимости с предыдущими процессорами семейства х86 каждый 32-битный регистр имеет обособленную младшую половину (младшие 16 бит), имеющую отдельное название, получаемое отбрасыванием буквы Е, то есть, иначе говоря, мы можем работать также с 16-битными регистрами АХ, ВХ,СХ, DХ, SI, DI, ВР и SР, которые представляют собой младшие половины соответствующих 32 битных регистров.

Кроме того, регистры АХ, ВХ, СХ и DХ также делятся на младшие и старшие части, теперь уже восьмибитные. Так, для регистра АХ его младитий байт имеет также название АL, а старитий байт — АН (от слов «Low» и «High»). Аналогично мы можем работать с регистрами ВL, ВН, СL., СН, DL, и DН, которые представляют собой младшие и старшие байты регистров ВХ, СХ и DХ. Остальные регистры общего
назначения таких обособленных однобайтовых подрегистров не имеют.

Каждый из регистров общего назначения, несмотря на такое название, в некоторых случаях играет специфическую, только ему присущую роль, частично  закодированную в имени регистра. Так, в имени регистра АХ буква А обозначает слово «accumulator»; на многих архитектурах, включая знаменитый IAS Джонафон Неймана, аккумулятором называли регистр, участвующий (по определению) во всех арифметических операциях, во-первых, в качестве одного из операндов, и, во вторых, в качестве места, куда следует поместить результат. Связанная с этим особая роль регистров АХ и ЕАХ проявляется в командах целочисленного умножения и деления. 

DX известен как регистр данных . Он также используется в операциях ввода / вывода. Он также используется с регистром AX вместе с DX для операций умножения и деления с большими значениями.

Обычно операции с процессором включают в себя обработку данных. Эти данные могут быть как сохранены в памяти, так и извлечены оттуда. Однако процесс чтения данных из памяти и хранения данных в памяти замедляет работу процессора, так как это предполагает сложный процесс отправки запроса данных в блок памяти и получение данных обратно из блока по одному и тому же каналу — через шину управления.

Чтобы ускорить свою работу, процессор подключает определенные внутренние места хранения памяти, которые называются регистрами. **Регистры** хранят элементы данных для обработки без необходимости получать доступ к памяти. Ограниченное количество регистров встроено в чип процессора.



## Пользовательские регистры 

Пользовательскими регистры (или же их еще называют регистром общего назначения) называются потому, что программист может их использовать при разработке программ. К пользовательским регистрам относятся:

 1) Восемь 32-битных регистров, которые могут использоваться программистами для хранения данных и адресов (регистры общего назначения): 

    EAX/AX/AH/AL (accumulator register) – аккумулятор; 
    EBX/BX/BH/BL (base register) –регистр базы; 
    ECX/CX/CH/CL (counter register) – счётчик; 
    EDX/DX/DH/DL (data register) – регистр данных;
    ESI/SI (source index register) – индекс источника;
    EDI/DI (destination index register) – индекс приёмника (получателя);
    ESP/SP (stack pointer register) – регистр указателя [[ZE. Стек и куча | стека]];
    EBP/BP (base pointer register) – регистр указателя базы кадра стека.

 2) Шесть регистров сегментов: 
     
     - CS
     - DS
     - SS
     - ES
     - FS
     - GS

 3) Регистр состояния (регистр флагов) eflags/flags;

 4) Регистр управления (регистр указателя команды) eip/ip.


Давайте разберём EAX – Это 32-битный регистр общего назначения. 16-бит регистра eax называется ax, 8-бит регистра ax называется ah и al. И так и с другими регистрами. 

В итоге у нас:

   Регистры EAX, EBX, ECX, EDX – это регистры общего назначения. Они имеют определённое назначение (так уж сложилось исторически), однако в них можно хранить любую информацию.

   Регистры EBP, ESP, ESI, EDI – это также регистры общего назначения. Они имеют уже более конкретное назначение. В них также можно хранить пользовательские данные, но делать это нужно уже более осторожно, чтобы не получить «неожиданный» результат. Регистры RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, Rx, RxD, RxW, RxB, SPL, BPL, SIL, DIL доступны только в 64-битном режиме работы процессора.


![[Pasted image 20220819085646.png]]





В имени регистра ВХ буква В обозначает слово «Базе», но никакой особой роли в 32-битных процессорах этому регистру не отведено (хотя в 16-битных процессорах такая роль существовала). В имени СХ буква С обозначает слово «counterг» (счётчик). Регистры ЕСХ, СХ, а в некоторых случаях даже CL, используются во многих машинных командах, предполагающих (в том или ином смысле) определённое количество итераций. Имя регистра DХ символизирует слово «data» (данные). В особой роли регистр ЕBХ (или ОХ, если выполняется шестнадцатиразрядная операция) выступает при выполнении операций целочисленного умножения (для хранения части результата, не поместившейся в аккумулятор) и целочисленного деления (для хранения старшей части делимого, а после выполнения операции — для хранения остатка от деления).

Cегментные регистры хранят начальные адреса сегмента. Чтобы получить точное местоположение данных или команды в сегменте, требуется значение смещения. Чтобы сослаться на любую ячейку памяти в сегменте, процессор объединяет адрес сегмента в сегментном регистре со значением смещения местоположения.
Некоторые из этих регистров данных имеют специфическое применение в арифметических операциях:

   AX (primary accumulator) — используется для ввода/вывода и в большинстве 
   арифметических операций. Например, в операции умножения один операнд 
   сохраняется в регистре EAX/AX/ALв соответствии с размером операнда.

   BX (base register) — используется при индексированной адресации.

   CX (count register) — хранит количество циклов в повторяющихся операциях (также, как и регистры ECX и CX).
   
   DX (data register) — используется в операциях ввода/вывода, а также с регистрами AX и DX для выполнения операций умножения и деления, связанных с большими значениями.


Несмотря на существующую специализацию, все регистры можно использовать в любых машинных операциях. Однако надо учитывать тот факт, что некоторые команды работают только с определёнными регистрами. Например, команды умножения и деления используют регистры EAX и EDX для хранения исходных данных и результата операции. Команды управления циклом используют регистр ECX в качестве счётчика цикла. То есть пусть и регистры EAX, EBX, ECX, EDX... И другие – регисры общего назначения пусть и называют регистрами общего назначени и в них можно хранить какие та там пользовательские промежудочнык данные, результат какой-то там оперции, но не надо забывать что у них есть определённые задачи, которые предназначена только для них и работают только с ними.

Ещё один нюанс состоит в использовании регистров в качестве базы, т.е. хранилища адреса оперативной памяти. В качестве регистров базы можно использовать любые регистры, но желательно использовать регистры EBX, ESI, EDI или EBP. В этом случае размер машинной команды обычно бывает меньше.


![[Pasted image 20220819085629.png]]





## Регистры-указатели

Регистрами-указателями являются 32-битные регистры EIP, ESP и EBP и соответствующие им 16-битные регистры IP, SP и BP. Есть три категории регистров-указателей:

   IP — 16-битный (младшая часть EIP)
   EIP — 32-битный аналог (младшая часть RIP)
   RIP — 64-битный аналог

Указатель на инструкцию или команду (Instruction Pointer или IP) — 16-битный регистр IP хранит смещение адреса следующей команды, которая должна быть выполнена. IP в сочетании с регистром CS (как CS:IP) предоставляет полный адрес текущей инструкции в сегменте кода. IP (англ. Instruction Pointer) — регистр, указывающий на смещение (адрес) инструкций в сегменте кода (1234:0100h сегмент/смещение).

Указатель на стек (Stack Pointer или SP) — 16-битный регистр SP обеспечивает значение смещения в программном стеке. SP в сочетании с регистром SS (SS:SP) означает текущее положение данных или адреса в программном стеке.

Базовый указатель (Base Pointer или BP) — 16-битный регистр BP используется в основном при передаче параметров в подпрограммы. Адрес в регистре SS объединяется со смещением в BP, чтобы получить местоположение параметра. BP также можно комбинировать с DI и SI в качестве базового регистра для специальной адресации.

![[Pasted image 20220820043846.png]]


Регистр (E)IP (Instruction Pointer) - Указывает на адрес следующей команды, когда текушая команда выполняется, этот регистр загружает в память адрес следующей команды ( увеличивается на единицу ) и будет указывать на адрес следуйющий иструкции.

Программе при запуске операционной системой выделяется участок адресов физической памяти. Внутри программа оперирует адресами вида 4020D8, но реальный физический адрес переменной будет [ds]+4020D8, ds это тоже регистр, в котором записан адрес "начала" сегмента данных, того самого диапазона адресов, выделенного программе. Ну это если по-простому.



## Индексные регистры

В процессоре существуют 32-битные индексные регистры ESI и EDI и их 16-битные версии: SI и DI. Все они используются в индексированной адресации, и, иногда, в операциях сложения/вычитания. Есть два типа индексных указателей:

   - **Исходный индекс (Source Index или SI)** — используется в качестве исходного индекса в строковых операциях.

   - **Индекс назначения (Destination Index или DI)** — используется в качестве индекса назначения в строковых операциях.

Индекс — элемент перечислимого множества, который указывает на конкретный элемент массива. Обычно является неотрицательным целым числом. В некоторых языках отрицательные индексы используются для отсчёта элементов в обратную сторону (начиная с конца массива).

![[Pasted image 20220820044318.png]]

Например – ESI хранить адрес (област памяти которую нужно скопировать), а EDI хранить адрес (обраст памяти куда нужно скопировать). 


## Регистры управления

Регистром управления является объединенный 32-битный регистр инструкций и 32-битный регистр флагов (регистр процессора, отражающий его текущее состояние). Многие инструкции включают в себя операции сравнения и математические вычисления, которые способны изменить состояния флагов, а некоторые другие условные инструкции проверяют значения флагов состояния, чтобы перенести поток управления в другое место.

Регистр флагов – это очень важный регистр процессора, который используется при выполнении большинства команд. Регистр флагов носит название EFLAGS. Это 32-разрядный регистр. Однако старшие 16 разрядов используются при работе в защищённом режиме, и пока мы их рассматривать не будем. К младшим 16 разрядам этого регистра можно обращаться как к отдельному регистру с именем FLAGS. Именно этот регистр мы и рассмотрим в этом разделе.

Каждый бит в регистре FLAGS является флагом. Флаг – это один или несколько битов памяти, которые могут принимать двоичные значения (или комбинации значений) и характеризуют состояние какого-либо объекта. Обычно флаг может принимать одно из двух логических значений. Поскольку в нашем случае речь идёт о бите, то каждый флаг в регистре может принимать либо значение 0, либо значение 1. Флаги устанавливаются в 1 при определённых условиях, или установка флага в 1 изменяет поведение процессора.

Простыми словами, флаги могут изменить ход программы. Когда делается какой нибудь переход или арифметическая операция, код сначало проверяет состояние флага.

Распространенные битовые флаги:

   - **Флаг переполнения (****Overflow** **Flag** **или** **OF****)** — указывает на переполнение старшего бита данных (крайнего левого бита) после [**signed**](https://ravesli.com/urok-31-tselochislennyj-tip-dannyh-integer/#toc-2) арифметической операции. Устанавливается в 1, если результат предыдущей арифметической операции над числами со знаком выходит за допустимые для них пределы. Например, если при сложении двух положительных чисел получается число со старшим битом, равным единице, то есть отрицательное. И наоборот.Этот флаг показывает наличие переполнения в знаковой целочисленной арифметике.
   
   - **Флаг направления (****Direction** **Flag** **или DF)** — определяет направление влево или вправо для перемещения или сравнения строковых данных. Если `DF = 0`, то строковая операция идет слева направо, а когда `DF = 1` — строковая операция идет справа налево. То есть Контролирует поведение команд обработки строк. Если установлен в 1, то строки обрабатываются в сторону уменьшения адресов, если сброшен в 0, то наоборот.

   - **Флаг прерывания (****Interrupt** **Flag** **или** **IF****)** — определяет, будут ли игнорироваться или обрабатываться внешние прерывания (например, ввод с клавиатуры и т.д.). Он отключает внешнее прерывание, когда значение равно `0`, и разрешает прерывание, когда установлено значение `1`. То есть Если сбросить этот флаг в 0, то процессор перестанет обрабатывать прерывания от внешних устройств. Обычно его сбрасывают на короткое время для выполнения критических участков программы.

   - **Флаг ловушка (Trap Flag или TF)** — позволяет настроить работу процессора в одношаговом режиме. Он был предусмотрен для работы отладчиков в пошаговом выполнении, которые не используют защищённый режим. Если этот флаг установить в 1, то после выполнения каждой программной команды управление временно передаётся отладчику (вызывается прерывание 1).

   - **Флаг знака (****Sign** **Flag** **или SF)** — показывает знак результата арифметической операции. Этот флаг устанавливается в соответствии со знаком элемента данных после выполнения арифметической операции. Знак определяется по старшему левому биту. Положительный результат сбрасывает значение SF в `0`, а отрицательный результат устанавливает его равным `1`.  Этот флаг всегда равен старшему биту результата.

   - **Нулевой флаг (****Zero** **Flag** **или ZF)** — указывает результат арифметической операции или операции сравнения. Ненулевой результат сбрасывает нулевой флаг в `0`, а нулевой результат устанавливает его равным `1`. То есть Флаг нуля Устанавливается 1, если результат предыдущей команды равен 0 в противном случае этот флаг сбрасывается.

   - **Вспомогательный флаг переноса (Auxiliary Carry Flag или AF)** — после выполнения арифметической операции содержит перенос от бита 3 до бита 4. Используется для специализированной арифметики. AF устанавливается, когда 1-байтовая арифметическая операция вызывает перенос из бита 3 в бит 4. 

   - **Флаг равенства (****Parity** **Flag** **или PF)** — указывает общее количество 1-битов в результате, полученном после выполнения арифметической операции. Чётное число 1-битов сбрасывает PF в `0`, а нечётное число 1-битов устанавливает PF равным `1`. То есть Устанавливается в 1, если младший байт результата предыдущей команды содержит чётное количество битов, равных 1. Если количество единиц в младшем байте нечётное, то этот флаг равен 0.

   - **Флаг переноса (****Carry** **Flag** **или CF)** — после выполнения арифметической операции содержит перенос `0` или `1` из старшего бита (крайнего слева). Кроме того, хранит содержимое последнего бита операции сдвига или поворота. Флаг переноса. Устанавливается в 1, если результат предыдущей операции не уместился в приёмнике и произошёл перенос из старшего бита или если требуется заём (при вычитании). Иначе установлен в 0. Например, этот флаг будет установлен при переполнении. Переполнение – это когда результат какой-либо операции не помещается в предназначенный для этого результата регистр. Разумеется, при переполнении результатом может быть и не ноль, а другое число. Например, при сложении чисел 110 и 147 в регистре AL будет число 1 (а не 257, как нам хотелось бы). Пример:


>**mov al, 255 ; заносим в AL значение 255 , то есть 0xFF**
  **add al, 8** **; добовляем 8**

  

**В результате мы получим число 7 в регистр al


Но мы ведь ожидали 0х107 (263 в десятичном виде). Что случилось? В регистре АL, может поместиться только 8-разрядное число (максимальное значение — 255). Девятый, «потерянный», бит скрыт в регистре признаков, а именно в флаге СF — признак переноса. Признак переноса используется в арифметических командах при работе с большими диапазонами чисел, чем могут поддерживать регистры.

![[Pasted image 20221005140142.png]]

| Бит  | 15  | 14  | 13  | 12  | 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Флаг | 0   | NT  | IO  | PL  | OF  | DF  | IF  | TF  | SF  | ZF  | 0   | AF  | 0   | PF  | 1   | CF  |
**Показано, какие флаги находятся в разрядах регистра FLAGS.
  


В следующей таблице указано положение битовых флагов в 16-битном регистре флагов:


| Флаг:   |     |     |     |     | O   | D   | I  | T  | S  | Z  |    | A  |    | P  |    | C |
|---------|-----|-----|-----|-----|-----|-----|----|----|----|----|----|----|----|----|----|---|
| Бит №:  | 15  | 14  | 13  | 12  | 11  | 10  | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0 |








## Сегментные регистры

Сегменты — это специфические части программы, которые содержат данные, код и стек. Есть три основных сегмента:

   - **Сегмент кода (****Code** **Segment** **или** **CS****)** — содержит все команды и инструкции, которые должны быть выполнены. 16-битный регистр сегмента кода или регистр CS хранит начальный адрес сегмента кода.

   - **Сегмент данных (****Data** **Segment** **или** **DS****)** — содержит данные, константы и рабочие области. 16-битный регистр сегмента данных или регистр DS хранит начальный адрес сегмента данных.

   - **Сегмент [[ZE. Стек и куча | стека]] (****Stack** **Segment** **или** **SS****)** — содержит данные и возвращаемые адреса процедур или подпрограмм. Он представлен в виде [**структуры данных «Стек»**](https://ravesli.com/urok-105-stek-i-kucha/). Регистр сегмента стека или регистр SS хранит начальный адрес стека.

Кроме регистров CS, DS и SS существуют и другие регистры дополнительных сегментов — ES (Extra Segment), FS и GS, которые предоставляют дополнительные сегменты для хранения данных.

При написании программ на ассемблере, программе необходим доступ к ячейкам памяти. Все области памяти в сегменте относятся к начальному адресу сегмента. Сегмент начинается с адреса, равномерно делимого на десятичное 16 или на [**шестнадцатеричное**](https://ravesli.com/assembler-vstuplenie/#toc-3) 10. Таким образом, крайняя правая шестнадцатеричная цифра во всех таких адресах памяти равна `0`, которая обычно не хранится в сегментных регистрах.

Сегментные регистры хранят начальные адреса сегмента. Чтобы получить точное местоположение данных или команды в сегменте, требуется значение смещения. Чтобы сослаться на любую ячейку памяти в сегменте, процессор объединяет адрес сегмента в сегментном регистре со значением смещения местоположения.

   - cs (code segment register) — содержит все команды и инструкции, которые должны быть выполнены. 16-битный регистр сегмента кода или регистр CS хранит начальный адрес сегмента кода. Другими словами, представлен секцией _.text_. Он определяет область в памяти, в которой хранятся коды инструкций. Это также фиксированная область.
  
   - ds (data segment register) — сегментный регистр данных - содержит данные, константы и рабочие области. 16-битный регистр сегмента данных или регистр DS хранит начальный адрес сегмента данных. Другими словами, представлен секциями _.data_ и _.bss_. Секция _.data_ используется для объявления области памяти, где хранятся элементы данных для программы. Эта секция не может быть расширена после объявления элементов данных, и она остается статической во всей программе. Секция _.bss_ также является секцией статической памяти, содержащей буферы для данных, которые будут объявлены в программе позже. Эта буферная память заполнена нулями.
   
   - ss (stack segment register) — сегментный регистр [[ZE. Стек и куча | стека]] - Он содержит адрес сегмента стека исполняемой программы. Другими словами, это сегмент, который содержит значения данных, передаваемые в функции и процедуры в программе.
   
Если программе недостаточно одного сегмента данных, то она имеет возможность использовать еще три дополнительных сегмента данных. Адреса дополнительных сегментов данных должны содержаться в регистрах :

   - es, gs, fs (extension data segment registers)- Они и вовсе могут и не использоваться.
   - es - дополнительный сегментный регистр данных или экстракодов (Extra Segment).

Другими словами, Помимо регистров DS, CS и SS, существуют другие регистры дополнительных сегментов - ES (дополнительный сегмент), FS и GS, которые предоставляют дополнительные сегменты для хранения данных.

ES называется дополнительным сегментным регистром. Обычно он используется с DI и делает указатели. Пара DS: SI и ES: DI обычно используется для выполнения строковых операций.

Напомню что регистр CS указывает на сегмент кода. Процессор обращается к CS всякий раз, когда надо считать из памяти очередную инструкцию для выполнения. Регистры DS и ES указывают на сегмент данных. К этим регистрам процессор обращается, когда выполняемая инструкция считывает или сохраняет данные. Имей в виду: DS используется чаще, чем ES. ES обычно вступает в игру, когда ты обрабатываешь массивы данных, индексируя их регистром DI. Регистр SS указывает на сегмент [[ZE. Стек и куча | стека]]. К этому регистру процессор обращается, когда выполняет инструкции, взаимодействующие со стеком: push, pop, call и ret.



## Итог у нас такой:

  Регистры делятся на три категории:
      
   - Общие регистры (General Registers);
   - Регистры управления (Control Registers);
   - Сегментные регистры (Segment Registers).

  В свою очередь, общие регистры делятся на следующие:
     
   - Регистры данных (Data Registers);
   - Регистры-указатели (Pointer Registers);
   - Индексные регистры (Index Registers).


   
   
# Пример на практике

Посмотрите на следующую простую программу, чтобы понять, как используются регистры в программировании на ассемблере. Эта программа выводит 9 звёздочек с простым сообщением:


```
section .text

   global _start ; должно быть объявлено для линкера (gcc)

_start:          ; сообщаем линкеру точку входа

   mov edx,len  ; длина сообщения
   mov ecx,msg  ; сообщение для вывода на экран
   mov ebx,1    ; файловый дескриптор (stdout)
   mov eax,4    ; номер системного вызова (sys_write)
   int 0x80     ; вызов ядра

   mov edx,9    ; длина сообщения
   mov ecx,s2   ; сообщение для написания
   mov ebx,1    ; файловый дескриптор (stdout)
   mov eax,4    ; номер системного вызова (sys_write)
   int 0x80     ; вызов ядра

   mov eax,1    ; номер системного вызова (sys_exit)
   int 0x80     ; вызов ядра

section .data

msg db 'Displaying 9 stars',0xa ; наше сообщение
len equ $ - msg  ; длина нашего сообщения
s2 times 9 db '*'


```

Результат выполнения программы:

`Displaying 9 stars   *********`

