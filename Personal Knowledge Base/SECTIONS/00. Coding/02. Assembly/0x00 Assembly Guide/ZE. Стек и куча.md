
# Локальная переменная

В программировании локальной переменной называют переменную, объявленную внутри блока кода. Область видимости локальной переменной начинается в точке её объявления и заканчивается в конце этого блока. Например, в языке Си локальными являются переменные объявленные внутри функции или блока (в Си, блоки ограничиваются фигурными скобками { и }). С локальными переменными могут работать только операторы, находящиеся в блоке, где данные переменные объявлены. Вне этого блока локальные переменные неизвестны. Следует помнить, что блок кода начинается открытием фигурной скобки и заканчивается закрытием фигурной скобки. Наиболее важно понять то, что локальные переменные существуют только в блоке кода, в котором они объявлены. Таким образом, локальные переменные создаются при входе в блок и уничтожаются при выходе из него.  

**Пример использования локальных переменных на языке С**

```c

#include <stdio.h>

int a = 0;  // глобальная переменная

int main()
{
    printf("%d", a); // будет выведено число 0
    {
       int a = 1; // объявлена локальная переменная а, глобальная переменная a не видна
       printf("%d", a); // будет выведено число 1
       {
          int a = 2; // еще локальная переменная в блоке, глобальная переменная a не видна, не видна и предыдущая локальная переменная
          printf("%d", a);  // будет выведено число 2
       }
    }
}

```

**Выдаст:
`012

  
Простыми словами,Переменные, объявляемые внутри функций, называются локальными переменными.

# Глобальная переменная
  
Глобальная переменная в программировании — переменная, областью видимости которой является вся программа, если только она не перекрыта

Пример на Си:

```c
int a; /* Объявление глобальной целочисленной переменной «а» */
float b = 6; /* Объявление глобальной переменной с плавающей запятой «b» и присваивание ей значения «6» */

int main(void)
{
   a = 12; /* Присваивание переменной «а» значения «12» */ return a+b;

}

```
  

В противоположность локальным переменным глобальные переменные видны всей программе и могут использоваться любым участком кода. Они хранят свои значения на протяжении всей работы программы. Глобальные переменные создаются путем объявления вне функции. К ним можно получить доступ в любом выражении, независимо от того, в какой функции находится данное выражение.

Как мы уже знаем SP обозначает «stack pointer» (указатель стека). Несмотря на принадлежность регистра ESP к группе регистров общего назначения, в реальности он всегда используется именно в качестве указателя стека, то есть хранит адрес текущей позиции вершины аппаратного стека. Поскольку обойтись без стека тяжело, а другие регистры для этой цели не подходят, можно считать, что

ЕSP никогда не выступает ни в какой иной роли. Простыми словами, адрес, содержащийся в ЕSP, указывает на вершину стека, то есть на ту область памяти, где хранится последнее занесённое в стек значение. Стек «растёт» в сторону уменьшения адресов, то есть при занесении в стек нового значения ЕSP уменьшается, при извлечении значения — увеличивается. Вершина стека представлена парой SS:SP – указатель на вершину стека. EBP – базовый указатель или указатель базы стекового кадра. Данный регистр предназначен для того, чтобы указывать на позицию в стековом кадре. Благодаря регистру ebp текущая функция всегда имеет своего рода точку отсчёта для доступа к аргументам и локальным переменным. Хранимый в регистре адрес изменяется, когда функция начинает или прекращает выполнение. Мы можем довольно просто адресовать любой объект в стековом кадре как смещение относительно ebp, что и показано на рисунке.



# Стек

Cтек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out), то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека (это например как патрон пистолета – последняя пуля, летить первым). Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека.

Представьте, что на столе в коробке лежит стопка бумажных листов. Чтобы получить доступ к самому нижнему листу, вам нужно достать самый первый лист, потом второй и так далее, пока не доберётесь до последнего. По схожему принципу и устроен стек: чтобы последний элемент стека стал верхним, нужно сначала вытащить все остальные. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных. Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора. Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.


## Использование стека 
  

У стека много задач, на давайте пройдем по самому главному. Сначало начнём с более высокого термина, например - язык Си:  

   Например у вас есть три функции – A(), B(), C(). Если функция A() вызывает функцию B(), то исходное состояние функции A() попадает в стек, а если функция B() вызывает функцию C(), то состояния самого B() попадет на вершину стека.

А теперь разберём более низкий термин, а именно ассемблер:

   При программировании очень часто возникает потребность временно сохранять содержимое регистров процессора или какого-то адреса памяти, чтобы через некоторое время восстановить исходные значения. Язык ассемблера удовлетворяет эту потребность набором команд для работы со специальной областью памяти, которая называется стеком. операция добавления в стек некоторого значения уменьшает адрес вершины, сдвигая тем самым вершину вверх (то есть в направлении мёньших адресов) и в новую вершину записывает добавляемое значение; операция извлечения считывает значение с вершины стека и сдвигает вершину вниз, увеличивая её адрес.

  
Стек можно использовать, например, для временного хранения значений регистров; если некоторый регистр хранит важное для нас значение, а нам при этом нужно временно задействовать этот регистр для хранения другого значения, то самый простой способ выйти из положения — это сохранить значение регистра в стеке, затем использовать регистр под другие нужды, и, наконец, восстановить исходное значение регистра путём извлечения этого значения из стека обратно в регистр. Но гораздо более важно другое: стек используется при вызовах подпрограмм для хранения адресов возврата, для передачи фактических параметров в подпрограммы, хранении параметров функции и для хранения локальных переменных. Именно использование стека позволяет реализовать механизм рекурсии, при котором подпрограмма может прямо или косвенно вызвать сама себя.

Практически каждый, кто занимался программированием, знает, что без стека невозможна рекурсия, так как при любом повторном входе в функцию требуется сохранение текущего состояния на вершине, причём при каждом выходе из функции, нужно быстро восстанавливать это состояние (как раз наша последовательность LIFO).  

Если же копнуть глубже, то можно сказать, что, по сути, весь подход к запуску и выполнению приложений устроен на принципах стека. Не секрет, что прежде чем каждая следующая программа, запущенная из основной, будет выполняться, состояние предыдущей занесётся  в стек, чтобы, когда следующая запущенная подпрограмма закончит выполняться, предыдущее приложение продолжило работу с места остановки.

![[Pasted image 20221011095203.png]]

## Основные Принципы Адресации в Стеке

1. **Стек растет вниз**: Во многих архитектурах, таких как x86 и ARM, стек растет от больших адресов к меньшим. Это означает, что новые данные добавляются на низкие адреса.
    
2. **Указатели стека**:
    
    - **Указатель стека (SP)**: Указывает на вершину стека, где находится последний добавленный элемент.
    - **Базовый указатель (BP)** или **указатель кадра (FP)**: Используется для доступа к параметрам функции и локальным переменным. Он устанавливается в начале вызова функции и не изменяется в течение выполнения функции.

## Стек растёт в сторону уменьшения адресов

"Стек растёт в сторону уменьшения адресов" означает, что при добавлении новых элементов в стек их адреса уменьшаются. Другими словами, при помещении нового элемента в стек его адрес будет меньше, чем адрес предыдущего элемента. Это связано с тем, что стек обычно организован в памяти таким образом, что он начинается с более высоких адресов и расширяется к более низким адресам. Когда данные помещаются в стек, они размещаются по адресам, которые находятся ниже адресов уже имеющихся данных. 

Просто запомните - верх стека направлен вниз!

При удалении данных из стека адреса увеличиваются, и старые данные "выталкиваются" из стека. Это важно для понимания работы стека в компьютерной архитектуре и программировании, так как многие операции работы со стеком (например, сохранение регистров или передача параметров функции) зависят от того, что стек растёт в сторону уменьшения адресов. Верхушка стека расположена внизу, в сторону уменьшения адресов памяти. То есть, при добавлении нового элемента он помещается на вершину стека, которая находится в самом "низу" стека по отношению к адресам памяти. При удалении элемента верхний элемент стека удаляется, и верхушка стека смещается в сторону увеличения адресов памяти.

Когда говорят, что стек растет в сторону уменьшения адресов, это означает, что каждый новый элемент, добавленный в стек, размещается по более низкому адресу памяти, чем предыдущий элемент. В контексте архитектуры компьютера это означает, что указатель стека (ESP на x86 или RSP на x64) уменьшается по мере добавления новых данных в стек.

Для примера у тебя общая память 100 байт. Указатель на начало стека (который в регистре ESP хранится)  указывает на адрес 50. Когда ты будешь класть в стек (память) данные, указатель стека будет подниматься (но при этом адрес уменьшается), так как если ты положил 4 байта в стек, то указатель начала стека будет уже по смещению 46  т.е.  данные записываются в сторону убывания адресов, снизу вверх.

**Пример размещения строки "Hello World!" в стеке**

Рассмотрим пример функции, которая размещает локальную переменную в стеке:

```c
void example() {
    int local_var = 42;
}
```

Когда функция `example` вызывается, стековая память будет изменена следующим образом:

**Начальное состояние стека**

```
Адрес        Значение
0xffe264d0   <старые данные стека>
```


**После вызова функции `example`**

```
Адрес        Значение
0xffe264cc   42              ; локальная переменная `local_var`
0xffe264d0   <старые данные стека>
```

Как видно, локальная переменная `local_var` размещена по адресу `0xffe264cc`, который меньше начального адреса `0xffe264d0`. Это иллюстрирует, как стек "растет" в сторону уменьшения адресов.

## Порядок LIFO

LIFO (Last In, First Out) — это порядок обработки данных, при котором последний добавленный элемент будет первым извлечен. Стек данных, который используется в программировании и компьютерной науке, работает по принципу LIFO.

Рассмотрим простой пример, чтобы продемонстрировать принцип работы LIFO.

**Инициализация стека:**

Начнем с пустого стека:

```
Стек: []
Добавление элементов (push):
```

Добавим элементы 1, 2 и 3 в стек по очереди:

```
push(1)
Стек: [1]
```

```
push(2)
Стек: [1, 2]
```

```
push(3)
Стек: [1, 2, 3]
```

**Извлечение элементов (pop):**

Теперь извлечем элементы из стека. Первый элемент, который будет извлечен, это последний добавленный элемент (3):


```
pop()
Стек: [1, 2]
Извлечено: 3
```

Следующий элемент, который будет извлечен, это элемент 2:

```
pop()
Стек: [1]
Извлечено: 2
```

Последний элемент, который будет извлечен, это элемент 1:

```
pop()
Стек: []
Извлечено: 1
```

Запись данных в выделенную область стека происходит снизу вверх, с более низких адресов к более высоким. Давайте еще раз уточним этот процесс с примерами для большей ясности. Допустим, мы хотим записать строку "HELLO" в стек. Мы сначала выделяем место в стеке, а затем записываем данные в выделенное место.

```
section .data
    message db 'HELLO', 0  ; строка с нулевым окончанием

section .bss

section .text
    global _start

_start:
    ; Получаем адрес строки
    lea esi, [message]

    ; Длина строки
    mov ecx, 5  ; Длина строки "HELLO"

    ; Выделяем место в стеке для строки (5 байт)
    sub esp, 5

    ; Записываем строку в стек
    mov edi, esp  ; Устанавливаем EDI в начало выделенной области

copy_loop:
    ; Читаем символ строки
    mov al, [esi]
    ; Записываем его в стек
    mov [edi], al

    ; Переходим к следующему символу
    inc esi
    inc edi

    ; Уменьшаем счетчик
    dec ecx

    ; Проверяем, если еще есть символы, продолжаем цикл
    jnz copy_loop

    ; Завершение программы
    mov eax, 1      ; Системный вызов для выхода
    xor ebx, ebx    ; Код выхода 0
    int 0x80        ; Вызов системного прерывания
```

1. **Выделение места в стеке**:
    
    - `sub esp, 5`: Уменьшаем указатель стека на 5 байт, тем самым выделяя место для 5 символов строки "HELLO".
2. **Запись данных в выделенное место**:
    
    - `mov edi, esp`: Устанавливаем `EDI` в начало выделенной области.
    - В цикле `copy_loop` читаем каждый символ строки из `ESI` и записываем его в `EDI`.
    - Увеличиваем `ESI` и `EDI`, чтобы двигаться к следующему символу строки и к следующему байту в выделенной области стека.

**Примерный дамп памяти**

Предположим, что указатель стека (ESP) перед началом записи был равен `0xffbf5a90`. После выполнения `sub esp, 5` указатель стека станет `0xffbf5a8b`. Теперь, данные будут записаны следующим образом:

```
Адрес        Значение
0xffbf5a8b   'H' (0x48)
0xffbf5a8c   'E' (0x45)
0xffbf5a8d   'L' (0x4C)
0xffbf5a8e   'L' (0x4C)
0xffbf5a8f   'O' (0x4F)
```

Таким образом, строка "HELLO" записывается в стек начиная с адреса `0xffbf5a8b` и заканчивая адресом `0xffbf5a8f`. Запись происходит в сторону возрастания адресов, начиная с самого нижнего адреса выделенной области. 

Тут срока `AABBHACKCCDD`. И он вот так выглядит в памяти:

```
0xff7fe470:     0xd0    0x8f    0x78    0xf5    0x41    0x41    0x42    0x42
0xff7fe478:     0x48    0x41    0x43    0x4b    0x43    0x43    0x44    0x44

```

Порядок последовательности:

```
0x74: 0x41 - A
0x75: 0x41 - A
0x76: 0x42 - B
0x77: 0x42 - B
0x78: 0x48 - H
0x79: 0x41 - A
0x80: 0x43 - C
0x81: 0x4b - K
0x82: 0x43 - C
0x83: 0x43 - C
0x84: 0x44 - D
0x85: 0x44 - D
```

**Заключение**

При освобождение памяти в стеке, стек растёт в сторону уменьшение адресов (сверху вниз), а при записи - запись делается в сторону возрастание адресов выделенного места (снизу вверх).

Стек растет в сторону уменьшения адресов:

- Когда вы создаете новую переменную или вызываете функцию, место для этих данных выделяется в стеке. Стек - это структура данных LIFO (последний пришел, первый вышел), которая растет в сторону уменьшения адресов. Это означает, что адрес верхней части стека уменьшается при добавлении новых данных.

Записывает в сторону возрастания адресов:

- Когда данные записываются в стек, они записываются поверх выделенного пространства, начиная с самого низкого адреса и продвигаясь к более высоким адресам. Это происходит потому, что указатель стека увеличивается для указания на новую позицию записи по мере добавления данных.

Объяснение:

- Стек можно представить как вертикальный список ячеек памяти, причем самая верхняя ячейка находится по самому высокому адресу. Когда выделяются новые данные, указатель стека уменьшается, чтобы указать на новую ячейку в верхней части стека. Когда данные записываются в стек, указатель стека увеличивается, чтобы указать на следующую доступную ячейку.

- **Выделение памяти в стеке**: Происходит в сторону уменьшения адресов (указатель стека уменьшается). Процесс выделения памяти в стеке происходит в сторону уменьшения адресов. Это означает, что при каждом новом вызове функции или выделении переменной указатель стека (`ESP` или `RSP` в x86/x64) уменьшается.
- **Запись данных**: Запись данных в выделенную область происходит снизу вверх, начиная с более низкого адреса и двигаясь к более высокому адресу в выделенной области. После того, как место в стеке выделено, данные могут быть записаны в этом месте по порядку, начиная с более низкого адреса и двигаясь к более высокому.

Просто запомните что, переменные ниже адреса возврата и вершина стека - младшие адреса, дно - старшие.

## Подпрограммы

Подпрограммой (процедуры), называется некоторая обособленная часть программного кода, которая может быть вызвана из главной программы (или из другой подпрограммы); под вызовом в данном случае понимается временная передача управления подпрограмме с тем, чтобы, когда подпрограмма сделает свою работу, она вернула управление в точку, откуда её вызвали. Читатель, вне всякого сомнения, уже встречался с подпрограммами. Это, например, процедуры и функции языка Паскаль, функции в языке Си и т.п.

При вызове подпрограммы необходимо запомнить адрес возврата, то есть адрес машинной команды, следующей за командой вызов подпрограммы, причём сделать это так, чтобы сама вызываемая подпрограмма могла, когда закончит свою работу, воспользоваться этим сохранённым адресом для возврата управления. Кроме того, подпрограммы чанение всей локальной информации, включая и адрес возврата, и параметры, и локальные переменные. Тогда вызов подпрограммы потребует прежде всего записать в принадлежащую подпрограмме область памяти (в заранее оговорённые места) значения параметров и адрес возврата, а затем передать управление в начало подпрограммы.

Интересно, что когда-то давно именно так с подпрограммами и поступали. Однако с развитием методов и приёмов программирования возникла потребность в рекурсии — таком построении программы, при котором некоторые подпрограммы могут прямо или косвенн вызывать сами себя, притом потенциально неограниченное" число раз. Ясно, что при каждом рекурсивном вызове требуется новый экземпляр области памяти для хранения адреса возврата, параметров и локальных переменных, причём чем позже такой экземпляр будет создан, тем раньше соответствующий вызов закончит работу, то есть рекурсивные вызовы подпрограмм в определённом смысле подчиняются правилу «последний пришел — первый ушел». Совершенно логично из этого вытекает идея использования при вызова подпрограмм уже знакомого нам стека.

В  современных вычислительных системах перед вызовом подпрограммы в стек помещаются значения параметров вызова, затем производится собственно вызов, то есть передача управления, которая совмещена с сохранением в том же стеке адреса возврата. Наконец, когда подпрограмма получает управление, она резервирует в стеке определённое количество памяти для хранения локальных переменных, обычно просто сдвигая адрес вершины вниз на соответствующее количество ячеек. Область стековой памяти, содержащую связанные с одним вызовом значения параметров, адрес возврата и локальные переменные, называют стековым фреймом.

Процедуры или подпрограммы очень важны в Ассемблере, так как большинство программ на ассемблере имеют большой размер. Процедуры идентифицируются по имени, после которого, собственно, и следует тело процедуры. Конец процедуры указывается стейтментом возврата.

## Выделение и освобождение памяти

Стек — это участок памяти, используемый для хранения локальных переменных, возвратных адресов, параметров функций и других данных во время выполнения программы. При использовании стека растущим вниз, указатель стека esp уменьшается при добавлении данных в стек и увеличивается при удалении данных из стека.

  >sub esp,0x10 ; выделил 16 байт пространства в стеке для переменных и прочего.

Команда `sub esp, <value>` вычитает `<value>` из значения регистра esp, указывая таким образом на новый начало области памяти в стеке для выделения места под дополнительные данные. 

Таким образом, команда `sub esp, <value>` расширяет стек, выделяя больше памяти, но не освобождает уже существующие данные в стеке. Для освобождения памяти в стеке используется инструкция `add esp, <value>`, которая увеличивает указатель стека esp, "освобождая" ранее занятую область стека.

## Пролог процедуры

Пролог процедуры – это несколько строк кода в начале функции, которе подготавливает стек и регистры для использовании функции. Код нашего пролога состоит из двух команд:

```
push ebp
mov ebp, esp
```

Первая строчка кода сохраняет старое значение регистра ebp в стек, чтобы в конце его восстановить, вдруг там что -то важное, а после будем использовать ebp для копии esp. Это можно называть настройка и подготовка.

![[Pasted image 20221011112336.png]]

Синтаксис ввода функции:  

```
push ebp
mov ebp, esp
sub esp, X
```
  
**X** – это общий размер в байтах всех автоматических переменных (автоматические переменные создаются при входе в функцию и уничтожаются при выходе из неё ), испльзуемых в функции.

Пример простого фрагмент кода функции Си:  

```c
void MyFunction(){

  int a;
  int b;
  int c;
…
}
```
  

**Ассеблерный код:

```
push ebp
mov ebp, esp
sub esp, 12        ; Освобождаем пространство для всех локальных переменных в стеке

mov [ebp – 4], 10  ; расположение a
mov [ebp – 8], 8   ; расположение b
mov [ebp – 12], 2  ; расположение c
```
  

**Результат:**

```
a = 20
b = 8
c = 2
```

В  стеке память выделяется путем простого вычитания нужной длины из текущего значения ESP. Так например, под локальный переменной нужен 16-байт, то после завершении пролог процедуры нужно выполнить команду **sub esp, 16.**

Когда операция завершается мы все вернем на свои места. Первым делом мы возвращаем значение ESP (**mov esp, ebp**), и вернём старое значение ebp из стека (**pop ebp**), а на последок забираем адрес возврата из верхушки стека, чтобы мы знали, от куда начинать продолжение – где мы останавились(**ret**).

Интересно, что процессор i386 поддерживает даже специальные команды для обслуживания стековых фреймов. Так, в начале подпрограммы вместо трёх команд:

```
push ebp
mov ebp, esp
sub esp, 16
```  

Можно бы дать всего одну команду:
  
```
enter 16, 0
```
  

А вмсето двух уоманд перед ret:

``` 
mov esp, ebp
pop ebp
ret
``` 

Можно просто:

```
leave

```
  
Проблема, как ни странно, в том, что команды enter и leave работают медленнее, чем соответствующий набор простых команд, так что их практически никогда не используют; если дизассемблировать машинный код, сгенерированный компилятором языка Си или Паскаль, мы, скорее всего, обнаружим в начале любой процедуры или функции именно такие команды, как показано выше, и нечего похожего на enter.

Сделаем ещё одно важное замечание. При работе под управлением ОС (Unix мы можем не беспокоиться ни о наличии стека, ни о задании его размера. Операционная система создаёт стек автоматически при запуске любой задачи и, более того, уже во время её исполнения при необходимости увеличивает размер доступной для стека памяти: по мере того как вершина стека продвигается по виртуальному адресному пространству «вверх» (то есть в сторону уменьшения адресов), операционная система ставит в соответствие виртуальным адресам всё новые и новые страницы физической памяти.

Как мы уже знаем, каждая функция будет генерировать свой собственный кадр стека, поэтому кадр стека в приведенном выше примере может быть поверх другого кадра в стеке, который используется для другой функции.

![[Pasted image 20221011113135.png]]


Пример класса памяти стека

Чтобы проиллюстрировать это, у меня есть пример простой программы на C, которая вызывает функцию addFunc, которая складывает вместе два числа (1+4) и выводит результат на экран:

```c
#include "stdio.h"

int addFunc (int a, int b);


int main (void) {

  int x = addFunc(1,4);
  printf("%d\n", x);

return 0;

}

int addFunc(int a, int b) {

  int c = a + b;

  return c;
}
```
  
Сосредоточившись на коде функции «addFunc», в качестве аргументов передаются два параметра (a и b) и локальная переменная «c», в которой хранится результат. После компиляции программа может быть загружена в x64dbg. Ниже показано, как будет выглядеть ассемблерный код этой программы:

```
push ebp
mov ebp,esp
sub esp,10

mov edx,dword ptr ss:[ebp+8]
mov eax,dword ptr ss:[ebp+C]
add eax,edx
mov dword ptr ss:[ebp-4],eax
mov eax,dword ptr ss:[ebp-4]

leave
ret
```

Первые три строки — это то, что известно как пролог функции, именно здесь в стеке создается место для функции.

**Разбор кода:
  
- **push ebp** сохраняет ESP, указатель предыдущего кадра стека, поэтому к нему можно вернуться в конце функции. Фрейм стека используется для хранения локальных переменных, и каждая функция будет иметь свой собственный фрейм стека в памяти.

- **mov ebp, esp** перемещает текущую позицию стека в EBP, который является основанием стека. Теперь у нас есть контрольная точка, которая позволяет нам ссылаться на наши локальные переменные, хранящиеся в стеке. Значение EBP теперь никогда не меняется.
 

- **sub esp, 10** увеличивает стек на 16 байт (10 в шестнадцатеричном формате), чтобы выделить место в стеке для любых переменных, на которые нам нужно ссылаться.
  
Ниже показано, как будет выглядеть стек для этой программы. Каждая используемая часть данных размещается друг над другом в разделе памяти в соответствии с представленной ранее схемой.


```
EBP-10

EBP-C

EBP-8

EBP-4 (int c)

EBP = Помещается в стек в начале функции. Это начало нашего стекового фрейма.

EBP+4 = адрес возврата предыдущей функции .

EBP+8 = Parameter 1 (int a)

EBP+C = Parameter 2 (int b)
```

 В   этом примере мы можем видеть, взглянув на стек, что нам было выделено место для четырех локальных переменных, однако у нас есть только одна переменная, 'int c'.

> **mov edx,dword ptr ss:[ebp+8]** — Здесь мы перемещаем «int a», значение которого равно 1, в регистр EDX.
  

Важная часть здесь **[ebp+8]**. Это в квадратных скобках, что означает, что вы напрямую обращаетесь к памяти в этом месте. Это ссылка на место в памяти, которое на 8 байт выше по стеку, чем то, что находится в EBP.

Мы   упомянули ранее, что параметры, которые передаются функции, всегда будут находиться в более высоком адресном пространстве, которое находится ниже по стеку. Наши параметры «int a» и «int b» были переданы функции до того, как был создан кадр стека, поэтому они находятся в «ebp+8» и «ebp+c».

- **mov eax,dword ptr ss:[ebp+C]** ссылаемся на — То же, что и выше, хотя теперь мы 'ebp+C', который является 'int b', значением '4' и перемещаем его в регистр EAX.
- **add eax, edx** – выполняет сложение и сохраняет результат в «EAX».
- **mov dword ptr ss:[ebp-4],eax** — Здесь мы перемещаем результат, хранящийся в «EAX», в локальную переменную «int c».

Локальная переменная 'c' определена внутри функции, поэтому она находится в памяти с меньшим адресом, чем вершина стека. Поэтому, поскольку он находится внутри кадра стека и имеет размер 4 байта, мы можем просто использовать часть пространства, выделенного ранее для переменных, вычитая 10 из esp, и в этом случае использовать «EBP-4».

- **mov eax,dword ptr ss:[ebp-4]** — большинство функций возвращают значение, хранящееся в «EAX», поэтому там, где выше возвращаемое значение находится в «EAX», и мы переместили его в переменную «c», здесь это просто снова поместив его в «EAX», готовый к возврату.
- **leave** — это маска для операции, которая перемещает «EBP» обратно в «ESP» и извлекает его из стека, т. е. подготавливает кадр стека для функции, вызвавшей эту функцию.
- **ret** — это переход к адресу возврата, чтобы вернуться к вызываемой функции, которая имеет хорошо сохранившийся кадр стека, потому что мы помнили его в начале этой функции.



![[Pasted image 20221011095135.png]]


## Инструкции работы со стеком

Инструкции для работы со стеком много, но мы разберём только основные, а именно **push** и **pop**.

### Инструкция PUSH


Команда PUSH позволяет поместить в стек содержимое любого 16- или 32- битного регистра или ячейки памяти. Команда push требует один оперенд. Синтаксис:  

>**push [оперенд]** **;заносим содержимое оперенда на вершину стека**


Оперендом должен быть непосредственным регистровым или типа память и иметь размер word или dword (если оперенд не регистровый, то размер необходимо указать явно). Команда PUSH уменьшает значение регистра стека на размер операнда (2 или 4) и копирует содержимое операнда в память по адресу SS:SP.

Пример использования:
 

```
push eax ;поместить eax в стек
```
  
Мы можем сами реализовать команду push с помощью следующей пары команд:

```  
sub esp, 4        ; уменьшаем ESP на 4 ( EAX - 4 - байтный регситр )
mov [ss:esp], eax ; сохраняем eax в стек
```  

  

Команда push совмещают копирование данных (на вершину стека ) со сдвигом самой вершины, то есть изменением значения регистра ESP. Понятно, что можно, вообще говоря, обратиться к значению на вершине стека, не извлекая его из стека — применив (в любо команде, допускающей операнд типа «память») операнд [esp]. Например, команда **mov eax, [esp]** - скопирует четырёхбайтное значение с вершины стека в регистр ЕАХ.
 
### Инструкция POP

Команда, РОР, записывает в свой операнд значение вершины стека (последнее сохраненное в стеке значение). Тип операнда должен быть таким же, как у инструкции PUSH (другими словами, если вы поместили в стек 32-разрядный регистр, извлечение из стека должн происходить тоже в 32разрядный регистр). Простыми словами команда pop нужен для извлечения значения из стека. Команда POP требует один оперен. Оперенд должен быть регистровым или типа память.; естественно, оперенд должен иметь размер слово или двойное слово. Синтаксис:

>**pop [оперенд] ; переместить значение вершины стека в оперенд**
  

Команду **pop** можно реализовать с помощью команд **mov** и **add**:

```
mov eax, [ss:esp]  ; Помещаем в EAX вершину стека ( последний элемент, который был занесен в стек )
add esp, 4         ; Удаляем последнее значение типа dowrd в стеке
```

**Рассмотрим несколько примеров:

```
push eax  ; сохранить значение регистра ЕАХ в стеке
push esi  ; сохранить значение регистра ESI в стеке**
рор еах   ; извлечь данные из стека в ЕАХ
рор esi   ; уизвлечь данные из стека в ESI
  ``` 

В результате выполнения этих команд мы поменяем местами значение регистров ЕАХ и ESI: сначала помещаем в стек значение ЕАХ, затем — ESI, после этого извлекаем из стека последнее сохраненное значение (бывшее значение регистра ESI) в регистр ЕАХ, после этого в стеке останется бывшее значение EAX, которое мы записываем в ESI.

Для обеспечения обратной совместимости с процессорами предыдущих поколений 16-битные регистры тоже можно поместить в стек:
  

```
mov ax, 0x1234  ; AX = 0x1234
mov bx, 0x5678  ; BX = 0x5678

push ax ; Сохранить значение регистра AX в стеке ( теперь на вершине стека стоить значение регистра AX)
push bx ; Сохранить значение регистра BX в стеке ( а вот теперь на вершине стека занесен значение регистра bx)

…

pop bx  ; Извлекаем вершину стека в BX

   ```

![[Pasted image 20221011110024.png]]

До выполнения первой команды PUSH вершина стека содержала значение 0х0000. На вершину стека указывает пара SS:SP. Допустим, что SР содержит адрес 0хFFFЕ. После выполнения РUSH АХ указатель стека был уменьшен на 2 и принял значение 0хFFFС, и по этому адресу (в новую вершину стека) было записано значение 0х1234. Вторая команда, PUSH ВХ, также уменьшила значение SР на 2 (0хFFFА записала в новую вершину стека значение 0х5678. Команда РОР ВХ удалила значение 0х5678 из стека и сохранила его в регистре ВХ, а указатель стека увеличила на 2. Он стал равен 0хFFFС, и в вершине стека оказалось значение 0х1234.

Помните, что 8-битные регистры сохранять в стеке нельзя. Нельзя и поместить в стек регистр IP (ЕIР) непосредственно, при помо команд РUSH/РОР: это делается по-другому, и чуть позже вы узнаете, как именно.

Как мы уже сказали, стек очень удобно использовать для временного хранения значения регистов:


```
push eax ; Копируем значение EAX на вершину стека

… ; Используем EAX подсторонние нужды …

pop eax  ; Восстанавливаем EAX**

```
  

Простыми словами, команда push помещает значение оперенда в стек ( на вершину стека ), а команда pop извлекает из стека данные в оперенд ( размер который указывает сам оперенд – размер самого оперенда указывет на требуемыйы размер для извлечение данных из стека).

## Инструкция CALL/RET  

Для вызова подпрограммы используется команда CALL, а для возврата из подпрограммы в основную программу – RET. CALL - вызывает процедуру (подпрограмму) сохранив при этом в стеке адрес возврата, call передаёт управление по указанному адресу и процессор выполняет команду который расположен по этому адресу. Обычно процедура или же подпрограмма заканчивается командой ret, она забирает из стека адрес возврата, и возвращает управление на команду, следующую за командой call. То есть при вызове подпрограммы и или прерывания, в стек заносится адрес возврата - это адрес памяти следующие инструкции приостанавливаемой программы, а управления передается подпрограмме. RET – это конец подпрограммы, она забирает из стека адрес возврата, и управления передаётся на следуюшую инструкцию приостоновленной программы. Простыми словами, при вызове call первым делом в стек сохраняется значения регистра IP (EIP), передача управления на указанный адрес называется вызовом подпрограммы, и когда заканчивается подпрограмма, а она заканчивается командой ret, он извлекает 4 байта с вершины стека ( это адрес возврата ) записывает его в регистр EIP, и программа начнётся с того место от куда был прерван.
  
Ниже приведен синтаксис определения процедуры:

```
имя_процедуры:

  тело_процедуры
...
ret
```
  

Процедура вызывается из другой функции с помощью инструкции CALL, которая содержит имя вызываемой процедуры в качестве аргумента:

>CALL имя_процедуры
 
Вызываемая процедура возвращает управление вызывающей процедуре с помощью инструкции RET.

Например, давайте напишем очень простую процедуру с именем sum, которая будет складывать переменные, хранящиеся в регистрах ECX и EDX, и возвращать сумму в регистр EAX:

```
section .text

   global _start  ; объявляем для использования gcc

_start:  ; сообщаем линкеру входную точку

  mov ecx, '4'
  sub ecx, '0'
  
  mov edx, '5'
  sub edx, '0'

  call sum  ; вызываем процедуру sum
  mov [res], eax
  mov ecx, msg
  mov edx, len
  mov ebx,1 ; файловый дескриптор (stdout)
  mov eax,4 ; номер системного вызова (sys_write)
  int 0x80  ; вызов ядра

  mov ecx, res
  mov edx, 1
  mov ebx, 1 ; файловый дескриптор (stdout)
  mov eax, 4 ; номер системного вызова (sys_write)
  int 0x80   ; вызов ядра

  mov eax,1 ; номер системного вызова (sys_exit)
  int 0x80  ; вызов ядра

sum:

  mov eax, ecx
  add eax, edx
  add eax, '0'
  ret



section .data
  msg db "The sum is:", 0xA,0xD
  len equ $- msg

segment .bss
  res resb 1
 ``` 

**Результат выполнения программы:

The sum is: 
`9`

Напомним что пространство памяти, зарезервированное в сегменте стека, используется для реализации стека, а именно — регистры SS и ESP (или SP) . На вершину стека, которая указывает на последний добавленный элемент, указывает регистр SS:ESP, где регистр SS указывает на начало сегмента стека, а SP (или ESP) показывает смещение в сегменте стека.

![[Pasted image 20221011111109.png]]

## stack frame

Stackframe (фрейм) или как его еще называют кадры – Это механизм передачи аргументов и выделения временной памяти (в процедурах языков программирования высокого уровня) с использованием системного стека. Всякий раз, когда в нашей программе происходит вызов функции, память для локальных переменных и других вызовов функций или подпрограмм сохраняется в кадре стека. Каждая функция получает свой собственный стековой фрейм в стековом сегменте памяти приложения. То есть, стековой фрейм, это та самая область памяти, выделяемая всякий раз когда вызывается подпрограмма. Можно сказать что кадр стека, это упакованная информация, связанная с вызовом функции,Кадр стека для каждой подпрограммы разделен на три части: параметры функции, обратный указатель на предыдущий кадр стека и локальные переменные.

![[Pasted image 20221011095905.png]]

Как мы уже говорили, в стеке всё храниться по принципу LIFO. Например, если у исходном коде значения хранится в виде: 0xcafebabe. То в стеке он выглядть так: `\xbe\xba\xfe\xca`. Напоминаем что стек растёт в сторону уменьшние адресов (верхушка стека внизу).  

Классический способ объяснения принципов стека звучит так: представьте, что вы моете посуду и складываете одинаковые чистые тарелки стопкой друг на друга. Каждая новая тарелка — это элемент стека, а вы просто добавляете их по одной в стек. Когда кому-то понадобится тарелка, он не будет брать её снизу или из середины — он возьмёт первую сверху, потом следующую и так далее.

![[Pasted image 20221011100043.png]]

## Организация стековых фреймов

Во многих случаях ( сложных - часто) нам наверняка потребуются локальные переменные, поскольку регистров на всё не хватит. Кроме того, передача параметров через регистры тоже может оказаться неудобна: во-первых, регистров может и не хватить, а вовторых, подпрограмме могут быть долго нужны значения, переданные через регистры, и это фактически лишит её возможности использовать под свои внутренние нужды те из регистров, которые были задействованы при передаче параметров. 

Наконец, передача параметров чер регистры (а равно и через какую-либо фиксированную область памяти) лишает нас возможности использовать рекурсию, что тоже, разумеется, плохо. Поэтому обычно (в особенности при трансляции программы с какого либо языка высокого уровня, с того же Паскаля или Си) параметры в функции передаются через стек, и в стеке же размещаются локальные переменные. Как было сказано выше, параметры в стеке размещает вызывающая программа, затем при вызове подпрограммы в стек заносится адрес возврата, и, наконец, уже сама вызванная подпрограмма, резервирует место в стеке под локальные переменные. Всё это вместе и образует стековый фрейм. К содержимому стекового фрейма можно обращаться, используя адреса, «привязанные» к адресу, по которому содержится адрес возврата, то есть, иначе говоря, ту ячейку памяти, начиная с которой в стек был занесён адрес возврата, используют в качестве своего рода реперной точки. Так, если в стек занести три четырёхбайтных параметра, а потом вызвать процедуру, то адрес возврата будет лежать в памяти по адресу [esp], ну а параметры, очевидно, окажутся доступны по адресам [esp+4], [esp+8] и [esp+12]. Если же разместить в стеке локальные четырёхбайтные переменные, то они окажутся доступны по адресам [esp-4], [esp-8] и т.д.

Заметим, что использовать для доступа к параметрам регистр ESP оказывается не слишком удобно, ведь в самой процедуре нам тоже может потребоваться стек (как для временного хранения данных, так и для вызова других подпрограмм). Поэтому первым же свои действием подпрограмма обычно сохраняет значение регистра ESP в каком-то другом регистре (чаще всего ЕВР) и именно его использует для доступа к параметрам и локальным переменным, ну а регистр ЕSР продолжает играть свою роль указателя стека, изменяясь по мере необходимости; перед возвратом из подпрограммы его обычно восстанавливают в исходном значении (попросту пересылая в него значение из ЕВР), чтобы он снова указывал на адрес возврата.

Наконец, возникает ещё один вопрос: а что если другие подпрограммы тоже используют регистр ЕВР для тех же целей? Ведь в этом случае первый же вызов другой подпрограммы испортит нам всю работу. Можно, конечно, сохранять ЕВР в стеке перед вызовом каждой подпрограммы, но поскольку в программе обычно гораздо больше вызовов подпрограмм, чем собственно самих подпрограмм, экономнее оказывается следовать простому правилу: каждая подпрограмма должна сама сохранить старое значение ЕВР ‘и восстановить его перед возвратом управления. Естественно, для сохранения значения ЕВР тоже используется стек, причём сохранение выполняется простой командой **push ebp** сразу после получения управления. Таким образом, старое значение ЕВР помещается в стек непосредственно после адреса возврата из подпрограммы, и в качестве «точки привязки» используется в дальнейшем именно этот адрес вершины стека. Д этого следующей командой выполняется **mov ebp,esp**. В результате регистр ЕВР указывает на то место в стеке, где находится его же, ЕВР, сохранённое значение; если теперь обратиться к памяти по адресу [ebp+4], мы обнаружим там адрес возврата из подпрограммы, ну а параметры, занесённые в стек перед вызовом подпрограммы, оказываются доступны по адресам [esp+8], [esp+12], [esp+16] и т.д. Память под локальные переменные выделяется путём простого вычитал ния нужной длины из текущего значения ЕSP; так, если под локальные переменные нам нужно 16 байт, то сразу после сохранения ЕВР и копирования в него содержимого ESP нужно выполнить команду:

**sub esp, 16**; если (для простоты картины) все наши локальные переменные тоже занимают по 4 байта, они окажутся доступны по адресам [ebp-4], [ebp-8] ит.д. Структура стекового фрейма с тремя четырёхбайтными параметрами и четырьмя четырёхбайтными локальными переменными показана.

![[Pasted image 20221011111404.png]]


![[Pasted image 20221011111414.png]]

Повторим, что в начале совей работы, согласно нашим договорённостям, каждая подпрограмма должно выполнить:

```
push ebp
mov ebp, esp
sub esp, 16
```

А завершении подпрограммы должен выглялить так:

```
mov esp, ebp
pop ebp
ret

```
  

Обычно EBP используется для резервного копирования ESP, поэтому, если ESP изменяется кодом в функции, все, что требуется д восстановления ESP, - это **mov ESP, EBP**. Кроме того, поскольку EBP обычно остается неизменным кодом в функции, его можно использовать для доступа к переданным параметрам или локальным переменным без необходимости корректировать смещения.

При использовании EBP в качестве указателя кадра, положительные смещение означают аргументы, а отрицательные смещени означают локальные переменные.

ESP может продолжать изменяться по мере необходимости во время работы функции. ESP является движущейся целью, поэтому доступ к параметрам и переменным с использованием динамических смещений относительно ESP может быть сложным, если не невозможным, в зависимости от того, как функция использует стек. Создание кадра стека, как правило, безопаснее за счет использования нескольких байтов пространства стека для сохранения указателя на кадр стека вызывающего объекта. Как мы можем понять, по мере увеличение или уменьшение стека во время выполнении функции смещение локальных переменных и параметро функии относительно ESP изменяет (адрес увеличивается):

![[Pasted image 20221011111556.png]]

Простыми словами ESP может менятся в любое время, когда что-то записывается или выводится ( во время выполнении функции), смещение локальных переменных и параметров функции относительно ESP изменяется. Для упрощения Intel использует базовый указатель (иногда называемый указателем кадра), который хранится в EBP. EBP — это указатель на вершину стека при первом вызове функции. EBP более удобный, он остаётся неизменчивым, и с помошью EBP более удобно получить доступ к локальным переменным и параметром функции. Поэтому выполняется команада:  

```
push ebp
mov ebp, esp

```

То есть EBP, известный как «указатель кадра», служит неизменной точкой отсчета для данных в стеке. Это позволяет программе определить, насколько далеко что-то в стеке находится от этой точки. Таким образом, если переменная находится на расстоянии дву «строительных блоков», то это [EBP+8], поскольку каждый «блок» в стеке составляет 4 байта. ESP изменится, поскольку он всегда указывает на вершину стека, сохранение его в EBP дает нам неизменную контрольную точку в стеке, и теперь функция может ссылаться на свои переменные и параметры в стеке из этого места.

При использовании базового указателя адрес возврата всегда будет иметь значение ebp+4, первый параметр всегда будет иметь значение ebp+8, а первая локальная переменная всегда будет иметь значение ebp- 4. Даже когда размер стека увеличивается и уменьшается, э смещения не меняются. Это также облегчает работу дизассемблеров, потому что легко отслеживать параметры и локальные переменные, к которым осуществляется доступ через функцию, поскольку их адреса никогда не меняются.

При обращении к данным в стеке необходимо учитывать, как организован стек и каким образом осуществляется адресация данных в различных контекстах, таких как вызовы функций, работа с локальными переменными и параметрами. Рассмотрим, как определяются и используются адреса в стеке.

## Соглашения о вызовах (Calling Conventions)

**Соглашение о вызовах** определяет, как параметры передаются в функцию, как используется стек и как осуществляется возврат из функции. Перед вызовом функции параметры функции обычно помещаются на верхушку стека. При вызове функции происходит сохранение текущего адреса возврата, затем параметры функции помещаются на стек, после чего управление передается внутреннему коду функции. 

Параметры функции можно поместить на стек перед вызовом функции, либо передать их через регистры процессора, в зависимости от архитектуры и соглашений вызова функций. 

В большинстве случаев параметры функции заносятся на стек перед вызовом функции. Однако, как именно это происходит, может зависеть от используемой архитектуры и соглашения о вызовах (calling convention). Итак, да, параметры функции обычно заносятся на верхушку стека перед вызовом функции.

Вот несколько распространенных соглашений:

1. **cdecl (C declaration)**:
    
    - **Параметры**: Передаются на стек в порядке справа налево.
    - **Управление стеком**: Вызывающая функция очищает стек после возврата.
    - **Использование**: Чаще всего используется в языке программирования C для x86.

2. **System V AMD64 ABI (Unix-like systems)**:
    
    - **Параметры**: До 6 параметров передаются через регистры (`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`), остальные через стек.
    - **Использование**: Используется в Unix-подобных системах для x86_64.

3. **stdcall (Standard call)**:
    
    - **Параметры**: Параметры передаются на стек аналогично cdecl.
    - **Управление стеком**: Функция, вызываемая (callee), очищает стек.
    - **Использование**: Используется Windows API для x86.

4. **fastcall**:
    
    - **Параметры**: Первые несколько параметров передаются через регистры, оставшиеся параметры через стек.
    - **Управление стеком**: Может варьироваться.

5. **fastcall на x64**:
    
    - **Параметры**: Первые 4 параметра передаются через регистры (обычно `rcx`, `rdx`, `r8`, `r9`), остальные через стек.
    - **Использование**: Используется большинством современных компиляторов на 64-битных платформах.

### Процесс передачи параметров на стек (cdecl)

Передача параметров на стек перед вызовом функции является ключевым аспектом работы с функциями на низком уровне, особенно в контексте архитектур x86 и x64. Этот процесс включает в себя несколько этапов, которые обеспечивают правильное размещение и использование параметров в стеке. Давайте рассмотрим этот процесс подробно.

1. Подготовка к вызову функции

    - Перед вызовом функции, вызывающий код (caller) должен подготовить параметры, которые будут переданы функции. Эти параметры заносятся на стек в порядке, определенном соглашением о вызовах.

 2. Занесение параметров на стек

    - Параметры передаются на стек в обратном порядке (справа налево), чтобы первый параметр оказался на верхушке стека, что упрощает их доступ внутри вызываемой функции (callee).

 3. Вызов функции.  Инструкция `CALL` используется для вызова функции. Она:

     - Сохраняет адрес возврата (адрес инструкции, следующей за `CALL`) в стек.
     - Передает управление вызываемой функции.

 4. Обработка параметров функцией

    - Функция, которую вызвали, получает доступ к параметрам через указатель стека (`ESP` для x86 или `RSP` для x86_64). Она может читать параметры и использовать их в своей логике.

 5. Возврат из функции

    - После выполнения, функция возвращает управление вызывающему коду, который может быть ответственен за очистку параметров из стека (в зависимости от соглашения о вызовах).

**Пример x86 с соглашением cdecl**

1. **Подготовка стека**:
    
    - Стек используется для передачи параметров. Параметры заносятся на стек в порядке справа налево, чтобы первый параметр оказался на самом верху.

1. **Вызов функции**:
    
    - Инструкция `CALL` сохраняет адрес возврата (куда нужно вернуться после завершения функции) в стек и передает управление функции.

1. **Выполнение функции**:
    
    - Функция считывает параметры со стека, выполняет свои действия и возвращает управление обратно вызывающему коду.

1. **Очистка стека**:
    
    - После возврата управление возвращается вызывающему коду, который очищает параметры со стека.

**Пример кода на ассемблере для x86 с использованием cdecl:**

```
; Пример вызова функции в стиле cdecl на x86
push dword 5         ; Параметр 2: 5
push dword 3         ; Параметр 1: 3
call my_function     ; Вызов функции
add esp, 8           ; Очистка стека (2 параметра по 4 байта)
```

**Функция на языке C:**

```c
int my_function(int a, int b) {
    return a + b;
}
```

Для демонстрации рассмотрим еще один пример на x86 с использованием соглашения о вызовах cdecl.

```
section .data
    result db 'Result: %d', 0

section .text
    global _start

_start:
    ; Параметры заносятся на стек справа налево
    push dword 5         ; Параметр 2
    push dword 3         ; Параметр 1

    call my_function     ; Вызов функции

    ; Очистка стека после вызова функции
    add esp, 8           ; 2 параметра по 4 байта

    ; Выход из программы
    mov eax, 1           ; Код sys_exit
    xor ebx, ebx         ; Код возврата 0
    int 0x80             ; Вызов системного вызова

my_function:
    ; Получение параметров из стека
    mov eax, [esp + 4]   ; Первый параметр (3)
    mov ebx, [esp + 8]   ; Второй параметр (5)

    ; Логика функции (сложение)
    add eax, ebx         ; eax = 3 + 5 = 8

    ; Возврат из функции
    ret
```

**Детальный разбор процесса**

1. Занесение параметров на стек:

```
push dword 5         ; Параметр 2
push dword 3         ; Параметр 1
```

В этом шаге параметры 5 и 3 заносятся на стек в обратном порядке. Теперь вершина стека указывает на значение 3, а ниже него находится значение 5.

2. Вызов функции:

```
call my_function
```

Инструкция CALL сохраняет адрес возврата (адрес следующей инструкции после CALL) в стек и передает управление функции my_function.

3. Получение параметров внутри функции:

```
mov eax, [esp + 4]   ; Первый параметр (3)
mov ebx, [esp + 8]   ; Второй параметр (5)
```

Внутри функции my_function указатель стека ESP указывает на сохраненный адрес возврата. Параметры находятся выше адреса возврата: [ESP + 4] — это первый параметр, [ESP + 8] — это второй параметр.

4. Возврат из функции:

```
ret
```

Инструкция RET извлекает адрес возврата из стека и передает управление обратно вызывающему коду. При этом указатель стека ESP смещается на 4 байта, чтобы удалить адрес возврата.

5 .Очистка стека:

```
add esp, 8
```

После возврата вызывающий код очищает параметры со стека. В данном случае два параметра занимают 8 байт (по 4 байта каждый).

**Пример на языке ассемблера для x86_64**

На x86_64 архитектуре параметры могут передаваться через регистры и стек в зависимости от их количества и типа. Рассмотрим пример с передачей параметров через стек:

```
section .data
    result db 'Result: %d', 0

section .text
    global _start

_start:
    ; Параметры заносятся на стек справа налево
    sub rsp, 16          ; Выделение места на стеке для параметров
    mov qword [rsp + 8], 5  ; Параметр 2
    mov qword [rsp], 3      ; Параметр 1

    call my_function     ; Вызов функции

    ; Очистка стека после вызова функции
    add rsp, 16          ; Освобождение стека

    ; Выход из программы
    mov eax, 60          ; Код sys_exit
    xor edi, edi         ; Код возврата 0
    syscall              ; Вызов системного вызова

my_function:
    ; Получение параметров из стека
    mov rdi, [rsp]       ; Первый параметр (3)
    mov rsi, [rsp + 8]   ; Второй параметр (5)

    ; Логика функции (сложение)
    add rdi, rsi         ; rdi = 3 + 5 = 8

    ; Возврат из функции
    ret
```

Передача параметров на стек — это фундаментальный механизм, обеспечивающий гибкость и универсальность при вызове функций. Понимание этого процесса важно для написания эффективного низкоуровневого кода и работы с различными архитектурами и соглашениями о вызовах.

Когда говорят, что параметры функции заносятся на стек "справа налево", это означает, что параметры функции добавляются в стек в порядке, обратном их объявлению в списке параметров функции. Эта стратегия используется в некоторых соглашениях о вызовах функций (calling conventions), таких как cdecl.

Рассмотрим функцию, которая принимает три параметра:

```c
void example(int a, int b, int c);
```

Если мы вызовем эту функцию следующим образом:

```
example(1, 2, 3);
```

Параметры `1`, `2`, и `3` будут занесены в стек в порядке справа налево. Это означает, что `3` (параметр `c`) будет занесен в стек первым, затем `2` (параметр `b`), и наконец, `1` (параметр `a`).

**Стек после занесения параметров**

Предположим, что указатель стека (ESP) перед вызовом функции указывает на адрес `0xffe264d0`. После занесения параметров стек будет выглядеть следующим образом:

```
Адрес        Значение
0xffe264cc   3 (значение параметра c)
0xffe264d0   2 (значение параметра b)
0xffe264d4   1 (значение параметра a)
```

**Почему так делают?**

1. **Совместимость с механизмом переменного числа аргументов**: В языках программирования, таких как C, часто используются функции с переменным числом аргументов (например, `printf`). При использовании соглашения cdecl первый параметр всегда находится по известному смещению от указателя стека, что упрощает доступ к этим параметрам в функции.
    
2. **Упрощение обработки вызовов функции**: При передаче параметров справа налево указатель стека (ESP) всегда указывает на последний параметр, что позволяет функции легко управлять этими параметрами.
    
**Пример на ассемблере**

Рассмотрим, как это может выглядеть на уровне ассемблера для x86:

```
; Вызов функции example(1, 2, 3)
push 3        ; заносим параметр c
push 2        ; заносим параметр b
push 1        ; заносим параметр a
call example  ; вызываем функцию example
```

В функции `example`, доступ к параметрам осуществляется через указатель стека (ESP):

```
example:
    mov eax, [esp+4]  ; параметр a
    mov ebx, [esp+8]  ; параметр b
    mov ecx, [esp+12] ; параметр c
    ret
```

**Итог**

- **Занесение параметров "справа налево"** означает, что параметры функции добавляются в стек в обратном порядке их объявления.
- **Преимущества** такого подхода включают совместимость с механизмами переменного числа аргументов и упрощение обработки вызовов функций.


### x86_64 с использованием System V ABI

В современных системах x86-64 (64-разрядная архитектура), аргументы функции обычно передаются через регистры, а не через стек. Это отличается от более старых соглашений о вызовах, используемых в x86 (32-разрядная архитектура), где аргументы часто передавались через стек. 

1. **Параметры через регистры**:
    
    - Параметры передаются через регистры до заполнения доступных регистров (например, до 6 регистров).

1. **Остальные параметры через стек**:
    
    - Дополнительные параметры передаются через стек.

1. **Вызов функции**:
    
    - Инструкция `CALL` передает управление функции и сохраняет адрес возврата.

1. **Очистка**:
    
    - Параметры в регистрах остаются неизменными, стек очищается автоматически.

Этот вид соглашения о вызовах называется **System V AMD64 ABI (Application Binary Interface)**. Это стандартное соглашение о вызовах для 64-битных Unix-подобных систем на архитектуре x86-64, таких как Linux, macOS и некоторые другие.

**Основные характеристики System V AMD64 ABI**

1. **Передача аргументов через регистры**:
    
    - Первые шесть целочисленных аргументов передаются через регистры:
        
        - `rdi` — первый аргумент
        - `rsi` — второй аргумент
        - `rdx` — третий аргумент
        - `rcx` — четвертый аргумент
        - `r8` — пятый аргумент
        - `r9` — шестой аргумент

    - Первые восемь аргументов с плавающей точкой передаются через регистры:
        
        - `xmm0` — первый аргумент
        - `xmm1` — второй аргумент
        - `xmm2` — третий аргумент
        - `xmm3` — четвертый аргумент
        - `xmm4` — пятый аргумент
        - `xmm5` — шестой аргумент
        - `xmm6` — седьмой аргумент
        - `xmm7` — восьмой аргумент

1. **Передача аргументов через стек**:
    
    - Если у функции более шести целочисленных аргументов или более восьми аргументов с плавающей точкой, оставшиеся аргументы передаются через стек.

1. **Возврат значений**:
    
    - Целочисленные значения и указатели возвращаются через регистр `rax`.
    - Значения с плавающей точкой возвращаются через регистр `xmm0`.

1. **Резервирование пространства в стеке**:
    
    - Входная функция должна резервировать определенное пространство в стеке для хранения значений регистров, которые могут быть затронуты вызовом функции.


**Пример вызова функции на x86_64:**


```
; Пример вызова функции на x86_64 System V ABI
mov rdi, 3          ; Первый параметр (в регистре rdi)
mov rsi, 5          ; Второй параметр (в регистре rsi)
call my_function    ; Вызов функции
```

**Функция на языке C:**

```c
int my_function(int a, int b) {
    return a + b;
}
```

Рассмотрим другой пример функции с большим количеством аргументов, чтобы показать, как они передаются:


```c
void example_function(int a, int b, int c, int d, int e, int f, int g, int h);
```

**Соответствующий код на ассемблере**:

```
section .text
global _start

_start:
    ; Передача первых шести аргументов через регистры
    mov rdi, 1      ; Первый аргумент a
    mov rsi, 2      ; Второй аргумент b
    mov rdx, 3      ; Третий аргумент c
    mov rcx, 4      ; Четвертый аргумент d
    mov r8,  5      ; Пятый аргумент e
    mov r9,  6      ; Шестой аргумент f

    ; Передача оставшихся аргументов через стек
    sub rsp, 16     ; Выделяем место на стеке для двух аргументов (g и h)
    mov QWORD [rsp+8], 8  ; Восьмой аргумент h (аргументы идут в обратном порядке)
    mov QWORD [rsp], 7    ; Седьмой аргумент g

    ; Вызов функции example_function
    call example_function

    ; Завершение программы
    mov eax, 60     ; Системный вызов для выхода (exit)
    xor edi, edi    ; Код возврата 0
    syscall

example_function:
    ; Функция example_function получает аргументы как указано выше
    ; ...
    ret
```
### Выводы

В x86-64 архитектуре аргументы функций передаются через регистры до тех пор, пока их количество не превышает шесть. Когда аргументов больше шести, оставшиеся передаются через стек. Соглашение о вызовах System V AMD64 ABI используется в большинстве 64-битных Unix-подобных систем и определяет, как функции должны передавать аргументы и возвращать значения, что позволяет компиляторам и программистам на ассемблере создавать совместимый код.



- **Стек как механизм**: На многих платформах параметры функции действительно заносятся на стек, что позволяет передавать данные функции и возвращать управление.
- **Архитектура и соглашение о вызовах**: Определяют точный порядок и способ передачи параметров.
- **Регистры и стек**: В современных системах часто используется комбинация регистров и стека для оптимальной передачи параметров.

Понимание этих механизмов важно для написания и отладки низкоуровневого кода, а также для работы с бинарными файлами и протоколами.

## Глобальные объявления и начало программы

```
section .text
global _start
```

- **section .text**: Эта секция определяет сегмент кода, в котором находятся исполняемые инструкции.
- **global `_start`**: Директива делает метку _start доступной для компоновщика как точку входа в программу.

## Основной код (`_start`)

```
_start:
    ; Вызов функции с двумя параметрами
    push dword 10      ; Параметр 2
    push dword 20      ; Параметр 1
    call func
    add esp, 8         ; Очистка параметров из стека

    ; Завершение программы
    mov eax, 1
    int 0x80
```

- **push dword 10**: В стек помещается значение 10, которое будет передано как второй параметр функции func.
- **push dword 20**: В стек помещается значение 20, которое будет передано как первый параметр функции func.
- **call func**: Выполняется вызов функции func. При этом адрес возврата помещается в стек, и управление передается на метку func.
- **add esp, 8**: После возврата из функции из стека убираются два параметра по 4 байта каждый (8 байт в сумме), чтобы восстановить стек.
## Завершение программы

- **mov eax, 1**: В регистр eax помещается код системного вызова exit (1).
- **int 0x80**: Выполняется системный вызов exit, завершая программу.
## Код функции (func)

```
func:
    push ebp           ; Сохранение старого EBP
    mov ebp, esp       ; Установка нового EBP
    sub esp, 4         ; Резервирование места для локальной переменной

    ; Доступ к параметрам и локальной переменной
    mov eax, [ebp + 8] ; Доступ к параметру 1 (20)
    mov ebx, [ebp + 12]; Доступ к параметру 2 (10)
    mov [ebp - 4], eax ; Локальная переменная = 20

    ; Эпилог функции
    mov esp, ebp       ; Восстановление старого ESP
    pop ebp            ; Восстановление старого EBP
    ret
```

- **push ebp**: Текущий регистр ebp сохраняется в стек для дальнейшего восстановления.
- **mov ebp, esp**: Устанавливается новый базовый указатель кадра стека ebp для доступа к параметрам и локальным переменным.
- **sub esp, 4**: Резервируется 4 байта в стеке для локальной переменной.

## Доступ к параметрам и локальной переменной

- **mov eax, [ebp + 8]**: Значение первого параметра (20) помещается в регистр eax. Параметры находятся выше базового указателя кадра ebp (4 байта для адреса возврата + 4 байта для параметра).
- **mov ebx, [ebp + 12]**: Значение второго параметра (10) помещается в регистр ebx.
- **mov [ebp - 4], eax**: Локальная переменная, расположенная ниже ebp на 4 байта, получает значение из eax (то есть 20).

Регистр EBP (Base Pointer) в x86 архитектуре процессора используется как указатель на начало текущего фрейма стека. EBP обычно указывает на базу (base) текущего фрейма стека, что позволяет функциям обращаться к своим локальным переменным и параметрам функции через смещения относительно EBP. Регистр ebp (base pointer) на самом деле указывает на базу текущего фрейма стека функции (конец пролога функции). Фрейм стека - это область памяти, выделенная для хранения локальных переменных функции, аргументов и другой информации, необходимой для выполнения функции.

В обычном случае, ebp указывает на базу текущего фрейма, а esp указывает на его вершину (текущее местоположение стека), то есть на место, где сохраняются адрес возврата и локальные переменные. Таким образом, ebp не указывает на дно стека в целом, а служит для упорядочения структуры стека в рамках отдельной функции.

Когда функция начинает выполнение, она резервирует место на стеке для хранения своих локальных переменных, аргументов и другой информации. Регистр ebp указывает на начало этого фрейма или базу стека, а выделенная область расширяется вниз по стеку для хранения данных функции. Таким образом, ebp указывает на начало или базу фрейма стека функции.

## Адресация Параметров и Локальных Переменных

При вызове функции параметры и локальные переменные располагаются в стеке в определенном порядке.

### Пример Адресации на Архитектуре x86

1. **Указатель стека (ESP)**: Указывает на вершину стека.
2. **Базовый указатель (EBP)**: Используется для адресации параметров и локальных переменных функции.

```
; Пример вызова функции и работы с параметрами и локальными переменными
section .text
global _start

_start:
    ; Вызов функции с двумя параметрами
    push dword 10      ; Параметр 2
    push dword 20      ; Параметр 1
    call func
    add esp, 8         ; Очистка параметров из стека

    ; Завершение программы
    mov eax, 1
    int 0x80

func:
    push ebp           ; Сохранение старого EBP
    mov ebp, esp       ; Установка нового EBP
    sub esp, 4         ; Резервирование места для локальной переменной

    ; Доступ к параметрам и локальной переменной
    mov eax, [ebp + 8] ; Доступ к параметру 1 (20)
    mov ebx, [ebp + 12]; Доступ к параметру 2 (10)
    mov [ebp - 4], eax ; Локальная переменная = 20

    ; Эпилог функции
    mov esp, ebp       ; Восстановление старого ESP
    pop ebp            ; Восстановление старого EBP
    ret
```

- **[ebp + 8]**: Доступ к первому параметру (20).
- **[ebp + 12]**: Доступ ко второму параметру (10).
- **[ebp - 4]**: Доступ к локальной переменной.

Перед вызовом функции нужно закинуть параметр функций в стек (`push <value>`) потом вызвать саму функцию. После выполнение функций освобождаем память (`add <value>`). Также это зависит от архитектуры и соглашение о вызове.

### Пример Адресации на Архитектуре x86_64

На x86_64 также используются указатели стека (RSP) и базовый указатель (RBP):

```
; Пример вызова функции и работы с параметрами и локальными переменными
section .text
global _start

_start:
    ; Вызов функции с двумя параметрами
    push rdi           ; Параметр 2 (10)
    push rsi           ; Параметр 1 (20)
    call func
    add rsp, 16        ; Очистка параметров из стека

    ; Завершение программы
    mov rax, 60        ; Системный вызов exit
    xor rdi, rdi       ; Код возврата 0
    syscall

func:
    push rbp           ; Сохранение старого RBP
    mov rbp, rsp       ; Установка нового RBP
    sub rsp, 8         ; Резервирование места для локальной переменной

    ; Доступ к параметрам и локальной переменной
    mov rax, [rbp + 16]; Доступ к параметру 1 (20)
    mov rbx, [rbp + 24]; Доступ ко второму параметру (10)
    mov [rbp - 8], rax ; Локальная переменная = 20

    ; Эпилог функции
    mov rsp, rbp       ; Восстановление старого RSP
    pop rbp            ; Восстановление старого RBP
    ret
```

- **[rbp + 16]**: Доступ к первому параметру.
- **[rbp + 24]**: Доступ ко второму параметру.
- **[rbp - 8]**: Доступ к локальной переменной.

Для иллюстрации, как это выглядит в высокоуровневом языке:

```
void func(int param1, int param2) {
    int local_var = param1 + param2;
}
```

В ассемблерном коде для x86 это может выглядеть следующим образом:

```
func:
    push ebp           ; Сохранение старого EBP
    mov ebp, esp       ; Установка нового EBP
    sub esp, 4         ; Резервирование места для локальной переменной

    ; Параметры и локальная переменная
    mov eax, [ebp + 8] ; param1
    mov ebx, [ebp + 12]; param2
    add eax, ebx
    mov [ebp - 4], eax ; local_var

    ; Эпилог функции
    mov esp, ebp       ; Восстановление старого ESP
    pop ebp            ; Восстановление старого EBP
    ret
```


Доступ к первому параметру функции осуществляется по адресу [ebp + 8], а не [ebp + 4], из-за структуры и порядка размещения данных в стеке при вызове функции на архитектуре x86. Давайте подробно рассмотрим, почему это так.

## Эпилог функции

- **mov esp, ebp**: Восстанавливается значение указателя стека, соответствующее началу кадра.
- **pop ebp**: Восстанавливается старое значение базового указателя кадра.
- **ret**: Возврат из функции, при этом адрес возврата снимается из стека и управление передается обратно в вызвавший код.

## Итоговая схема

Программа сначала сохраняет два параметра в стеке и вызывает функцию func. Функция получает параметры, обрабатывает их и завершает выполнение, возвращая управление основной программе, которая затем завершает выполнение через системный вызов.

## Визуализация стека

```
|       10       |   <-- Параметр 2 (20)
|       20       |   <-- Параметр 1 (20)
| адрес возврата |
|    старый EBP  |
|       ...      |
| локальная пе - |
|  ременная (20) |
```

Этот код иллюстрирует базовые операции работы со стеком и вызовами функций на языке ассемблера x86. 

## Структура стека при вызове функции

Когда вызывается функция на архитектуре x86, происходит следующее:

**1. Вызов функции:**

- Параметры функции помещаются в стек с помощью команд push в обратном порядке.
- Адрес возврата (IP/EIP) автоматически помещается в стек после выполнения команды call.

**2. Начало функции:**

- В начале функции выполняется сохранение текущего значения указателя базы (EBP) в стеке.
- Затем указатель базы (EBP) устанавливается на текущее значение указателя стека (ESP).

## Пример: Вызов и выполнение функции

### Вызов функции

Допустим, у нас есть функция func с двумя параметрами:

```scss
; Стек до вызова функции (ESP указывает на вершину стека)
; [ESP]    <- свободное место (до вызова функции)

; Вызов функции с двумя параметрами
push 10    ; Параметр 2
push 20    ; Параметр 1
call func  ; Вызов функции, адрес возврата помещается в стек

; [ESP + 0]    <- Параметр 1 (20)
; [ESP + 4]    <- Параметр 2 (10)
; [ESP + 8]    <- Адрес возврата (EIP после call)
```

### Выполнение функции

При входе в функцию func выполняются следующие шаги:

```scss
func:
    push ebp           ; Сохранение старого EBP
    mov ebp, esp       ; Установка нового EBP
    sub esp, 4         ; Резервирование места для локальной переменной

    ; Стек после установки EBP и ESP:
    ; [EBP]    <- Старый EBP
    ; [EBP + 4] <- Адрес возврата
    ; [EBP + 8] <- Параметр 1 (20)
    ; [EBP + 12] <- Параметр 2 (10)

    ; Доступ к параметрам
    mov eax, [ebp + 8] ; Доступ к параметру 1 (20)
    mov ebx, [ebp + 12]; Доступ ко второму параметру (10)

    ; Эпилог функции
    mov esp, ebp       ; Восстановление старого ESP
    pop ebp            ; Восстановление старого EBP
    ret
```

### Разбиение Структуры Стека

Когда вызывается функция, стек организуется следующим образом (для двух параметров):

```scss
[ESP + 0]    <- Параметр 1 (20)
[ESP + 4]    <- Параметр 2 (10)
[ESP + 8]    <- Адрес возврата (EIP после команды call)
[ESP + 12]   <- Старый EBP (после команды push ebp)
[ESP + 16]   <- Место для локальной переменной (после sub esp, 4)
```

После выполнения mov ebp, esp, указатель базы (EBP) указывает на старый ESP, который теперь стал началом кадра стека для текущей функции.

```
[EBP]: указывает на старое значение EBP.
[EBP + 4]: адрес возврата (следующий после выполнения функции командный адрес).
[EBP + 8]: первый параметр функции.
[EBP + 12]: второй параметр функции.
```

Адрес возврата функции обычно находится по адресу ebp+4 – это значение сохраняется в стеке перед вызовом функции. После завершения выполнения функции, управление возвращается на адрес, который был сохранен в стеке. В отладочных ситуациях и при работе с low-level программированием можно также воспользоваться регистром eip (instruction pointer), который хранит адрес следующей инструкции, которая должна быть выполнена процессором. 

Таким образом, для нахождения адреса возврата функции, можно использовать ebp+4 или регистр eip, в зависимости от методов отладки и требований конкретной ситуации.
### Почему [EBP + 8] для первого параметра?

Адрес первого параметра находится на 8 байт выше значения указателя базы (EBP), потому что перед ним в стеке располагаются:

- **Старое значение EBP ([EBP])**
- **Адрес возврата ([EBP + 4])**

Следовательно, первый параметр функции располагается на 8 байт выше EBP ([EBP + 8]).

## Визуализация Структуры Стека

Вот визуализация, как выглядит стек при вызове функции с двумя параметрами:

```
[EBP]      <- Старый EBP
[EBP + 4]  <- Адрес возврата (EIP после call)
[EBP + 8]  <- Параметр 1 (20)
[EBP + 12] <- Параметр 2 (10)
[ESP]      <- Вершина стека после sub esp, 4
```

Таким образом, доступ к первому параметру функции осуществляется по адресу [EBP + 8], потому что первые 4 байта отведены для адреса возврата, а следующие 4 байта — это сам параметр.

Таким образом, [EBP + 8] используется для доступа к первому параметру функции, а [EBP + 12] — ко второму параметру, потому что стек организован таким образом, что при вызове функции сначала сохраняется адрес возврата, затем параметры функции, и старое значение EBP.

# Куча

Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершени приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.
Размер кучи задаётся во время запуска приложения, однако, в отличие от того, как работает стек, в куче размер ограничен только физически, что позволяет создавать переменные динамического типа

Если сравнивать, опять же, с тем, как работает стек, то куча функционирует медленнее, т. к. переменные разбросаны по памяти, а не находятся вверху стека. Тем не менее данный факт не уменьшает важности кучи, и если вам надо работать с глобальными либо динамическими переменными, она больше подходит. Однако управлять памятью тогда должен программист либо сборщик мусора.

Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны. Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.

В  сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей. По умолчанию все глобальные переменные хранятся в памяти кучи. Куча не управляется автоматически и не так жестко управляется ЦП. Это больше похоже на свободно плавающую область памяти.

![[Pasted image 20221011094246.png]]


# Заключение

Для эффективного обращения к данным в стеке, необходимо понимать, как данные расположены относительно указателей стека и как к ним обращаться с использованием относительных смещений. Это позволяет корректно адресовать локальные переменные и параметры функций, обеспечивая правильное функционирование программ и систем.

В стеке могут храниться различные данные и переменные, такие как числа, символы, адреса памяти и т.д. Стек используется для организации временного хранения данных во время выполнения программы. Например, стек используется для хранения локальных переменных функций, адресов возврата, параметров функций и других временных данных. Когда функция вызывается, ее локальные переменные помещаются в стек, а когда функция завершает свою работу, они извлекаются из стека. Это обеспечивает корректную работу программы и эффективное управление памятью.

В стеке также могут храниться адреса возврата, указатели на данные или функции, временные переменные, структуры данных, адреса памяти, локальные переменные и регистры процессора. Стек также используется для передачи параметров функциям, хранения контекста вызова функций, управления памятью и обработки исключений. В общем, в стеке могут храниться различные типы данных и информация, необходимая для обеспечения правильного выполнения программы. В стеке хранятся не только параметры функции и переменные, но и адреса возврата, указатели на предыдущие фреймы стека, а также сохраненные значения регистров и прочие локальные данные. Однако инструкции программы хранятся в других областях памяти, таких как секция кода (code section).
