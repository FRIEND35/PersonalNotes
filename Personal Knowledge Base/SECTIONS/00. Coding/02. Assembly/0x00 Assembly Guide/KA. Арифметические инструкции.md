На этом уроке мы будем разбираться с арифметическими инструкциями в [**ассемблере**](https://ravesli.com/assembler-vstuplenie/) на примере INC, DEC, ADD, SUB и пр.


# Инструкция INC

**Инструкция INC** (от англ. _«**INC**REMENT»_) используется для увеличения операнда на единицу. Она работает с одним операндом, который может находиться либо в [**регистре**](https://ravesli.com/assembler-segmenty-pamyati-i-registry/), либо в памяти.

**Синтаксис инструкции** **INC**:

>`INC место_назначения`

Операндом `место_назначения` может быть 8-битный, 16-битный или 32-битный операнд.

Пример:

```
INC EBX      ; выполняем инкремент 32-битного регистра

INC DL       ; выполняем инкремент 8-битного регистра

INC [count]  ; выполняем инкремент переменной count

INC o1       ; o1 = o1 + 1

```


# Инструкция DEC

**Инструкция DEC** (от англ. _«**DEC**REMENT»_) используется для уменьшения операнда на единицу. Она работает с одним операндом, который может находиться либо в регистре, либо в памяти.

**Синтаксис инструкции** **DE****C**:

`DEC место_назначения`

Операндом `место_назначения` может быть 8-битный, 16-битный или 32-битный операнд.

Пример:

```
segment .data

   count dw  0
   value db  15

segment .text

   inc [count]
   dec [value]
   mov ebx, count
   inc word [ebx]
   mov esi, value
   dec byte [esi]
  ```


# Инструкции ADD и SUB

Инструкции ADD и SUB используются для выполнения простого сложения/вычитания двоичных данных размером один byte, word или doubleword, то есть для сложения или вычитания 8-битных, 16-битных или 32-битных операндов, соответственно.  ADD – делает простое арифметическое сложение. ADD требует два оперенда, делает сложение над ними, предыдущая значения
первого оперенда теряется и сохраняет результат сложение на первом оперенде. 

**Синтаксис инструкций** **ADD** **и** **SUB**:

ADD/SUB  Пример умножения в Ассемблере
Итак, например, нам надо умножить 150 на 250. Тогда мы делаем так:

```
MOV AL, 150  ; Первый множитель в регистр AL
MOV BL, 250  ; Второй множитель в регистр BL
MUL BL       ; Теперь АХ = 150 * 250 = 37500
```

Обратите внимание, что нам приходится два раза использовать команду MOV, так как команда MUL не работает непосредственно с числами, а только с регистрами общего назначения или с памятью.
После выполнения этого кода в регистре АХ будет результат умножения чисел 150 и 250, то есть число 37500 (927С в шестнадцатеричной системе).    место_назначения, источник`

Инструкции ADD/SUB могут выполняться между:

   - регистром и регистром;

   - памятью и регистром;

   - регистром и памятью;

   - регистром и [**константами**](https://ravesli.com/assembler-peremennye-i-konstanty/);

   - памятью и константами.



Однако, как и для других инструкций, операции типа память-в-память невозможны с использованием инструкций ADD/SUB. Операции ADD или SUB устанавливают или сбрасывают флаги переполнения и переноса.

В следующем примере мы спрашиваем у пользователя два числа, сохраняем их в регистрах EAX и EBX, затем выполняем операцию сложения, сохраняем результат в ячейке памяти `res` и выводим его на экран:


```
SYS_EXIT  equ 1
SYS_READ  equ 3
SYS_WRITE equ 4
STDIN     equ 0
STDOUT    equ 1

segment .data

   msg1 db "Enter a digit ", 0xA,0xD
   len1 equ $- msg1

   msg2 db "Please enter a second digit", 0xA,0xD
   len2 equ $- msg2

   msg3 db "The sum is: "
   len3 equ $- msg3

segment .bss

   num1 resb 2
   num2 resb 2
   res resb 1    

section .text

   global _start    ; должно быть объявлено для использования gcc

_start:             ; сообщаем линкеру входную точку

   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg1        
   mov edx, len1
   int 0x80                

   mov eax, SYS_READ
   mov ebx, STDIN  
   mov ecx, num1
   mov edx, 2
   int 0x80            

   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg2          
   mov edx, len2        
   int 0x80

   mov eax, SYS_READ  
   mov ebx, STDIN  
   mov ecx, num2
   mov edx, 2
   int 0x80        

   mov eax, SYS_WRITE        
   mov ebx, STDOUT        
   mov ecx, msg3          
   mov edx, len3        
   int 0x80

   ; перемещаем первое число в регистр EAX, а второе число - в регистр EBX
   ; и вычитаем ASCII '0' для конвертации в десятичное число

   mov eax, [num1]
   sub eax, '0'
   mov ebx, [num2]
   sub ebx, '0'

   ; складываем eax и ebx
   add eax, ebx

   ; добавляем '0' для конвертации суммы из десятичной системы в ASCII
   add eax, '0'

   ; сохраняем сумму в ячейке памяти res
   mov [res], eax

   ; выводим сумму
   mov eax, SYS_WRITE        
   mov ebx, STDOUT
   mov ecx, res        
   mov edx, 1        
   int 0x80

exit:    

   mov eax, SYS_EXIT  
   xor ebx, ebx
   int 0x80

   ```
   
**Результат выполнения программы:

`Enter a digit:
`3   
`Please enter a second digit:
`4   
`The sum is: 
`7`


Ниже рассмотрен пример, в котором за счет того, что значения переменных для арифметических выражений прописаны в самом коде программы, можно получить код программы короче и проще:


```
section .text

   global _start    ; должно быть объявлено для использования gcc

_start:             ; сообщаем линкеру входную точку

   mov eax,'3'
   sub     eax, '0'
   
   mov ebx, '4'
   sub     ebx, '0'
   add eax, ebx
   add eax, '0'

   mov [sum], eax
   mov ecx,msg
   mov edx, len
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80  ; вызов ядра

   mov ecx,sum
   mov edx, 1
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80  ; вызов ядра

   mov eax,1 ; номер системного вызова (sys_exit)
   int 0x80  ; вызов ядра

section .data

   msg db "The sum is:", 0xA,0xD
   len equ $ - msg  

segment .bss

   sum resb 1

   ```
   
***Результат выполнения программы:

`The sum is:   7`

sub eax, '0' - это инструкция в ассемблере x86 для вычитания ASCII-кода символа '0' из значения, которое находится в регистре eax. Например, если в регистре eax хранится ASCII-код цифры '4' (который равен 52), выполнение sub eax, '0' приведет к результату 4, так как ASCII-код символа '0' равен 48. Таким образом, данная инструкция используется для конвертации ASCII-кода цифры в фактическое числовое значение.

Давйте разберем наш код. Сначало мы переместили число ‘3’ ( ASCII ) в регистр eax (mov eax, ‘3’), потом мы конвертировали число “3” с ASCII в десятичный с помощью простой операции ( sub eax, “0”). Такую операцию мы повторили и с регистром ebx. После того как числа были записаны в регистр и были конвертированы с ASCII в десятичный число, мы можем выполнить нашу арифметическую операцию –
что мы и сделали ( add eax, ebx). Чтобы вывести результать вычислении, нам нужно в регистр eax переместить число 4, но в регистре eax находится результать нашей вычислении и если мы туда запишем число 4 то результать будет потерян. Поэтому мы создали неинициализированную переменную sum который принимает 1 байт. Мы копируем результат нашей вычислении в неинициализированную переменную sub чтобы его не потерять. После чего закидываем число 4 в eax и печатаем сообщения на экран и результать который находится в переменной num.

# Инструкции MUL и IMUL

  

Есть 2 инструкции для умножения двоичных данных:

   - **инструкция MUL** (от англ. _«**MUL**TIPLY»_) обрабатывает данные [**unsigned**](https://ravesli.com/urok-31-tselochislennyj-tip-dannyh-integer/#toc-2);

   - **инструкция IMUL** (от англ. _«**I**NTEGER **MUL**TIPLY»_) обрабатывает данные signed.

Обе инструкции влияют на флаги переноса и переполнения.

**Синтаксис инструкций** **MUL/****IMUL**:

>`MUL/IMUL множитель`

Множимое в обоих случаях будет находиться в аккумуляторе, в зависимости от размера множимого и множителя, и результат умножения также сохраняется в двух регистрах, в зависимости от размера операндов.

Рассмотрим 3 разных сценария:

_**Сценарий №1**:_ **Перемножаются 2 значения типа byte**. Множимое находится в регистре AL, а множителем является значение типа byte в памяти или в другом регистре. Результат произведения находится в AX. Старшие 8 бит произведения хранятся в AH, а младшие 8 бит хранятся в AL:


![[Pasted image 20220930124431.png]]


**_Сценарий №2:_ Перемножаются 2 значения типа word**. Множимое должно находиться в регистре AX, а множителем является значение типа word в памяти или в другом регистре. Например, для такой инструкции, как `MUL DX`, вы должны сохранить множитель в DX, а множимое — в AX. В результате получится значение типа doubleword, для которого понадобятся два регистра. Часть высшего порядка (крайняя слева) сохраняется в DX, а часть нижнего порядка (крайняя справа) сохраняется в AX:

![[Pasted image 20220930124447.png]]

**_Сценарий №3:_ Перемножаются 2 значения типа** **doubleword**. Множимое должно находиться в EAX, а множителем является значение типа doubleword, хранящееся в памяти или в другом регистре. Результат умножения сохраняется в регистрах EDX и EAX. Биты старшего порядка сохраняются в регистре EDX, а биты младшего порядка сохраняются в регистре EAX:

![[Pasted image 20220930124459.png]]



Инструкция MUL в Ассемблере выполняет умножение без знака. Понять работу команды MUL несколько сложнее, чем это было для
команд, рассмотренных ранее. Но, надеюсь, что я помогу вам в этом разобраться. Команда mul принимает один оперенд.
Итак, синтаксис команды MUL такой:

>MUL ОПЕРЕНД

Оперендом может быть один из следующих:

 - Область памяти (MEM)
 - Регистр общего назначения (REG)

Эта команда не работает с сегментными регистрами, а также не работает непосредственно с числами. То есть вот так

>MUL 200 ; неправильно

делать нельзя. Для начала обратите внимание, что инструкция MUL работает либо с регистром АХ, либо с регистром AL. То есть перед выполнением этой команды нам надо записать в регистр АХ или в регистр AL значение, которое будет участвовать в умножении. Сделать это можно, например, с помощью уже известной нам команды MOV. Затем мы выполняем умножение, и получаем результат либо в регистр АХ (если ЧИСЛО - это байт), либо в пару регистров DX и AX (если ЧИСЛО - это слово). Причём в последнем случае в регистре DX будет старшее слово, а в регистре AX - младшее. 

## Пример умножения в Ассемблере
Итак, например, нам надо умножить 150 на 250. Тогда мы делаем так:


```
MOV AL, 150  ; Первый множитель в регистр AL
MOV BL, 250  ; Второй множитель в регистр BL
MUL BL       ; Теперь АХ = 150 * 250 = 37500
  ```

Обратите внимание, что нам приходится два раза использовать команду MOV, так как команда MUL не
работает непосредственно с числами, а только с регистрами общего назначения или с памятью.
После выполнения этого кода в регистре АХ будет результат умножения чисел 150 и 250, то есть число
37500 (927С в шестнадцатеричной системе).

Пример:


```
MOV AL, 10
MOV DL, 25
MUL DL

...

MOV DL, 0FFH ; DL= -1
MOV AL, 0BEH ; AL = -66
IMUL DL
  ```
  
А в следующем примере мы 3 умножаем на 2 и выводим результат:


```
section .text

   global _start    ; должно быть объявлено для использования gcc

_start:             ; сообщаем линкеру входную точку

   mov al,'3'
   sub     al, '0'
   
   mov bl, '2'
   sub     bl, '0'
   mul bl
   add al, '0'
   
   mov [res], al
   mov ecx,msg
   mov edx, len
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80 ; вызов ядра

   mov ecx,res
   mov edx, 1
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80 ; вызов ядра

   mov eax,1 ; номер системного вызова (sys_exit)
   int 0x80 ; вызов ядра

section .data

msg db "The result is:", 0xA,0xD
len equ $- msg  

segment .bss

res resb 1
   ```

***Результат выполнения программы:

`The result is:   6`


# Инструкции DIV и IDIV

Операция деления генерирует два элемента: **частное** и **остаток**. В случае умножения переполнения не происходит, так как для хранения результата используются регистры двойной длины. Однако в случае деления, переполнение может произойти. Если это произошло, то процессор генерирует прерывание.

**Инструкция DIV** (от англ. _«**DIV**IDE»_) используется с данными unsigned, а **инструкция IDIV** (от англ. _«**I**NTEGER **DIV**IDE»_) используется с данными signed.

**Синтаксис инструкций** **DIV****/****IDIV**:

>`DIV/IDIV     делитель`

Делимое находится в аккумуляторе. Обе инструкции могут работать с 8-битными, 16-битными или 32-битными операндами. Данная операция влияет на все 6 флагов состояния.

Рассмотрим следующие 3 сценария:

_**Сценарий №1**:_ **Делителем является значение типа byte**. Предполагается, что делимое находится в регистре AX (16 бит). После деления частное переходит в регистр AL, а остаток переходит в регистр AH:

![[Pasted image 20220930124712.png]]

**_Сценарий №2:_** **Делителем является значение типа word**. Предполагается, что делимое имеет длину 32 бита и находится в регистрах DX и AX. Старшие 16 бит находятся в DX, а младшие 16 бит — в AX. После деления 16-битное частное попадает в регистр AX, а 16-битный остаток — в регистр DX:

![[Pasted image 20220930124732.png]]

**_Сценарий №3:_** **Делителем является значение типа doubleword**. Предполагается, что размер делимого составляет 64 бита и оно размещено в регистрах EDX и EAX. Старшие 32 бита находятся в EDX, а младшие 32 бита — в EAX. После деления 32-битное частное попадает в регистр EAX, а 32-битный остаток — в регистр EDX:

![[Pasted image 20220930124746.png]]


В следующем примере мы делим 8 на 2. Делимое 8 сохраняется в 16-битном регистре AX, а делитель 2 — в 8-битном регистре BL:


```
section .text

   global _start    ; должно быть объявлено для использования gcc

_start:             ; сообщаем линкеру входную точку

   mov ax,'8'
   sub     ax, '0'
   
   mov bl, '2'
   sub     bl, '0'
   div bl
   add ax, '0'

   mov [res], ax
   mov ecx,msg
   mov edx, len
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80 ; вызов ядра

   mov ecx,res
   mov edx, 1
   mov ebx,1 ; файловый дескриптор (stdout)
   mov eax,4 ; номер системного вызова (sys_write)
   int 0x80 ; вызов ядра

   mov eax,1 ; номер системного вызова (sys_exit)
   int 0x80 ; вызов ядра

section .data

msg db "The result is:", 0xA,0xD
len equ $- msg  

segment .bss

res resb 1
  ```
  
**Результат выполнения программы:

`The result is:   4`