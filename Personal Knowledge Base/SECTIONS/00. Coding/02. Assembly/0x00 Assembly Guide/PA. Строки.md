Строки с переменной в качестве длины могут содержать столько символов, сколько необходимо. Как правило, длина строки указывается одним из следующих двух способов:

 - Явное содержание длины строки;

 - Использование сигнального символа.

Мы можем явно хранить длину строки, используя символ счетчика местоположения $, который предоставляет текущее значение счетчика местоположения строки. Например:

>msg db 'Hello, world!',0xa ; наша строка
  len equ $ - msg    ; длина нашей строки

Символ $ указывает на byte после последнего символа строковой переменной msg. Следовательно, $ - msg указывает на длину строки. Мы также можем написать:

>msg db 'Hello, world!',0xa ; наша строкаlen equ 13  ; длина нашей строки

То есть $ - используется для ссылки на текущий адрес, ну типа – Хэй адрес этой строки вот тут, который будет равен длинны строки.

В качестве альтернативы мы можем хранить строки с завершающим сигнальным символом. Сигнальным символом является специальный символ, который не должен находиться внутри строки. Например:

>message DB 'I am loving it!', 0


# Строковые инструкции

Каждая строковая инструкция может требовать исходного операнда и операнда назначения. Для 32-битных сегментов строковые инструкции используют [**регистры**](https://ravesli.com/assembler-segmenty-pamyati-i-registry/) ESI и EDI, чтобы указать на операнды источника и назначения, соответственно.

Однако для 16-битных сегментов, чтобы указать на источник и место назначения, используются другие регистры: SI и DI.

**Существует 5 основных инструкций для работы со строками в Ассемблере**:

   - `MOVS` — эта инструкция перемещает 1 [**byte, word или doubleword**](https://ravesli.com/assembler-peremennye-i-konstanty/) данных из одной ячейки памяти в другую;

   - `LODS` — эта инструкция загружается из памяти. Если операндом является значение типа byte, то оно загружается в регистр AL, если типа word — загружается в регистр AX, если типа doubleword — загружается в регистр EAX;

   - `STOS` — эта инструкция сохраняет данные из регистра (AL, AX или EAX) в память;

   - `CMPS` — эта инструкция сравнивает два элемента данных в памяти. Данные могут быть размера byte, word или doubleword;

   - `SCAS` — эта инструкция сравнивает содержимое регистра (AL, AX или EAX) с содержимым элемента, находящегося в памяти.

Каждая из вышеприведенных инструкций имеет версии byte, word или doubleword, а строковые инструкции могут повторяться с использованием префикса повторения.

Эти инструкции используют пары регистров `ES:DI` и `DS:SI`, где регистры DI и SI содержат валидные адреса смещения, которые относятся к байтам, хранящимся в памяти. SI обычно ассоциируется с DS (сегмент данных), а DI всегда ассоциируется с ES (дополнительный сегмент).

Регистры `DS:SI` (или ESI) и `ES:DI` (или EDI) указывают на операнды источника и назначения, соответственно. Предполагается, что операндом-источником является `DS:SI` (или ESI), а операндом назначения — место в памяти, на которое указывает пара `ES:DI` (или EDI).

Для 16-битных адресов используются регистры SI и DI, а для 32-битных адресов используются регистры ESI и EDI.

В следующей таблице представлены различные версии строковых инструкций и предполагаемое место операндов:


| **Основная инструкция** | **Операнды в:**     | **Операция byte**     | **Операция word**     | **Операция doubleword** |
| ------------------- | --------------- | ----------------- | ----------------- | ----------------------- |
| **MOVS**                | ES:DI, DS:SI    | MOVSB             | MOVSW             | MOVSD                   |
| **LODS**                | AX, DS:SI       | LODSB             | LODSW             | LODSD                   |
| **STOS**                | ES:DI, AX       | STOSB             | STOSW             | STOSD                   |
| **CMPS**                | DS:SI, ES:DI    | CMPSB             | CMPSW             | CMPSD                   |
| **SCAS**                | ES:DI, AX       | SCASB             | SCASW             |      SCASD                   |


## Инструкция MOVS

**Инструкция MOVS** используется для копирования элемента данных (byte, word или doubleword) из исходной строки в строку назначения. Исходная строка указывается с помощью `DS:SI`, а строка назначения указывается с помощью `ES:DI`.

**Рассмотрим это на практике:


```
section .text
   global _start        ; должно быть объявлено для использования gcc

_start:                 ; сообщаем линкеру входную точку

   mov ecx, len
   mov esi, s1
   mov edi, s2
   cld
   rep movsb

   mov edx,20         ; длина сообщения
   mov ecx,s2         ; сообщение для вывода на экран
   mov ebx,1         ; файловый дескриптор (stdout)
   mov eax,4         ; номер системного вызова (sys_write)
   int 0x80         ; вызов ядра

   mov eax,1         ; номер системного вызова (sys_exit)
   int 0x80         ; вызов ядра

section .data
   s1 db 'Hello, world!',0     ; первая строка
   len equ $-s1

section .bss
   s2 resb 20      ; назначение

```

**Результат:

`Hello, world!`


## Инструкция LODS

LODS — эта инструкция загружается из памяти. Если операндом является значение типа byte, то оно загружается в регистр AL, если типа word — загружается в регистр AX, если типа doubleword — загружается в регистр EAX;

Могут использоваться для копирования какого-то участка памяти в другое место с выполнением над данными каких-либо действий. Используются в паре с командами STOS, STOSB, STOSW, STOSD, которые выполняют обратные действия по сохранению значения регистра в память.

### LODSB
Команда LODSB копирует один байт из памяти по адресу DS:SI в регистр AL. После выполнения команды, регистр SI увеличивается на 1, если флаг DF = 0, или уменьшается на 1, если DF = 1.

Если команда используется в 32-разрядном режиме адресации, то используется регистр ESI.Пример:

>
mov  si, offset str1
cld
lodsb

В криптографии шифр Цезаря является одним из самых простых известных методов шифрования. В этом методе каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите.

В этом примере давайте зашифруем данные, просто заменив каждую букву алфавита со сдвигом в две буквы, таким образом `A` будет заменено на `C`, `B` на `D` и т.д.

Мы используем **инструкцию LODS** для помещения оригинальной строки `password` в память:

```
section .text
   global _start         ; должно быть объявлено для использования gcc

_start:                  ; сообщаем линкеру входную точку

   mov    ecx, len
   mov    esi, s1
   mov    edi, s2

loop_here:

   lodsb
   add al, 02
   stosb
   loop    loop_here          
   cld
   rep     movsb

   mov     edx,20        ; длина сообщения
   mov     ecx,s2        ; сообщение для вывода на экран
   mov     ebx,1          ; файловый дескриптор (stdout)
   mov     eax,4         ; номер системного вызова (sys_write)
   int     0x80            ; вызов ядра
   mov     eax,1         ; номер системного вызова (sys_exit)
   int     0x80           ; вызов ядра

section .data
   s1 db 'password', 0      ; источник
   len equ $-s1

section .bss
   s2 resb 10               ; назначение


```

**Результат:

`rcuuyqtf`

### LODSW

Команда LODSW копирует слово из памяти по адресу DS:SI в регистр AX. После выполнения команды, регистр SI увеличивается на 2, если флаг DF = 0, или уменьшается на 2, если DF = 1.
Если команда используется в 32-разрядном режиме адресации, то используется регистр ESI.Пример:

```
mov
cld
lodsw
si,offset str1

```


### LODSD

Команда LODSD копирует двойное слово из памяти по адресу DS:SI в регистр EAX. После выполнения команды, регистр SI увеличивается на 4, если флаг DF = 0, или уменьшается на 4, если DF = 1.
Если команда используется в 32-разрядном режиме адресации, то используется регистр ESI. Например:

```
mov si,offset str1
cld
lodsd

```
Ввод:
 -  DS:SI - строка, из которой выполняется копирование
 - ES:DI - строка, в которую выполняется копирование

 Вывод: нет

## Инструкция STOS

Это инструкция противоположность инструкции lods. Эта инструкция сохраняет данные из регистра (AL, AX или EAX) в память. Инструкция STOS копирует элемент данных из регистров AL (для byte — STOSB), AX (для word — STOSW) или EAX (для doubleword — STOSD) в строку назначения, на которую указывает ES:DI в памяти.Команда STOS на самом деле не является командой процессора. Когда в тексте программы встречается эта команда, компилятор вычисляет размерность ее операнда и на основании вычислений подставляет на ее место одну из реальных команд процессора STOSB, STOSW или STOSD.

Пример:

>stos es:str2

**Инструкция STOS** копирует элемент данных из регистров AL (для byte — STOSB), AX (для word — STOSW) или EAX (для doubleword — STOSD) в строку назначения, на которую указывает `ES:DI` в памяти.

### Инструкция STOSB

Команда STOSB сохраняет регистр AL в ячейке памяти по адресу ES:DI. После выполнения команды, регистр DI увеличивается на 1, если флаг DF = 0, или уменьшается на 1, если DF = 1.
Если команда используется в 32-разрядном режиме адресации, то используется регистр EDI.

Пример:

```
mov di,offset str1
cld
stosb
```

### Инструкция STOSW
Команда STOSW сохраняет регистр AX в ячейке памяти по адресу ES:DI. После выполнения команды, регистр DI увеличивается на 2, если флаг DF = 0, или уменьшается на 2, если DF = 1.
Если команда используется в 32-разрядном режиме адресации, то используется регистр EDI.

Примеры:

```
mov  di,offset str1
cld
stosw

```

### Инструкция STOSD
Команда STOSD сохраняет регистр EAX в ячейке памяти по адресу ES:DI. После выполнения команды, регистр DI увеличивается на 4, если флаг DF = 0, или уменьшается на 4, если DF = 1.
Если команда используется в 32-разрядном режиме адресации, то используется регистр EDI.

Пример:

```
mov di,offset str1
cld
stosd

```

В следующем примере мы с помощью инструкций LODS и STOS будем конвертировать строки из верхнего регистра в нижний регистр:

```
section .text
  global _start  ; должно быть объявлено для использования gcc

_start:  ; сообщаем линкеру входную точку

  mov ecx, len
  mov esi, s1
  mov edi, s2
  
loop_here:
  lodsb
  or al, 20h
  stosb
  loop loop_here
  cld
  rep movsb
  
  mov edx,20  ; длина сообщения
  mov ecx,s2  ; сообщение для вывода на экран
  mov ebx,1  ; файловый дескриптор (stdout)
  mov eax,4  ; номер системного вызова (sys_write)
  
  int 0x80  ; вызов ядра
  mov eax,1  ; номер системного вызова (sys_exit)
  int 0x80  ; вызов ядра

section .data
  s1 db 'HELLO, WORLD', 0 ; источник
  len equ $-s1

section .bss
  s2 resb 20  ; назначение

```

**Результат:
hello, world

В следующем примере мы с помощью **инструкций LODS** и **STOS** будем конвертировать строки из верхнего регистра в нижний регистр:


```
section .text
  
   global _start        ; должно быть объявлено для использования gcc

_start:                 ; сообщаем линкеру входную точку

   mov    ecx, len
   mov    esi, s1
   mov    edi, s2

loop_here:

   lodsb
   or      al, 20h
   stosb
   loop    loop_here
   cld
   rep movsb

   mov edx,20         ; длина сообщения
   mov ecx,s2         ; сообщение для вывода на экран
   mov ebx,1         ; файловый дескриптор (stdout)
   mov eax,4         ; номер системного вызова (sys_write)
   int 0x80         ; вызов ядра
   
   mov eax,1         ; номер системного вызова (sys_exit)
   int 0x80         ; вызов ядра

section .data
   
   s1 db 'HELLO, WORLD', 0 ; источник
   len equ $-s1

section .bss

   s2 resb 20              ; назначение

```

**Результат:

`hello, world`  


## Инструкция CMPS


**Инструкция** **CMPS** сравнивает две строки. Эта инструкция сравнивает два элемента данных одного byte, word или doubleword, на которые указывают регистры `DS:SI` и `ES:DI`, и устанавливает соответствующие флаги. Вы также можете использовать [**инструкции прыжков**](https://ravesli.com/assembler-usloviya/) вместе с этой инструкцией. Другими словами, Команда CMPSB сравнивает один байт из памяти по адресу DS:SI с байтом по адресу ES:DI. Аналогична по действию команде CMP. После выполнения команды, регистры SI и DI увеличиваются на 1, если флаг DF = 0, или уменьшаются на 1, если DF = 1. Если команда используется в 32-разрядном режиме адресации, то используются регистры ESI и EDI соответственно. 

Флаги OF, SF, ZF, AF, PF и CF устанавливаются в соответствии с результатом.

Пример:

```
mov si, offset str1
mov di, offset str2
cld
cmpsb


```

Так и с инструкциии CMPSW и CMPSD, разница в размерах.

В следующем примере мы будем сравнивать две строки, используя инструкцию CMPS:

```
section .text
   global _start            ; должно быть объявлено для использования gcc

_start:                     ; сообщаем линкеру входную точку

   mov esi, s1
   mov edi, s2
   mov ecx, lens2
   cld
   repe  cmpsb
   jecxz  equal             ; выполняем прыжок, когда ECX равен нулю

   ; Если не равно, то выполняем следующий код
   mov eax, 4
   mov ebx, 1
   mov ecx, msg_neq
   mov edx, len_neq
   int 80h
   jmp exit

equal:

   mov eax, 4
   mov ebx, 1
   mov ecx, msg_eq
   mov edx, len_eq
   int 80h

exit:

   mov eax, 1
   mov ebx, 0
   int 80h

section .data

   s1 db 'Hello, world!',0      ; наша первая строка
   lens1 equ $-s1

   s2 db 'Hello, there!', 0     ; наша вторая строка
   lens2 equ $-s2

   msg_eq db 'Strings are equal!', 0xa
   len_eq  equ $-msg_eq

   msg_neq db 'Strings are not equal!'
   len_neq equ $-msg_neq

```

**Результат:

`Strings are not equal!`  

Команды JCXZ и JECXZ служат для выполнения перехода в зависимости от состояния регистра CX или ECX. Могут использоваться, например, в циклах, где счетчиком как раз и является регистр CX или ECX.
Командa JCXZ проверяет значение регистра CX и, если оно равно нулю, производится передача управления по адресу, заданному операндом команды. Команда JECXZ производит аналогичные действия, но использует регистр ECX.


## Инструкция SCAS

Инструкция SCAS используется для поиска определенного символа или набора символов в строке. Искомый элемент данных должен находиться в регистрах AL (для SCASB), AX (для SCASW) или EAX (для SCASD). Искомая строка должна находиться в памяти, и на нее должны указывать ES:DI (или EDI). То есть инструкция SCAS ищет определённый символ или набор символов в строке. Символ
которую мы будем искать должен находиться в регистре al (ax, eax - в зависимости от размера), а строке где мы будем искать симво, должен находиться в памяти по адресу ES:(E)DI.

**Инструкция SCAS** используется для поиска определенного символа или набора символов в строке. Искомый элемент данных должен находиться в регистрах AL (для SCASB), AX (для SCASW) или EAX (для SCASD). Искомая строка должна находиться в памяти, и на нее должны указывать `ES:DI` (или `EDI`).

Рассмотрим использование инструкции SCAS на практике:

```
section .text

    global _start        ; должно быть объявлено для использования gcc

_start:                 ; сообщаем линкеру входную точку

   mov ecx,len
   mov edi,my_string
   mov al , 'e'
   cld
   repne scasb
   je found ; когда нашли

   ; Если не нашли, то выполняем следующее
   mov eax,4
   mov ebx,1
   mov ecx,msg_notfound
   mov edx,len_notfound
   int 80h
   jmp exit

found:

   mov eax,4
   mov ebx,1
   mov ecx,msg_found
   mov edx,len_found
   int 80h

exit:

   mov eax,1
   mov ebx,0
   int 80h

section .data

   my_string db 'hello world', 0
   len equ $-my_string  

   msg_found db 'found!', 0xa
   len_found equ $-msg_found

   msg_notfound db 'not found!'
   len_notfound equ $-msg_notfound

```

**Результат:

`found!`  

При использовании префикса REP и значения длины в регистре CX команда SCAS может сканировать строки любой длины. Эту команду удобно применять при решении задач, в которых требуется заменить одни символы на другие. Команда SCAS на самом деле не является командой процессора. Когда в тексте программы встречается эта команда, компилятор вычисляет размерность ее операнда и на основании вычислений подставляет на ее место одну из реальных команд процессора SCASB, SCASW или SCASD.

Флаги OF, SF, ZF, AF, PF, CF устанавливаются в соответствии с результатом.


## Префиксы повторения

**Префикс REP**, если он установлен перед строковой инструкцией (например, `REP MOVSB`), вызывает повторение инструкции на основе счетчика, размещенного в регистре CX. `REP` выполняет инструкцию, уменьшает CX на 1 и проверяет, равен ли CX нулю. Он повторяет обработку инструкций, пока CX не станет равным нулю.

Флаг направления (DF) определяет направление операции:

  -  Используйте `CLD` (англ. _«Clear Direction Flag» = «Сбросить флаг направления»_, `DF = 0`), чтобы выполнить операцию слева направо.

  -  Используйте `STD` (англ. _«Set Direction Flag» = «Установить флаг направления»_, `DF = 1`), чтобы выполнить операцию справа налево.

Префикс REP также имеет следующие вариации:

   - `REP` — это безусловное повторение, которое повторяет операцию, пока CX не станет равным нулю.

   - `REPE` или `REPZ` — это условное повторение, которое повторяет операцию до тех пор, пока нулевой флаг (ZF) указывает на равенство нулю результата (сам ZF установлен в единицу). Повторение останавливается, когда ZF указывает на неравенство результата нулю (ZF сброшен в ноль), или когда CX равен нулю.

   `REPNE` или `REPNZ` — это также условное повторение, которое повторяет операцию до тех пор, пока нулевой флаг указывает на неравенство нулю результата. Повторение останавливается, когда ZF указывает на равенство нулю результата, или когда CX уменьшается до нуля.