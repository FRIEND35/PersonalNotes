Набор команд процессора содержит логические инструкции **AND**, **OR**, **XOR**, **TEST** и **NOT**, которые проверяют, устанавливают и очищают биты в соответствии с потребностями программы.

## Логические инструкции

Синтаксис использования логических инструкций следующий:

   - `AND операнд1, операнд2`

   - `OR операнд1, операнд2`

   - `XOR операнд1, операнд2`

   - `TEST операнд1, операнд2`

   - `NOT операнд1`

Во всех случаях первый операнд находится либо в регистре, либо в памяти. Второй операнд может находиться либо в [**регистре**](https://ravesli.com/assembler-segmenty-pamyati-i-registry/)/памяти, либо являться константой. Тем не менее, операции типа «память-в-память» невозможны.  


# Инструкция AND

Инструкция AND выполняет логическое И между всеми битами двух операндов. Результат записывается в первый операнд.
Синтаксис:

> AND первый_оперенд, второй_оперенд

Первым оперендом может быть одним из следующих:

 - Область памяти (MEM)
 - Регистр общего назначения (REG)

Вторым оперендом может быть одним из следующих:

 - Область памяти (MEM)
 - Регистр общего назначения (REG)
 - Непосредственное значение (IMM)

Как было сказано, команда AND выполняет операцию логического И между всеми битами двух чисел. Таблица истинности для операции
логического И выглядит следующим образом:

| 0   | 0   | 0   |
| --- | --- | --- |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1    |

Почему это называется таблицей истинности? Потому что она отображает результаты выполнения функции
с разными параметрами. И эти результаты могут принимать только одно из двух значений: ИСТИНА
(логическая 1) или ЛОЖЬ (логический 0).

Логическое И - это операция логического умножения. Чтобы легче было запомнить таблицу истинности
для логического И, вспомните математику:

>
0 * 0 = 0
0 * 1 = 0
1 * 0 = 0
1 * 1 = 1

**Инструкция AND** выполняет побитовую операцию И. Побитовая операция И возвращает `1`, если совпадающие биты обоих операндов равны `1`, в противном случае — возвращается `0`. Например:

> `Операнд №1: 0101 
> `Операнд №2: 0011 
> `--  
> `После применения AND -> Операнд №1: 0001`



![[Pasted image 20221005131729.png]]



Операция AND может быть использована для сброса одного или нескольких бит. Например, допустим, что регистр BL содержит `0011 1010`. Если вам необходимо сбросить старшие биты в ноль, то вы выполняете операцию AND между этим регистром и числом `0FH`:

> AND BL, 0FH   ; эта строка устанавливает для регистра BL значение 0000 1010

Давайте рассмотрим другой пример. Если вы хотите проверить, является ли определенное число чётным или нечётным, то с помощью простого теста вы сможете проверить младший значимый бит числа. Если им окажется `1`, то число нечётное, если же `0` — число чётное.

Например, если число находится в регистре AL, то мы можем написать следующее:


```
AND AL, 01H     ; выполняем операцию AND с 0000 0001
JZ    EVEN_NUMBER

```

Следующая программа это проиллюстрирует:

```
Live Demo

section .text

   global _start            ; должно быть объявлено для использования gcc

_start:                     ; сообщаем линкеру входную точку

   mov   ax,   8h           ; записываем 8 в регистр AX
   and   ax, 1              ; выполняем операцию AND с AX
   jz    evnn
   mov   eax, 4             ; номер системного вызова (sys_write)
   mov   ebx, 1             ; файловый дескриптор (stdout)
   mov   ecx, odd_msg       ; сообщение для вывода на экран
   mov   edx, len2          ; длина сообщения
   int   0x80               ; вызов ядра
   jmp   outprog

evnn:  

   mov   ah,  09h
   mov   eax, 4             ; номер системного вызова (sys_write)
   mov   ebx, 1             ; файловый дескриптор (stdout)
   mov   ecx, even_msg      ; сообщение для вывода на экран
   mov   edx, len1          ; длина сообщения
   int   0x80               ; вызов ядра

outprog:

   mov   eax,1              ; номер системного вызова (sys_exit)
   int   0x80               ; вызов ядра

section   .data

even_msg  db  'Even Number!' ; сообщение с чётным числом
len1  equ  $ - even_msg

odd_msg db  'Odd Number!'    ; сообщение с нечётным числом
len2  equ  $ - odd_msg

```

**Результат выполнения программы:

`Even Number!`

Изменяем значение в регистре AX, указав нечётную цифру:

>mov  ax, 9h    ; записываем 9 в регистр AX

И результат:

`Odd Number!`

Вы можете точно так же очистить весь регистр, используя AND с `00H`.  


# Инструкция OR

**Инструкция OR** выполняет побитовую операцию ИЛИ. Побитовый оператор ИЛИ возвращает `1`, если совпадающие биты одного или обоих операндов равны `1`, и возвращает `0`, если оба бита равны нулю. Например:

> `Операнд №1: 0101  
   `Операнд №2: 0011   
` -- 
`После применения OR -> Операнд №1: 0111`

Операция OR может быть использована для указания одного или нескольких бит. Например, допустим, что регистр AL содержит `0011 1010`, и нам необходимо установить четыре младших бита. Мы можем сделать это, используя оператор OR со значением `0000 1111` (т.е. с регистром FH):

![[Pasted image 20221005131846.png]]


>OR BL, 0FH                   ; эта строка устанавливает для BL значение 0011 1111

В качестве другого примера давайте сохраним значения `5` и `3` в регистрах AL и BL соответственно. Таким образом, следующая инструкция:

>OR AL, BL

Должна сохранить `7` в регистре AL:


```
section .text

   global _start            ; должно быть объявлено для использования gcc

_start:                     ; сообщаем линкеру входную точку

   mov    al, 5             ; записываем 5 в регистр AL
   mov    bl, 3             ; записываем 3 в регистр BL
   or     al, bl            ; выполняем операцию OR с регистрами AL и BL, результатом должно быть число 7
   add    al, byte '0'      ; выполняем конвертацию из десятичной системы в ASCII

   mov    [result],  al
   mov    eax, 4
   mov    ebx, 1
   mov    ecx, result
   mov    edx, 1
   int    0x80

outprog:

   mov    eax,1             ; номер системного вызова (sys_exit)
   int    0x80              ; вызов ядра

section    .bss

result resb 1

  ```
  
**Результат выполнения программы:

`7`  

# Инструкция XOR

**Инструкция XOR** выполняет побитовую операцию XOR. Побитовая операция XOR возвращает `1`, если биты операндов являются различными, если же они являются одинаковыми (оба равны `0` или `1`), то возвращается `0`. Например:


![[Pasted image 20221005131918.png]]


>
`Операнд №1: 0101
`Операнд №2: 0011  
`--
`После применения XOR -> Операнд №1: 0110`

Следующая инструкция очищает регистр (сбрасывает все биты в `0`):

>XOR     EAX, EAX

Конструкция из 3 xor позволяет поменять местами значения в регистрах.

>
XOR ax, bx
XOR bx, ax
XOR ax, bx

Вот так вот это выглядит. И, что очень важно, работает быстрее, нежели специальная команда, для обмена значениями.



# Инструкция TEST

**Инструкция TEST** работает так же, как и инструкция AND, но, в отличие от инструкции AND, она не изменяет первый операнд. Таким образом, если нам нужно проверить, является ли число в регистре чётным или нечётным, мы можем сделать это, используя инструкцию TEST, без необходимости изменять исходное число:

>
TEST    AL, 01H
JZ      EVEN_NUMBER


Как можно догадаться, команды AND и TEST по сути выполняют одну и ту же операцию - операцию логического И. Но только AND
записывает результат в первом оперенде, а TEST просто влияет на флаги.

Если команда AND наиболее часто используется для сброса определённых битов числа, то команда TEST обычно используется для
проверки битов и совместно с командами условного перехода.


```
Пример программы:
.model  tiny
.code
 ORG  100h

start:

 MOV AX, 5
 TEST AX,1 ;Проверка числа на чётность
 JNZ Odd   ;нечетное, переход на метку Odd
 JZ  Even  ;четное, переход на метку Even

Odd:  ;Если число в АХ нечетное

 ADD AX, 1  ;AX = AX + 1
 JMP EndProg

Even:  ;Если число в АХ чётное

 ADD AX, 2 ;AX = AX + 2

EndProg:
 END start
```

Здесь мы проверяем, является ли число в регистре АХ чётным или нечётным. И в зависимости от
результата переходим к той или иной метке.



# Инструкция NOT  

**Инструкция NOT** выполняет побитовую операцию НЕ. Побитовая операция НЕ изменяет биты операнда на противоположные. Операнд может находиться либо в регистре, либо в памяти. Например:

![[Pasted image 20221005131934.png]]

>
`Операнд №1: 0101 0011  
`--   
`После применения NOT -> Операнд №1: 1010 1100`



# Что такое битовая маска

Для чего используются логические операции, такие как логическое умножение? И зачем в ассемблере команды, такие как AND?

Дело в том, что довольно часто приходится сравнивать какое-то число с так называемой битовой маской. И в зависимости от результата выполнять какие-то действия. То есть побитовая маска – это то число с которым мы сравниваем дургой число с п.м. логической инструкции. Иными словами, довольно часто бывает так, что надо узнать состояние отдельного бита (или нескольких битов) в числе.

Давайте представим, что у нас есть какое-то устройство с 8 входами. И сигналы с этих входов каким-то образом  упаковываются в один байт, где каждому биту соответствует отдельный вход (с 0 до 7).

А теперь вопрос - как нам узнать, есть сигнал на входе 3 или нет? То есть установлен третий бит в 1, или сброшен в 0? А вот для этого-то и существуют битовые маски.

Допустим, мы хотим узнать, сброшены ли нулевой и третий биты числа в регистре AL. Тогда можно использовать такую команду с
битовой маской, где установлены 3-й и 0-й биты:

>TEST AL, 00001001b

А теперь несколько примеров, которые показывают, как работает этот код.

0 0 1 0 0 1 0 1  - Исходное значение
0 0 0 0 1 0 0 1  - Битовая маска
0 0 0 0 0 0 0 1  - Результат: ZF = 0

0 0 1 0 1 0 0 0   - Исходное значение
0 0 0 0 1 0 0 1  - Битовая маска
0 0 0 0 1 0 0 0  - Результат: ZF = 0



0 0 1 0 0 1 0 0  -  Исходное значение
0 0 0 0 1 0 0 1  -  Битовая маска
0 0 0 0 0 0 0 0  - Результат: ZF = 1

То есть флаг нуля ZF будет установлен только в том случае, если оба бита (0-й и 3-й) сброшены.
Давай те все обьсним коротко и ясно. Зачем использовать инструкция test если инструкция and? Да потому что инструкция test влияет
на такие флаги как: ZF, SF, PF. И связи с этим мы можем использовать эту команду для работы с переходами на какую-то метку. Если
вы сейчас нечего не понимаете, то это значить что вы не знакомы с флагами и переходами. Но не переживайте мы еще поговорим об
этом.

Вот список логических побитовых команд:

- AND — Побитовое логическое умножение. Используют для выделения части битов.1100 AND 1010 = 1000

- OR — Побитовое логическое сложение. Используют вместо команд сравнения

- XOR — Побитовое сложение по модулю два. Используют для обнуления.

- TEST — Выполняется логическое умножение, но приемник не меняется. Меняются только флаги.

- NOT — Инвертирует каждый бит

![[Pasted image 20221005134354.png]]

