
# [[Mastering Privilege Escalation. Exploiting Vulnerabilities for Elevated Access|Privilege Escalation]]

Наш первоначальный доступ к удаленному серверу обычно осуществляется в контексте пользователя с низкими привилегиями, что не дает нам полного доступа через этот компьютер. Чтобы получить полный доступ, нам нужно будет найти внутреннюю/локальную уязвимость, которая повысит наши привилегии до `root` пользователь на `Linux` или `administrator`/ `SYSTEM` пользователь на `Windows`. Давайте рассмотрим некоторые распространенные методы повышения наших привилегий.

---

## PrivEsc Checklists

Получив первоначальный доступ к ящику, мы хотим тщательно его просмотреть, чтобы найти любые потенциальные уязвимости, которые мы можем использовать для достижения более высокого уровня привилегий. В Интернете можно найти множество контрольных списков и шпаргалок, в которых есть набор проверок, которые мы можем выполнить, и команды для запуска этих проверок. Одним из отличных ресурсов является [HackTricks](https://book.hacktricks.xyz) , который содержит отличный контрольный список для [как в Linux](https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist) , так и [в Windows](https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation) повышения локальных привилегий . Еще один отличный репозиторий — [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) , в котором также есть контрольные списки как для [Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md) , так и [для Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) . Мы должны начать экспериментировать с различными командами и методами и ознакомиться с ними, чтобы понять многочисленные слабые места, которые могут привести к повышению наших привилегий.

---

## Enumeration Scripts

Многие из вышеперечисленных команд могут быть автоматически запущены со сценарием для просмотра отчета и поиска слабых мест. Мы можем запустить множество сценариев для автоматического перечисления сервера, выполняя общие команды, которые возвращают любые интересные результаты. Некоторые из распространенных сценариев перечисления в Linux включают [LinEnum](https://github.com/rebootuser/LinEnum.git) и [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker) , а для Windows — [Seatbelt](https://github.com/GhostPack/Seatbelt) и [JAWS](https://github.com/411Hall/JAWS) .

Еще один полезный инструмент, который мы можем использовать для перечисления серверов, — это набор сценариев [Privilege Escalation Awesome Scripts SUITE (PEASS)](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite) , поскольку он постоянно поддерживается в актуальном состоянии и включает сценарии для перечисления как для Linux, так и для Windows.

Примечание. Эти сценарии запускают множество команд, известных для выявления уязвимостей, и создают много «шума», который может активировать антивирусное программное обеспечение или программное обеспечение для мониторинга безопасности, которое ищет события такого типа. Это может помешать запуску сценариев или даже вызвать сигнал тревоги о том, что система скомпрометирована. В некоторых случаях нам может потребоваться выполнить перечисление вручную вместо запуска сценариев.

Давайте возьмем пример запуска сценария Linux из `PEASS` называется `LinPEAS`:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ ./linpeas.sh
...SNIP...

Linux Privesc Checklist: https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
 LEYEND:
  RED/YELLOW: 99% a PE vector
  RED: You must take a look at it
  LightCyan: Users with console
  Blue: Users without console & mounted devs
  Green: Common things (users, groups, SUID/SGID, mounts, .sh scripts, cronjobs)
  LightMangenta: Your username


====================================( Basic information )=====================================
OS: Linux version 3.9.0-73-generic
User & Groups: uid=33(www-data) gid=33(www-data) groups=33(www-data)
...SNIP...
```

Как мы видим, после запуска скрипта он начинает собирать информацию и отображать ее в виде отличного отчета. Давайте обсудим некоторые уязвимости, которые нам следует искать в выходных данных этих сценариев.

---

## Kernel Exploits

Всякий раз, когда мы сталкиваемся с сервером, работающим под управлением старой операционной системы, нам следует начинать с поиска потенциальных уязвимостей ядра, которые могут существовать. Предположим, на сервере не установлены последние обновления и исправления. В этом случае он, вероятно, уязвим для определенных эксплойтов ядра, обнаруженных в непропатченных версиях Linux и Windows.

Например, приведенный выше сценарий показал нам версию Linux, которая будет `3.9.0-73-generic`. Если мы используем Google для этой версии или используем `searchsploit`, мы бы нашли `CVE-2016-5195`, иначе известный как `DirtyCow`. Мы можем найти и загрузить [эксплойт DirtyCow](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs) и запустить его на сервере, чтобы получить root-доступ.

Та же концепция применима и к Windows, поскольку в непропатченных/более старых версиях Windows существует множество уязвимостей, а также различные уязвимости, которые можно использовать для повышения привилегий. Мы должны помнить, что эксплойты ядра могут вызвать нестабильность системы, и нам следует проявлять большую осторожность, прежде чем запускать их в производственных системах. Лучше всего опробовать их в лабораторной среде и запускать в производственных системах только с явного одобрения и согласования с нашим клиентом.

---

## Vulnerable Software

Еще одна вещь, на которую нам следует обратить внимание, — это установленное программное обеспечение. Например, мы можем использовать `dpkg -l` команду в Linux или посмотрите `C:\Program Files`в Windows, чтобы узнать, какое программное обеспечение установлено в системе. Нам следует искать общедоступные эксплойты для любого установленного программного обеспечения, особенно если используются более старые версии, содержащие неисправленные уязвимости.

---

## User Privileges

Еще один важный аспект, на который следует обратить внимание после получения доступа к серверу, — это привилегии, доступные пользователю, к которому у нас есть доступ. Предположим, нам разрешено запускать определенные команды от имени пользователя root (или от имени другого пользователя). В этом случае мы можем повысить наши привилегии до пользователей root/системы или получить доступ как другой пользователь. Ниже приведены некоторые распространенные способы использования определенных привилегий пользователя:

1. Sudo
2. SUID
3. Windows Token Privileges

The `sudo`Команда в Linux позволяет пользователю выполнять команды от имени другого пользователя. Обычно он используется, чтобы позволить пользователям с более низкими привилегиями выполнять команды от имени пользователя root, не предоставляя им доступа к пользователю root. Обычно это делается, поскольку определенные команды можно запускать только от имени пользователя root, например `tcpdump`' или разрешить пользователю доступ к определенным корневым каталогам. Мы можем проверить, что `sudo` привилегии, которые мы имеем с `sudo -l` команда:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ sudo -l

[sudo] password for user1:
...SNIP...

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```

В приведенном выше выводе говорится, что мы можем запускать все команды с помощью `sudo`, что дает нам полный доступ, и мы можем использовать `su` команда с `sudo` для переключения на пользователя root:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ sudo su -

[sudo] password for user1:
whoami
root
```

Для приведенной выше команды требуется пароль для запуска любых команд с `sudo`. В определенных случаях нам может быть разрешено запускать определенные приложения или все приложения без необходимости предоставления пароля:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```

The `NOPASSWD` запись показывает, что `/bin/echo`команду можно выполнить без пароля. Это было бы полезно, если бы мы получили доступ к серверу через уязвимость и не знали пароля пользователя. Как говорится `user`, мы можем бежать `sudo`как этот пользователь, а не как root. Для этого мы можем указать пользователя с помощью `-u user`:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ sudo -u user /bin/echo Hello World!

    Hello World!
```

Как только мы найдем конкретное приложение, мы сможем запустить его. `sudo`, мы можем поискать способы использовать его, чтобы получить оболочку от имени пользователя root. [GTFOBins](https://gtfobins.github.io) содержит список команд и способы их использования. `sudo`. Мы можем найти приложение, которое у нас есть. `sudo` привилегия, и если она существует, она может сказать нам точную команду, которую мы должны выполнить, чтобы получить root-доступ, используя `sudo` привилегия, которую мы имеем.

[LOLBAS](https://lolbas-project.github.io/#) также содержит список приложений Windows, которые мы можем использовать для выполнения определенных функций, таких как загрузка файлов или выполнение команд в контексте привилегированного пользователя.

---

## Scheduled Tasks

И в Linux, и в Windows существуют методы запуска сценариев через определенные промежутки времени для выполнения задачи. В некоторых примерах антивирусное сканирование выполняется каждый час или сценарий резервного копирования выполняется каждые 30 минут. Обычно есть два способа воспользоваться запланированными задачами (Windows) или заданиями cron (Linux) для повышения наших привилегий:

1. Добавить новые запланированные задачи/задания cron
2. Обманите их, чтобы запустить вредоносное программное обеспечение

Самый простой способ — проверить, разрешено ли нам добавлять новые запланированные задачи. В Linux распространенной формой выполнения запланированных задач является `Cron Jobs`. Существуют определенные каталоги, которые мы можем использовать для добавления новых заданий cron, если у нас есть `write`разрешения над ними. К ним относятся:

1. `/etc/crontab`
2. `/etc/cron.d`
3. `/var/spool/cron/crontabs/root`

Если мы можем выполнить запись в каталог, вызываемый заданием cron, мы можем написать сценарий bash с командой обратной оболочки, которая должна отправить нам обратную оболочку при выполнении.

---

## Exposed Credentials

Затем мы можем найти файлы, которые мы можем прочитать, и посмотреть, содержат ли они какие-либо открытые учетные данные. Это очень часто встречается у `configuration` файлы, `log` файлы и файлы истории пользователей ( `bash_history` в Linux и `PSReadLine`в Windows). Сценарии перечисления, которые мы обсуждали вначале, обычно ищут потенциальные пароли в файлах и предоставляют их нам, как показано ниже:

Повышение привилегий

```shell-session
...SNIP...
[+] Searching passwords in config PHP files
[+] Finding passwords inside logs (limit 70)
...SNIP...
/var/www/html/config.php: $conn = new mysqli(localhost, 'db_user', 'password123');
```

Как мы видим, пароль базы данных ' `password123`' открыт, что позволит нам войти в локальную `mysql`базы данных и искать интересную информацию. Мы также можем проверить `Password Reuse`, поскольку пользователь системы мог использовать свой пароль для баз данных, что может позволить нам использовать тот же пароль для переключения на этого пользователя, как показано ниже:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ su -

Password: password123
whoami

root
```

Мы также можем использовать учетные данные пользователя для `ssh` на сервер в качестве этого пользователя.

---

## SSH Keys

Наконец, давайте обсудим ключи SSH. Если у нас есть доступ для чтения через `.ssh` для конкретного пользователя, мы можем прочитать его личные ssh-ключи, найденные в `/home/user/.ssh/id_rsa` или `/root/.ssh/id_rsa`и используйте его для входа на сервер. Если мы сможем прочитать `/root/.ssh/` каталог и можете прочитать `id_rsa` файл, мы можем скопировать его на нашу машину и использовать `-i` флаг для входа с ним:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ vim id_rsa
Uliam@htb[/htb]$ chmod 600 id_rsa
Uliam@htb[/htb]$ ssh root@10.10.10.10 -i id_rsa

root@10.10.10.10#
```

Обратите внимание, что мы использовали команду «chmod 600 id_rsa» для ключа после того, как создали его на нашем компьютере, чтобы изменить разрешения файла на более строгие. Если ключи ssh имеют слабые разрешения, т. е. могут быть прочитаны другими людьми, ssh-сервер не позволит им работать.

Если мы окажемся с доступом на запись к пользователям `/.ssh/` каталог, мы можем поместить наш открытый ключ в каталог ssh пользователя по адресу `/home/user/.ssh/authorized_keys`. Этот метод обычно используется для получения доступа по ssh после получения оболочки от имени этого пользователя. Текущая конфигурация SSH не принимает ключи, написанные другими пользователями, поэтому она будет работать только в том случае, если мы уже получили контроль над этим пользователем. Сначала мы должны создать новый ключ с помощью `ssh-keygen` и `-f` флаг для указания выходного файла:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:...SNIP... user@parrot
The key's randomart image is:
+---[RSA 3072]----+
|   ..o.++.+      |
...SNIP...
|     . ..oo+.    |
+----[SHA256]-----+
```

Это даст нам два файла: `key` (который мы будем использовать с `ssh -i`) и `key.pub`, который мы скопируем на удаленный компьютер. Давайте скопируем `key.pub`, затем на удаленной машине мы добавим его в `/root/.ssh/authorized_keys`:

Повышение привилегий

```shell-session
user@remotehost$ echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```

Теперь удаленный сервер должен позволить нам войти в систему под этим пользователем, используя наш закрытый ключ:

Повышение привилегий

```shell-session
Uliam@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost# 
```

Как мы видим, теперь мы можем войти по SSH от имени пользователя. `root`. В модулях [«Повышение привилегий Linux»](https://academy.hackthebox.com/module/details/51) и [«Повышение привилегий Windows»](https://academy.hackthebox.com/module/details/67) более подробно описано, как использовать каждый из этих методов для повышения привилегий, а также многие другие.

---

# Questions

SSH с пользователем «user1» и пароль " password1 ";

1. SSH к указанному выше серверу с предоставленными учетными данными и используйте «-p xxxxxx», чтобы указать порт, показанный выше. После входа в систему попытайтесь найти способ перейти к пользователю «user2», чтобы получить флаг в «/home/user2/flag.txt».
2. Как только вы получите доступ к «user2», попытайтесь найти способ повысить свои привилегии до root, чтобы получить флаг в «/root/flag.txt».

Хорошо, давайте начнем. Давайте откроем терминал и подключимся к удаленной системе по SSH. Подключитесь по SSH к указанному выше серверу с предоставленными учетными данными и используйте «-p xxxxxx», чтобы указать порт, показанный выше.

![[Pasted image 20240805031525.png]]

Просто для вашего сведения я использовал параметр -p, а затем номер порта, поскольку эта удаленная система не использует параметр порта по умолчанию для ssh, который равен 22.

После входа в систему попытайтесь найти способ перейти к пользователю «user2», чтобы получить флаг в «/home/user2/flag.txt».

Итак, при чтении модуля предлагается использовать опцию `sudo -l`, чтобы указать, какой тип махинаций с `sudo` мы можем совершить, поэтому давайте посмотрим, что мы (или кто-то другой) можем делать или не делать с `sudo`.

![[Pasted image 20240805031625.png]]

В выводе команды `sudo -l` для пользователя user1 указано, что он может без пароля **(NOPASSWD)** запускать команду `/bin/bash` от имени пользователя user2. Это означает, что user1 имеет повышенные привилегии и может выполнять задачи с правами user2. Обычно такая конфигурация нежелательна, поскольку она может привести к эскалации привилегий и компрометации системы. 

Из этого вывода мы видим, что user2 может запускать команды `/bin/bash` без запроса пароля. Итак, что мы можем сделать, это использовать опцию `sudo -u` для запуска команд от имени пользователя user2. Как именно нам это сделать, потому что если мы просто попробуем запускать команды от имени пользователя user2, мы столкнемся с этой проблемой.

![[Pasted image 20240805031946.png]]

Так что это выглядит немного запутанно, но все, что я пытаюсь запустить команду ls от имени пользователя user2, но она (справедливо) говорит мне: нет, мне не разрешено это делать. Итак, если я могу получить доступ к /bin/bash только как пользователь user2, как мы можем это сделать? Ну, один инструмент, который дает нам модуль, — это [GTFOBin](https://gtfobins.github.io/) . Это сайт, который может дать нам некоторые рекомендации по повышению привилегий в зависимости от того, к какому типу команд у нас есть доступ. Давайте посмотрим, что он говорит.

![[Pasted image 20240805032028.png]]

Итак, если вы откроете страницу и прокрутите вниз до bsh, она сообщит нам, что мы можем читать файлы, если у нас есть доступ к этой команде, давайте посмотрим, что она рекомендует.

![[Pasted image 20240805032039.png]]

Хорошо, похоже, мы могли бы сохранить файл, который хотим прочитать, как переменную в bash, которую мы могли бы затем вызвать позже, но если вы видите опцию `bash -c`, похоже, что она просто позволяет нам запускать команды bash, поэтому давайте попробуем сделать это как user2.

![[Pasted image 20240805032119.png]]

Хорошо. Давайте найдем и прочитаем этот пользовательский флаг. Обычно эти флаги можно найти в домашних каталогах, поэтому давайте займемся поиском в домашнем каталоге пользователя user2.

![[Pasted image 20240805032136.png]]

Или вместо того чтобы каждый раз запускать команду от имени user2 можно стать user2:

```bash
user1@ng-431590-gettingstartedprivesc-pir7p-695cdfcc7c-wz87w:/home/user2$ sudo -u user2 bash
user2@ng-431590-gettingstartedprivesc-pir7p-695cdfcc7c-wz87w:~$ whoami  
user2
```

Или укажите польный путь к `bash`:

```bash
sudo -u user2 /bin/bash
```

Всё, можно получить флаг. После выполнения команды `sudo -u user2 /bin/bash`мы смогли прочитать содержимое файла, используя `cat flag.txt`.

![[Pasted image 20240805214248.png]]

Отсюда я подтвердил, что все еще нахожусь в `/home/user2`, затем «ls», показывая мой flag.txt, и «cat flag.txt» дали мне первую часть. Это заняло у меня некоторое время. По какой-то причине я смотрел на вещи netcat. Глупый я, но я признал свои ошибки! Потрясающий.

Хорошо, следующая часть… получите `/root/flag.txt`, повысив свои привилегии. Теперь мы подошли к той части. В модуле говорится о хищении закрытых ключей ssh ​​как о способе повышения привилегий, и в конечном итоге именно такая идея здесь и есть. 

Давайте посмотрим, к чему мы можем получить доступ в домашнем каталоге root.

![[Pasted image 20240805032711.png]]

Ах, давайте попробуем от имени пользователя user2.

![[Pasted image 20240805032724.png]]

Итак, мне бросаются в глаза две вещи, в первую очередь флаг, но, как мы видим по разрешениям, его может прочитать только root. Однако похоже, что пользователь 2 может получить доступ к каталогу .ssh, где, возможно, есть закрытый ключ RSA, который мы можем украсть?

![[Pasted image 20240805032744.png]]

Думаю, дальше нас ждет кое-какое развлечение по SSH-ключу. Здесь мы видим, что этот милый файл закрытого ключа id_rsa доступен для глобального чтения... Итак, я бы разобрался и показал вам, но в нем много чего-то похожего на случайные символы, поэтому я собираюсь провести вас через это.

Что мы хотим сделать, так это вывести ключ на терминал, а затем вы скопируете все, что выводится. Затем мы собираемся выйти из этого сеанса ssh, вернуться на наш хост, создать файл и вставить этот ключ в наш файл. Я собираюсь сделать все это, а затем показать вам ключ на нашем «локальном» хосте.

![[Pasted image 20240805032757.png]]

![[Pasted image 20240805214545.png]]

Хорошо, вот ключ к нашей атакующей виртуальной машине. Следует отметить одну вещь: убедитесь, что этот файл **точно** такой же, как ключ, который мы скопировали. Главное, что я видел, это то, что когда вы вставляете его в [текстовый редактор по вашему выбору], он просто создает еще одну строку в конце файла. Вы захотите вернуть место или избавиться от этой лишней строки, она должна быть длиной 38 строк. Мы можем проверить это с помощью wc -l, но я знаю, что моя длина составляет 38 строк. Итак, теперь, наконец, давайте воспользуемся этим ключом, чтобы попытаться подключиться к нашей жертве по SSH от имени пользователя root.

![[Pasted image 20240805032818.png]]

Упс, я действительно сделал упс. Мы получаем эту ошибку, потому что наш ключ может быть прочитан другими. Давайте посмотрим разрешения этого ключа, чтобы вы поняли, что я имею в виду.

![[Pasted image 20240805032905.png]]

Хорошо, здесь мы видим, что и групповые, и другие разрешения настроены на чтение, чего мы не хотим для наших закрытых ключей ssh. Да, группа, которая может читать этот файл, — это только моя группа пользователей, но это все равно не нормально, поэтому мы собираемся использовать команду `chmod`, чтобы установить разрешения, чтобы только владелец файла (я) мог читать (и писать) это файл.

![[Pasted image 20240805032944.png]]


Обратите внимание, что мы использовали команду «chmod 600 id_rsa» для ключа после того, как создали его на нашем компьютере, чтобы изменить разрешения файла на более строгие. Если ключи ssh имеют слабые разрешения, т. е. могут быть прочитаны другими людьми, ssh-сервер не позволит им работать.  Теперь давайте попробуем sshing еще раз.

- Итак, в уроке говорится о ssh-ключе для повышения привилегий. Итак, я `cat /root/.ssh` подтвердил, что это каталог, а затем он выплюнул эту маленькую путаницу с OPENSSH PRIVATE KEY. Поэтому я перенес это в другой терминал, сохранил в id_rsa и выполнил команду «chmod 600 id_rsa» для ключа, чтобы изменить права доступа к машинным файлам, чтобы они были более строгими. Если ключи ssh слишком слабы, нам будет отказано, как и раньше.

```
ssh root@REMOTE_IP -p port -i id_rsa
```

![[Pasted image 20240805032957.png]]

Хорошо, давайте, наконец, прочитаем этот флаг.

![[Pasted image 20240805033013.png]]

# Conclusion

Итак, это было очень простое повышение привилегий в Linux. Я определенно был немного смущен, проходя через это, но опять же, мы все учимся, все делаем это шаг за шагом. Для нас важно продолжать тренироваться и просто продолжать пытаться, и в конечном итоге мы все доберемся до того, чего хотим. Желаю вам хорошего дня и увидимся в следующий раз!