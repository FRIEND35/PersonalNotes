Реверс-инжиниринг — это творческий процесс анализа программного обеспечения и его понимания без доступа к исходному коду. Это процесс, в ходе которого программное обеспечение деконструируется таким образом, что раскрываются его самые внутренние детали, такие как его структура, функции и работа.

[Реверс-инжиниринг](https://www.infosecinstitute.com/courses/reverse-engineering-boot-camp/?utm_source=resources&utm_medium=infosec%20network&utm_campaign=skills%20pricing&utm_content=hyperlink) — один из основных навыков, необходимых в индустрии безопасности программного обеспечения. Большинство атак, которые обычно запускаются в виде вредоносного программного обеспечения, должны быть отменены и проанализированы. После запуска вредоносной атаки в системе ключевыми требованиями являются очистка системы и узлов и их защита от компрометации. 

Работа аналитика программного обеспечения состоит в том, чтобы определить, как вредоносное программное обеспечение установилось в системе, и разработать шаги для его удаления. [Обратное проектирование используется при анализе вредоносных программ,](https://www.infosecinstitute.com/courses/reverse-engineering-boot-camp/?utm_source=resources&utm_medium=infosec%20network&utm_campaign=skills%20pricing&utm_content=hyperlink) чтобы понять, что делает этот фрагмент кода, и создать процесс обнаружения, чтобы предотвратить повторное заражение системы.


# Что такое radare2?

Radare2 — это платформа с открытым исходным кодом, которая может выполнять дизассемблирование, отладку, анализ, сравнение данных и манипулирование двоичными файлами. Этот фреймворк работает на Windows, Linux и многих других платформах и архитектурах. Установщик Windows можно скачать с [GitHub](https://github.com/radareorg/radare2-win-installer) .


# Утилиты Radare2

Radare2 поставляется с несколькими другими важными инструментами. Эти инструменты представляют собой утилиты командной строки, которые можно использовать вместе или по отдельности. В этой статье мы обсудим четыре ключевые утилиты, которые поставляются с Radare2.

## rax2

rax2 пригодится, когда необходимо выполнить базовые преобразования между шестнадцатеричными представлениями, значениями с плавающей запятой, строками шестнадцатеричных пар в ASCII, двоичные, восьмеричные, целые числа и т. д.

![[Pasted image 20221219153242.png]]

Рисунок 1. Использование rax2 для преобразования двоичного числа 0011000011111111d в целое число 12543

## rasm2

rasm2 — это ассемблер и дизассемблер для нескольких архитектур, включая Intel x86.

![[Pasted image 20221219153311.png]]


Рисунок 2. Преобразование кода языка ассемблера для return ( **ret** ) в машинный код


![[Pasted image 20221219153331.png]]


Рисунок 3. rasm2 преобразует машинный код **c3** в язык ассемблера

## rabin2 

rabin2 предоставляет ключевую информацию об исполняемых двоичных файлах. Он в основном известен как средство извлечения информации о бинарных программах. Как показано на рис. 4, мы видим, что рассматриваемый исполняемый двоичный файл будет работать на архитектуре x86 и имеет тип bin в формате Portable Executable (PE). Мы также видим, что этот двоичный файл был написан с использованием C++.

Существует дополнительная информация о том, хранится ли наименее значимое (с прямым порядком байтов) или наиболее значимое значение (с прямым порядком байтов) в последовательности по более низкому адресу хранения.

![[Pasted image 20221219153410.png]]

Рисунок 4. Утилита rabin2 извлекает информацию из исполняемого бинарного файла

## radare2

Это основная библиотека и инструмент фреймворка, использующий ядро шестнадцатеричного редактора и отладчика. Это утилита, которую можно использовать для реверсирования программного обеспечения.



# Как реконструировать исполняемый двоичный файл

В этом разделе описывается, как реверсировать исполняемый двоичный файл. Когда эта стандартная программа запрашивает у пользователя ввод секретного пароля для входа в систему, она сравнивает введенный пароль со статической строкой, а затем выводит оператор для правильного и неправильного кода. Цель состоит в том, чтобы проиллюстрировать функциональность Radare2.

Для начала реверсируем, запускаем radare2 и загружаем бинарный файл с именем binfile.exe.

![[Pasted image 20221219153726.png]]

Рис. 6. Загрузка исполняемого бинарного файла в радар

Мы можем проанализировать двоичный файл с помощью команды aa . Команда aa анализирует все флаги, начинающиеся с символов, функций и начальной точки программы.

![[Pasted image 20221219153747.png]]

Рис. 7. Как инициировать анализ бинарника, загруженного в radare2

Во время бинарного анализа мы можем перейти к любому разделу бинарного кода. Команда « s » в радаре2 используется для «поиска» данных в коде. Как показано на рисунке 8, он используется для поиска ключа «пароль» в коде. Обратите внимание, что адрес меняется с точки входа **0x00401500** на адрес, где находится ключ: **0x00488019** . Запуск команды s entry0 в любое время вернет нас к начальному адресу **0x00401500,** показанному на рисунке 10.

![[Pasted image 20221219153811.png]]

Рисунок 8. Поиск ключевых слов в двоичном коде

![[Pasted image 20221219153828.png]]

Рисунок 9. Ключевое слово найдено по адресу **0x140008b14**

![[Pasted image 20221219153844.png]]

Рисунок 10. Возврат к точке входа

Чтобы продолжить анализ кода, мы можем перейти в визуальный режим с кодом « V ». Это представляет шестнадцатеричный вид визуального режима, показанного на рисунке 12.

![[Pasted image 20221219153933.png]]

Рисунок 11. Переход в визуальный режим для анализа кода

![[Pasted image 20221219154002.png]]

Рис. 12. Шестнадцатеричный редактор в Radare2

Поскольку результаты шестнадцатеричного редактора на самом деле не то, что нам нужно видеть, мы можем изменить представление, используя команду p и клавишу со стрелкой вниз, пока не доберемся до диапазона адресов от **0x00401563** до **0x004015bb** . В этом диапазоне адресов мы видим ключевую информацию, пароль randome2 , который никогда не доступен Пользователю во время выполнения программы.

![[Pasted image 20221219154019.png]]

Рисунок 13. Просмотр скрытых кодов в бинарных файлах с помощью Radare2

Вместо того, чтобы загружать исполняемый файл непосредственно в radare2, мы могли бы также запустить его с ключом -d , который загружает двоичный файл в режиме отладки.

![[Pasted image 20221219154038.png]]

Рисунок 14. Запуск радара2 с опцией -d

В режиме отладки исполняемый файл можно запустить с помощью команды dc .

![[Pasted image 20221219154055.png]]

Рисунок 15. Запуск бинарного файла в режиме отладки

![[Pasted image 20221219154108.png]]

Рисунок 16. Проверка состояния регистра в режиме отладки

---


#  Базовые команды

   - **i**  - Информация о файле (Язык программирование, размер, ОС, архитектура, формат и т.д. другими словами методанные).
  
   - **aa** - Анализ файла (Поиск строк, функции коментарии - ну анализ кода). Это нужно для загрузки содержимое файла.Разница между a, aa, aaa в том, что чем большн "a", тем глубже утилита делает анализ файла.

   - **s** - Переход по указанному адресу или же в другой область памяти. Например s main = Перейти в адрес main, s 0x13f22 = Перейти в адрес 0x13f22.

   - **iz** - Поиск всех строк в файле.
   - **pdf** - Дизассемблировать участок кода. Пример:  
    
```                                                              
1)~s main ; Перейти в участок main
1)~pdf    ; Дизассемблировать участок main
```

   - **V**  - Показать код в визуальном (16-ом) режиме.
   
   - **VV** - Показать графику программы (удобно).
 
   - **v**  - Полностью дизассемблировать файл.

```
!)~s main ----\
               |  тоже самое что и pdf@main (@ - адресация)
2)~pdf   -----/
```

   - **pdc@main** - Показать участок main в синтаксисе более высокого языка [mov eax,4 ----> eax = 4].

   - **iM** - Точка входа программы.
   
   - **/Test** - Поиск строки "Test" в файле.

   - **axt** - Показать где находится ссылка на строку [ axt 0x1432 ----> main [DATA] push str.Test].

# Запуск программы (Отладка)

```
1)~aaa   ;Анализ файла (Загрузка программы).
2)~doo   ;Режим отладки.
3)~pdf@main ~strcmp  ;Найти strcmp в блоке main.
4)~s 0x4456  ;Переход по адресу.
5)~db 0x1132 ;Оставим брек-пойнт (точка останова).
6)~dc ;Запускаем программу.
```


# Редактирование бинарного файла (сборка обратной разработке)

```
1)~oo+ - Открывает (переоткрывает) файл в режиме чтение-запись.
2)~s 0x33f55 - Переходим по адресу инструкции который хотим перезаписать.
3)~wa nop - Заменяем предыдущего инструкцию на инструкцию nop.
```

Если хотим перезаписать инструкцию которая идёт после текущей инструкции, то это делается с п.м. точка запятой ";" [nop;nop;mov eax, 5].Вот так мы и пропатчили программу.


