# О чем это?

Я видел, как многие люди изо всех сил пытались решить простые задачи обратного проектирования (RE) (я тоже, когда только начинал), ну, я не говорю, что сейчас я хорош в этом, но действительно улучшил свои навыки, так что теперь я могу решить многие проблемы RE в ctfs. Вот почему я пишу этот блог, надеясь, что он поможет хотя бы нескольким людям.

---
# Но что есть в задачах RE?

По сути, в задачах RE вы получите приложение или исполняемый файл, из которых мы должны найти правильный ввод, который приведет к желаемому результату путем обратного проектирования, конечной целью является получение флага. В основном я видел следующие типы исполняемых файлов: 

• Средство проверки пароля - примет пароль в качестве входных данных и напечатает флаг, если пароль правильный.

• Средство проверки флагов — примет флаг в качестве входных данных и проверит его правильность.

# Итак, я получил бинарный код в вызове, что теперь?

В основном нам нужно найти флаг , который может быть в разных форматах, таких как THM{}, ictf{} и т. д., или просто цифрами, в зависимости от задачи. 

----

# Я понимаю, но как? 

Вот моя простая методология или путь для ее решения.

![[Pasted image 20221227152151.png]]



Вы также можете использовать Radare2/gdb вместо Ghidra для статического анализа, если вы знакомы и знакомы с ассемблером.
Позже в блоге я объясню, почему я решил сделать именно так.

---
# строки

**strings**  очень полезная, но такая простая команда.

![[Pasted image 20221227152254.png]]

Согласно руководству, он печатает печатные символы в файле. Так почему это полезно? Что ж, если флаг присутствует в виде печатных символов, мы можем его сразу найти. Вот пример, предположим, у меня есть двоичный файл rev_me

![[Pasted image 20221227152322.png]]

я побежал  strings rev_me  и нашел пароль и флаг :)

![[Pasted image 20221227152347.png]]

Вот доказательство,

![[Pasted image 20221227152408.png]]

зачем начинать с  strings  ? -> Вы найдете множество задач, которые можно решить с помощью этой единственной команды. Если вы просто запустите его и найдете флаг, это сэкономит вам много вашего драгоценного времени.

ПРИМЕЧАНИЕ :  strings  Команда также очень полезна при анализе вредоносных программ, для этого посмотрите Джона Хаммонда по анализу вредоносных программ на YouTube или MAL:strings room на TryHackMe.

---
# трассировка

А что, если флага не было в строках? Следующее место — трассировка библиотечных вызовов, таких как  strcmp() если они используются, мы делаем это  ltrace.

![[Pasted image 20221227152749.png]]

Синтаксис:  ltrace /path/to/binary - Он покажет используемые вызовы библиотеки, например:

```
...
strcmp('idk','p@ssw0rd')
...
```

   **IMP** : Я не показывал пример, как сейчас,  ltrace  не может отслеживать вызовы из-за того, как gcc компилирует программу. Но это все еще может быть полезно в ctfs. Это занимает всего 2 секунды. чтобы сделать это, так что всегда пробуйте, мы никогда не знаем.
Теперь давайте начнем некоторые действительно классные вещи. Позвольте мне сначала пояснить, почему я вначале разделил задачи на две категории. 

---

# Проверка пароля

Эти двоичные файлы имеют рабочий процесс, например:

1. Take input -> 2. check if input matches the password -> 3. print flag if it matches.

Наша главная цель — получить флаг, поэтому вместо того, чтобы выяснять пароль, мы сразу переходим к коду, где он печатает флаг.
Например, у меня есть двоичный файл, который печатает флаг, если пароль правильный. Давайте использовать  gdb

![[Pasted image 20221227153751.png]]

Как видите, я разобрал основную функцию. В основной функции

![[Pasted image 20221227153816.png]]

![[Pasted image 20221227153848.png]]


мы ищем  cmp  здесь. мы можем видеть это в  <+103>. Он сравнивает 2 значения и, если они равны, переходит к  <main+129>. Мы можем сказать, что код в <main+129>  печатает флаг, как он вызывается, если сравнение успешно, поэтому давайте установим точку останова сразу после получения ввода, т.е. <main+68>  а затем запустить его.

![[Pasted image 20221227154037.png]]

мы снабжаем его любым случайным паролем, так как мы все равно пропустим проверку. Теперь давайте перейдем к  <main+129>
и посмотреть, что происходит. 

![[Pasted image 20221227154112.png]]

Мы успешно получили флаг!!

   **IMP** : то же самое можно сделать с помощью radiuse2. вместо  jump, использовать  dr rip={address to jump}  а затем продолжить, остальная процедура аналогична. Проверка флага А что, если сам флаг является паролем? рабочий процесс похож на 
   Take flag as input -> check if it is correct.
   
Теперь бесполезно обходить проверку, так как наша цель — получить флаг. Итак, как это сделать? Допустим, у нас есть двоичный файл с именем  rev  как:

![[Pasted image 20221227154254.png]]

Итак, чтобы найти флаг, я использовал Ghidra. Откройте ghidra, создайте новый проект, а затем импортируйте двоичный файл. Вы можете узнать больше о ghidra в CC:Ghidra на TryHackMe, или для этого доступно множество руководств. После анализа бинарника я проверил псевдокод , сгенерированный ghidra. В  main  функция, вы можете видеть, что она обрабатывает каждый символ с помощью  5  а затем добавление  5  к нему, то он сравнивает результат с flag .

![[Pasted image 20221227154442.png]]

Давайте проверим, что внутри  flag  и обратите внимание на эти значения.

![[Pasted image 20221227154546.png]]

Теперь, когда мы знаем, что такое результат, давайте найдем, что к нему приводит, для этого напишите скрипт, который будет брать символ из результата, а затем вычитать  5  а затем xor против  5 . Мы делаем операции, которые он сделал с нашим входом, в обратном порядке.

   ПРИМЕЧАНИЕ. Если вам интересно, почему это выглядит так сложно, ну, вот как работает ghidra. Попробуйте скомпилировать  cобственные двоичные файлы, а затем перевернуть их, чтобы увидеть, как ghidra генерирует код.
   
```
flag_bytes = [0x48, 0x4e, 0x49, 0x47, 0x83, 0x82, 0x3a, 0x7c, 0x5f, 0x82, 0x6f,
flag = ""
for x in flag_bytes:
   flag += chr((x - 5)^5)
print(flag)
```

Выполнение скрипта Python дает флаг!

![[Pasted image 20221227154806.png]]

Давайте проверим флаг

![[Pasted image 20221227154824.png]]

IMP: Вы могли бы решить другие проблемы, используя ghidra, так как она
дает псевдокод очень полезный Хотя иногда это может быть неправильно. В
конце концов я предпочел использовать Ghidra, так как он требователен к
ресурсам, но если у вас есть ресурсы, вы можете запустить его сразу.
Что делать, если вызов не является исполняемым файлом Linux?

• За  .NET assembly  использовать  ilspy  или какой-то другой  .NET decompiler

• За  .apk , Здесь есть несколько шагов с разными инструментами, но я просто ищу  online apk decompiler в Google и использовать онлайн-инструменты.

• Вы также можете декомпилировать  .exe двоичные файлы с использованием ghidra. 

---

# Злые крутые трюки 

Вот несколько трюков, которые я разработал на практике.

• Если вы видите, что шестнадцатеричные числа назначаются переменным в ghidra или что-то в этом роде, всегда смотрите их значение ASCII. Это может быть флаг или пароль прямо перед вами.

• Много  .java  файлы после декомпиляции  .apk  ? Предположим, что формат флага  flag{} , просто зайдите в каталог, где есть все  .java файлы и  запустить  cat *.java | grep flag{  или вы также можете попробовать что-то вроде  grep -iRl flag{ .

• В первый раз циклы в псевдокоде, сгенерированном ghidra, могут показаться сложными из-за наличия указателей. 
``**(int)((long)local28 +4)`` ,  не беспокойтесь об этом, просто сосредоточьтесь на нашей цели и понимании потока.

• Если нет  main  функция, внешний вид  entry  функция, обычно первая вызываемая функция `` __libc_start_main``  и первым аргументом обычно является  main  функция.

• Если двоичные файлы печатаются как  wrong,  give flag  что ли, посмотрите какая функция за это отвечает, это скорее всего  main  функция. Я предлагаю скомпилировать несколько бинарных файлов и посмотреть, как ghidra генерирует псевдокод. Это будет очень полезно для понимания. 

• Ты можешь использовать  angr. Это среда Python для анализа двоичных файлов. Посмотрите видео и уроки для него. Я уверен, что это того стоит.

---

# Что дальше?

TL;DR - **практика!!**

Мы только слегка поцарапали поверхность реверс-инжиниринга. Это похоже на методологию, вам нужно много практиковаться, если вы хотите овладеть ею. Разные способы решения задачи, взгляд на ассемблер и псевдокод, где искать флаги и что может быть кроличьей норой и т.д.

Не беспокойтесь, если вы думаете, что не понимаете, что делает приложение, или не можете решать задачи, все приходит с практикой. Есть много замечательных ресурсов и множество их списков, которые вы можете найти в Интернете, использовать их, чтобы узнать больше и продолжать практиковаться.