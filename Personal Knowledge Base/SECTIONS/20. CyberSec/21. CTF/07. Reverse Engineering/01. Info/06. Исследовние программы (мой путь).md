# Немного о работе стека


Также читайте:

   structure programm in memory
   Структура памяти C-программ


---

КОД XREF перекрестная ссылка, которая показывает взаимосвязь между вызовами функций, переходами или объявлениями. Например, loc_1000D325 имеет перекрестную ссылку кода на sub_1000D2F9+19, что означает, что sub_ по адресу 1000D2F9 обращается к этому местоположению по 0x19. Стрелка показывает, что код находится по более низкому адресу, чем ссылка, а буква «j» предполагает переход.

**Перекрестные ссылки** (или просто XREF) — это функция дизассемблеров, позволяющая показать вам, откуда были вызваны определенные функции и объекты или какие функции и объекты используются конкретной функцией. Мы можем упростить его, назвав его XREF-To и XREF-From. Ссылка может быть либо данными, либо кодом.

---

Локольные переменные в стеке будут храниться в обратном порядке. Например, если мы создадим три локальных переменных:  

```
char name[5] = “Alex”;
int age = 20;
pass[10] = “Hello World!”;
```
  

В стек будет занесён сначало переменная name, а потом age и после него pass – это означает что в самом внизу будет переменная name, а в самом вверху будет переменная pass. Стек легче представить как патрон пистолета, а данные в стеке это пули. Стек работает так же как и патрон пистолета. Но на этом не всё, Зависит от компилятора, режима оптимизации, других переменных, кода вокруг, фазы луны… Например у int foo(void) { int a = 5, b = 7; return a + b; } с -O3 вообще никаких переменных не будет. Потому что две константы будет:

```
mov eax, 12
ret
```

  
Ну вот с глобальными скорее всего ничего не случится, будут в том порядке, в котором определены. Думаю в данном случае, если они как глобальные определены, тогда компилятор просто сначала a потом b положит, т.к будет построчно обрабатывать код.

В других случаях, при другом размере переменных, можно было бы сказать, что при:

```c
char[]

int
```
  

Сначала будет int, потом char[] из-за выравнивания по границе. 

Да, стек работает как патрон пистолета, но обычно у тебя так будут лежать целые кадры стека, а не отдельные переменные. Отдельные переменные будут только в стековых виртуальных машин типа джавы.  

Просто секция изначально выравнена по 4-х байтной (или 8-байтной границе), и легче положить туда int, и не выравнивать nop'ами, чем положить char с выравниванием на 1, а потом выравнивать на 4, и ложить int


Данные в памяти буфера (в стеке) тоже находится в обратном порядке. Например:

```
char buffer[20] = “This is buffer!”;
```

Строка “This is buffer!” будет выглядить вот так в памяти: “sihT si ffub!re” – Конечно же не в таком строковом виде, а ascii.

---


![[d.png]]

И так, это простой исходник программы. Мы сначало создаём переменную max и выделяем для него 4-байта, занесем в него значение Max. После переменной max мы создаём переменную alex, выделяем для него 5-байта и занесем туда значение Alex.

То в стек сначало попадает Max потом Alex. Это означает что Alex будет стоять на верху у Max-a так? Ну...

`\0xaM\0xelA` если считать в порядке уменьшения адресов. 

```
\0xaM\0xelA
^         ^
ebp       esp
```



  
Давайте посмотрим наш компилированный код в радаре:

![[Pasted image 20221215111035.png]]

Выше программа была скомпилированна в решиме отладчика, поэтому синтаксис кода такой понятный.

По метки max записывается значение ‘Max’ размером в dword (4-байта), каждая буква по байту в формате ascii. По метки alex записывается значение ‘Alex’ размером в dword (4-байта), тоже каждая буква по байту в формате ascii. По скольку под переменной alex мы освободили 5-байт, а заполнили только 4-байта, еще 1-байт остаётся свободным, ядро заполняет его нулями.


Порядок инструкции такой же как и в исходнике, но посмотрите на вверх:

![[Pasted image 20221215111242.png]]


Радар сначало показывет нам переменную alex, а потом max. Мы то создали сначало max потом alex.


Давайте посмотрим в память с п.м. отладчика gdb:

![[Pasted image 20221215111339.png]]

После значение переменной max в памяти больше нечего нет (хотя после max мы определили alex), а после значение переменной alex идёт значение переменной max (как-то наоборот). Это значить, что в памть был занесён сначало max, а потом alex. В этом случае переменная alex находиться с верху переменной max, а переменная max снизу переменной alex. Чтобы была легче представить подумайте что память это патрон от пистолета, а переменный это пули, мы сначало в патрон засовываем пулю с идентификатором max, а потом пулю с идентификатором alex. Так они будут находиться в памяти.

Но не всё так просто, есть много других факторов которые измениять струтуру данных - такие как оптимизация кода, выравнивание для компактности на стеке и многое другое


**Важно: Код такой четкий из за компиляции в режиме  отладки – cc -g code.c**

  
На самом деле код выглядит вот так:

![[Pasted image 20221215111436.png]]


Помещаем куда нибудь данные в буфер, то эти данные будут занесены по частям в регистр или в другой область памяти. Напомним, что когда вы резервируете область памяти – например создаете переменные, они будут будто бы разделен на несколько частей отличающий друг от друга размером. Но давайте разберём всё по порядку.

![[Pasted image 20221215111509.png]]

В левой части ассемблерный код, а в правой исходный. Ну код очень простой, освободить 21 байт памяти и записать туда строку. Имейте ввиду того что а асме нет прямой записи память-память (есть исключение), то сделано через регистры как промежуточное звено. 

Переменная у нас одна, но radare2 показывает нам доступы к разным частям массива и  нам кажется, что это разные переменные.  Как мы видим, сначало данные запиcывается в регистр, а от туда в нашу переменную (память).

>Напоминаю что radare2 для удобства rbp-[смещение] показывает как var_[смещение]. В компьютерных науках термин "offset" в памяти обычно относится к смещению или сдвигу относительно начала определенной области памяти. Когда программа обращается к определенному участку памяти, она указывает не просто на адрес этой памяти, а на адрес с учетом определенного смещения от начала этой области памяти. Например, если у вас есть массив данных, начинающийся с адреса 0x1000 в памяти, и вам нужно получить доступ к третьему элементу массива, то вы можете использовать offset 2 (поскольку индексация массивов начинается с 0) относительно начала массива для получения адреса третьего элемента. Использование offset в памяти помогает программистам эффективно управлять доступом к данным в памяти и обращаться к различным участкам памяти с помощью относительных адресов, что упрощает работу с данными в программировании.

Но поскольку размер регистра сильно ограничен rax, rdx – 8-байт (64-бит), поэтому сначало мы записываем первые 8-байт данных в регистр rax, а следующий 8-байт данных в регистр rdx, а от туда в память по указанному адресу (var_20, var_18). После мы записываем 4-байт данных по метки var_10, и 1-байт данных по метки var_ch.

8+8+4+1=21 – Общий размер выделенной памяти. По сути, эти метки var, осуществляют наш выделенный память, это не разные переменные, а разные области одной переменной, а var на показывает дебагер чтобы нам была удобно, это на самом же деле адреса. По скольку мы данные не запихиваем целиком, а по частям из за ограничение с регистрами и многих дургих факторов, мы указываем с помощью var от куда начать запись данных (где находиться выделенный область памяти), и от куда продолжить (от куда продолжить запись следующих байтов).

Кусок твоей строки он бьет по 8 байт (размер регистров), и показывает нам разные части переменную для записи в регистр по метке var… , была бы у нас строка глобальная, такого бы небыло. Так инициализируются локальные переменные. у нас в коде есть строка и определена/проинициализирована она как локальная переменная. а работа с локальными переменными происходит на стеке, что мы и видим в диззаме.

То есть, это не переменная, а указатель на массив типа char так это вроде называется, это не переменная, а именно указатель и док-во этому синтаксис с которым ты скажем в функции этот массив передаешь типа по ссылке или указателю, не амперсанда не звездочки не указываешь. а кусками потому что компилятор передает в стек не адрес где лежат данные, а сами данные кусками через регистры а размер регистра ограничен, вот и разбивает на куски. Он это делает типа для оптимизации потому что непосредственно кладет символы в регистр, а так пришлось бы дополнительную операцию делать, сначала копировать в память потом уже в регистр адрес передавать где данные лежат и потом в стек уже копировать например.



# Доступ к данным в памяти

Когда мы записываем данные, например в размере 10-байт, то инструкция будет выглядить  примерно так:

```
mov qword [данные]
mov word  [данные+8]
```

Напомню, такое ограничение из за регистров. Стек растёт в сторону уменьшение адресов, то есть стек в памяти растет сверху вниз, это значит что **при добавлении значения в него адрес вершины стека уменьшается, а когда вы извлекаете из него, то адрес вершины стека увеличивается**. Теперь кратко рассмотрим что такое регистры. Это ячейки памяти в самом процессоре.  Другими словами ebp ( указатель дно стека) находится на верху, а esp (указатель вершины стека) находиться в самом внизу. 

Допустим у меня переменная name:

```c
char name[] = "Alex";
```

То под дебагером мы можем видет:

```
22: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_5h @ rbp-0x5  
│           ; var int64_t var_1h @ rbp-0x1  
│           0x00001129      55             push rbp  
│           0x0000112a      4889e5         mov rbp, rsp  
│           0x0000112d      c745fb416c65.  mov dword [var_5h], 0x78656c41 ; 'Alex'  
│           0x00001134      c645ff00       mov byte [var_1h], 0  
│           0x00001138      b800000000     mov eax, 0  
│           0x0000113d      5d             pop rbp  
└           0x0000113e      c3             ret
```

Тут

```
x - ebp-2 (5-2) = 0x3
e - ebp-3 (5-3) = 0x2
l - ebp-4 (5-4) = 0x1
A - ebp-5 (5-5) = 0x0
```

var_5h это тоже самое что и rbp-0x5. Это указатель начала стекового кадра (начало адреса от куда должны записаться данные), а -5  значит на 5 байт ниже. Это значить что значение записывается начиная c rbp-0x5 до rbp-0x0. 

![[Pasted image 20230604075346.png]]

![[Pasted image 20230604075520.png]]



### Регистры общего назначения

Регистр — это небольшой (обычно 4 или 8 байт) кусочек памяти в процессоре с чрезвычайно большой скоростью доступа. Регистры делятся на регистры специального назначения и регистры общего назначения. Нас сейчас интересуют регистры общего назначения. Как можно догадаться по названию, программа может использовать эти регистры под свои нужды, как ей вздумается.

На x86 доступно восемь 32-х битных регистров общего назначения — eax, ebx, ecx, edx, esp, ebp, esi и edi. Регистры не имеют заданного наперед типа, то есть, они могут трактоваться как знаковые или беззнаковые целые числа, указатели, булевы значения, ASCII-коды символов, и так далее. Несмотря на то, что в теории эти регистры можно использовать как угодно, на практике обычно каждый регистр используется определенным образом. Так, esp указывает на вершину стека, ecx играет роль счетчика, а в eax записывается результат выполнения операции или процедуры. Существуют 16-и битные регистры ax, bx, cx, dx, sp, bp, si и di, представляющие собой 16 младших бит соответствующих 32-х битных регистров. Также доступны и 8-и битовые регистры ah, al, bh, bl, ch, cl, dh и dl, которые представляют собой старшие и младшие байты регистров ax, bx, cx и dx соответственно.

Рассмотрим пример. Допустим, выполняются следующие три инструкции:

```
(gdb) x/3i $pc  
=> 0x8048074: mov    $0xaabbccdd,%eax  
   0x8048079: mov    $0xee,%al  
   0x804807b: mov    $0x1234,%ax

Значения регистров после записи в eax значения 0xAABBCCDD:

(gdb) p/x $eax  
$1 = 0xaabbccdd  
(gdb) p/x $ax  
$2 = 0xccdd  
(gdb) p/x $ah  
$3 = 0xcc  
(gdb) p/x $al  
$4 = 0xdd

Значения после записи в регистр al значения 0xEE:

(gdb) p/x $eax  
$5 = 0xaabbccee  
(gdb) p/x $ax  
$6 = 0xccee  
(gdb) p/x $ah  
$7 = 0xcc  
(gdb) p/x $al  
$8 = 0xee

Значения регистров после записи в ax числа 0x1234:

(gdb) p/x $eax  
$9 = 0xaabb1234  
(gdb) p/x $ax  
$10 = 0x1234  
(gdb) p/x $ah  
$11 = 0x12  
(gdb) p/x $al  
$12 = 0x34
```

Как видите, ничего сложного.

_Примечание:_ Синтаксис GAS позволяет явно указывать размеры операндов путем использования суффиксов b (байт), w (слово, 2 байта), l (длинное слово, 4 байта), q (четверное слово, 8 байт) и [некоторых других](https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax#Operation_Suffixes). Например, вместо команды `mov $0xEE, %al` можно написать `movb $0xEE, %al`, вместо `mov $0x1234, %ax` — `movw $0x1234, %ax`, и так далее. В современном GAS эти суффиксы являются опциональными и я лично их не использую. Но не пугайтесь, если увидите их в чужом коде.

На x64 размер регистров был увеличен до 64-х бит. Соответствующие регистры получили название rax, rbx, и так далее. Кроме того, регистров общего назначения стало шестнадцать вместо восьми. Дополнительные регистры получили названия r8, r9, …, r15. Соответствующие им регистры, которые представляют младшие 32, 16 и 8 бит, получили название r8d, r8w, r8b, и по аналогии для регистров r9-r15. Кроме того, появились регистры, представляющие собой младшие 8 бит регистров rsi, rdi, rbp и rsp — sil, dil, bpl и spl соответственно.

### Про адресацию

Как уже отмечалось, регистры могут трактоваться, как указатели на данные в памяти. Для разыменования таких указателей используется специальный синтаксис:

mov  (%rsp), %rax

Эта запись означает «прочитай 8 байт по адресу, записанному в регистре rsp, и сохрани их в регистр rax». При запуске программы rsp указывает на вершину стека, где хранится число аргументов, переданных программе (argc), указатели на эти аргументы, а также переменные окружения и кое-какая другая информация. Таким образом, в результате выполнения приведенной выше инструкции (разумеется, при условии, что перед ней не выполнялось каких-либо других инструкций) в rax будет записано количество аргументов, с которыми была запущена программа.

В одной команде можно указывать адрес и смешение (как положительное, так и отрицательное) относительно него:

mov  8(%rsp), %rax

Эта запись означает «возьми rsp, прибавь к нему 8, прочитай 8 байт по получившемуся адресу и положи их в rax». Таким образом, в rax будет записан адрес строки, представляющей собой первый аргумент программы, то есть, имя исполняемого файла.

При работе с массивами бывает удобно обращаться к элементу с определенным индексом. Соответствующий синтаксис:

```
#инструкция xchg меняет значения местами  
xchg 16(%rsp,%rcx,8), %rax
```

Читается так: «посчитай rcx*8 + rsp + 16, и поменяй местами 8 байт (размер регистра) по получившемуся адресу и значение регистра rax». Другими словами, rsp и 16 все так же играют роль смещения, rcx играет роль индекса в массиве, а 8 — это размер элемента массива. При использовании данного синтаксиса допустимыми размерами элемента являются только 1, 2, 4 и 8. Если требуется какой-то другой размер, можно использовать инструкции умножения, бинарного сдвига и прочие, которые мы рассмотрим далее.

Наконец, следующий код тоже валиден:

```
.data  
msg:  
  .ascii "Hello, world!\n"  
.text  
  
.globl _start  
_start:  
  # обнуление rcx  
  xor %rcx, %rcx  
  mov msg(,%rcx,8), %al  
  mov msg, %ah
```

В смысле, что можно не указывать регистр со смещением или вообще какие-либо регистры. В результате выполнения этого кода в регистры al и ah будет записан ASCII-код буквы H, или 0x48.

В этом контексте хотелось бы упомянуть еще одну полезную ассемблерную инструкцию:

```
# rax := rcx*8 + rax + 123  
lea 123(%rax,%rcx,8), %rax
```

Инструкция lea очень удобна, так как позволяет сразу выполнить умножение и несколько сложений.

**Fun fact!** На x64 в байткоде инструкций никогда не используются 64-х битовые смещения. В отличие от x86, инструкции часто оперируют не абсолютными адресами, а адресами относительно адреса самой инструкции, что позволяет обращаться к ближайшим +/- 2 Гб оперативной памяти. Соответствующий синтаксис:

```
movb msg(%rip), %al
```

Сравним длины опкодов «обычного» и «относительного» mov (`objdump -d`):

```
4000b0: 8a 0c 25 e8 00 60 00  mov    0x6000e8,%cl  
4000b7: 8a 05 2b 00 20 00     mov    0x20002b(%rip),%al # 0x6000e8
```

Как видите, «относительный» mov еще и на один байт короче! Что это за регистр такой rip мы узнаем чуть ниже.

Для записи же полного 64-х битового значения в регистр предусмотрена специальная инструкция:

```
movabs $0x1122334455667788, %rax
```

Другими словами, процессоры x64 так же экономно кодируют инструкции, как и процессоры x86, и в наше время нет особо смысла использовать процессоры x86 в системах, имеющих пару гигабайт оперативной памяти или меньше (мобильные устройства, холодильники, микроволновки, и так далее). Скорее всего, процессоры x64 будут даже более эффективны за счет большего числа доступных регистров и большего размера этих регистров.


---

# Exmaple 1

![[Pasted image 20221210135817.png]]


В левой части находится ассемблерный код (инструкции), в правом верхнем - исходный код, а в правом нижнем наш код был скомпилирован и запущен(результат).


## Исходный код примера

```
#include <stdio.h>  
  
void call_me(){  
  
       int age = 5;  
       char name[10] = "Alex";  
       printf("%s", "This is other function!\n");  
}  
  
int main(){  

       int key = 1;  
       char buffer[50] = "This is buffer!";  
       char pass[5] = "AAAAA";  
       char text[30] = "This is simple text for you!";  
       printf("Hello World!\n");  
  
       if(key == 1){  
  
               printf("This is test!\n");  
       }  
  
       call_me();  
  
       return 0;  
  
}
```






## Код в отладчике

```
           ; DATA XREF from entry0 @ 0x1064  
┌ 200: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
│           0x00001168      55             push rbp  
│           0x00001169      4889e5         mov rbp, rsp  
│           0x0000116c      4883ec70       sub rsp, 0x70  
│           0x00001170      c745fc010000.  mov dword [var_4h], 1  
│           0x00001177      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x00001181      48ba62756666.  movabs rdx, 0x21726566667562 ; 'buffer!'  
│           0x0000118b      488945c0       mov qword [var_40h], rax  
│           0x0000118f      488955c8       mov qword [var_38h], rdx  
│           0x00001193      48c745d00000.  mov qword [var_30h], 0  
│           0x0000119b      48c745d80000.  mov qword [var_28h], 0  
│           0x000011a3      48c745e00000.  mov qword [var_20h], 0  
│           0x000011ab      48c745e80000.  mov qword [var_18h], 0  
│           0x000011b3      66c745f00000   mov word [var_10h], 0  
│           0x000011b9      c745bb414141.  mov dword [var_45h], 0x41414141 ; 'AAAA'  
│           0x000011c0      c645bf41       mov byte [var_41h], 0x41    ; 'A'  
│           0x000011c4      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x000011ce      48ba73696d70.  movabs rdx, 0x7420656c706d6973 ; 'simple t'  
│           0x000011d8      48894590       mov qword [var_70h], rax  
│           0x000011dc      48895598       mov qword [var_68h], rdx  
│           0x000011e0      48b865787420.  movabs rax, 0x20726f6620747865 ; 'ext for '  
│           0x000011ea      488945a0       mov qword [var_60h], rax  
│           0x000011ee      c745a8796f75.  mov dword [var_58h], 0x21756f79 ; 'you!'  
│           0x000011f5      66c745ac0000   mov word [var_54h], 0  
│           0x000011fb      488d051a0e00.  lea rax, str.Hello_World_   ; 0x201c ; "Hello World!"  
│           0x00001202      4889c7         mov rdi, rax                ; const char *s  
│           0x00001205      e826feffff     call sym.imp.puts           ; int puts(const char *s)  
│           0x0000120a      837dfc01       cmp dword [var_4h], 1  
│       ┌─< 0x0000120e      750f           jne 0x121f  
│       │   0x00001210      488d05120e00.  lea rax, str.This_is_test_  ; 0x2029 ; "This is test!"  
│       │   0x00001217      4889c7         mov rdi, rax                ; const char *s  
│       │   0x0000121a      e811feffff     call sym.imp.puts           ; int puts(const char *s)  
│       │   ; CODE XREF from main @ 0x120e  
│       └─> 0x0000121f      b800000000     mov eax, 0  
│           0x00001224      e810ffffff     call sym.call_me  
│           0x00001229      b800000000     mov eax, 0  
│           0x0000122e      c9             leave  
└           0x0000122f      c3             ret
```




Результать выполнение программы: 

```
Hello World!  
This is test!  
This is other function!
```





## Разбор кода

Исходник:

В главной функции (main) у нас четыре переменных:

- Переменная key, тип int, размер 4-байта, значение: 1;
- Переменная buffer, тип char, размер 50-байт, значение: This is buffer!;
- Переменная pass, тип char, размер 5-байт, значение: AAAAA;
- Переменная text, тип char, размер 30-байт, значение: This is simple text for you!


С п.м. функции printf() мы выводим строку "Hello World!" на экран. После проверяем переменную key, если его значение является число 1, то выводим на экран строку "This is test!". После чего вызываем функцию call_me(). В функции call_me() у нас два переменных:

- Переменная age, тип int, размер 4-байт, значение: 5;
- Переменная name, тип char, размер 10-байт, значение: Alex;

С п.м. функции printf() мы выводим на экран строку "This is other function!".

Отладчик: 

Первые две строки кода это пролог процедуры:

```
│           0x00001168      55             push rbp  
│           0x00001169      4889e5         mov rbp, rsp  
```

Освобождаем память со стека (0x70 = 112 в десятичном виде). Другими словами освобождаем 112 байт со стека для наших локльных переменных и других данных.

```
sub rsp, 0x70
```

**sub esp, 10** увеличивает стек на 16 байт (10 в шестнадцатеричном формате), чтобы выделить место в стеке для любых переменных, на которые нам нужно ссылаться.

Основная/прямая причина использования чего-то вроде sub esp,0x18 (24 байта) заключается в том, чтобы зарезервировать место в стеке. Это можно использовать, чтобы освободить место для локальных переменных подпрограммы. Это также можно использовать для выравнивания указателя стека, если это необходимо для производительности или по другим причинам.

**add esp,10** - добавить это просто дополнение. add esp, 8 просто **добавляет значение 8 к ESP** . Поскольку ESP указывает на вершину (адрес памяти) стека, а стек растет «вниз» от высоких к низким адресам памяти, добавляя 8 к указателю стека, вы эффективно удаляете верхние 8 байтов из стека.


Напомнить чтр стек вверх ногами расположен?
sub esp - добавить место под переменные. Т.е. вставить какие-то данные в стек
add esp - освободить место в стеке


#### Переменные

Код на C:

```
 int key = 1;  
 char buffer[50] = "This is buffer!";  
 char pass[5] = "AAAAA";  
 char text[30] = "This is simple text for you!";  
```


В отладчике мы видем очень много участок памяти для переменных:

```
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
```

---

Самая нижняя выделенная участок памяти (переменная) – var_4h, которая находиться в самом внизу, это наша переменная key. Первый кусок данных которые были занесени в стек, будут нахдиться на самом последнем месте – самом внизу. Переменная key был добавлен в стек первым, поэтому он находиться в самом внизу. Элемент, непосредственно примыкающий к нижней границе, называется _дном стека_.

Записываем число один размером в двойное слово (32-бит или 4 байт). Почему 4 байта? Да потому что у переменной типа int размер 4 байта. Мы записываем данные определённого размера, а именно размером который мы выделили в памяти. Поскольку у переменной int размер 4-байта, мы записываем его в точночти 4-байта.

```
mov dword[var_4h], 1
```

Начиная с области `var_40h` до `var_10h` - это наша переменная `buffer` под которым мы выделили 50 байт. Если вам так интересно почему всё так рабито по частям, то обьясняю:

   Поскольку наш процессор работает в 64-битном режиме, мы имеем доступ к 64-битным регистрам (rax, rbx, rcx, rdx и т.д.), а это значить что наши данные тоже должны быть размером 64-бита, а то как процессор их запехнёт в свой регистр, это просто невозможно. А мы записываем значение "This is buffer!" в переменную `buffer`. Одна буква состоить из 8-битов (ASCII), а это означает что значение "This is buffer" состоить из 15 символов - `15*8` = 120. То есть 120-бит весить наше значение. И тут возникает вопрос. Как работать с 120-битовым данным с 64-битовым местом (регистром). Отвечаю - по частям, то есть сначало часть данных кидаем, потом другую часть и т.д. 

---


Код на Си:

```
char buffer[50] = "This is buffer!";
```

В отладчике:

```
│           0x00001177      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x00001181      48ba62756666.  movabs rdx, 0x21726566667562 ; 'buffer!'  
│           0x0000118b      488945c0       mov qword [var_40h], rax  
│           0x0000118f      488955c8       mov qword [var_38h], rdx  
│           0x00001193      48c745d00000.  mov qword [var_30h], 0  
│           0x0000119b      48c745d80000.  mov qword [var_28h], 0  
│           0x000011a3      48c745e00000.  mov qword [var_20h], 0  
│           0x000011ab      48c745e80000.  mov qword [var_18h], 0  
│           0x000011b3      66c745f00000   mov word [var_10h], 0  
```

 Большинство инструкций не могут работать с 64-битными адресами: ; movabs — это AT-имя специальной формы, которая принимает 64-битные непосредственные данные. ; ; Intel просто помещает его в MOV, а NASM просто использует «mov». 
 
 movabs используется для абсолютных перемещений данных, либо для загрузки произвольной 64-битной константы в регистр, либо для загрузки данных в регистр с 64-битного адреса.

`movabs rax, 0x2073692073696854 ; 'This is '` - Записываем первые 64-бита значении "This is buffer ". Это 8 символов, а `8*8=64`. Регистр у нас 64-битовый же. Простыми словами,  записываем в регистр rax строку “This is” (ascii формат).

`movabs rdx, 0x21726566667562 ; 'buffer!'` - Записываем следующие 64-бита нашего значение. То есть Записываем в регистр rdx строку “buffer!”  (остальной часть нашей переменной).

`mov qword [var_40h], rax` – Записываем в память var_40h значение регистра rax – “ This is” .

`mov qword [var_38h], rdx` – Записываем в память var_40h значение регистра rdx – “buffer!” .

Так, мы освободили 50-байт (400-бит) памяти, а использовали лишь 15-байт (120-бит), что же будет с остальным 35-байтой (280-бит). В нашем случае ядро заполняет их нулями:

```
mov qword [var_30h], 0  
mov qword [var_28h], 0  
mov qword [var_20h], 0  
mov qword [var_18h], 0  
mov word [var_10h], 0  
```

Не всегда свободное место ядро заполняет нулями как в нашем случае. Это зависить от компилятора может быть. Но вы даже можете указать чем именно заполнить свободное место, например с п.м. фунции memset().

Последние цифры в называние переменных которые показывает нам отладчик, означает позицию (расположение) и размер данных. Например, у нас он вот такой:

```
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
```

Как мы знаем в самом внизу находится наша первая переменная key, у которого тип int и размер которого состовляет 4-байта, названия участка в отладчике **var_4h** - то есть первые четыре байта. Как уже сказали начиная, наченая с область памяти **var_40h** до **var_10h** - это переменная buffer, тип которого char и размер 50-байт. В var_40h мы кинули первую партию данных, var_38h вторую, var_30h третью и так до var_10h. И всё это состовляет нашу переменную buffer. Как мы уже сказали, мы кидаем данные по партиям (частям) из за ограничения регистров процессора, ведь его размер ограниченный (64-бит).

Обратите внимание что после `var_10h` идёт `var_18h` . Чтобы понять как это работает заглянем в отладчик:

```
mov qword [var_20h], 0  
mov qword [var_18h], 0  
mov word [var_10h], 0  
```

Сначало мы закидываем данные размером в байт. После закидываем сл. партию данных рамером 8-байт. Это я и имел ввиду что указывают размер и позицию.

Давайте проведёи итог:

   Можно понять что var_40h это начало нашей переменной buffer. Он наченается с области var_40h и заканчевается в var_10h. Почему он наченается с верху вниз? Да потому что стек растет в сторону уменьшение адресов. Самый старший адрес – это начало памяти, а самый младший – конец памяти. Если мы освобождаем большой кусок памяти, то он будет освобожден по частям. В нашем случае мы освободили 50 байт памяти который состоить из 7 частей. 6 из них мы заполнили 8 байтными данными (48) и один двухбайтным и у нас получается 50 байт, это и есть наш буфер целиком. В нашем случае свободное пространство заполняется нулями. Например: mov qword [var_30h], 0 – заполнить var_30h нулями из 8 байт. В общем начиная с области var_40h до var_10h составляет нашу переменную buffer размером 50 байт.

---

Код на Си:

```
char pass[5] = "AAAAA"; 
```

Код в отладчике:

```
mov dword [var_45h], 0x41414141 ; 'AAAA'  
mov byte [var_41h], 0x41    ; 'A'  
```

И так, мы освободили 5-байт область памяьт под переменной pass типа char. В отладчике мы видим что сначало закидывается первые 4-байта данных по области var_45h, после другой и последный байт по области var_41h. Можно понять что var_45h - var_41h это переменная pass. Подскази очень хорошо помогают процессору работает с данными.

Записать в область памяти var_45h “AAAA” в формате hex ascii размером в двйное слово (4 байт):

```
mov dword [var_45h], 0x41414141
```

Записать в область памяти var_41h “A” в формате hex ascii размером в byte (1 байт):

```
mov byte [var_41h], 0x41
```
   
Можно понять, что область памяти var_45h и var_41h состовляет нашу переменную pass.


---

Ну дальше у нас привычный код. Записать в rax hex ascii “This is “:

```
movabs rax, 0x2073692073696854
```

Записать в rdx hex ascii “simple t”:

```
movabs rdx, 0x7420656c706d6973 – Записать в rdx hex ascii “simple t” 
```

 Записать в область памяти var_70h значение регистра rax размером 8 байт:
 
```
mov qword [var_70h], rax
```

Записать в область памяти var_68h значение регистра rdx размером 8 байт:

```
mov qword [var_68h], rdx 
```

Записать в rax hex ascii “ext for “ :

```
movabs rax, 0x20726f6620747865 
```

Записать в область памяти var_60h значение регистра rax размером 8 байт:

```
mov qword [var_60h], rax
```

Записать в область памяти var_58h hex ascii “you!” размером в 8 байт :

```
mov dword [var_58h], 0x21756f79
```

Заполнить область памяти var_54h нулями размером в 2 байта . Простыми словами, заполняем свободное пространство нулями.

```
mov word [var_54h], 0
```

Область памяти var_70h – var_54h, составляет нашу переменную text.

---


#### Вывод строки на экран


Кад на C:

```
printf("Hello World!\n");
```


В отладчике:

```
lea rax, str.Hello_World_   ; 0x201c ; "Hello World!"  
mov rdi, rax                ; const char *s  
call sym.imp.puts           ; int puts(const char *s)  
```

**lea rax, str.Hello_World_** - Помещаем в регистр rax адрес строки “Hello World!” ; 0x201c .

**mov rdi, rax** - Указываем на строку которую хотим вывести . ; const char *s

**call sym.imp.puts** - Вызываем функцию который должен вывести указанную строку ; int puts(const char *s) . В нашем случае это функция imp.puts – Он выводить что либо.

  
_**Регистр**_ **DI**. Этот регистр является _**индексом назначения**_ и применяется также для строковых операций.

И так, чтобы вывести какую нибудь строку на экран, нам нужно поместить его адрес в регистр DI, а потом вызвать функция который выведет нашу строку на экран (printf, puts и т.д.). Функция для вывода строки обращается к нужному регистру и извлекает от туда строку. Сама строка находится в сегменте .data и их аналога.

Если мы в функции printf() закинем строку которую нужно выводить, то на деле это будет звучить где-то так:


1.  Поместить адрес строки в регистр DI
    
2.  Вызвать функцию printf() - или любая другая функция которая будет выводить нашу строку.
    
![](file:///tmp/lu1801cnpp.tmp/lu1801cnq8_tmp_9fd0a5586b06b79f.png) 

Всё как мы и сказалт. Строка Hello World! находится по адресу 0x2004, закидываем этот адрес в регистр DI и вызываем функцию для вывода строки. По адресу 0x2004 у нас находится область памяти (в сегменте .data) именированная под .string в которой и находится наша строка Hello World! . Это просто область памяти в которой была записана наша строка.


Если мы создадим переменную и дадим ей значение, а после в функции printf() укажем название переменной для вывода её значение, то на деле это будет звучить так:

  

1.  Освободить место в верхушке стека
    
2.  Именириуем освобожденные места
    
3.  Закидываем строку (по частям) в какой нибудь регистр, а потом в освобожденный область памяти, или же сразу в освобожденный область памяти
    
4.  Записать начальный адрес освобожденного область памяти в регистр DI
    
5.  Вызвать функцию для вывода строки
    


И так мы освободили 0x10 = 22d байт памяти в стеке. Записываем первые 8-байт нашей строки в регистр rax, а с регистра rax в область памяти именируемый под называнием formar. После записываем следующий 4-байт нашей строки в область памяти именируемый под названием var_5h, и область памяти var_1h остается пустым, поэтому заполняем его нулями. Кидаем начальный адрес освобожеденной область памяти, где от-куда началась запись данных в регистр DI, и вызываем функцию для вывода строки.

Можно понять что format - var_1h – это и есть наша освобожденная памяти, разнициа лишь в областе, var_1h продолжение (другая часть) памяти format.


##### Заключение

И так, можно понять что, если мы в функции printf() сразу кидаем строку, то ядро не будет искать эту строку с неба, а это строка будет сначало записан в какой нибудь область памяти (в сегменте .data), после чего его адрес будет вычислятся или (или сама строка будет где-то записан в зависимости от типа инструкции – mov, lea) для дальнейшее операции .

Но если наша строка находится в переменной, а в функции printf() мы кидаем название переменной, то ядро сначало освобождает место в стеке, после чего именирует освобожденное место в стеке, дальше после именированние кидает в память (место которое мы освободили) строку, и начало адрес памяти в который была записана строка (от-куда) будет записывает в регистр DI. После чего будет вызвана функция printf().


Да это всего лишь вывод на экран и функция printf(), но это о многом говорить – откуда процессор берет данные и это конечно же многое обьясняет.

Если вы увидите вот такой код:

```
lea rax, str.String
```

  
То знайте, где-то то там в памяти (в сегменте .data) записана наша строка и нам нужен адрес где наченается наша строка для вывода, после чего значение rax будет записан в регистр DI и вызов функции для работы строк.

  
----

#### Условный переход

Код в C:

```
if(key == 1){
    printf("This is test!\n");
}
```

То есть если значение переменной key равняется цыфрой 1, то выводим строку "This is test!".

Код в отладчике:

```
cmp dword [var_4h], 1  
jne 0x121f  
lea rax, str.This_is_test_  ; 0x2029 ; "This is test!"  
mov rdi, rax                ; const char *s  
call sym.imp.puts           ; int puts(const char *s)  
```


**CMP** сравнивает два оперенда путем вычитание, и если оперенды равны то результат будет 0 и флаг ZF устанавливается и перехода не будет.

**cmp dword [var_4h], 1 –** Сравниваем значение область памяти (переменной) var_4h с числом 1 . Если результат равен нулю, то ЧИСЛО1 = ЧИСЛО2. Если числа равны, то есть результат равен 0, то устанавливается флаг ZF.

**jne 0x121f -** Перейти, если не равно (ZF = 0). В нашем случае если true, то блок кода пропускается. По адресу 0x121f стоит конец условии, то есть его завершении, и если результат равен нулю, флаг ZF = 1, то переходим по адресу 0x121f – это означает что условия пропускается.

**lea rax, str.This_is_test_** - Если флаг ZF = 1, то это означает что jne = false (не переходим никуда, а выполняем условие). В этом случае мы помещаем в rax адрес строки. ; 0x2029 ; "This is test!"

**mov rdi, rax** - Помещаем в rdi значение регистра rax, чтобы вывести строку. ; const char *s

**call sym.imp.puts** - Вызываем функцию для вывода строки. ; int puts(const char *s)


Вот граф:
![[e.png]]


Как можно увидеть, если чило1 == число2 (ZF = 1), то в этом случае jne = false - выполняется определённый блок кода, а если число1 != число2 (ZF = 0), то в этом случае jne = true - блок кода пропускается. Простыми словами если наше условия истино (ZF = 1, jne = false) то не переходим никуда, а выполняем блок кода, а если условие ложно (ZF = 0, jne = true), то наш блок кода пропускается.

Да знаю, все немного запутанно, но просто знайте что если:

```
cmp n1, n2

n1 == n2 (ZF = 1, jne = false) ; если jne ложно, то выполняется условия.
n1 != n2 (ZF = 0, jne = true ) ; если jne истино, то блок кода пропускается.
```

Вы заметили что мы использовали для записи данных только два регистра – rax и rdx. Сначало мы переместили данные в эти регистры, а потом с этих регистров копировали их в область памяти.

---

### Вызов функции

**call sym.call_me -** Вызов функции call_me()

Код на C:

```c
call_me();
```

В отладчике:

```c
call sym.call_me  
```


**Загляним что внутри функции call_me().

Код на C:

```
void call_me(){  
  
      int age = 5;  
      char name[10] = "Alex";  
      printf("%s", "This is other function!\n");  
}  
```


В отладчике:

![[p.png]]

var_4h – Это переменная age. Он был занесён в стек самым первым поэтому он в стеке находится в самом внизу.

var_eh – var_6h - Это переменная name. Он был занесён в стек после переменной age, поэтому он стоит с вреху переменной age.
  

Если переменные в стеке кладуться как тарелки, вот иснтрукции будут выполнятся в таком же виде как и в исходном коде. Например – Мы сначало дали значение переменной age, после переменной age мы дали значение переменной name. Хотя в стеке переменная name стоит с верху переменной age.


---

# Example 2


## Аргументы командной строки

  

![[acs.png]]

  

### Исходник

  

И так, это простая программа которая требует только 2 аргумента командной строки, если аргумент больше чем 2, то получаем сообщение об ошибке (Error!), а если аргумент командной строки меньше чем 2, тоже самое – получаем сообщение об ошибке (Error!) . Чтобы получить строку об успешной завершении программы (Success!), у нас должен быть ровно 2 аргумента командной строки.

  

### Отладчик

На уровни ассемблера всё звучить вот так – Освободить место в стеке, именировать освобожденные места чтобы была проще с ними работать, записать значение регистра edi в память var_4h, записать значение регитра rsi в память var_10h. Суди по всему в регистре edi находился значение argc, а в регистре rsi находился значение argv. Регисты rsi и rdi нам еще понадобиться для работы со строкой, их значение записываются в другом месте чтобы не потерять их. Тем более это регисты общего назначение. Сравнить значение var_4h с числом 2. Как мы помним, в памяти var_4h нaходиться значение argc. Если значение var_4h равен число 2, то программа делает прыжок по адресу 0x1177 - По этому адресу наченается вывод сообщение об успешной завершении программы (Success!) и выходим из программы вызовом функции exit(). Если значение var_4h не равно 2, то наченаем выводить сообщение об ошибке (Error!) после чего выходим из программы вызовом функции exit().

  

### Графика

![[Pasted image 20230105135928.png]]


Посмотрите пример выще, там условие и используется инструкция **je** для прыжка. Ну давайте ка всё по порядку. В примере выще в регистр edi кидается число (количество аргументов командной строки). Сравниваем значение регистра edi с числом 2 после чего вызываем инструкция je. 

JE -  переход если условние равно. После сравнение, если условие равно (аргумент командной строки == 2) то переходим по указанному адресу, в противном случае переход не выполняется.

---

# Example 3

## Циклы 

Циклы позволяют выполнять некоторое действие в зависимости от соблюдения некоторого условия. Другими словами, Циклы — управляющая конструкция, которая дает возможность выполнять определенный участок кода многократно.

### Цикл for 

Цикл for используется для перебора последовательности (то есть списка, кортежа, словарь, набор или строка).

![[Screenshot_20230106_094158.png]]

На скрине выще мы видим исходный код, код программы в отладчике и результат выполнение программы. Это простой цикл который проверяет значение переменной с числом 0xa (10d). Если значение меньше числа то выводим строку "Hello World!". 


---


# Логика работы

Есть сегментные регистры, которые будут указывать на начало сегментов. Да и в коде можно переключаться с одного сегмента на другой с помощью директивы section или segment, a компилятор сам расставит всё как надо.

Теперь смотрите на фрагмент инструкии:

```
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, len 
```

Теперь на другой фрагмент  инструкции:

```
mov edx,  len
mov ecx,  msg
mov ebx,  1
mov, eax, 4
```

Они оба правильные, но как программа не даёт сбой? Ведь инструкции написаны сверху вниз(

Инструкции будут выполнятся сверху вниз 

А как? Вывод же будет одинаковым - Потому-что у тебя операции взаимодействуют с разными регистрами. Попробуй сделать логику с cmp и условными переходами - всё пойдёт по `пи*де.

Как компилятор понимает что нужно читать снизу вверх? По регистрам что ли ? - Он никак не понимает. Просто у тебя код удачный, и в нём не важен порядок.

Смотрите. У тебя изменяются разные регистры. Теперь попробуй сделать такую штуку: 
  
  Попробуй сделать две строки msg1 с длиной len1 и msg2 с длиной len2. Потом напиши код, который выводит строки поочерёдно. Потом возьми этот же код и напиши в обратном порядке. Строки должны быть разными

В коде не важен порядок, потому что в каждой строке значения перемещаются в разные регистры и не происходит никаких вызовов.

Пример в С:

```
int a = 4;
int b = 1;
char* c = msg;
unsigned d = len;
```

А теперь наоборот:

```
unsigned d = len;
char* c = msg;
int b = 1;
int a = 4;
```

А теперь пойми почему даже при перестановке этот код сделает одно и то же. В коде не важен порядок, потому что в каждой строке значения перемещаются в разные регистры и не происходит никаких вызовов.

Прежде чем вызывать какой нибудь системный вызов или функцию, мы должны поместить в определённые регистры параметры, чтобы функция понял от куда взять данные. Потом функция сама извлекает данные с регистра и начинает операцию над ним.



### Важно понять

Что картина меняться при оптимизации программы, да и многих других факторов. Например у меня в компиле без оптимизации сначала в стек заносится строка через цикл, а потом число. с оптимизацией строка также заносится, но число в стек не кладется явно как лок. переменная и не выделяется место, а просто пушится перед вызовом принтф (чтоб переменная использовалась). Если эти переменные нигде не используются, то строка все равно заносится в стек через цикл, а число никак не пушится.

