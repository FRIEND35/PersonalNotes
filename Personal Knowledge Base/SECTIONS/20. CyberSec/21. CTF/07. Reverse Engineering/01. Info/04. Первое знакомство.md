>В данном посте начнётся рассмотрение достаточно большой темы - Обратная разработка.

Определение с википедии

**Обратная разработка** (обратное проектирование, обратный инжиниринг, реверс-инжиниринг; англ. reverse engineering) — исследование некоторого готового устройства или программы, а также документации на него с целью понять принцип его работы; например, чтобы обнаружить недокументированные возможности (в том числе программные закладки), сделать изменение или воспроизвести устройство,
программу или иной объект с аналогичными функциями, но без прямого копирования. 

>К нему можно дополнить, что обратная разработка также служит для поиска   уязвимостей в ПО или устройстве.



# Принцип обратной разработки на житейском примере.


>Для начального представления об обратной разработке рассмотрим следующий пример.

Вы получаете квадратную коробку, с одной стороны у коробки есть ручка, регулируя которую, вы выставляете различные значения на вход, после фиксации ручки вы можете нажать на копку и получить значение на другой стороне коробки, которая считается выходом. То есть по сути у вас есть чёрный ящик, которому вы можете предоставлять входные данные и получать выходные.

![[Pasted image 20221224154213.png]]

Теперь представим, что вам дали только этот ящик и никаких документов к нему нет, то есть, как он работает, вы не знаете, вы просто можете подавать значения на вход и получать значения на выходе, как они связаны вы не понимаете, но хотите разобраться. Зачем? Ну, например, для того, чтобы сделать такой же ящик или чтобы найти в ящике ошибку – момент, когда он будет выдавать одинаковые
результаты на разные входные данные, хотя так не должно быть, или что-то другое. Ваши цели могут быть совсем иные, важно лишь то, что вам нужно понять, как он работает или как работают его отдельные части.

Чтобы решить эту проблему, вы можете использовать разные варианты, например, вы можете проанализировать связь входных и выходных данных и найти формулу, по которым они меняются, но здесь вас может подстерегать проблема: вдруг внутри машины есть заранее определённые константы, о которых вы не знаете, да и для подтверждения вашей формулы вам придётся проверить все пары входных и выходных данных, а их может быть очень много. Хорошим решением данной проблемы будет разбор ящика и анализ его
внутреннего устройства. Для разбора ящика необходимы инструменты, а они могут быть различны в зависимости от задач, однако есть основные мультизадачные инструменты. Например, с помощью отвёртки можно раскрутить каркас ящика, крепления внутренних элементов, полностью разобрать его и достать необходимые элементы наружу, однако мы всё равно не получим представление о работе ящика, если просто всё вытащим из него. Нам необходимо проанализировать взаимосвязь всех компонентов при их совместной работе, в идеале понять через какие элементы ящика проходят наши входные значения, как преобразуются и как обрабатываются на
различных этапах, в общем, полностью понять алгоритмы обработки наших значений. Лучшим вариантом, конечно, будет, пошаговое наблюдение за работой ящика, однако это не всегда возможно как в ящиках, так и в реальных анализах программ. Считается, что обратная разработка является самой сложной частью информационной безопасности, наверное, так и есть, ведь, чтобы действительно проводить полноценные исследования, нужно знать очень много фундаментальных вещей, начиная от построения процессора и заканчивая алгоритмами и их реализациями, поэтому данная тематика считается очень сложной и оплачивается соответственно.

![[Pasted image 20221224155214.png]]

Перед тем как мы перейдём непосредственного к исследованию нашей первой программы, мы вспомним основы информатики, работы ЦП, устройства ОС и исполняемых файлов, вспомним про низкоуровневые языки программирования (далее ЯП) и многое другое. Всё это необходимо для того, чтобы у вас было хотя бы малейшее представление и понимание того, что вы должны будете сделать при
исследовании приложения.

---

# Начнём с простого.

Повторим, что такое ЦП (центральный процессор) и для чего он нужен. 

Итак, ЦП служит для выполнения команд компьютером, он по сути выполняет ряд заложенных в него на стадии производства команд, современные процессоры могут выполнить за раз огромное количество операций.

Все операции процессора очень просты, например, сложить два регистра (переменные) или выдать значение на шину данных, положить в регистр значение, взять значение с шины данных и другие простейшие операции. Были упомянуты следующие, возможно, незнакомые вам определения: регистр, шина данных, они будут объяснены далее. 


Нужно помнить, что фактически процессор воспринимает только последовательности 0 и 1, то есть он работает на очень низком уровне и оперирует только бинарным кодом. 

В зависимости от архитектуры длины команд могут быть различны, могут иметь фиксированную длину (так называемая RISC-архитектура), либо иметь нефиксированную длину команды (например, x86, x86-64). Человеку сложно воспринимать просто числа и считать их командами, для него нужна более высокая абстракция, которой как раз и является язык Ассемблера.

Язык Ассемблера различен для различных архитектур процессоров. Язык ассемблера напрямую связан с двоичными кодами команд процессора, то есть каждая команда на ассемблере имеет однозначное прямое соответствие с опкодом процессора (опкод – это
операционный код, довольно частое применяется для описания одной команды процессора). Посмотрим на примере. У нас есть команда на языке ассемблера для архитектуры x86-64:

```
mov eax, 1 – что означает положи в регистр eax значение 1
```

В шестнадцатеричном представлении опкодов эта команда будет выглядеть так:

```
B8 01 00 00 00
```

Видно, что ассемблерное представление удобнее для человека и позволяет лучше понять, что происходит в данном участке кода.
На изображении ниже, слева вы можете увидеть шестнадцатеричное представление опкодов, а справа представление на языке ассемблера. 

![[Pasted image 20221224155713.png]]

---

# Резюме.

• Обратная разработка - исследование (с различными целями) ПО или устройства
• Центральный процессор выполняет команды, представленные в виде 0 и 1 (бинарный вид)
• Для удобства представления команд процессора используется язык ассемблера
• Однак команда на языке ассемблера соответствует одной процессорной команде
• Язык ассемблера уникален для каждой из существующих архитектур

Чтобы не перегружать читателя информацией, данный пост заканчивается. В следующих постах по данной тематике будут разобраны такие темы как:

• Строение процессора
• Формат исполняемого файла
• Процесс компиляции
• Процесс дизассемблирования

и другие темы, связанные с обратной разработкой (следите за обновлениями).