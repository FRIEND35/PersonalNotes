


# Часть 1

Это разбитая на две части статья, которая показывает самые азы реверс-инжиниринга. Эти статьи и примеры совсем простые, в них содержаться интересные подсказки по анализу исполнимых файлов, которые могут пригодиться даже в повседневной работе с бинарниками, к примеру, будет показано, как можно извлечь все текстовые строки, которые встречаются в файле.

Кстати, как говорит [Википедия](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0):

Обратная разработка (обратное проектирование, обратный инжиниринг, реверс-инжиниринг; англ. reverse engineering) — исследование некоторого готового устройства или программы, а также документации на него с целью понять принцип его работы; например, чтобы обнаружить недокументированные возможности (в том числе программные закладки), сделать изменение или воспроизвести устройство, программу или иной объект с аналогичными функциями, но без прямого копирования.

Применяется обычно в том случае, если создатель оригинального объекта не предоставил информации о структуре и способе создания (производства) объекта. Правообладатели таких объектов могут заявить, что проведение обратной разработки или использование её результатов нарушает их исключительное право по закону об авторском праве и патентному законодательству.

Это перевод и автором является **Jacob Pimental**, но для лаконичности там, где он говорит «я», в тексте также будет говориться от первого лица, но имейте ввиду, что «я» - это Jacob Pimental.

Эта статья подразумевает, что у читателя есть хоть какие-то базовые знания в области программирования и языка Ассемблер. Если нет, то рекомендуется изучить «[Введение в Ассемблер](https://hackware.ru/?p=8654)», благодаря которому многое при анализе кода и отладке программы станет намного понятнее.

Обратный инжиниринг в программном обеспечении — это возможность разобрать (дизассемблировать) программу, чтобы увидеть, как она функционирует. Реинжиниринг позволяет разбирать на части программу или программное обеспечение и пересоздавать его без даже без доступа к исходному коду. Это используется, к примеру, при анализе вредоносного ПО (Malware Analysis) для понимания, что делают куски вредоносной программы, чтобы создать идентификатор для предупреждения последующих инфицирований вашего компьютера. Это также может использоваться для [исправления ошибок в старых играх](https://www.youtube.com/watch?v=A9U5wK_boYM), или для поиска эксплойтов в некоторых программах.

Radare2 — это инструмент, используемый в обратном инжиниринге. Он отличается от других инструментов тем, что он бесплатный, у него открыт исходный код и он использует интерфейс командной строки, а не графический. В этой статье я собираюсь провести вас по самым основам обратной инженерии: используя radare2, мы дизассемблируем программы, которые я предварительно для этого создал. [Здесь](https://github.com/JacobPimental/Intro-to-Radare2) вы можете загрузить эти программы, которые мы будем разбирать в этом уроке, или создать свою собственную и следовать уроку по аналогии.

Для установки Radare2 начните с проверки, возможно эта программу уже присутствует в стандартных репозиториях вашего дистрибутива.

Например, в Kali Linux эта программа не только присутствует, но и установлена по умолчанию.

В Debian и производных попробуйте выполнить установку с помощью команды:

|   |   |
|---|---|
|1|`sudo` `apt` `install` `radare2`|

В Arch Linux и BlackArch для установки Radare2 выполните:

|   |   |
|---|---|
|1|`sudo` `pacman -S radare2`|

Для установки Radare2 в дистрибутивы Linux, для которых она отсутствует в источниках приложений, вам нужно клонировать исходный код с [GitHub](https://github.com/radare/radare2) и запустить файл sys/install.sh:

```bash
git clone https://github.com/radare/radare2
cd radare2
sudo sys /install.sh
```


Теперь давайте взглянем на бинарники, которые вы [загрузили](https://github.com/JacobPimental/Intro-to-Radare2) ранее (или создали сами). Программа **intro** при запуске в консоли выводит строку “Hello World”:

```bash
./intro
Hello World
```

Код этой программы простой:

```c
#include <stdio.h>

void main(){
    printf("Hello World\n");
}
```

Radare2 поставляется с очень удобным инструментом под названием rabin2. Он может использоваться для вытягивания информации из бинарника, в этой информации будут: строки, время компиляции и другая полезная информация. Я обычно использую это перед запуском любого серьёзного анализа, поэтому могу узнать в общих чертах, что программа может быть делает. Я начну с добавления флага **-I**. Это даст нам важную информацию о бинарнике.

|   |   |
|---|---|
|1|`rabin2 -I intro`|

Пример вывода:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27<br><br>28<br><br>29<br><br>30<br><br>31|`arch     x86`<br><br>`baddr    0x0`<br><br>`binsz    6485`<br><br>`bintype  elf`<br><br>`bits     64`<br><br>`canary   false`<br><br>`class    ELF64`<br><br>`compiler GCC: (GNU) 7.2.0`<br><br>`crypto   false`<br><br>`endian   little`<br><br>`havecode true`<br><br>`intrp    /lib64/ld-linux-x86-64.so.2`<br><br>`laddr    0x0`<br><br>`lang     c`<br><br>`linenum  true`<br><br>`lsyms    true`<br><br>`machine  AMD x86-64 architecture`<br><br>`maxopsz  16`<br><br>`minopsz  1`<br><br>`nx       true`<br><br>`os       linux`<br><br>`pcalign  0`<br><br>`pic      true`<br><br>`relocs   true`<br><br>`relro    partial`<br><br>`rpath    NONE`<br><br>`sanitiz  false`<br><br>`static   false`<br><br>`stripped false`<br><br>`subsys   linux`<br><br>`va       true`|


![[Pasted image 20230720184407.png]]

Это говорит нам, что программа предназначена для работы на Linux и что она была написана на языке программирования C. Мы также можем увидеть что **bintype** имеет значение “**elf**”. Это называется «магическим числом» (“magic number”) и может нам помочь узнать, какого типа этот файл (бинарник Linux). Это всё, что нам нужно сейчас знать. Следующая команда, которую я люблю использовать, это **rabin2 -z**. Она выведет список всех строк из секции данных (data) этого бинарного файла. Запуском этой команды мы можем увидеть нашу строку “Hello World”:

```bash
rabin2 -z intro
```

Пример вывода:

---

|   |   |
|---|---|
|1<br><br>2<br><br>3|`[Strings]`<br><br>`Num Paddr      Vaddr      Len Size Section  Type  String`<br><br>`000 0x000006e4 0x000006e4  11  12 (.rodata) ascii Hello World`|


![[Pasted image 20230720184506.png]]

После этого я иногда продолжаю с **rabin2 -zz**, которая показывает все строки в бинарнике (а не только из секции данных). Она выводит обычно довольно много строк. Иногда там имеются важные спрятанные строки, иногда — нет. В случае с разбираемой программой, там ничего интересного, поэтому мы закончили с **rabin2**. Другие флаги **rabin2** вы можете посмотреть командой:

|   |   |
|---|---|
|1|`rabin2 -h`|

Имеется много других интересных вещей, которые может показать **rabin2**, такие как импорты, экспорты и секции кода, но для данного двоичного файла это не особо интересно. При анализе вредоносного ПО, этим команды могут пригодиться, но не для такой простой программы вроде этой.

Поэтому теперь мы можем перейти к действительному запуску нашей программы в **radare2** для просмотра кода Ассемблера. Запускаем команду:

|   |   |
|---|---|
|1|`r2 intro`|

Она загрузит наш исполнимый файл в **radare2**. Следующий шаг — это включить анализ двоичного файла в **radare2**. С помощью него найдуться такие вещи как строки, функции и другая важная информация, которую **radare2** может показать нам во время анализа, то есть мы не просто пялимся в код Ассемблера. Для включения анализа, запустите команду “**aa**”. Это базовая команда анализа для **radare2**. У нас также есть “**aaa**” и “**aaaa**”, каждая анализирует больше информации, чем предыдущая. На данный момент нам достаточно просто “**aa**”.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`r2 intro`<br><br> `-- Enhance your graphs by increasing the size of the block and graph.depth` `eval` `variable.`<br><br>`[0x00000540]> aa`<br><br>`[x] Analyze all flags starting with sym. and entry0 (aa)`<br><br>`[0x00000540]>`|

![[Pasted image 20230720184640.png]]

Теперь наш исполнимый файл анализируется, мы можем перейти в раздел бинарника, где на самом деле размещён код. Команда “**s**” в **radare2** используется для “seek” (поиска) места в памяти. Её можно использовать либо с действительным шестнадцатеричным адресом, или мы можем напечатать имя функции, которую надо найти. Поскольку мы знаем, что большинство программ Linux запускаются с функции “**main**”, мы можем поискать её:

|   |   |
|---|---|
|1<br><br>2|`[0x00000540]> s main`<br><br>`[0x0000064a]>`|

Вы заметите, что адрес у курсора сменился с 0x00000540 на 0x0000064a. Это означает, что теперь текущим адресом является 0x0000064a и что мы в функции **main**. Мне нравится анализировать код в визуальном режиме **radare2** (прямо сейчас мы в командном режиме). Для переключения в визуальный режим наберите “**v**” и нажмите Enter.

|   |   |
|---|---|
|1|`[0x0000064a]> v`|

![[Pasted image 20230720184740.png]]

То, на что вы смотрите сейчас — это шестнадцатеричный редактор **radare2** (да, у него есть всё!). Но это не обязательно код, который мы хотим видеть. Для изменения вида нажимайте “**p**”. Вид смениться на «вид разборки» (disassembly view) и мы сможем увидеть код ассемблера программы. Обратите внимание, что radare2 отделяет функции на небольшие типы ASCII «блоков». Код главной функции выглядит примерно так:

```c
/ (fcn) sym.main 19                                                                                                                                                                           
|   sym.main ();                                                                                                                                                                              
|              ; DATA XREF from 0x0000055d (entry0)                                                                                                                                           
|           0x0000064a      55             push rbp                                                                                                                                           
|           0x0000064b      4889e5         mov rbp, rsp                                                                                                                                       
|           0x0000064e      488d3d8f0000.  lea rdi, str.Hello_World    ; 0x6e4 ; "Hello World"                                                                                                
|           0x00000655      e8d6feffff     call sym.imp.puts           ;[1] ; int puts(const char *s)                                                                                         
|           0x0000065a      90             nop                                                                                                                                                
|           0x0000065b      5d             pop rbp                                                                                                                                            
\           0x0000065c      c3             ret
```

Теперь давайте пройдёмся по исходному коду. Поскольку этот исполнимый файл является x64 приложением, мы можем увидеть, что мы помещаем нашу строку “Hello World” в rdi по адресу памяти 0x0000064e. Затем мы вызываем функцию “sym.imp.puts” (или “**puts**”), которая то же самое, что и “**printf**”. То есть эта функция напечатает нашу строку. После этого команда “**nop**” делает абсолютно ничего (как команда **pass** в python), затем мы очищаем и завершаем функцию, используя “**pop rbp**” и “**ret**”. Поскольку наша функция закончила работу, и поскольку это главная функция, наша программа также отработала.

![[Pasted image 20230720185539.png]]

Даже без запуска самой программы мы можем сказать, что эта программа выводит стоку “Hello World”.

Это было очень простое применение **radare2**. В следующей статье мы будем использовать **radare2** для «взлома» простой программы в стиле Capture the Flag (решение хакерских задач, когда доказательством достижения цели является получение специально спрятанной автором задачи информации - «Флага»)

---

# Часть 2

Эта статья является продолжением первой статьи «[Обратный инжиниринг с использованием Radare2 (Reverse Engineering)](https://hackware.ru/?p=8498)», где дано базовое введение в инструмент. Настоятельно рекомендуется начать оттуда, если вы этого ещё не сделали, поскольку первая часть охватывает самые основы.

Эта статья продемонстрирует некоторые другие интересные возможности **Radare2**, проведём вас через процесс решения простой задачи с программой в стиле Capture the Flag. Вы можете [загрузить](https://github.com/JacobPimental/Intro-to-Radare2) эту программу с GitHub (исполнимый файл **crackme**). Если вы уже ушли дальше и запустили это программу, вы увидите, что она требует от нас ввода пароля.

|   |   |
|---|---|
|1<br><br>2|`.``/crackme`<br><br>`What's the password?`|

Если мы попробуем ввести пароль, пусть даже неверный, то мы увидем сообщение, которое говорит о том, что мы потерпели неудачу.

|   |   |
|---|---|
|1<br><br>2<br><br>3|`.``/crackme`<br><br>`What's the password?` `test`<br><br>`You failed`|

Есть несколько способов разрешить эту проблему. Мы можем попытаться брут-форсить пароль, отправляя в программу множество различных комбинаций из букв, пока мы случайно не вычислим пароль. Длина стандартного пароля примерно 8 символов. Разумно предположить, что пароль составлен из больших и маленьких букв и, может быть, даже цифр. В соответствии с [этим калькулятором](http://lastbit.com/pswcalc.asp), тогда подбор такого пароля займёт примерно 15 лет чтобы узнать его методом брут-форса. У меня нет столько времени на ожидание, поэтому я собираюсь использовать Radare2 для взлома пароля.

Точно также, как и в предыдущем уроке, мы начнём с использования **rabin2**, чтобы получить некоторую информацию об этой программе. Давайте запустим её с опцией **-I**, чтобы увидеть, с чем мы имеем дело.

|   |   |
|---|---|
|1|`rabin2 -I crackme`|

Вывод:

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>11<br><br>12<br><br>13<br><br>14<br><br>15<br><br>16<br><br>17<br><br>18<br><br>19<br><br>20<br><br>21<br><br>22<br><br>23<br><br>24<br><br>25<br><br>26<br><br>27|`arch     x86`<br><br>`binsz    6759`<br><br>`bintype  elf`<br><br>`bits     64`<br><br>`canary   true`<br><br>`class    ELF64`<br><br>`crypto   false`<br><br>`endian   little`<br><br>`havecode true`<br><br>`intrp    /lib64/ld-linux-x86-64.so.2`<br><br>`lang     c`<br><br>`linenum  true`<br><br>`lsyms    true`<br><br>`machine  AMD x86-64 architecture`<br><br>`maxopsz  16`<br><br>`minopsz  1`<br><br>`nx       true`<br><br>`os       linux`<br><br>`pcalign  0`<br><br>`pic      true`<br><br>`relocs   true`<br><br>`relro    partial`<br><br>`rpath    NONE`<br><br>`static   false`<br><br>`stripped false`<br><br>`subsys   linux`<br><br>`va       true`|

Точно также, как и в предыдущий раз, мы видим, что имеем дело с исполнимым файлом x64 Linux, который был написан на C. Эта информация интересная, но не особо нам помогает узнать, что же там за пароль. Может быть строки из исполнимого файла дадут нам ключ. Мы можем просмотреть их используя **rabin2**. Обычно мы используем флаг **-z**, но он показывает много вывода. Мы можем использовать флаг **-zqq** для показа только строк.

|   |   |
|---|---|
|1|`rabin2 -zqq crackme`|

```
What's the password?
radare2
Congratulations
What's the second password?
What's the third password?`
You failed
Flag is: r2{%s %s %s}\n
```

![[Pasted image 20230721075237.png]]

Здесь мы можем видеть много интересных вещей! Мы видим сообщение, которое говорит “You failed” («вы потерпели неудачу»), которое мы получили когда ввели неверный пароль. Мы также можем видеть “Congratulations” («Поздравления»), которые, как можно предположить, мы получим когда введём правильный пароль. Мы также видим строку “radare2”. Мы можем предположить, что это может быть пароль. Может быть и не так, но от попытке хуже не будет.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4|`.``/crackme`<br><br>`What's the password? radare2`<br><br>`Congratulations`<br><br>`What's the second password?`|

Отлично, мы узнали пароль! Иногда это не так просто, строка пароля может быть обфусцирована или зашифрована. В подобных случаях мы должны обратным инжинирингом узнать способ шифрования, но, как видим, в этот раз нам повезло.

Тем не менее теперь у нас спрашивают другой пароль, чтобы мы могли пройти в этом испытании дальше. Проверяя строки ещё раз, я больше не вижу ничего такого, что выглядит как пароль, поэтому нам нужно продолжить углубляться. Давайте загрузим исполнимый файл в **radare2** и проанализируем его используя “**aaa**”. Эта команда проанализирует все функции, какие имеет программа.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10|`r2 crackme`<br><br> `-- Pass` `'-j'` `to rabin2 to get the information of the binary` `in` `JSON` `format``.`<br><br>`[0x000006f0]> aaa`<br><br>`[x] Analyze all flags starting with sym. and entry0 (aa)`<br><br>`[x] Analyze` `function` `calls (aac)`<br><br>`[x] Analyze len bytes of instructions` `for` `references (aar)`<br><br>`[x] Check` `for` `objc references`<br><br>`[x] Check` `for` `vtables`<br><br>`[x] Type matching analysis` `for` `all functions (aaft)`<br><br>`[x] Use -AA or aaaa to perform additional experimental analysis.`|

![[Pasted image 20230721075331.png]]

Нам также следует поискать функцию **main**, поскольку с неё начинается программа.

|   |   |
|---|---|
|1<br><br>2|`[0x000006f0]> s main`<br><br>`[0x000007fa]>`|

Теперь, когда мы на функции **main**, мы переключимся в графический режим radare2. Это попоможет нам увидеть как программа течёт и увидеть, где выполняются проверки этих паролей. Для перехода в графический режим, используйте команду “**VV**”.

|   |   |
|---|---|
|1|`[0x000007fa]> VV`|

Вы должны увидеть ascii график radare2. Вы можете передвигаться по графику используя клавиши **HJKL** как в **Vim** или курсорные клавиши. Если вы посмотрите на первый блок в графике, вы можете увидеть проверку нашего первого пароля.

![[Pasted image 20230721075402.png]]

Вы можете увидеть в последних нескольких строчках, что принимается строка “**radare2**” и сравнивается с вводом пользователя используя функцию **strcmp**. Затем делается проверка, чтобы выяснить, строки одинаковые или нет. Если они не одинаковые, тогда мы следуем по зелёной линии **t** (которая означает, что условие истинно) вниз к этому блоку кода:

![[Pasted image 20230721075426.png]]

Мы можем видеть в верхнем блоке, что программа сравнивает некоторую величину с нулём. Если она не равна нулю, то выводится выражение “Flag is: r2{%s %s %s}”. Это должен быть наш флаг по завершению задания. К сожалению, вместо статичной строки, используется формат вывода строки, поэтому просто глядя на эту запись мы не знаем, каким будет флаг. Если эта переменная в первом блоке равна нулю, тогда он печатает сообщение “You failed”. Таким образом, из этого можно сделать вывод, что некоторая переменная, которая определяет, будет ли получен флаг, будет изменена, как только мы введём все правильные пароли. Давайте перейдём к вершине и посмотрим, что произойдёт, если мы получим правильный первый пароль.

![[Pasted image 20230721075501.png]]

Итак, этот блок печатает строку с поздравлениями “Congratulations”, затем печатает запрос на ввод второго пароля “What’s the second password?”, затем он берёт нашу строку ввода используя **scanf** и пропускает его через функцию **atoi**. Функция **atoi** используется для конвертации строки в число, поэтому второй пароль должен быть числом! Мы можем видеть, что в блоке вывод **atoi** сравнивается со значением **0xf**. Теперь если вы не знаете с ходу десятичное значение этого шестнадцатеричного числа, то у radare2 для вас имеется другой замечательный инструмент! Откройте новый терминал и используйте команду **rax2** для конвертации значения **0xf** в десятичное число.

|   |   |
|---|---|
|1<br><br>2|`rax2 0xf`<br><br>`15`|

Итак, второй пароль это 15! Давайте попробуем его и посмотрим, работает ли он.

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6|`.``/crackme`<br><br>`What's the password? radare2`<br><br>`Congratulations`<br><br>`What's the second password? 15`<br><br>`Congratulations`<br><br>`What's the third password?`|

Кажется нам ещё нужно вводить и третий пароль. Давайте продвинимся вниз к следующему блоку кода в radare2 и посмотрим, что нам нужно делать.

![[Pasted image 20230721075519.png]]

Это похоже на предыдущую проверку пароля, которую мы делали. Вы можем видеть, что спрашивается третий пароль, пользовательский ввод пропускается через **atoi** и сравнивается со значением **0x539**. Если мы пропустим его через **rax2**, мы найдём, что это десятичный эквивалент 1337. Итак, мы вставляем его в качестве последнего пароля и получаем:

|   |   |
|---|---|
|1<br><br>2<br><br>3|`What's the third password? 1337`<br><br>`Congratulations`<br><br>`Flag is: r2{radare2 15 1337}`|

Отлично! Это дало нам наш флаг! Если бы это был настоящий Capture the Flag, тогда нам нужно было бы ввести куда-то это значение для получения очков.

Мы сумели получить пароли без необходимости запускать программу много раз и нам даже совсем не пришлось угадывать пароли. Обратный инжиниринг приложения, алгоритма его работы, дали нам всю необходимую информацию. Реверс-инжиниринг — очень удобный инструмент, который можно использовать в любых условиях, поскольку вы можете применить его, чтобы узнать всё, что делает приложение. Я надеюсь, что введение в **radare2** было полезным для тех, кто хочет начать на этом поприще.

Спасибо за чтение и весёлого ревёрсинга!