![[Pasted image 20221210135459.png]]

### Понятие стека и его предназначение

Под стеком в программировании подразумевают структуру данных, построенную по принципу ПОСЛЕДНИЙ ВОШЁЛ - ПЕРВЫЙ ВЫШЕЛ (LIFO, last in first out), т.е. такой объект, над которым определены операции "добавить элемент" и "извлечь элемент", причём элементы, которые были добавлены, извлекаются в обратном порядке.

В применении к низкоуровнему программированию понятие стека ещё уже: здесь под стеком понимается непрерывная область памяти, для которой в специальном регистре хранится **адрес вершины стека**, причём память в рассматриваемой области выше вершины (т.е. с адресами, меньшими адреса вершины) считается свободной, а память от вершины до конца области (до старших адресов), включая и саму вершину, считается занятой; регистр, хранящий адрес вершины, называется **указателем стека** (см. рисунок). Операция добавления в стек некоторого значения уменьшает адрес вершины, сдвигая тем самым вершину вверх (т.е. в направлении меньших адресов) и в новую вершину записывает добавляемое значение; операция извлечения считввает значение с вершины стека и сдвигает вершину вниз, увеличивая её адрес.

Стек можно использовать, например, для временного хранения значений регистров; если некоторый регистр хранит важное для нас значение, а нам при этом нуно временно задействовать этот регистр для хранения другого значения, то самый простой способ выйти из положения - это сохранить значение регистра в стеке, затем использовать регистр под другие нужды, и, наконец, восстановить исходное значение регистра путём извлечения этого значения из стека обратно в регистр. Но гораздо более важно другое: **стек используется при вызовах подпрограмм для хранения адресов возврата, для передачи фактических параметров и для хранения локальных переменных**. Именно использование стека позволяет реализовать механизм рекурсии, при котором подпрограммма может прямо или косвенно вызвать сама себя.

### Организация стека в процессоре

Команды работы со стеком позволяют заносить в стек и извлекать из него двухбайтные слова и четырёхбайтные двойные слова; отдельные байты записывать в стек нельзя, так что адрес вершины стека всегда остаётся чётным.

Регистр ESP, формально относящийся к группе регистров общего назначения, тем не менее практически никогда не используется ни в какой иной роли, кроме роли **указателя стека**; название этого регистра как раз и означает stack pointer. Считается, что адрес, содержащийся в ESP, указывает на вершину стека, то есть на ту область памяти, где находится последнее занесённое в стек значение. Стек растёт в сторону уменьшения адресов, т.е. при занесении в стек нового значения ESP уменьшается, при извлечении значения - увеличивается.

Занесение значения в стек производится командой **push**, имеющей один операнд. Этот операнд может быть непосредственным, регистровым или типа "память" и иметь размер word или dword (если операнд не регистровый, то размер необходимо указать явно). Для извлечения значения из стека используется команда **pop**, операнд которой может быть регистровым или типа "память"; естественно, операнд должен иметь размер word или dword.

  
  

### Стек

Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.

Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора. Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.

В итоге стек позволяет управлять памятью наиболее эффективным образом — но если вам нужно использовать динамические структуры данных или глобальные переменные, то стоит обратить внимание на кучу.


#### Теория

- Стек _времени выполнения_ — это массив памяти, управляемый непосредственно ЦП с использованием регистра ESP, известного как _регистр указателя стека_ .
- Регистр ESP содержит 32-битное смещение относительно некоторого места в стеке. Мы редко манипулируем ESP напрямую; вместо этого он косвенно модифицируется такими инструкциями, как CALL, RET, PUSH и POP.  
    
- ESP всегда указывает на последнее значение, которое нужно добавить или _поместить_ на вершину стека.  
    

Для демонстрации начнем со стека, содержащего одно значение.  

- На рис. 1 ESP (расширенный указатель стека) содержит шестнадцатеричное число 00001000, смещение последнего помещенного значения (00000006).  
    
- На наших диаграммах вершина стека перемещается вниз, когда значение указателя стека уменьшается:  
    
- Каждая ячейка стека на этом рисунке содержит 32 бита, что имеет место, когда программа работает в 32-битном режиме. В режиме 16-битного реального адреса регистр SP указывает на самое последнее переданное значение, а записи стека обычно имеют длину 16 бит.
  

![[Pasted image 20230618071516.png]]

#### PUSH-операция

- 32-разрядная операция push уменьшает указатель стека на 4 и копирует значение в место в стеке, на которое указывает указатель стека.
- На рис. 2 показан эффект помещения 000000A5 в стек, который уже содержит одно значение (00000006). Обратите внимание, что регистр ESP всегда указывает на вершину стека.  
    
- На рисунке показан порядок стека, противоположный порядку стека пластин, который мы видели ранее, потому что стек времени выполнения растет в памяти вниз, от более высоких адресов к более низким адресам. Перед пушем ESP = 00001000h; после нажатия ESP = 00000FFCh.

![[Pasted image 20230618071605.png]]

- На рис. 3 показан тот же стек после помещения в него четырех целых чисел.
![[Pasted image 20230618071621.png]]

#### POP-операция

- Операция _pop_ удаляет значение из стека. После извлечения значения из стека указатель стека увеличивается (на размер элемента стека), чтобы указывать на следующее по величине место в стеке.
- На рис. 4 показан стек до и после извлечения значения 00000002.

![[Pasted image 20230618071650.png]]

- Область стека ниже ESP _логически пуста_ и будет перезаписана в следующий раз, когда текущая программа выполнит любую инструкцию, которая помещает значение в стек.

#### Стек приложений

Есть несколько важных применений стеков времени выполнения в программах:  

- Стек представляет собой удобную временную область для хранения регистров, когда они используются более чем для одной цели. После изменения их можно восстановить до исходных значений.  
    
- Когда выполняется инструкция CALL, ЦП сохраняет адрес возврата текущей подпрограммы в стеке.  
    
- При вызове подпрограммы вы передаете входные значения, называемые _аргументами_ , помещая их в стек.  
    
- Стек обеспечивает временное хранение локальных переменных внутри подпрограмм.

#### PUSH- и POP-инструкции

###### PUSH-инструкции

Инструкция PUSH сначала уменьшает ESP, а затем копирует исходный операнд в стек.  
16-битный операнд вызывает уменьшение ESP на 2. 32-битный операнд вызывает уменьшение ESP на 4.

Существует три формата инструкций:  

```
PUSH reg/mem16
PUSH reg/mem32
PUSH imm32
```

##### POP-инструкции

Инструкция POP сначала копирует содержимое элемента стека, на который указывает ESP, в 16- или 32-битный операнд назначения, а затем увеличивает ESP. Если операнд 16-битный, ESP увеличивается на 2; если операнд 32 бита, ESP увеличивается на 4:  

```
POP reg/mem16
POP reg/mem32
```

##### Инструкции PUSHFD и POPFD

- Инструкция PUSHFD помещает 32-битный регистр EFLAGS в стек, а POPFD извлекает из стека регистр EFLAGS:  
    

```
pushfd
popfd
```

- 16-разрядные программы используют инструкцию PUSHF для помещения 16-разрядного регистра FLAGS в стек и POPF для извлечения из стека FLAGS.  
    
- в 32-битном программировании можно использовать как PUSHF, так и PUSHFD для помещения 32-битных EFLAGS в стек.
- Инструкцию MOV нельзя использовать для копирования флагов в переменную, поэтому PUSHFD может быть лучшим способом сохранить флаги. Бывают случаи, когда полезно сделать резервную копию флагов, чтобы потом можно было восстановить их прежние значения. Часто мы заключаем блок кода в PUSHFD и POPFD:  
    

```
pushfd ; save the flags
;
; any sequence of  statements here...
;
popfd ; restore the flags
```

- При использовании push и pop такого типа убедитесь, что путь выполнения программы не пропускает инструкцию POPFD. Когда программа изменяется с течением времени, может быть сложно вспомнить, где расположены все нажатия и выталкивания.

Необходимость в точной документации имеет решающее значение!  
Менее подверженный ошибкам способ сохранения и восстановления флагов — поместить их в стек и сразу же вставить в переменную:  

```
.data
saveFlags DW 0
.code
pushfd ; push flags on  stack
pop saveFlags ; copy into  a variable
```

- Следующие операторы восстанавливают флаги из той же переменной:

```
push saveFlags ; push  saved flag values
popfd ; copy into the  flags
```

##### PUSHAD, PUSHA, POPAD, и POPA

- Инструкция PUSHAD помещает все 32-битные регистры общего назначения в стек в следующем порядке:  
    EAX, ECX, EDX, EBX, ESP (значение перед выполнением PUSHAD), EBP, ESI и EDI.
- Инструкция POPAD извлекает те же самые регистры из стека в обратном порядке.
- Точно так же в 16-битных программах инструкция PUSHA, представленная в процессоре 80286, помещает 16-битные регистры общего назначения (AX, CX, DX, BX, SP, BP, SI, DI) в стек в указанном порядке.
- Инструкция POPA выталкивает те же регистры в обратном порядке.
- в 32-битном программировании POPA и POPAD, соответственно, PUSHA и PUSHAD ведут себя одинаково

Если вы пишете процедуру, которая изменяет ряд 32-битных регистров, используйте PUSHAD в начале процедуры и POPAD в конце, чтобы сохранить и восстановить регистры. Следующий фрагмент кода является примером:

```
pushad ; save  general-purpose registers
.
.
mov eax,...
mov edx,...
mov ecx,...
.
.
popad ; restore  general-purpose registers
```

- Следует указать на важное исключение из приведенного выше примера; процедуры, возвращающие результаты в один или несколько регистров, не должны использовать PUSHA и PUSHAD.
- Предположим, следующая **процедура ReadValue** возвращает целое число в EAX; вызов POPAD перезаписывает возвращаемое значение из EAX:

```
ReadValue PROC
pushad ; save  general-purpose registers
.
.
mov eax,return_value
.
.
popad ; overwrites EAX!
ret
ReadValue ENDP
```

##### Примеры

![[Pasted image 20230618071740.png]]

![[Pasted image 20230618071746.png]]

![[Pasted image 20230618071751.png]]

![[Pasted image 20230618071803.png]]

- ESP **В отличие от регистра** , управление базовым указателем EBP осуществляется только явно.
- EBP используется языками высокого уровня для ссылки на параметры функций и локальные переменные в стеке. Его нельзя использовать для обычных арифметических операций или передачи данных, кроме как на продвинутом уровне программирования. Его часто называют _расширенным регистром указателя кадра_ .
    
- Роль EBP будет уточнена на последних курсах семестра, когда будет изучаться интеграция языка ассемблера с языками программирования высокого уровня (а именно C в нашем случае). Но несколько слов о роли регистров стека EBP и ESP в функционировании стека времени выполнения можно сказать и в этот момент, учитывая только код ASM для реализации функции, концепция, признанная только высокоуровневым **программированием** . язык.
- Новая вызываемая процедура/функция станет текущей выполняемой подпрограммой, поэтому в стеке времени выполнения для этой подпрограммы должен быть построен новый кадр стека. Этот новый кадр стека будет ограничен регистрами указателя стека EBP (в основе) и ESP (вверху), поэтому значения из EBP и ESP должны быть обновлены для адаптации к новому контексту подпрограммы.
    
- Но для того, чтобы иметь возможность после вызова вернуться к вызывающей стороне, стековый фрейм вызывающей стороны должен быть восстановлен, поэтому текущее («старое») значение EBP для вызывающей стороны должно быть сохранено. Это делается в первую очередь новой вызванной подпрограммой, которая сохраняет В СТЕКЕ с помощью PUSH EBP базовый адрес стекового фрейма вызывающей стороны. После этого значение EBP может быть обновлено так, чтобы оно указывало на начало нового кадра стека ( _mov ebp,esp_ ), которое будет именно тем местом, которое показывает ESP, поэтому новый кадр стека будет начинаться со значения «старого» EBP. . Таким образом, в этой точке EBP и ESP имеют одинаковое значение (указывающее, что новый кадр стека пуст и готов принять необходимые данные для «роста» и начала выполнения текущей подпрограммы.
- Этот механизм кратко проиллюстрирован ниже на примере процедуры **AddTwo** , которая складывает значения двух переданных параметров и возвращает их сумму в EAX:

**Добавить два:**  

```
push ebp; saving the caller’s  stackframe base for further being able to restore it
mov ebp,esp ; initialising the base of the new stack frame for the currently  executing 
; procedure AddTwo  (see the  picture below which illustrates exactly 
; this described situation)
mov eax,[ebp + 12] ; transferring into EAX the value of the second parameter passed 
; on to the stack by the caller BEFORE  the new stackframe takes 
; the run time control
add eax,[ebp + 8] ; adding to EAX the first parameter
pop ebp ; restoring the caller stackframe  as being the new currently executing one 
ret ; going back immediately to the point of call for continuing the execution 
  ;  of the program
```

Кадр стека после отправки EBP и значения ESP были скопированы в EBP:

![[Pasted image 20230618071844.png]]

После выполнения следующих двух инструкций (mov и add) на следующем рисунке показано содержимое кадра стека: вызов функции, такой как AddTwo(5, 6), приведет к тому, что второй параметр будет помещен в стек, а затем первый параметр:

![[Pasted image 20230618071854.png]]

AddTwo может помещать в стек дополнительные регистры, не изменяя смещения параметров стека от EBP. ESP изменит значение, а EBP — нет.


### Куча

Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.

  

Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны. Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.

В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей.

  
  

  
  