# Порядок байтов 

Допустим я создаю простую переменную:

```c
char max[] = "Max";
```

Глянем код под gdb:

```
mov    DWORD PTR [rbp-0xc],0x78614d
```

- 78 - x 
- 61 - a
- 4d - M

У нас получается "xaM". 

То, что вы видите в отладчике, связано с порядком байтов (эндиянностью) в памяти.

**Эндиянность и порядок байтов**

Существует два основных типа порядка байтов:

1. **Младший байт первым (Little-endian)**: Младшие байты значения хранятся по меньшим адресам, старшие — по большим.
2. **Старший байт первым (Big-endian)**: Старшие байты значения хранятся по меньшим адресам, младшие — по большим.

**Что происходит в вашем случае**

Когда вы объявляете строку:

```c
char max[] = "Max";
```

Компилятор преобразует её в массив символов `{'M', 'a', 'x', '\0'}`. В отладчике вы видите значение `0x78614d`, которое соответствует байтам строки, но в обратном порядке.

**Как это выглядит в памяти**

В случае little-endian, массив `{'M', 'a', 'x', '\0'}` (в шестнадцатеричном формате это `0x4D 0x61 0x78 0x00`) будет записан в память следующим образом:

```arduino
0x4D ('M')  0x61 ('a')  0x78 ('x')  0x00 ('\0')
```


Но в little-endian, если вы интерпретируете это как одно 32-битное значение, память будет отображаться следующим образом:

```css
[0x00][0x78][0x61][0x4D]
```

Таким образом, значение в памяти для строки `"Max"` при little-endian будет отображаться как `0x78614D00`. Если вы смотрите только на первые три байта (без нулевого байта `\0`), это будет `0x78614D`, что соответствует строке `"xaM"`.

**Почему строка в обратном порядке?**

Причина в том, как отладчик отображает это значение в little-endian системе. Он показывает байты в порядке от младшего к старшему, что вызывает эффект, будто строка `"Max"` хранится в обратном порядке. 


**Как правильно интерпретировать?**

Когда вы видите `0x78614D` в отладчике, это означает, что строка `"Max"` хранится в памяти как `{'M', 'a', 'x', '\0'}`, но при выводе целого значения этих байтов они отображаются в little-endian порядке. Это просто отображение порядка байтов в памяти, а не фактический порядок символов в строке.

Использование little-endian (LE) порядка байтов исторически обусловлено рядом факторов, связанных с архитектурой процессоров, производительностью и совместимостью.


Допустим у меня строка **AABBCC**. 

**Как строка хранится в памяти:**

Строка `"AABBCC"` в памяти будет выглядеть так:

- **'A'**: 0x41
- **'A'**: 0x41
- **'B'**: 0x42
- **'B'**: 0x42
- **'C'**: 0x43
- **'C'**: 0x43
- **'\0'** (null-терминатор): 0x00

**Влияние little-endian:**

Little-endian порядок означает, что если бы эта строка представляла собой 48-битное значение (6 байтов), то байты в памяти будут расположены так, что младший байт окажется по наименьшему адресу, а старший — по наибольшему.

**Порядок байтов в памяти:**

В little-endian строка `"AABBCC"`  - `\xdd\xcc\xbb\xaa`

- **0x41** (младший байт)
- **0x41**
- **0x42**
- **0x42**
- **0x43**
- **0x43** (старший байт)

Учитывайте то что вершина стека имеет наименьший адрес, а у нас младший байт у нас это **0x4141** (**AA**). Запись начинается с это места учитывая порядок little-endian

Давайте представим, что у нас есть 32-битное число (4 байта) со значением 0x12345678.  Мы хотим добавить это число в стек. 

**Big-Endian:**

Память:  В Big-Endian системе байты будут записаны в память в следующем порядке:
- **0x12** (самый старший байт) по адресу  0x1000
- **0x34** по адресу 0x1001
- **0x56** по адресу 0x1002
- **0x78** (самый младший байт) по адресу 0x1003

Стек:  В стек число будет добавлено как единое целое,  независимо от того, как байты хранятся в памяти.  

**Little-Endian:**

Память:  В Little-Endian системе байты будут записаны в память в следующем порядке:
- **0x78** (самый младший байт) по адресу  0x1000
- **0x56** по адресу 0x1001
- **0x34** по адресу 0x1002
- **0x12** (самый старший байт) по адресу 0x1003

**Стек:**  В стек число будет добавлено как единое целое,  независимо от того, как байты хранятся в памяти. 

**Результат:**

Независимо от порядка байтов, в стеке будет храниться  целое  число 0x12345678.  Порядок байтов  влияет только на то,  как  это  число  будет  записано  в  память,  но  не  на  его  логическое  представление  в  стеке. 
### Основные причины использования little-endian:

1. **Производительность и упрощение аппаратного обеспечения**:
    - **Математические операции**: В little-endian порядок байтов упрощает работу с целыми числами, особенно при сложении, вычитании и других арифметических операциях. Так как младшие байты хранятся по более низким адресам, процессор может выполнять арифметические операции быстрее, начиная с младших байтов и продвигаясь к старшим. Например, если число занимает несколько байтов, то сумма начинается с младших байтов, и если возникает перенос, он может быть сразу добавлен к следующему байту, что упрощает дизайн процессора.
2. **Совместимость и наследие**:
    - **Архитектура x86**: Процессоры с архитектурой x86 (Intel, AMD) используют little-endian, что стало де-факто стандартом для большинства персональных компьютеров. Исторически это связано с архитектурными решениями, принятыми в начале разработки процессоров Intel. В результате этого LE порядок байтов стал широко использоваться и в других архитектурах, которые стремятся быть совместимыми с x86.
3. **Легкость работы с различными типами данных**:
    - **Универсальность**: Little-endian позволяет легко работать с различными типами данных. Например, если у вас есть 32-битное значение, хранящееся в little-endian формате, и вы хотите прочитать его как 16-битное, вы просто берете первые два байта. В big-endian вам пришлось бы учитывать, что 16-битные и 32-битные значения лежат в разных частях памяти, что усложняет операции.
4. **Исторические причины и влияние платформ**:
    - **DEC VAX и другие старые системы**: В старых компьютерных системах, таких как DEC VAX, также использовался little-endian порядок, что способствовало его распространению. В то время как big-endian также широко использовался в других системах (например, IBM), развитие персональных компьютеров и доминирование архитектуры x86 закрепило little-endian в качестве наиболее распространенного порядка байтов.
5. **Простота программирования**:
    - **Работа с указателями и преобразованиями типов**: В little-endian системе указатель на данные может указывать на младший байт, что упрощает работу с типами данных разного размера, преобразования и доступ к данным.


### Почему не big-endian?

Big-endian (BE) также имеет свои преимущества и используется в других архитектурах (например, в некоторых сетевых протоколах, PowerPC). Однако в большинстве современных систем, особенно в ПК и серверах, преимущество оказалось на стороне little-endian из-за вышеуказанных причин.

### Заключение 

Little-endian стал стандартом в первую очередь из-за архитектурных решений в процессорах x86 и их наследия, что привело к его широкому использованию. Большинство современных процессоров и систем ориентируются на x86 совместимость, что и поддерживает использование LE на протяжении многих лет.


# Переменные 

В языке C существует несколько видов переменных, каждая из которых по-разному управляется компилятором и отображается в машинном коде на уровне ассемблера. Рассмотрим основные типы переменных в C и их соответствие на уровне ассемблера:

### Локальные переменные (Local Variables)

Простыми словами, переменные, объявляемые внутри функций или цикла, называются локальными переменными. 

Локальные переменные (или автоматические переменные) обычно размещаются в **стеке** (stack). Стек — это область памяти, используемая для хранения данных, связанных с вызовами функций, таких как локальные переменные, параметры функции и адреса возврата.

- **Описание**: Переменные, объявленные внутри функций. Доступны только в пределах функции.
- **Ассемблер**: Хранятся в стеке. Компилятор выделяет место для них с помощью инструкции `sub` для указателя стека (`esp` или `rsp`), а доступ к ним осуществляется через указатель стека (`ebp` или `rbp`).

```c
void func() {
    int local_var = 5;
}
```

```asm
func:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 4      ; выделение места для локальной переменной
    mov     DWORD PTR [rbp-4], 5   ; инициализация local_var
    ...
    leave
    ret
```

Основные характеристики размещения локальных переменных в стеке:

- **Автоматическое управление памятью:** Память для локальных переменных выделяется автоматически при входе в функцию и освобождается при выходе из неё. Это происходит благодаря тому, что при каждом вызове функции создаётся новый фрейм стека (stack frame), в который помещаются локальные переменные и другие данные, связанные с выполнением этой функции.
    
- **Упорядоченное размещение:** Локальные переменные размещаются в стеке последовательно. Порядок их размещения определяется компилятором и может зависеть от различных факторов, включая архитектуру процессора и оптимизации.
    
- **Ограниченный размер:** Поскольку стек имеет ограниченный размер (обычно несколько мегабайт), чрезмерное использование локальных переменных большого размера или глубокая рекурсия могут привести к переполнению стека (stack overflow).

**Порядок расположении данных в стеке**


```c  
void foo(){  

    int a = 5;  
    int b = 10;  
    int c = 15;    
}
```

```asm
  0x0000000000001119 <+0>:     push   rbp  
  0x000000000000111a <+1>:     mov    rbp,rsp  
  0x000000000000111d <+4>:     mov    DWORD PTR [rbp-0xc],0x5  
  0x0000000000001124 <+11>:    mov    DWORD PTR [rbp-0x8],0xa  
  0x000000000000112b <+18>:    mov    DWORD PTR [rbp-0x4],0xf  
  0x0000000000001132 <+25>:    nop  
  0x0000000000001133 <+26>:    pop    rbp  
  0x0000000000001134 <+27>:    ret
```

Расположение локальных переменных в стеке зависит от того, как компилятор распределяет их относительно указателя кадра (`rbp` или `ebp`). В большинстве случаев компилятор располагает переменные в порядке их объявления, но это не гарантировано и может варьироваться в зависимости от оптимизаций компилятора и других факторов.

Однако стоит учитывать, что конкретное расположение может изменяться в зависимости от компилятора и настроек оптимизации, поэтому всегда лучше проверять конкретный ассемблерный код, сгенерированный компилятором, чтобы точно узнать порядок размещения переменных в стеке.

**Возможное расположение в стеке:**

1. **Первая переменная (последняя в стеке)**: Переменная, которая будет последней помещена в стек, обычно находится в самом начале списка локальных переменных. В данном примере это может быть переменная `a`.
2. **Последняя переменная (первая в стеке)**: Переменная, которая будет первой в стеке, обычно объявлена последней в списке. В данном случае это может быть переменная `c`.

**Возможное распределение в стеке:**

- Допустим, стек растет вниз (уменьшаясь в направлении младших адресов):
    - Переменная `c` может быть помещена по адресу `[rbp-4]`.
    - Переменная `b` может быть помещена по адресу `[rbp-8]`.
    - Переменная `a` может быть помещена по адресу `[rbp-12]`.

Обычно данные в стеке данные размещатся последовательно по порядку:  

- В стек будет занесён сначало переменная a
- Потом  переменная  b 
- После переменной b - c

 >Не забываем что многое зависит от компилятора и может зависеть от различных факторов, включая архитектуру процессора и оптимизации). И не забываем что стек растет в сторону уменьшение адресов.

Это означает что в самом внизу (первым) будет переменная `a` (большие адреса), а в самом вверху (последнем) будет переменная `c` (меньшие адреса). Не забываем что верхушка стека находится внизу, то есть он растёт вниз в сторону уменьшение адресов. Стек легче представить как патрон пистолета, а данные в стеке это пули. 

**Итог:**

- **Переменная `c`** будет **первой в стеке**.
- **Переменная `a`** будет **последней в стеке**.

Представьте, что у вас есть стек, и вы добавляете в него три элемента:  A, B, C.  Элемент C будет добавлен последним, поэтому он окажется на вершине стека.  Когда вы захотите извлечь элемент, вы получите сначала C, затем B, а потом A.

**Важно:** 

Разные архитектуры процессоров могут использовать разные модели стека. Например, в некоторых процессорах стек растет вниз по адресу, а в других - вверх.   В  языках программирования,  как правило,  обеспечивается  абстракция  от  физической  организации  стека.  Вы  работаете  с  понятием  "стек"  как  с  абстрактным  данным  типом,  не  задумываясь  о  его  физическом  реализации.

Напоминаю что многое зависит от компилятора, режима оптимизации, других переменных, кода вокруг, фазы луны… Например у `int foo(void) { int a = 5, b = 7; return a + b; }` с -O3 вообще никаких переменных не будет. Потому что будет только две костанты:

```
mov eax, 0xc
ret
```
  
Ну вот с глобальными скорее всего ничего не случится, будут в том порядке, в котором определены. Думаю в данном случае, если они как глобальные определены, тогда компилятор просто сначала a потом b положит, т.к будет построчно обрабатывать код.

В других случаях, при другом размере переменных, можно было бы сказать, что при:

```c
char[]

int
```
  

Сначала будет int, потом char[] из-за выравнивания по границе. Да, стек работает как патрон пистолета, но обычно у тебя так будут лежать целые кадры стека, а не отдельные переменные. Отдельные переменные будут только в стековых виртуальных машин типа джавы.  

Просто секция изначально выравнена по 4-х байтной (или 8-байтной границе), и легче положить туда int, и не выравнивать nop'ами, чем положить char с выравниванием на 1, а потом выравнивать на 4, и ложить int.


**Работа с данными**

![[d.png]]

И так, это простой исходник программы. Мы сначало создаём переменную max и выделяем для него 4-байта, занесем в него значение Max. После переменной max мы создаём переменную alex, выделяем для него 5-байта и занесем туда значение Alex.

То в стек сначало попадает Max потом Alex. Это означает что Alex будет стоять на верху у Max-a так? Ну...

`\0xaM\0xelA` если считать в порядке уменьшения адресов.

```
\0xaM\0xelA
^         ^
ebp       esp
```

Давайте посмотрим наш обьектный файл в отладчике radare2:

![[Pasted image 20221215111035.png]]

Выше программа была скомпилированна c отладочной информации, поэтому синтаксис кода такой понятный.

```c
char text[20] = "This is text";
```

```
  0x000000000000114e <+21>:    xor    eax,eax  
  0x0000000000001150 <+23>:    movabs rax,0x2073692073696854  
  0x000000000000115a <+33>:    mov    edx,0x74786574  
  0x000000000000115f <+38>:    mov    QWORD PTR [rbp-0x20],rax  
  0x0000000000001163 <+42>:    mov    QWORD PTR [rbp-0x18],rdx  
  0x0000000000001167 <+46>:    mov    DWORD PTR [rbp-0x10],0x0  
  0x000000000000116e <+53>:    nop
```

Команда push/pop часто используют регситры для работы с данными, если размер данных превышают размер регистра, то операция извлечение и запись будет по частям. Мы кидаем записываем по партиям (частям) из за ограничения регистров процессора, ведь их размер ограниченный (64-бит).


![[Pasted image 20221215111509.png]]

>Синтаксис может менятся в зависимости от компилятора и его параметров

Ну код очень простой, освободить 21 байт памяти и записать туда строку. Имейте ввиду того что а асме нет прямой записи память-память (есть исключение), то сделано через регистры как промежуточное звено.

Мы обьявили локальные переменные, а локальные переменные хранятся в стеке, В стек они заносятся с п.м. команды push, а команда push в качестве оперенда обычно принимает регистры, но поскольку размер регистров у нас ограничен, мы записываем данные по частям.

- **Объявление локальных переменных**:
    
    - Когда вы объявляете локальные переменные в функции, они выделяются в стеке. Выделение места в стеке обычно выполняется инструкцией `SUB` для уменьшения указателя стека (`ESP` или `RSP`), что освобождает необходимое место.
- **Запись в стек**:
    
    - Для записи значений в стек обычно используется команда `PUSH`, которая записывает данные из регистра в стек. Поскольку размер регистра может быть меньше размера данных, необходимо выполнять запись по частям.

Но поскольку размер регистра сильно ограничен rax, rdx – 8-байт (64-бит), поэтому сначало мы записываем первые 8-байт данных в регистр rax, а следующий 8-байт данных в регистр rdx, а от туда в стек.

8+8+4+1=21 – Общий размер выделенной памяти (обращайте внимания на подсказки размеров). 

> radare2 для удобства rbp-[смещение] показывает как var_[смещение]. В компьютерных науках термин "offset" в памяти обычно относится к смещению или сдвигу относительно начала определенной области памяти. Когда программа обращается к определенному участку памяти, она указывает не просто на адрес этой памяти, а на адрес с учетом определенного смещения от начала этой области памяти. Например, если у вас есть массив данных, начинающийся с адреса 0x1000 в памяти, и вам нужно получить доступ к третьему элементу массива, то вы можете использовать offset 2 (поскольку индексация массивов начинается с 0) относительно начала массива для получения адреса третьего элемента. Использование offset в памяти помогает программистам эффективно управлять доступом к данным в памяти и обращаться к различным участкам памяти с помощью относительных адресов, что упрощает работу с данными в программировании.


**Доступ к данным в памяти**

Когда мы записываем данные, например в размере 10-байт, то инструкция будет выглядить примерно так:

```
mov qword [данные]
mov word  [данные+8]
```

Напомню, такое ограничение из за регистров. Стек растёт в сторону уменьшение адресов, то есть стек в памяти растет сверху вниз, это значит что **при добавлении значения в него адрес вершины стека уменьшается, а когда вы извлекаете из него, то адрес вершины стека увеличивается**. Теперь кратко рассмотрим что такое регистры. Это ячейки памяти в самом процессоре. Другими словами ebp ( указатель дно стека) находится на верху, а esp (указатель вершины стека) находиться в самом внизу.

Допустим у меня переменная name:

```c
char name[] = "Alex";
```

То под дебагером мы можем видет:

```
22: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_5h @ rbp-0x5  
│           ; var int64_t var_1h @ rbp-0x1  
│           0x00001129      55             push rbp  
│           0x0000112a      4889e5         mov rbp, rsp  
│           0x0000112d      c745fb416c65.  mov dword [var_5h], 0x78656c41 ; 'Alex'  
│           0x00001134      c645ff00       mov byte [var_1h], 0  
│           0x00001138      b800000000     mov eax, 0  
│           0x0000113d      5d             pop rbp  
└           0x0000113e      c3             ret
```

Тут

```
x - ebp-2 (5-2) = 0x3
e - ebp-3 (5-3) = 0x2
l - ebp-4 (5-4) = 0x1
A - ebp-5 (5-5) = 0x0
```

var_5h это тоже самое что и rbp-0x5. Это указатель начала стекового кадра (начало адреса от куда должны записаться данные), а -5 значит на 5 байт ниже. Это значить что значение записывается начиная c rbp-0x5 до rbp-0x0.

![[Pasted image 20230604075346.png]]

![[Pasted image 20230604075520.png]]
### Глобальные переменные (Global Variables)

Глобальные переменные попадают в специальный сегмент памяти, называемый **сегментом данных** (data segment). Этот сегмент разделяется на две части:

1. **Сегмент инициализированных данных** (initialized data segment) — сюда попадают глобальные и статические переменные, которым присвоены начальные значения.
    
2. **Сегмент неинициализированных данных** (uninitialized data segment или BSS) — сюда попадают глобальные и статические переменные, которым не присвоено начальное значение.

Эти сегменты, в отличие от стека, выделяются в памяти на протяжении всего времени выполнения программы.

- **Описание**: Переменные, объявленные вне функций. Доступны везде в программе после объявления.
- **Ассемблер**: Обычно хранятся в `.data` или `.bss` сегментах памяти.
- **Пример (C)**:

```c
int global_var = 10;
```

```asm
.data
global_var:
    .long 10
```


### Статические переменные (Static Variables)

- **Описание**: Переменные, сохраняющие своё значение между вызовами функции или сохраняющиеся в глобальной области, но недоступные вне файла, если объявлены как `static`.
- **Ассемблер**: Обычно также хранятся в `.data` или `.bss` сегментах. Для локальных статических переменных используется выделение памяти в этих сегментах, а не в стеке.

```c
void func() {
    static int static_var = 7;
}
```

```asm
.data
static_var:
    .long 7
func:
    ...
    mov eax, DWORD PTR static_var
    ...
```


### Регистровые переменные (Register Variables)

- **Описание**: Переменные, которые компилятор может попытаться хранить в регистре процессора, чтобы ускорить доступ к ним.
- **Ассемблер**: Такие переменные не хранятся в памяти, а назначаются регистрами процессора, если компилятор посчитает это оптимальным.

```c
void func() {
    register int reg_var = 3;
}
```

```asm
func:
    mov eax,3    ; использование регистра для хранения reg_var
    ...
```

### Динамически выделяемые переменные (Heap Variables)

- **Описание**: Переменные, выделяемые во время выполнения программы с помощью функций `malloc`, `calloc`, и т.д. Хранятся в куче (heap).
- **Ассемблер**: Адрес возвращаемого указателя хранится в регистре или в локальной переменной, но фактическое выделение памяти управляется системными вызовами или стандартной библиотекой.

```c
void func() {
    int *heap_var = malloc(sizeof(int));
    *heap_var = 9;
}
```

```asm
func:
    mov     edi, 4           ; размер памяти (4 байта)
    call    malloc           ; вызов функции malloc
    mov     QWORD PTR [rbp-8], rax   ; сохранение указателя в heap_var
    mov     DWORD PTR [rax], 9   ; инициализация heap_var
    ...
```

На уровне ассемблера можно увидеть, как разные виды переменных в C управляются компилятором, будь то выделение памяти в сегментах данных, работа со стеком, регистрами или динамическим выделением памяти в куче.

### Заключение

1. **Локальные переменные** (автоматические переменные):
    
    - **Место хранения:** Локальные переменные, объявленные внутри функции, по умолчанию попадают в **стек**.
    - **Особенности:** Они существуют только во время выполнения функции, в которой объявлены. После завершения функции, соответствующая часть стека освобождается, и память, использованная для этих переменных, становится доступной для других вызовов функций.

1. **Глобальные переменные**:
    
    - **Место хранения:** Глобальные переменные размещаются в **сегменте данных** (data segment), который включает две части:
        - **Инициализированные данные** (для переменных с начальными значениями).
        - **Неинициализированные данные** (BSS) для переменных без начальных значений.

1. **Статические локальные переменные**:
    
    - **Место хранения:** Локальные переменные, объявленные как `static`, хранятся в **сегменте данных** вместе с глобальными переменными, но их область видимости ограничена функцией, в которой они объявлены.
    - **Особенности:** Они сохраняют своё значение между вызовами функции и существуют на протяжении всего времени выполнения программы, как и глобальные переменные.

Резюме:

   - **Локальные переменные** — в **стеке**.
   - **Глобальные переменные** — в **сегменте данных**.
   - **Статические локальные переменные** — тоже в **сегменте данных**.

Статические переменные не хранятся в сегменте `.rodata`. Давайте уточним:

1. **Сегмент `.rodata`**:

    - **Содержимое:** Сегмент `.rodata` (read-only data) хранит **константные данные**, такие как строки и другие литералы, которые не изменяются в течение выполнения программы.
    - **Характеристики:** Этот сегмент доступен только для чтения, и любые попытки изменить данные в этом сегменте приведут к ошибке выполнения (например, сегментирование в Unix-подобных системах).

2. **Статические переменные (глобальные и локальные)**:

    - **Место хранения:** Статические переменные хранятся в **сегменте данных** (`.data` для инициализированных переменных) или в **сегменте BSS** для неинициализированных переменных.
    - **Инициализированные статические переменные**: Хранятся в сегменте `.data`. Это касается как глобальных статических переменных, так и локальных переменных с модификатором `static`.
    - **Неинициализированные статические переменные**: Хранятся в сегменте `.bss`.
    - **Характеристики:** Статические переменные, независимо от того, глобальные они или локальные, существуют на протяжении всего времени выполнения программы и сохраняют своё значение между вызовами функций.

```c
int global_var = 42;        // В сегменте .data
static int static_global;   // В сегменте .bss

void foo() {
    static int static_local = 5; // В сегменте .data
    const char *str = "Hello";   // Строка "Hello" будет храниться в сегменте .rodata
}
```

- `static_local` будет храниться в сегменте `.data` (так как она инициализирована).
- `static_global` — в сегменте `.bss`.
- Строка `"Hello"` будет храниться в сегменте `.rodata`, поскольку она является неизменяемой константой.