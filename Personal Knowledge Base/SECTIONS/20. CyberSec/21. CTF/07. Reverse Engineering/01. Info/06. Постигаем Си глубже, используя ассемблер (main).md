

## Регистры общего назначения

Регистр — это небольшой (обычно 4 или 8 байт) кусочек памяти в процессоре с чрезвычайно большой скоростью доступа. Регистры делятся на регистры специального назначения и регистры общего назначения. Нас сейчас интересуют регистры общего назначения. Как можно догадаться по названию, программа может использовать эти регистры под свои нужды, как ей вздумается.

На x86 доступно восемь 32-х битных регистров общего назначения — eax, ebx, ecx, edx, esp, ebp, esi и edi. Регистры не имеют заданного наперед типа, то есть, они могут трактоваться как знаковые или беззнаковые целые числа, указатели, булевы значения, ASCII-коды символов, и так далее. Несмотря на то, что в теории эти регистры можно использовать как угодно, на практике обычно каждый регистр используется определенным образом. Так, esp указывает на вершину стека, ecx играет роль счетчика, а в eax записывается результат выполнения операции или процедуры. Существуют 16-и битные регистры ax, bx, cx, dx, sp, bp, si и di, представляющие собой 16 младших бит соответствующих 32-х битных регистров. Также доступны и 8-и битовые регистры ah, al, bh, bl, ch, cl, dh и dl, которые представляют собой старшие и младшие байты регистров ax, bx, cx и dx соответственно.

Рассмотрим пример. Допустим, выполняются следующие три инструкции:

```
(gdb) x/3i $pc  
=> 0x8048074: mov    $0xaabbccdd,%eax  
   0x8048079: mov    $0xee,%al  
   0x804807b: mov    $0x1234,%ax

Значения регистров после записи в eax значения 0xAABBCCDD:

(gdb) p/x $eax  
$1 = 0xaabbccdd  
(gdb) p/x $ax  
$2 = 0xccdd  
(gdb) p/x $ah  
$3 = 0xcc  
(gdb) p/x $al  
$4 = 0xdd

Значения после записи в регистр al значения 0xEE:

(gdb) p/x $eax  
$5 = 0xaabbccee  
(gdb) p/x $ax  
$6 = 0xccee  
(gdb) p/x $ah  
$7 = 0xcc  
(gdb) p/x $al  
$8 = 0xee

Значения регистров после записи в ax числа 0x1234:

(gdb) p/x $eax  
$9 = 0xaabb1234  
(gdb) p/x $ax  
$10 = 0x1234  
(gdb) p/x $ah  
$11 = 0x12  
(gdb) p/x $al  
$12 = 0x34
```

Как видите, ничего сложного.

_Примечание:_ Синтаксис GAS позволяет явно указывать размеры операндов путем использования суффиксов b (байт), w (слово, 2 байта), l (длинное слово, 4 байта), q (четверное слово, 8 байт) и [некоторых других](https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax#Operation_Suffixes). Например, вместо команды `mov $0xEE, %al` можно написать `movb $0xEE, %al`, вместо `mov $0x1234, %ax` — `movw $0x1234, %ax`, и так далее. В современном GAS эти суффиксы являются опциональными и я лично их не использую. Но не пугайтесь, если увидите их в чужом коде.

На x64 размер регистров был увеличен до 64-х бит. Соответствующие регистры получили название rax, rbx, и так далее. Кроме того, регистров общего назначения стало шестнадцать вместо восьми. Дополнительные регистры получили названия r8, r9, …, r15. Соответствующие им регистры, которые представляют младшие 32, 16 и 8 бит, получили название r8d, r8w, r8b, и по аналогии для регистров r9-r15. Кроме того, появились регистры, представляющие собой младшие 8 бит регистров rsi, rdi, rbp и rsp — sil, dil, bpl и spl соответственно.

# Адресация 

Как уже отмечалось, регистры могут трактоваться, как указатели на данные в памяти. Для разыменования таких указателей используется специальный синтаксис:

```
mov  (%rsp), %rax
```

Эта запись означает «прочитай 8 байт по адресу, записанному в регистре rsp, и сохрани их в регистр rax». При запуске программы rsp указывает на вершину стека, где хранится число аргументов, переданных программе (argc), указатели на эти аргументы, а также переменные окружения и кое-какая другая информация. Таким образом, в результате выполнения приведенной выше инструкции (разумеется, при условии, что перед ней не выполнялось каких-либо других инструкций) в rax будет записано количество аргументов, с которыми была запущена программа.

- При запуске программы, резервный указатель стека rsp указывает на вершину стека, где размещены данные, такие как количество аргументов (argc) и сами аргументы (argv), а также другие данные для настройки среды выполнения.

- Поскольку argc — это значение, которое представляет количество аргументов, переданных программе (в том числе имя самой программы), выполнение указанной инструкции на самом деле приведет к тому, что в rax будет записано значение argc. 

- Если это первый оператор в программе и перед ним не было других манипуляций со стеком, то можно ожидать, что в rax будет находиться именно количество аргументов, с которыми была запущена программа.

В одной команде можно указывать адрес и смешение (как положительное, так и отрицательное) относительно него:

```
mov  8(%rsp), %rax
```

Эта запись означает «возьми rsp, прибавь к нему 8, прочитай 8 байт по получившемуся адресу и положи их в rax». Таким образом, в rax будет записан адрес строки, представляющей собой первый аргумент программы, то есть, имя исполняемого файла.

При работе с массивами бывает удобно обращаться к элементу с определенным индексом. Соответствующий синтаксис:

```
#инструкция xchg меняет значения местами  
xchg 16(%rsp,%rcx,8), %rax
```

Читается так: «посчитай `rcx*8 + rsp + 16`, и поменяй местами 8 байт (размер регистра) по получившемуся адресу и значение регистра rax». Другими словами, rsp и 16 все так же играют роль смещения, rcx играет роль индекса в массиве, а 8 — это размер элемента массива. При использовании данного синтаксиса допустимыми размерами элемента являются только 1, 2, 4 и 8. Если требуется какой-то другой размер, можно использовать инструкции умножения, бинарного сдвига и прочие, которые мы рассмотрим далее.

Наконец, следующий код тоже валиден:

```
.data  
msg:  
  .ascii "Hello, world!\n"  
.text  
  
.globl _start  
_start:  
  # обнуление rcx  
  xor %rcx, %rcx  
  mov msg(,%rcx,8), %al  
  mov msg, %ah
```

В смысле, что можно не указывать регистр со смещением или вообще какие-либо регистры. В результате выполнения этого кода в регистры al и ah будет записан ASCII-код буквы H, или 0x48.

В этом контексте хотелось бы упомянуть еще одну полезную ассемблерную инструкцию:

```
# rax := rcx*8 + rax + 123  
lea 123(%rax,%rcx,8), %rax
```

Инструкция lea очень удобна, так как позволяет сразу выполнить умножение и несколько сложений.

**Fun fact!** На x64 в байткоде инструкций никогда не используются 64-х битовые смещения. В отличие от x86, инструкции часто оперируют не абсолютными адресами, а адресами относительно адреса самой инструкции, что позволяет обращаться к ближайшим +/- 2 Гб оперативной памяти. Соответствующий синтаксис:

```
movb msg(%rip), %al
```

Сравним длины опкодов «обычного» и «относительного» mov (`objdump -d`):

```
4000b0: 8a 0c 25 e8 00 60 00  mov    0x6000e8,%cl  
4000b7: 8a 05 2b 00 20 00     mov    0x20002b(%rip),%al # 0x6000e8
```

Как видите, «относительный» mov еще и на один байт короче! Что это за регистр такой rip мы узнаем чуть ниже.

Для записи же полного 64-х битового значения в регистр предусмотрена специальная инструкция:

```
movabs $0x1122334455667788, %rax
```

Другими словами, процессоры x64 так же экономно кодируют инструкции, как и процессоры x86, и в наше время нет особо смысла использовать процессоры x86 в системах, имеющих пару гигабайт оперативной памяти или меньше (мобильные устройства, холодильники, микроволновки, и так далее). Скорее всего, процессоры x64 будут даже более эффективны за счет большего числа доступных регистров и большего размера этих регистров.

---

![[Pasted image 20221210135817.png]]

# Порядок байтов 

Допустим я создаю простую переменную:

```c
char max[] = "Max";
```

Глянем код под gdb:

```
mov    DWORD PTR [rbp-0xc],0x78614d
```

- 78 - x 
- 61 - a
- 4d - M

У нас получается "xaM". 

То, что вы видите в отладчике, связано с порядком байтов (эндиянностью) в памяти.

**Эндиянность и порядок байтов**

Существует два основных типа порядка байтов:

1. **Младший байт первым (Little-endian)**: Младшие байты значения хранятся по меньшим адресам, старшие — по большим.
2. **Старший байт первым (Big-endian)**: Старшие байты значения хранятся по меньшим адресам, младшие — по большим.

**Что происходит в вашем случае**

Когда вы объявляете строку:

```c
char max[] = "Max";
```

Компилятор преобразует её в массив символов `{'M', 'a', 'x', '\0'}`. В отладчике вы видите значение `0x78614d`, которое соответствует байтам строки, но в обратном порядке.

**Как это выглядит в памяти**

В случае little-endian, массив `{'M', 'a', 'x', '\0'}` (в шестнадцатеричном формате это `0x4D 0x61 0x78 0x00`) будет записан в память следующим образом:

```arduino
0x4D ('M')  0x61 ('a')  0x78 ('x')  0x00 ('\0')
```


Но в little-endian, если вы интерпретируете это как одно 32-битное значение, память будет отображаться следующим образом:

```css
[0x00][0x78][0x61][0x4D]
```

Таким образом, значение в памяти для строки `"Max"` при little-endian будет отображаться как `0x78614D00`. Если вы смотрите только на первые три байта (без нулевого байта `\0`), это будет `0x78614D`, что соответствует строке `"xaM"`.

**Почему строка в обратном порядке?**

Причина в том, как отладчик отображает это значение в little-endian системе. Он показывает байты в порядке от младшего к старшему, что вызывает эффект, будто строка `"Max"` хранится в обратном порядке. 


**Как правильно интерпретировать?**

Когда вы видите `0x78614D` в отладчике, это означает, что строка `"Max"` хранится в памяти как `{'M', 'a', 'x', '\0'}`, но при выводе целого значения этих байтов они отображаются в little-endian порядке. Это просто отображение порядка байтов в памяти, а не фактический порядок символов в строке.

Использование little-endian (LE) порядка байтов исторически обусловлено рядом факторов, связанных с архитектурой процессоров, производительностью и совместимостью.


Допустим у меня строка **AABBCC**. 

**Как строка хранится в памяти:**

Строка `"AABBCC"` в памяти будет выглядеть так:

- **'A'**: 0x41
- **'A'**: 0x41
- **'B'**: 0x42
- **'B'**: 0x42
- **'C'**: 0x43
- **'C'**: 0x43
- **'\0'** (null-терминатор): 0x00

**Влияние little-endian:**

Little-endian порядок означает, что если бы эта строка представляла собой 48-битное значение (6 байтов), то байты в памяти будут расположены так, что младший байт окажется по наименьшему адресу, а старший — по наибольшему.

**Порядок байтов в памяти:**

В little-endian строка `"AABBCC"`  - `\xdd\xcc\xbb\xaa`

- **0x41** (младший байт)
- **0x41**
- **0x42**
- **0x42**
- **0x43**
- **0x43** (старший байт)

Учитывайте то что вершина стека имеет наименьший адрес, а у нас младший байт у нас это **0x4141** (**AA**). Запись начинается с это места учитывая порядок little-endian

Давайте представим, что у нас есть 32-битное число (4 байта) со значением 0x12345678.  Мы хотим добавить это число в стек. 

**Big-Endian:**

Память:  В Big-Endian системе байты будут записаны в память в следующем порядке:
- **0x12** (самый старший байт) по адресу  0x1000
- **0x34** по адресу 0x1001
- **0x56** по адресу 0x1002
- **0x78** (самый младший байт) по адресу 0x1003

Стек:  В стек число будет добавлено как единое целое,  независимо от того, как байты хранятся в памяти.  

**Little-Endian:**

Память:  В Little-Endian системе байты будут записаны в память в следующем порядке:
- **0x78** (самый младший байт) по адресу  0x1000
- **0x56** по адресу 0x1001
- **0x34** по адресу 0x1002
- **0x12** (самый старший байт) по адресу 0x1003

**Стек:**  В стек число будет добавлено как единое целое,  независимо от того, как байты хранятся в памяти. 

**Результат:**

Независимо от порядка байтов, в стеке будет храниться  целое  число 0x12345678.  Порядок байтов  влияет только на то,  как  это  число  будет  записано  в  память,  но  не  на  его  логическое  представление  в  стеке. 

### Почему не big-endian?

Big-endian (BE) также имеет свои преимущества и используется в других архитектурах (например, в некоторых сетевых протоколах, PowerPC). Однако в большинстве современных систем, особенно в ПК и серверах, преимущество оказалось на стороне little-endian из-за вышеуказанных причин.

### Основные причины использования little-endian:

1. **Производительность и упрощение аппаратного обеспечения**:
    - **Математические операции**: В little-endian порядок байтов упрощает работу с целыми числами, особенно при сложении, вычитании и других арифметических операциях. Так как младшие байты хранятся по более низким адресам, процессор может выполнять арифметические операции быстрее, начиная с младших байтов и продвигаясь к старшим. Например, если число занимает несколько байтов, то сумма начинается с младших байтов, и если возникает перенос, он может быть сразу добавлен к следующему байту, что упрощает дизайн процессора.
2. **Совместимость и наследие**:
    - **Архитектура x86**: Процессоры с архитектурой x86 (Intel, AMD) используют little-endian, что стало де-факто стандартом для большинства персональных компьютеров. Исторически это связано с архитектурными решениями, принятыми в начале разработки процессоров Intel. В результате этого LE порядок байтов стал широко использоваться и в других архитектурах, которые стремятся быть совместимыми с x86.
3. **Легкость работы с различными типами данных**:
    - **Универсальность**: Little-endian позволяет легко работать с различными типами данных. Например, если у вас есть 32-битное значение, хранящееся в little-endian формате, и вы хотите прочитать его как 16-битное, вы просто берете первые два байта. В big-endian вам пришлось бы учитывать, что 16-битные и 32-битные значения лежат в разных частях памяти, что усложняет операции.
4. **Исторические причины и влияние платформ**:
    - **DEC VAX и другие старые системы**: В старых компьютерных системах, таких как DEC VAX, также использовался little-endian порядок, что способствовало его распространению. В то время как big-endian также широко использовался в других системах (например, IBM), развитие персональных компьютеров и доминирование архитектуры x86 закрепило little-endian в качестве наиболее распространенного порядка байтов.
5. **Простота программирования**:
    - **Работа с указателями и преобразованиями типов**: В little-endian системе указатель на данные может указывать на младший байт, что упрощает работу с типами данных разного размера, преобразования и доступ к данным.


### Заключение 

Little-endian стал стандартом в первую очередь из-за архитектурных решений в процессорах x86 и их наследия, что привело к его широкому использованию. Большинство современных процессоров и систем ориентируются на x86 совместимость, что и поддерживает использование LE на протяжении многих лет.

---

# Переменные 

В языке C существует несколько видов переменных, каждая из которых по-разному управляется компилятором и отображается в машинном коде на уровне ассемблера. Рассмотрим основные типы переменных в C и их соответствие на уровне ассемблера:

### Локальные переменные (Local Variables)

Простыми словами, переменные, объявляемые внутри функций или цикла, называются локальными переменными. 

Локальные переменные (или автоматические переменные) обычно размещаются в **стеке** (stack). Стек — это область памяти, используемая для хранения данных, связанных с вызовами функций, таких как локальные переменные, параметры функции и адреса возврата.

- **Описание**: Переменные, объявленные внутри функций. Доступны только в пределах функции.
- **Ассемблер**: Хранятся в стеке. Компилятор выделяет место для них с помощью инструкции `sub` для указателя стека (`esp` или `rsp`), а доступ к ним осуществляется через указатель стека (`ebp` или `rbp`).

```c
void func() {
    int local_var = 5;
}
```

```asm
func:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 4      ; выделение места для локальной переменной
    mov     DWORD PTR [rbp-4], 5   ; инициализация local_var
    ...
    leave
    ret
```

Основные характеристики размещения локальных переменных в стеке:

- **Автоматическое управление памятью:** Память для локальных переменных выделяется автоматически при входе в функцию и освобождается при выходе из неё. Это происходит благодаря тому, что при каждом вызове функции создаётся новый фрейм стека (stack frame), в который помещаются локальные переменные и другие данные, связанные с выполнением этой функции.
    
- **Упорядоченное размещение:** Локальные переменные размещаются в стеке последовательно. Порядок их размещения определяется компилятором и может зависеть от различных факторов, включая архитектуру процессора и оптимизации.
    
- **Ограниченный размер:** Поскольку стек имеет ограниченный размер (обычно несколько мегабайт), чрезмерное использование локальных переменных большого размера или глубокая рекурсия могут привести к переполнению стека (stack overflow).

#### Порядок расположении данных в стеке


```c  
void foo(){  

    int a = 5;  
    int b = 10;  
    int c = 15;    
}
```

```asm
  0x0000000000001119 <+0>:     push   rbp  
  0x000000000000111a <+1>:     mov    rbp,rsp  
  0x000000000000111d <+4>:     mov    DWORD PTR [rbp-0xc],0x5  
  0x0000000000001124 <+11>:    mov    DWORD PTR [rbp-0x8],0xa  
  0x000000000000112b <+18>:    mov    DWORD PTR [rbp-0x4],0xf  
  0x0000000000001132 <+25>:    nop  
  0x0000000000001133 <+26>:    pop    rbp  
  0x0000000000001134 <+27>:    ret
```

Расположение локальных переменных в стеке зависит от того, как компилятор распределяет их относительно указателя кадра (`rbp` или `ebp`). В большинстве случаев компилятор располагает переменные в порядке их объявления, но это не гарантировано и может варьироваться в зависимости от оптимизаций компилятора и других факторов.

Однако стоит учитывать, что конкретное расположение может изменяться в зависимости от компилятора и настроек оптимизации, поэтому всегда лучше проверять конкретный ассемблерный код, сгенерированный компилятором, чтобы точно узнать порядок размещения переменных в стеке.

**Возможное расположение в стеке:**

1. **Первая переменная (последняя в стеке)**: Переменная, которая будет последней помещена в стек, обычно находится в самом начале списка локальных переменных. В данном примере это может быть переменная `a`.
2. **Последняя переменная (первая в стеке)**: Переменная, которая будет первой в стеке, обычно объявлена последней в списке. В данном случае это может быть переменная `c`.

**Возможное распределение в стеке:**

- Допустим, стек растет вниз (уменьшаясь в направлении младших адресов):
    - Переменная `c` может быть помещена по адресу `[rbp-4]`.
    - Переменная `b` может быть помещена по адресу `[rbp-8]`.
    - Переменная `a` может быть помещена по адресу `[rbp-12]`.

Обычно данные в стеке данные размещатся последовательно по порядку:  

- В стек будет занесён сначало переменная a
- Потом  переменная  b 
- После переменной b - c

 >Не забываем что многое зависит от компилятора и может зависеть от различных факторов, включая архитектуру процессора и оптимизации). И не забываем что стек растет в сторону уменьшение адресов.

Это означает что в самом внизу (первым) будет переменная `a` (большие адреса), а в самом вверху (последнем) будет переменная `c` (меньшие адреса). Не забываем что верхушка стека находится внизу, то есть он растёт вниз в сторону уменьшение адресов. Стек легче представить как патрон пистолета, а данные в стеке это пули. 

**Итог:**

- **Переменная `c`** будет **первой в стеке**.
- **Переменная `a`** будет **последней в стеке**.

Представьте, что у вас есть стек, и вы добавляете в него три элемента:  A, B, C.  Элемент C будет добавлен последним, поэтому он окажется на вершине стека.  Когда вы захотите извлечь элемент, вы получите сначала C, затем B, а потом A.

**Важно:** 

Разные архитектуры процессоров могут использовать разные модели стека. Например, в некоторых процессорах стек растет вниз по адресу, а в других - вверх.   В  языках программирования,  как правило,  обеспечивается  абстракция  от  физической  организации  стека.  Вы  работаете  с  понятием  "стек"  как  с  абстрактным  данным  типом,  не  задумываясь  о  его  физическом  реализации.

Напоминаю что многое зависит от компилятора, режима оптимизации, других переменных, кода вокруг, фазы луны… Например у `int foo(void) { int a = 5, b = 7; return a + b; }` с -O3 вообще никаких переменных не будет. Потому что будет только две костанты:

```
mov eax, 0xc
ret
```
  
Ну вот с глобальными скорее всего ничего не случится, будут в том порядке, в котором определены. Думаю в данном случае, если они как глобальные определены, тогда компилятор просто сначала a потом b положит, т.к будет построчно обрабатывать код.

В других случаях, при другом размере переменных, можно было бы сказать, что при:

```c
char[]

int
```
  

Сначала будет int, потом char[] из-за выравнивания по границе. Да, стек работает как патрон пистолета, но обычно у тебя так будут лежать целые кадры стека, а не отдельные переменные. Отдельные переменные будут только в стековых виртуальных машин типа джавы.  

Просто секция изначально выравнена по 4-х байтной (или 8-байтной границе), и легче положить туда int, и не выравнивать nop'ами, чем положить char с выравниванием на 1, а потом выравнивать на 4, и ложить int.


#### Работа с данными

![[d.png]]

И так, это простой исходник программы. Мы сначало создаём переменную max и выделяем для него 4-байта, занесем в него значение Max. После переменной max мы создаём переменную alex, выделяем для него 5-байта и занесем туда значение Alex.

То в стек сначало попадает Max потом Alex. Это означает что Alex будет стоять на верху у Max-a так? Ну...

`\0xaM\0xelA` если считать в порядке уменьшения адресов.

```
\0xaM\0xelA
^         ^
ebp       esp
```

Давайте посмотрим наш обьектный файл в отладчике radare2:

![[Pasted image 20221215111035.png]]

Выше программа была скомпилированна c отладочной информации, поэтому синтаксис кода такой понятный.

```c
char text[20] = "This is text";
```

```
  0x000000000000114e <+21>:    xor    eax,eax  
  0x0000000000001150 <+23>:    movabs rax,0x2073692073696854  
  0x000000000000115a <+33>:    mov    edx,0x74786574  
  0x000000000000115f <+38>:    mov    QWORD PTR [rbp-0x20],rax  
  0x0000000000001163 <+42>:    mov    QWORD PTR [rbp-0x18],rdx  
  0x0000000000001167 <+46>:    mov    DWORD PTR [rbp-0x10],0x0  
  0x000000000000116e <+53>:    nop
```

Команда push/pop часто используют регситры для работы с данными, если размер данных превышают размер регистра, то операция извлечение и запись будет по частям. Мы кидаем записываем по партиям (частям) из за ограничения регистров процессора, ведь их размер ограниченный (64-бит).


![[Pasted image 20221215111509.png]]

>Синтаксис может менятся в зависимости от компилятора и его параметров

Ну код очень простой, освободить 21 байт памяти и записать туда строку. Имейте ввиду того что а асме нет прямой записи память-память (есть исключение), то сделано через регистры как промежуточное звено.

Мы обьявили локальные переменные, а локальные переменные хранятся в стеке, В стек они заносятся с п.м. команды push, а команда push в качестве оперенда обычно принимает регистры, но поскольку размер регистров у нас ограничен, мы записываем данные по частям.

- **Объявление локальных переменных**:
    
    - Когда вы объявляете локальные переменные в функции, они выделяются в стеке. Выделение места в стеке обычно выполняется инструкцией `SUB` для уменьшения указателя стека (`ESP` или `RSP`), что освобождает необходимое место.
- **Запись в стек**:
    
    - Для записи значений в стек обычно используется команда `PUSH`, которая записывает данные из регистра в стек. Поскольку размер регистра может быть меньше размера данных, необходимо выполнять запись по частям.

Но поскольку размер регистра сильно ограничен rax, rdx – 8-байт (64-бит), поэтому сначало мы записываем первые 8-байт данных в регистр rax, а следующий 8-байт данных в регистр rdx, а от туда в стек.

8+8+4+1=21 – Общий размер выделенной памяти (обращайте внимания на подсказки размеров). 

> radare2 для удобства rbp-[смещение] показывает как var_[смещение]. В компьютерных науках термин "offset" в памяти обычно относится к смещению или сдвигу относительно начала определенной области памяти. Когда программа обращается к определенному участку памяти, она указывает не просто на адрес этой памяти, а на адрес с учетом определенного смещения от начала этой области памяти. Например, если у вас есть массив данных, начинающийся с адреса 0x1000 в памяти, и вам нужно получить доступ к третьему элементу массива, то вы можете использовать offset 2 (поскольку индексация массивов начинается с 0) относительно начала массива для получения адреса третьего элемента. Использование offset в памяти помогает программистам эффективно управлять доступом к данным в памяти и обращаться к различным участкам памяти с помощью относительных адресов, что упрощает работу с данными в программировании.


#### Доступ к данным в памяти

Когда мы записываем данные, например в размере 10-байт, то инструкция будет выглядить примерно так:

```
mov qword [данные]
mov word  [данные+8]
```

Напомню, такое ограничение из за регистров. Стек растёт в сторону уменьшение адресов, то есть стек в памяти растет сверху вниз, это значит что **при добавлении значения в него адрес вершины стека уменьшается, а когда вы извлекаете из него, то адрес вершины стека увеличивается**. Теперь кратко рассмотрим что такое регистры. Это ячейки памяти в самом процессоре. Другими словами ebp ( указатель дно стека) находится на верху, а esp (указатель вершины стека) находиться в самом внизу.

Допустим у меня переменная name:

```c
char name[] = "Alex";
```

То под дебагером мы можем видет:

```
22: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_5h @ rbp-0x5  
│           ; var int64_t var_1h @ rbp-0x1  
│           0x00001129      55             push rbp  
│           0x0000112a      4889e5         mov rbp, rsp  
│           0x0000112d      c745fb416c65.  mov dword [var_5h], 0x78656c41 ; 'Alex'  
│           0x00001134      c645ff00       mov byte [var_1h], 0  
│           0x00001138      b800000000     mov eax, 0  
│           0x0000113d      5d             pop rbp  
└           0x0000113e      c3             ret
```

Тут

```
x - ebp-2 (5-2) = 0x3
e - ebp-3 (5-3) = 0x2
l - ebp-4 (5-4) = 0x1
A - ebp-5 (5-5) = 0x0
```

var_5h это тоже самое что и rbp-0x5. Это указатель начала стекового кадра (начало адреса от куда должны записаться данные), а -5 значит на 5 байт ниже. Это значить что значение записывается начиная c rbp-0x5 до rbp-0x0.

![[Pasted image 20230604075346.png]]

![[Pasted image 20230604075520.png]]


![[Pasted image 20221210135817.png]]

В левой части находится ассемблерный код (инструкции), в правом верхнем - исходный код, а в правом нижнем наш код был скомпилирован и запущен (результат).

**Исходный код примера:**

```c
#include <stdio.h>  
  
void call_me(){  
  
       int age = 5;  
       char name[10] = "Alex";  
       printf("%s", "This is other function!\n");  
}  
  
int main(){  

       int key = 1;  
       char buffer[50] = "This is buffer!";  
       char pass[5] = "AAAAA";  
       char text[30] = "This is simple text for you!";  
       printf("Hello World!\n");  
  
       if(key == 1){  
  
               printf("This is test!\n");  
       }  
  
       call_me();  
  
       return 0;  
  
}
```

**Код под отладчиком:**

```
           ; DATA XREF from entry0 @ 0x1064  
┌ 200: int main (int argc, char **argv, char **envp);  
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
│           0x00001168      55             push rbp  
│           0x00001169      4889e5         mov rbp, rsp  
│           0x0000116c      4883ec70       sub rsp, 0x70  
│           0x00001170      c745fc010000.  mov dword [var_4h], 1  
│           0x00001177      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x00001181      48ba62756666.  movabs rdx, 0x21726566667562 ; 'buffer!'  
│           0x0000118b      488945c0       mov qword [var_40h], rax  
│           0x0000118f      488955c8       mov qword [var_38h], rdx  
│           0x00001193      48c745d00000.  mov qword [var_30h], 0  
│           0x0000119b      48c745d80000.  mov qword [var_28h], 0  
│           0x000011a3      48c745e00000.  mov qword [var_20h], 0  
│           0x000011ab      48c745e80000.  mov qword [var_18h], 0  
│           0x000011b3      66c745f00000   mov word [var_10h], 0  
│           0x000011b9      c745bb414141.  mov dword [var_45h], 0x41414141 ; 'AAAA'  
│           0x000011c0      c645bf41       mov byte [var_41h], 0x41    ; 'A'  
│           0x000011c4      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x000011ce      48ba73696d70.  movabs rdx, 0x7420656c706d6973 ; 'simple t'  
│           0x000011d8      48894590       mov qword [var_70h], rax  
│           0x000011dc      48895598       mov qword [var_68h], rdx  
│           0x000011e0      48b865787420.  movabs rax, 0x20726f6620747865 ; 'ext for '  
│           0x000011ea      488945a0       mov qword [var_60h], rax  
│           0x000011ee      c745a8796f75.  mov dword [var_58h], 0x21756f79 ; 'you!'  
│           0x000011f5      66c745ac0000   mov word [var_54h], 0  
│           0x000011fb      488d051a0e00.  lea rax, str.Hello_World_   ; 0x201c ; "Hello World!"  
│           0x00001202      4889c7         mov rdi, rax                ; const char *s  
│           0x00001205      e826feffff     call sym.imp.puts           ; int puts(const char *s)  
│           0x0000120a      837dfc01       cmp dword [var_4h], 1  
│       ┌─< 0x0000120e      750f           jne 0x121f  
│       │   0x00001210      488d05120e00.  lea rax, str.This_is_test_  ; 0x2029 ; "This is test!"  
│       │   0x00001217      4889c7         mov rdi, rax                ; const char *s  
│       │   0x0000121a      e811feffff     call sym.imp.puts           ; int puts(const char *s)  
│       │   ; CODE XREF from main @ 0x120e  
│       └─> 0x0000121f      b800000000     mov eax, 0  
│           0x00001224      e810ffffff     call sym.call_me  
│           0x00001229      b800000000     mov eax, 0  
│           0x0000122e      c9             leave  
└           0x0000122f      c3             ret
```

Результат выполнение программы: 

```
Hello World!  
This is test!  
This is other function!
```

**Разбор кода**

1. Исходный код:

     В главной функции (main) у нас четыре переменных:

    - Переменная key, тип int, размер 4-байта, значение: 1;
    - Переменная buffer, тип char, размер 50-байт, значение: This is buffer!;
    - Переменная pass, тип char, размер 5-байт, значение: AAAAA;
    - Переменная text, тип char, размер 30-байт, значение: This is simple text for you!


     С п.м. функции printf() мы выводим строку "Hello World!" на экран. После проверяем переменную key, если его значение является число 1, то выводим на экран строку "This is test!". После чего вызываем функцию call_me(). В функции call_me() у нас два переменных:

    - Переменная age, тип int, размер 4-байт, значение: 5;
    - Переменная name, тип char, размер 10-байт, значение: Alex;

     С п.м. функции printf() мы выводим на экран строку "This is other function!".

**Под отладчиком:** 

Первые две строки кода это пролог процедуры:

```
│           0x00001168      55             push rbp  
│           0x00001169      4889e5         mov rbp, rsp  
```

- Освобождаем память со стека (0x70 = 112 в десятичном виде). Другими словами освобождаем 112 байт в стеке для наших локльных переменных и других данных.

```
sub rsp, 0x70
```

- **sub esp, 10** увеличивает стек на 16 байт (10 в шестнадцатеричном формате), чтобы выделить место в стеке для любых переменных, на которые нам нужно ссылаться.

Основная/прямая причина использования чего-то вроде sub esp,0x18 (24 байта) заключается в том, чтобы зарезервировать место в стеке. Это можно использовать, чтобы освободить место для локальных переменных и других данных подпрограммы. Это также можно использовать для выравнивания указателя стека, если это необходимо для производительности или по другим причинам.

- **add esp,10** - добавить это просто дополнение. `add esp, 8` просто **добавляет значение 8 к ESP** . Поскольку ESP указывает на вершину (адрес памяти) стека, а стек растет «вниз» от высоких к низким адресам памяти, добавляя 8 к указателю стека, вы эффективно удаляете верхние 8 байтов из стека тем самым освобождаете выделенный участок памяти.

Напомнаю что стек растёт вниз и:

- `sub esp` - выделить место для данных. Т.е. вставить какие-то данные в стек
- `add esp` - освободить место в стеке


**Переменные:**

1. Исходный код:

```c
 int key = 1;  
 char buffer[50] = "This is buffer!";  
 char pass[5] = "AAAAA";  
 char text[30] = "This is simple text for you!";  
```


Под отладчиком вот так выглядит выделенные участки памяти для переменных:

```
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
```

Самый нижный участок памяти  `rbp-0x4`, которая находиться в самом внизу, это наша переменная key. Первый кусок данных которые были занесени в стек, будут нахдиться на самом верху (дно стека), а последние – самом внизу (верхушка стека). Переменная `key` была добавлена в стек первым, поэтому он находиться на дне стека и имеет самый выйсокий адрес что указывает что он находится на дне стека. Переменная `text` была добавлена в стек последней, она имеет наименьший адрес что указывает что она находится в верхушке стека. Элемент, непосредственно примыкающий к нижней границе, называется _дном стека_.

Записываем число один размером в двойное слово (32-бит или 4 байт). Почему 4 байта? Да потому что у переменной типа int размер 4 байта. Мы записываем данные определённого размера, а именно размером который мы выделили в памяти. Поскольку у переменной int размер 4-байта, мы записываем его в точночти 4-байта.

```
mov dword[var_4h], 1
```

Поскольку наш процессор работает в 64-битном режиме, мы имеем доступ к 64-битным регистрам (rax, rbx, rcx, rdx и т.д.), а это значить что наши данные тоже должны быть размером 64-бита, а то как процессор их запехнёт в свой регистр, это просто невозможно. А мы записываем значение "This is buffer!" в переменную `buffer`. Одна буква состоить из 8-битов (ASCII), а это означает что значение "This is buffer" состоить из 15 символов - `15*8` = 120. То есть 120-бит весить наше значение. И тут возникает вопрос. Как работать с 120-битовым данным с 64-битовым местом (регистром). Отвечаю - по частям, то есть сначало часть данных кидаем, потом другую часть и т.д. 

---


**Исходный код:**

```c
char buffer[50] = "This is buffer!";
```

**Под отладчиком:**

Начиная с адреса `rbp-0x40` до `rbp-0x10` - это наша переменная `buffer` под которым мы выделили 50 байт. В контексте использования регистра rbp, который часто служит для установления "основного" указателя стека (base pointer) в x86-64 архитектуре, можно сделать такие выводы:

- Адрес `rbp-0x10` указывает на более высокую (ближайшую к началу стека) область памяти, чем rbp - 0x40.

- Таким образом, если у вас данные в стеке находятся между `rbp-0x10` и `rbp-0x40`, то `rbp-0x10` — это, скорее всего, конец области данных (например, верхний предел для локальной переменной), а rbp - 0x40 — это начало области, содержащей эти данные (например, начало массива или нескольких локальных переменных).

Таким образом, можно сделать вывод, что `rbp-0x10` указывает на конец данных, а `rbp-0x40` — это начало.

```
│           0x00001177      48b854686973.  movabs rax, 0x2073692073696854 ; 'This is '  
│           0x00001181      48ba62756666.  movabs rdx, 0x21726566667562 ; 'buffer!'  
│           0x0000118b      488945c0       mov qword [var_40h], rax  
│           0x0000118f      488955c8       mov qword [var_38h], rdx  
│           0x00001193      48c745d00000.  mov qword [var_30h], 0  
│           0x0000119b      48c745d80000.  mov qword [var_28h], 0  
│           0x000011a3      48c745e00000.  mov qword [var_20h], 0  
│           0x000011ab      48c745e80000.  mov qword [var_18h], 0  
│           0x000011b3      66c745f00000   mov word [var_10h], 0  
```

 Большинство инструкций не могут работать с 64-битными адресами: ; movabs — это AT-имя специальной формы, которая принимает 64-битные непосредственные данные. ; ; Intel просто помещает его в MOV, а NASM просто использует «mov». 
 
 movabs используется для абсолютных перемещений данных, либо для загрузки произвольной 64-битной константы в регистр, либо для загрузки данных в регистр с 64-битного адреса.

`movabs rax, 0x2073692073696854 ; 'This is '` - Записываем первые 64-бита значении "This is buffer ". Это 8 символов, а `8*8=64`. Регистр у нас 64-битовый же. Простыми словами,  записываем в регистр rax строку “This is” (ascii формат).

`movabs rdx, 0x21726566667562 ; 'buffer!'` - Записываем следующие 64-бита нашего значение. То есть Записываем в регистр rdx строку “buffer!”  (остальная часть данных нашей переменной).

`mov qword [var_40h], rax` – Записываем в память по относительному адресу `rbp-0x40` значение регистра `rax` – “ This is” .

`mov qword [var_38h], rdx` – Записываем в память по относительному адресу `rbp-0x38` значение регистра `rdx` – “buffer!” .

Так, мы освободили 50-байт (400-бит) памяти, а использовали лишь 15-байт (120-бит), что же будет с остальным 35-байтой (280-бит). В нашем случае свободная место заполняется нулями:

```
mov qword [var_30h], 0  
mov qword [var_28h], 0  
mov qword [var_20h], 0  
mov qword [var_18h], 0  
mov word [var_10h], 0  
```

Не всегда свободное место заполняется нулями как в нашем случае. Это зависить от компилятора, и параметры оптимизации кода. Но вы даже можете указать чем именно заполнить свободное место, например с п.м. фунции `memset()`.

Последние цифры в называние переменных которые показывает нам отладчик, означает позицию (расположение) и размер данных. Например, у нас он вот такой:

```
│           ; var int64_t var_70h @ rbp-0x70  
│           ; var int64_t var_68h @ rbp-0x68  
│           ; var int64_t var_60h @ rbp-0x60  
│           ; var int64_t var_58h @ rbp-0x58  
│           ; var int64_t var_54h @ rbp-0x54  
│           ; var int64_t var_45h @ rbp-0x45  
│           ; var int64_t var_41h @ rbp-0x41  
│           ; var int64_t var_40h @ rbp-0x40  
│           ; var int64_t var_38h @ rbp-0x38  
│           ; var int64_t var_30h @ rbp-0x30  
│           ; var int64_t var_28h @ rbp-0x28  
│           ; var int64_t var_20h @ rbp-0x20  
│           ; var int64_t var_18h @ rbp-0x18  
│           ; var int64_t var_10h @ rbp-0x10  
│           ; var uint32_t var_4h @ rbp-0x4  
```

Как мы знаем в самом внизу находится наша первая переменная key, у которого тип int и размер которого состовляет 4-байта, названия участка в отладчике **var_4h** (`rbp-0x4`) - то есть первые четыре байта. Как уже сказали начиная, наченая с область памяти **rbp-40h**  до **rbp-10h** - это переменная buffer, тип которого char и размер 50-байт. В var_40h мы кинули первую партию данных, var_38h вторую, var_30h третью и так до var_10h. И всё это состовляет нашу переменную buffer. Как мы уже сказали, мы кидаем данные по партиям (частям) из за ограничения регистров процессора, ведь его размер ограниченный (64-бит).

---

**Исходный код:**

```c
char pass[5] = "AAAAA"; 
```

**Под отладчиком:**

```
mov dword [var_45h], 0x41414141 ; 'AAAA'  
mov byte [var_41h], 0x41    ; 'A'  
```

И так, мы освободили 5-байт в памяти под переменной `pass`. В отладчике мы видим что сначало закидывается первые 4-байта данных по относительному адресу `rbp-45h`, после другой и последный байт по относительному адресу `rbp-41h`.  Процессор  работает с данными с п.м. подсказок которые помогают эффективно использовать память. 

Записать по относительному адрес `rbp-45h` “AAAA” в формате hex ascii размером в двйное слово (4 байт):

```
mov dword [var_45h], 0x41414141
```

Записать в область памяти `rbp-41h` “A” в формате hex ascii размером в byte (1 байт):

```
mov byte [var_41h], 0x41
```
   
Можно понять, что область памяти var_45h и var_41h состовляет нашу переменную pass.

Использование различных размерностей данных, таких как byte, word, dword, и других, в ассемблере и других языках программирования обусловлено несколькими ключевыми причинами:

1. Эффективность памяти:
    - Разные типы данных позволяют более эффективно использовать память. Например, если требуется хранить только небольшие числовые значения, использование byte вместо dword экономит память. Это особенно важно в условиях ограниченных ресурсов, таких как встроенные системы.

2. Оптимизация производительности:
    - Использование подходящих размеров данных позволяет процессору оптимально обрабатывать информацию. Процессоры обычно оптимизированы под определенные размеры данных, и работа с word или dword может быть быстрее, чем работа с byte, так как они обрабатываются за один такт.

3. Удобство работы с типами данных:
    - Различные типы данных позволяют программистам легко управлять и понимать, как данные хранятся и обрабатываются. Это повышает читаемость кода и упрощает отладку.

4. Совместимость с архитектурой:
    - Разные архитектуры имеют свои особенности и предпочтения. Например, 16-битные системы, 32-битные системы и 64-битные системы могут иметь разные размеры word и dword. Используя стандартные обозначения, программисты могут легче адаптировать код под разные платформы.

5. Работа с SIMD и многопоточностью:
    - Использование широких данных, таких как qword, особенно важно в контексте SIMD (Single Instruction, Multiple Data) инструкций, которые позволяют обрабатывать множество данных параллельно, что значительно ускоряет выполнение задач.

6. Типобезопасность:
    - Явное указание размера данных может помочь избежать ошибок, связанных с переполнением или некорректной интерпретацией данных. Это позволяет компилятору или ассемблеру более эффективно проверять правильность кода.

7. Простота взаимодействия с аппаратным обеспечением:
    - Различные операции с памятью и регистрами могут требовать данных определённой размерности, что делает использование разных типов данных необходимым для корректной работы программ.

Таким образом, использование различных размеров данных улучшает управление ресурсами, увеличивает производительность, облегчает разработку и отладку, а также обеспечивает более эффективное взаимодействие с оборудованием.

---

Ну дальше у нас привычный код. Записать в rax hex ascii “This is “:

```
movabs rax, 0x2073692073696854
```

Записать в rdx  ascii строку  “simple t” в формате hex:

```
movabs rdx, 0x7420656c706d6973 – Записать в rdx hex ascii “simple t” 
```

 Записать в память по относительному адресу `rbp-70h` значение регистра rax размером 8 байт:
 
```
mov qword [var_70h], rax
```

Записать в память по относительному адресу `rbp-68h` значение регистра rdx размером 8 байт:

```
mov qword [var_68h], rdx 
```

Записать в `rax`  ascii строку “ext for “ в формате hex :

```
movabs rax, 0x20726f6620747865 
```

Записать в область памяти var_60h значение регистра rax размером 8 байт:

```
mov qword [var_60h], rax
```

Записать в память по относительному адресу `rbp-58h` ascii строку “you!” в формате hex размером в 8 байт :

```
mov dword [var_58h], 0x21756f79
```

Заполнить  память по относитльному адресу `rbp-54h` нулями размером в 2 байта . Простыми словами, заполняем свободное пространство нулями.

```
mov word [var_54h], 0
```

Область памяти var_70h – var_54h, составляет нашу переменную text.

### Глобальные переменные (Global Variables)

Глобальные переменные попадают в специальный сегмент памяти, называемый **сегментом данных** (data segment). Этот сегмент разделяется на две части:

1. **Сегмент инициализированных данных** (initialized data segment) — сюда попадают глобальные и статические переменные, которым присвоены начальные значения.
    
2. **Сегмент неинициализированных данных** (uninitialized data segment или BSS) — сюда попадают глобальные и статические переменные, которым не присвоено начальное значение.

Эти сегменты, в отличие от стека, выделяются в памяти на протяжении всего времени выполнения программы.

- **Описание**: Переменные, объявленные вне функций. Доступны везде в программе после объявления.
- **Ассемблер**: Обычно хранятся в `.data` или `.bss` сегментах памяти.
- **Пример (C)**:

```c
int global_var = 10;
```

```asm
.data
global_var:
    .long 10
```


### Регистровые переменные (Register Variables)

- **Описание**: Переменные, которые компилятор может попытаться хранить в регистре процессора, чтобы ускорить доступ к ним.
- **Ассемблер**: Такие переменные не хранятся в памяти, а назначаются регистрами процессора, если компилятор посчитает это оптимальным.

```c
void func() {
    register int reg_var = 3;
}
```

```asm
func:
    mov eax,3    ; использование регистра для хранения reg_var
    ...
```

### Динамически выделяемые переменные (Heap Variables)

- **Описание**: Переменные, выделяемые во время выполнения программы с помощью функций `malloc`, `calloc`, и т.д. Хранятся в куче (heap).
- **Ассемблер**: Адрес возвращаемого указателя хранится в регистре или в локальной переменной, но фактическое выделение памяти управляется системными вызовами или стандартной библиотекой.

```c
void func() {
    int *heap_var = malloc(sizeof(int));
    *heap_var = 9;
}
```

```asm
func:
    mov     edi, 4           ; размер памяти (4 байта)
    call    malloc           ; вызов функции malloc
    mov     QWORD PTR [rbp-8], rax   ; сохранение указателя в heap_var
    mov     DWORD PTR [rax], 9   ; инициализация heap_var
    ...
```

На уровне ассемблера можно увидеть, как разные виды переменных в C управляются компилятором, будь то выделение памяти в сегментах данных, работа со стеком, регистрами или динамическим выделением памяти в куче.

### Статические переменные (Static Variables)

- **Описание**: Переменные, сохраняющие своё значение между вызовами функции или сохраняющиеся в глобальной области, но недоступные вне файла, если объявлены как `static`.
- **Ассемблер**: Обычно также хранятся в `.data` или `.bss` сегментах. Для локальных статических переменных используется выделение памяти в этих сегментах, а не в стеке.

```c
void func() {
    static int static_var = 7;
}
```

```asm
.data
static_var:
    .long 7
func:
    ...
    mov eax, DWORD PTR static_var
    ...
```


### Заключение

1. **Локальные переменные** (автоматические переменные):
    
    - **Место хранения:** Локальные переменные, объявленные внутри функции, по умолчанию попадают в **стек**.
    - **Особенности:** Они существуют только во время выполнения функции, в которой объявлены. После завершения функции, соответствующая часть стека освобождается, и память, использованная для этих переменных, становится доступной для других вызовов функций.

1. **Глобальные переменные**:
    
    - **Место хранения:** Глобальные переменные размещаются в **сегменте данных** (data segment), который включает две части:
        - **Инициализированные данные** (для переменных с начальными значениями).
        - **Неинициализированные данные** (BSS) для переменных без начальных значений.

1. **Статические локальные переменные**:
    
    - **Место хранения:** Локальные переменные, объявленные как `static`, хранятся в **сегменте данных** вместе с глобальными переменными, но их область видимости ограничена функцией, в которой они объявлены.
    - **Особенности:** Они сохраняют своё значение между вызовами функции и существуют на протяжении всего времени выполнения программы, как и глобальные переменные.

Резюме:

   - **Локальные переменные** — в **стеке**.
   - **Глобальные переменные** — в **сегменте данных**.
   - **Статические локальные переменные** — тоже в **сегменте данных**.

Статические переменные не хранятся в сегменте `.rodata`. Давайте уточним:

1. **Сегмент `.rodata`**:

    - **Содержимое:** Сегмент `.rodata` (read-only data) хранит **константные данные**, такие как строки и другие литералы, которые не изменяются в течение выполнения программы.
    - **Характеристики:** Этот сегмент доступен только для чтения, и любые попытки изменить данные в этом сегменте приведут к ошибке выполнения (например, сегментирование в Unix-подобных системах).

2. **Статические переменные (глобальные и локальные)**:

    - **Место хранения:** Статические переменные хранятся в **сегменте данных** (`.data` для инициализированных переменных) или в **сегменте BSS** для неинициализированных переменных.
    - **Инициализированные статические переменные**: Хранятся в сегменте `.data`. Это касается как глобальных статических переменных, так и локальных переменных с модификатором `static`.
    - **Неинициализированные статические переменные**: Хранятся в сегменте `.bss`.
    - **Характеристики:** Статические переменные, независимо от того, глобальные они или локальные, существуют на протяжении всего времени выполнения программы и сохраняют своё значение между вызовами функций.

```c
int global_var = 42;        // В сегменте .data
static int static_global;   // В сегменте .bss

void foo() {
    static int static_local = 5; // В сегменте .data
    const char *str = "Hello";   // Строка "Hello" будет храниться в сегменте .rodata
}
```

- `static_local` будет храниться в сегменте `.data` (так как она инициализирована).
- `static_global` — в сегменте `.bss`.
- Строка `"Hello"` будет храниться в сегменте `.rodata`, поскольку она является неизменяемой константой.

---

