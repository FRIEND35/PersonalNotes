**Платформа:** https://crackmes.one/
**Тип файла**: elf
**Уровень:** Easy

**Описание**: Небольшая простая крякми, где вам нужно угадать пин-код :)


# Способ первый: IDA 
## Декомпиляция кода

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v4; // rdx
  const char *v5; // [rsp+10h] [rbp-30h]
  size_t v6; // [rsp+28h] [rbp-18h]
  char *s1; // [rsp+38h] [rbp-8h]

  if ( argc == 2 )
  {
    s1 = (char *)decode_pin(argv[1], argv, envp);
    v6 = strlen(argv[1]);
    v4 = strlen("8446");
    if ( !strncmp(s1, "8446", v4) && v6 == strlen(s1) )
    {
      puts("Correct PIN entered!");
      v5 = (const char *)decode_string("}|.wOlHtc}j@z9jf3 O Q", argv[1]);
      printf("Decoded String: %s\n", v5);
      return 0;
    }
    else
    {
      puts("This is not right");
      return 1;
    }
  }
  else
  {
    printf("Usage: %s <pin>\n", *argv);
    return 1;
  }
}
```

1. **Проверяет количество аргументов** командной строки (argc):
    
    - Если аргументов ровно два (само имя программы и введённый PIN), то программа продолжает выполнение.
    - В противном случае, выводится сообщение об использовании и программа завершается с кодом 1.

Первое что попадается в глаза, это то что пользовательский ввод сравнивается со строкой "8446":

```c
if ( !strncmp(s1, "8446", v4) && v6 == strlen(s1) )
    {
      puts("Correct PIN entered!");
      ...
    }
```

 Вычисляет длину введенного PIN и сравнивает её с длиной строки `"8446"`.
 
 Давате ка проверим это:

```
./authorize 8446  
This is not right
```

Нет, это не работает. Так в чем же проблема? Если внимательно посмотреть, то заметим что пользовательский ввод сначало попадает в функцию `decode_pin`, потом попадает в `strncmp` для сравнения строк:

```c
s1 = (char *)decode_pin(argv[1], argv, envp);
```
  
- Вызывает функцию `decode_pin`, передавая введённый PIN в качестве аргумента.
- Сохраняет результат в переменную `s1`.

Код сравнивает декодированный PIN с `"8446"`.  Если декодированный PIN совпадает с `"8446"` и его длина совпадает с длиной введенного PIN, программа выводит "Correct PIN entered!".  В противном случае, программа выводит "This is not right" и завершается с кодом 1.

Нужно разобрать эту функцию чтобы понять что она делает для решение задачи. Ведь когда мы вводим PIN, функция `decode_pin` изменяет строку потом сравнивает изменённый PIN с 8446. Нам нужно ввести PIN так чтобы когда он попадает в `decode_pin` при переобразовании в ответ получили 8446:

### Разбор функции decode_pin

```c
_BYTE *__fastcall decode_pin(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-8h]
  int i; // [rsp+14h] [rbp-4h]

  for ( i = 0; i <= 3; ++i )
  {
    v2 = *(char *)(i + a1) - 53;
    decoded_pin_1[i] = v2 + (v2 < 0 ? 0xA : 0) + 48;
  }
  byte_4089 = 0;
  return decoded_pin_1;
}
```

1. **Подпись функции**:

```c
_BYTE *__fastcall decode_pin(__int64 a1)
```

- Функция называется `decode_pin`.
- Она принимает один аргумент `a1` типа `__int64` (64-битное целое число).
- Возвращает указатель на `_BYTE`.

2. **Переменные**:

```c
int v2; // [rsp+10h] [rbp-8h]
int i;  // [rsp+14h] [rbp-4h]
```

-  `v2` и `i` - это локальные переменные типа `int`.

3. **Цикл**:

```c
for (i = 0; i <= 3; ++i)
{
    v2 = *(char *)(i + a1) - 53;
    decoded_pin_1[i] = v2 + (v2 < 0 ? 0xA : 0) + 48;
}
```

- Цикл `for` выполняется от 0 до 3 (всего 4 итерации), таким образом, обрабатывая 4 байта данных, начиная с адреса `a1`.
- Внутри цикла:

    - `v2 = *(char *)(i + a1) - 53;`: Извлекается байт данных по адресу `a1 + i` и вычитается 53.
    - `decoded_pin_1[i] = v2 + (v2 < 0 ? 0xA : 0) + 48;`: Если результат `v2` меньше 0, то добавляется 0xA (10 в десятичной системе), затем добавляется 48 (ASCII-код символа '0'), и результат сохраняется в массив `decoded_pin_1`.


Извлечение байта данных по адресу `a1 + i` означает, что программа обращается к памяти по адресу, который получается добавлением смещения `i` к базовому адресу `a1`. Это типичная операция в C/C++ для доступа к элементам массива или строке.

Рассмотрим более подробно, как это работает:

1. **Базовый адрес** `a1` указывает на начало строки или массива.
2. **Смещение** `i` указывает, на сколько байтов нужно сдвинуться от базового адреса, чтобы получить нужный элемент.

Допустим, `a1` указывает на строку `"579A"`, представленной в памяти как байтовый массив `[53, 55, 57, 65]` (где 53, 55, 57, 65 - это ASCII коды символов '5', '7', '9' и 'A' соответственно).

**Процесс извлечения байта**

- **Первая итерация (i = 0)**:
    
    - Адрес: `a1 + 0` указывает на первый байт.
    - Извлекается байт: 53 (соответствует символу '5').
- **Вторая итерация (i = 1)**:
    
    - Адрес: `a1 + 1` указывает на второй байт.
    - Извлекается байт: 55 (соответствует символу '7').
- **Третья итерация (i = 2)**:
    
    - Адрес: `a1 + 2` указывает на третий байт.
    - Извлекается байт: 57 (соответствует символу '9').
- **Четвертая итерация (i = 3)**:
    
    - Адрес: `a1 + 3` указывает на четвертый байт.
    - Извлекается байт: 65 (соответствует символу 'A').

В Python доступ к элементам строки или массива осуществляется проще и безопаснее:

```python
a1 = b'579A'  # Строка в виде байтов

for i in range(4):
    byte_value = a1[i]  # Извлекается байт по индексу i
    print(byte_value)
```

В этом коде `a1[i]` извлекает байт по индексу `i` из строки байтов `a1`. Это эквивалентно `*(char *)(i + a1)` в C/C++.

### Интерпретация логики

Функция `decode_pin` декодирует 4-байтный PIN-код. Каждому байту исходного PIN-кода вычитается 53, и если результат меньше 0, добавляется 10, после чего добавляется 48 для получения корректного символа в ASCII-кодировке.

Допустим, `a1` указывает на строку "579A" (в ASCII-кодах: [53, 55, 57, 65]):

- 1-я итерация: `i = 0`
    - `v2 = 53 - 53 = 0`
    - `decoded_pin_1[0] = 0 + 48 = 48` ('0')
- 2-я итерация: `i = 1`
    - `v2 = 55 - 53 = 2`
    - `decoded_pin_1[1] = 2 + 48 = 50` ('2')
- 3-я итерация: `i = 2`
    - `v2 = 57 - 53 = 4`
    - `decoded_pin_1[2] = 4 + 48 = 52` ('4')
- 4-я итерация: `i = 3`
    - `v2 = 65 - 53 = 12`
    - `v2 < 0` - условие ложное
    - `decoded_pin_1[3] = 12 + 48 = 60` ('<')


В результате `decoded_pin_1` будет содержать строку "024<".

Вот простая копия функции на Python:

```python
def decode_pin(a1: bytes) -> str:
    decoded_pin = []

    for i in range(4):
        v2 = a1[i] - 53
        decoded_pin.append(chr(v2 + (10 if v2 < 0 else 0) + 48))

    return ''.join(decoded_pin)

# Пример использования
a1 = b'579A'  # Строка в виде байтов
print(decode_pin(a1))  # Вывод: '024<'
```

1. **Функция** `decode_pin` принимает один аргумент `a1` типа `bytes`.
2. **Создаем пустой список** `decoded_pin` для хранения декодированных символов.
3. **Цикл** `for` проходит по индексам от 0 до 3.
4. **Вычисляем** `v2` как `a1[i] - 53`.
5. **Проверяем**, если `v2` меньше 0, добавляем 10 к `v2`.
6. **Добавляем** 48 к `v2` для получения корректного ASCII символа.
7. **Преобразуем** результат в символ с помощью `chr` и добавляем в список `decoded_pin`.
8. **Возвращаем** объединенный список символов как строку.

`decode_pin(a1: bytes) -> str:` это строка объявления функции в Python с типизацией. Она сообщает, что функция `decode_pin` принимает аргумент `a1` типа `bytes` и возвращает значение типа `str`:

```python
def call(a1:bytes)->str:
    print(a1)

c = chr(0x41)
call(c)
```

Если в качестве PIN мы введём 0000, то результат будет 5555, а 5555 != 8446. Для `b'0000'` каждый байт имеет значение 48 (ASCII-код символа '0'). Давайте разберем шаги подробно:

1. Для каждого байта из `a1`, вычисляется `v2` как `a1[i] - 53`. Если байт '0' (48), то `v2` будет 48 - 53 = -5.
2. Если `v2` меньше 0 (а это так), то добавляется 10 к `v2`, поэтому -5 + 10 = 5.
3. Затем добавляется 48, чтобы получить корректный ASCII-код символа: 5 + 48 = 53, который является ASCII-кодом символа '5'.

1. **Первый байт '0' (48)**:
    - `v2 = 48 - 53 = -5`
    - `v2 < 0`, поэтому `v2 = -5 + 10 = 5`
    - `chr(5 + 48) = chr(53) = '5'`
2. **Второй байт '0' (48)**:
    - Аналогичные вычисления приводят к '5'.
3. **Третий байт '0' (48)**:
    - Аналогичные вычисления приводят к '5'.
4. **Четвертый байт '0' (48)**:
    - Аналогичные вычисления приводят к '5'.

В итоге функция возвращает строку `'5555'`.
### Завершение decode_pin

```c
byte_4089 = 0;
return decoded_pin_1;
```

- Устанавливается значение переменной `byte_4089` в 0.
- Возвращается указатель на массив `decoded_pin_1`.
 - Функция возвращает указатель (скорее всего на начало массива decoded_pin_1).

**Если PIN верен**, программа декодирует строку:
    
 - Вызывает функцию `decode_string`, передавая закодированную строку и введённый PIN.
 - Выводит декодированную строку.



---

И так наша задача в результате получить 8446 (в ASCII-кодах:  [56 52 52 54])

```
1. 
    x - 53 = z   
    z + 48 = 56  
	    
    	x − 53 + 48 = 56 (ascii "8")
	    x − 5 = 56
	    x = 56 + 5 = 61 
	    x = 61 (ascii "=")
	
2. 
    x - 53 = z
    z + 48 = 52
     
        x − 53 + 48 = 52 (ascii "4")
	    x − 5 = 52 
        x = 52 + 5 = 57
        x = 57 (ascii "9")
	
3. 
    x - 53 = z
    z + 48 = 52

        x − 53 + 48 = 52 (ascii "4")
	    x − 5 = 52 
        x = 52 + 5 = 57
        x = 57 (ascii "9")

4. 
    x - 53 = z
    z + 48 = 54

        x − 53 + 48 = 54 (ascii "6")
        x − 5 = 54
        x = 54 + 5 = 59
        x = 59 (ascii ";")
```

Ответ:

```
1. x = 61
2. x = 57
3. x = 57
4. x = 59
```

То есть:

```
61 - 53 + 48 = 56 (ascii "8")
57 - 53 + 48 = 52 (ascii "4")
57 - 53 + 48 = 52 (ascii "4")
59 - 53 + 48 = 54 (ascii "6")
```
### Обратное декодирование

**Декодирование "8446":**

1. **Для '8'**:
    
    - ASCII-код '8' = 56
    - 56 - 48 = 8
    - Если результат (v2) меньше 0, добавляем 10, но 8 >= 0, поэтому не добавляем 10.
    - x - 53 = 8
    - x = 8 + 53
    - x = 61
2. **Для '4'**:
    
    - ASCII-код '4' = 52
    - 52 - 48 = 4
    - Если результат (v2) меньше 0, добавляем 10, но 4 >= 0, поэтому не добавляем 10.
    - x - 53 = 4
    - x = 4 + 53
    - x = 57
3. **Для '4'**: Аналогично предыдущему:
    
    - x = 57
4. **Для '6'**:
    
    - ASCII-код '6' = 54
    - 54 - 48 = 6
    - Если результат (v2) меньше 0, добавляем 10, но 6 >= 0, поэтому не добавляем 10.
    - x - 53 = 6
    - x = 6 + 53
    - x = 59

**Десятичные значения**

Для того чтобы получить строку "8446", входные значения должны быть:

- '8' -> 61 (ascii "=")
- '4' -> 57 (ascii "9")
- '4' -> 57 (ascii "9")
- '6' -> 59 (ascii ";")

И так когда мы вводим `"=99;"` в качестве пароля (ascii [61,57,57,59]),  и парол подходит. Но у нас есть еще правильный пароль, и это `3991`. Для того чтобы PIN-код "3991" был закодирован в "8446", нужно рассчитать, какие исходные байты соответствуют этим значениям после декодирования:
### Декодирование строки 

1. **Для '8' (ASCII 56):**
    
    - `56 - 48 = 8`
    - Нужно, чтобы `v2 = 8`, а это `v2 = (char - 53)`
    - Следовательно, исходный байт = `8 + 53 = 61` (в ASCII это `'='`, но нам нужен конкретный байт).

1. **Для '4' (ASCII 52):**
    
    - `52 - 48 = 4`
    - Нужно, чтобы `v2 = 4`, а это `v2 = (char - 53)`
    - Следовательно, исходный байт = `4 + 53 = 57` (в ASCII это `'9'`).

### Проверка PIN-кода 

1. **Для символа '3' (ASCII 51):**
    
    - `v2 = 51 - 53 = -2`
    - Приводим к положительному значению: `-2 + 10 = 8`
    - `8 + 48 = 56` (это '8')

1. **Для символа '9' (ASCII 57):**
    
    - `v2 = 57 - 53 = 4`
    - `4 + 48 = 52` (это '4')

1. **Для символа '9' (ASCII 57) повторяется:**
    
    - Снова '4'

1. **Для символа '1' (ASCII 49):**
    
    - `v2 = 49 - 53 = -4`
    - Приводим к положительному значению: `-4 + 10 = 6`
    - `6 + 48 = 54` (это '6')

### Итоговый PIN-код

Для строкового ввода PIN-кода, чтобы получить "8446" при декодировании, используйте строку `"3991"` или `"=99;"`. 
Любой символ, ascii код которого при -53+48 соответсвует символу PIN-кода, может быть паролем:

- `3991`
- `=99;`
- `=991`
- `399;`


# Способ второй: GDB


Мы уже знаем на что обращать внимания, так что давайте сразу к делу. 


```
Dump of assembler code for function decode_pin:  
  0x0000555555555238 <+0>:     push   rbp  
  0x0000555555555239 <+1>:     mov    rbp,rsp  
  0x000055555555523c <+4>:     mov    QWORD PTR [rbp-0x18],rdi  
  0x0000555555555240 <+8>:     mov    DWORD PTR [rbp-0x4],0x0  
  0x0000555555555247 <+15>:    jmp    0x555555555287 <decode_pin+79>  
  0x0000555555555249 <+17>:    mov    eax,DWORD PTR [rbp-0x4]  
  0x000055555555524c <+20>:    movsxd rdx,eax  
  0x000055555555524f <+23>:    mov    rax,QWORD PTR [rbp-0x18]  
  0x0000555555555253 <+27>:    add    rax,rdx  
  0x0000555555555256 <+30>:    movzx  eax,BYTE PTR [rax]  
  0x0000555555555259 <+33>:    movsx  eax,al  
  0x000055555555525c <+36>:    sub    eax,0x35  
  0x000055555555525f <+39>:    mov    DWORD PTR [rbp-0x8],eax  
  0x0000555555555262 <+42>:    cmp    DWORD PTR [rbp-0x8],0x0  
  0x0000555555555266 <+46>:    jns    0x55555555526c <decode_pin+52>  
  0x0000555555555268 <+48>:    add    DWORD PTR [rbp-0x8],0xa  
  0x000055555555526c <+52>:    mov    eax,DWORD PTR [rbp-0x8]  
  0x000055555555526f <+55>:    add    eax,0x30  
  0x0000555555555272 <+58>:    mov    ecx,eax  
  0x0000555555555274 <+60>:    mov    eax,DWORD PTR [rbp-0x4]  
  0x0000555555555277 <+63>:    cdqe  
  0x0000555555555279 <+65>:    lea    rdx,[rip+0x2e05]        # 0x555555558085 <decoded_pin.1>  
  0x0000555555555280 <+72>:    mov    BYTE PTR [rax+rdx*1],cl  
  0x0000555555555283 <+75>:    add    DWORD PTR [rbp-0x4],0x1  
  0x0000555555555287 <+79>:    cmp    DWORD PTR [rbp-0x4],0x3  
  0x000055555555528b <+83>:    jle    0x555555555249 <decode_pin+17>  
  0x000055555555528d <+85>:    mov    BYTE PTR [rip+0x2df5],0x0        # 0x555555558089 <decoded_pin.1+4>  
  0x0000555555555294 <+92>:    lea    rax,[rip+0x2dea]        # 0x555555558085 <decoded_pin.1>  
  0x000055555555529b <+99>:    pop    rbp  
  0x000055555555529c <+100>:   ret  
End of assembler dump.
```

#### Начальная установка

```
0x0000555555555238 <+0>:     push   rbp
0x0000555555555239 <+1>:     mov    rbp,rsp
0x000055555555523c <+4>:     mov    QWORD PTR [rbp-0x18],rdi
0x0000555555555240 <+8>:     mov    DWORD PTR [rbp-0x4],0x0
```

1. `push rbp`:  Сохраняет значение регистра `rbp` на стеке.  Это нужно для сохранения предыдущего фрейма стека, чтобы потом можно было к нему вернуться.

2.  `mov rbp, rsp`:  Устанавливает `rbp` равным `rsp`.  Это создает новый фрейм стека для текущей функции.

3. `mov QWORD PTR [rbp-0x18], rdi`:  Копирует значение регистра `rdi` (аргумент функции, указывающий на строку с PIN-кодом) в локальную переменную по адресу `[rbp-0x18]`.

4.  `mov DWORD PTR [rbp-0x4], 0x0`:  Инициализирует локальную переменную по адресу `[rbp-0x4]` значением `0`.  Эта переменная будет использоваться как индекс для итераций по строке.
#### Основной цикл

1. `jmp 0x555555555287 <decode_pin+79>`: Переход к концу цикла, где будет проверяться условие завершения.
2. `mov eax, DWORD PTR [rbp-0x4]`:  Загружает текущее значение индекса цикла в `eax`.
3. `movsxd rdx, eax`:  Преобразует значение `eax` (32-битное) в `rdx` (64-битное).
4.  `mov rax, QWORD PTR [rbp-0x18]`:  Загружает базовый адрес строки PIN-кода в `rax`.
5.  `add rax, rdx`:  Добавляет смещение (индекс) к базовому адресу, чтобы получить адрес текущего символа PIN-кода.
6.  `movzx eax, BYTE PTR [rax]`:  Загружает текущий символ PIN-кода (1 байт) в `eax`.
7.  `movsx eax, al`:  Преобразует загруженный байт в знаковое 32-битное значение `eax`.

```
0x0000555555555247 <+15>:    jmp    0x555555555287 <decode_pin+79>     ;Переход к проверке завершения цикла.
0x0000555555555249 <+17>:    mov    eax,DWORD PTR [rbp-0x4]            ;Загружаем текущий индекс (`eax = [rbp-0x4]`).
0x000055555555524c <+20>:    movsxd rdx,eax                            ;Преобразуем его в 64-битное значение (`rdx`).
0x000055555555524f <+23>:    mov    rax,QWORD PTR [rbp-0x18]           ;Загружаем базовый адрес строки PIN-кода (`rax = [rbp-0x18]`).
0x0000555555555253 <+27>:    add    rax,rdx                            ;Добавляет смещение (индекс) к базовому адресу, чтобы получить адрес текущего символа PIN-кода.
0x0000555555555256 <+30>:    movzx  eax,BYTE PTR [rax]                 ;Загружает текущий символ PIN-кода (1 байт) в `eax`.
0x0000555555555259 <+33>:    movsx  eax,al                             ;Преобразует загруженный байт в знаковое 32-битное значение `eax`.
0x000055555555525c <+36>:    sub    eax,                               ;Вычитает `0x35` из значения `eax`.
0x000055555555525f <+39>:    mov    DWORD PTR [rbp-0x8],eax            ;Сохраняет декодированное значение в локальной переменной `[rbp-0x8]`.
0x0000555555555262 <+42>:    cmp    DWORD PTR [rbp-0x8],0x0            ;Сравнивает декодированное значение с нулем.
0x0000555555555266 <+46>:    jns    0x55555555526c <decode_pin+52>     ;Переход к следующей инструкции, если декодированное значение не отрицательное (знак не установлен).
0x0000555555555268 <+48>:    add    DWORD PTR [rbp-0x8],0xa            ;Если значение отрицательное, добавляет `0xa`, чтобы преобразовать его в корректный диапазон.
0x000055555555526c <+52>:    mov    eax,DWORD PTR [rbp-0x8]            ;Загружает декодированное значение в `eax`.
0x000055555555526f <+55>:    add    eax,0x30                           ;Добавляет `0x30`
0x0000555555555272 <+58>:    mov    ecx,eax                            ;Копирует значение в регистр `ecx`.
0x0000555555555274 <+60>:    mov    eax,DWORD PTR [rbp-0x4]            ;Загружает индекс цикла в `eax`.
0x0000555555555277 <+63>:    cdqe                                      ;Преобразует `eax` в 64-битное значение `rax`.
0x0000555555555279 <+65>:    lea    rdx,[rip+0x2e05]                   ;Загружает адрес массива `decoded_pin` в `rdx`. по текущему индексу.
0x0000555555555280 <+72>:    mov    BYTE PTR [rax+rdx*1],cl            ;Сохраняет декодированный символ в массив `decoded_pin` по текущему индексу.
0x0000555555555283 <+75>:    add    DWORD PTR [rbp-0x4],0x1            ;Увеличивает индекс цикла на 1.
0x0000555555555287 <+79>:    cmp    DWORD PTR [rbp-0x4],0x3            ;Сравнивает индекс с 3 (цикл проходит по четырем символам).
0x000055555555528b <+83>:    jle    0x555555555249 <decode_pin+17>     ;Переход к началу тела цикла, если индекс <= 3.
0x000055555555528d <+85>:    mov    BYTE PTR [rip+0x2df5], 0x0         ;Добавляет нулевой байт в конец массива `decoded_pin`, чтобы завершить строку.
0x0000555555555294 <+92>:    lea    rax, [rip+0x2dea]                  ;Загружает адрес начала массива `decoded_pin` в `rax`.
0x000055555555529b <+99>:    pop    rbp                                ;Восстанавливает значение `rbp` из стека.
0x000055555555529c <+100>:   ret                                       ;Возвращается из функции, возвращая адрес декодированной строки.

```

Давайте поставим бреёкпоинт. С декомпиялотора IDA мы можем понять что `add eax 0x30` это участок `decoded_pin_1[i] = v2 + (v2 < 0 ? 0xA : 0) + 48;`. Ведь `48 = 0x30`. Тут мы поставим брейкпоинт и будем анализировать.

```
b*0x000055555555526f 
```

### Анализ дампа памяти

И запустим программу:

```
run 1234
```

После запуска программа останавливается на указанном месте. Мы хотим проверить значение регистров:

```
rax            0x6                 0x6  
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x7ffff7f77680      0x7ffff7f77680  
rdx            0x0                 0x0  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb20      0x7fffffffdb20  
rsp            0x7fffffffdb20      0x7fffffffdb20
```

Проверяем значение памяти `rbp-4` и `rbp-8`:

```
0x7fffffffdb1c: 0x00  
gef➤  x/x $rbp-8  
0x7fffffffdb18: 0x06
```

Продолжим командой `next`, поскольку цикл у нас имеет 4 итерации, программа будет останавливатся на указанном месте 4 раза. Мы же поставили брейкпоинт внутри цикла. Запускаем команду `next` еще 3 раза, и посмотрим значение регистров и памяти:

 **1-я итерация:** 

В первом итерации мы получали

```
rax            0x6                 0x6
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x7ffff7f77680      0x7ffff7f77680  
rdx            0x0                 0x0  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb20      0x7fffffffdb20  
rsp            0x7fffffffdb20      0x7fffffffdb20  
r8             0x555555555500      0x555555555500


rbp-4          0x00
rbp-8          0x06
```

- `rax` = 6;
- `rdx` = 0x0;
- `rbp-4` = 0x00;
- `rbp-8` = 0x06;


 **2-я итерация:** 

```
rax            0x7                 0x7  
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x36                0x36  
rdx            0x1                 0x1  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb20      0x7fffffffdb20  
rsp            0x7fffffffdb20      0x7fffffffdb20

rbp-4          0x01
rbp-8          0x07
```

- `rax` = 7;
- `rdx` = 0x1;
- `rcx` = 0x36 (ascii '6')
- `rbp-4` = 0x01;
- `rbp-8` = 0x07;

 **3-я итерация:**

```
rax            0x8                 0x8  
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x37                0x37  
rdx            0x2                 0x2  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb20      0x7fffffffdb20  
rsp            0x7fffffffdb20      0x7fffffffdb20  
r8             0x555555555500      0x555555555500

rbp-4          0x02
rbp-8          0x08
```

- `rax` = 8;
- `rdx` = 0x2;
- `rcx` = 0x37 (ascii '7');
- `rbp-4` = 0x02;
- `rbp-8` = 0x08;

 **4-я итерация:**

```
rax            0x9                 0x9  
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x38                0x38  
rdx            0x3                 0x3  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb20      0x7fffffffdb20  
rsp            0x7fffffffdb20      0x7fffffffdb20  
r8             0x555555555500      0x555555555500

rbp-4          0x03
rbp-8          0x09
```

- `rax` = 9;
- `rdx` = 0x3;
- `rcx` = 0x38 (ascii '8')
- `rbp-4` = 0x03;
- `rbp-8` = 0x09;

По сути 5-ой итерации и нет, тут наш цикл завершается, но брейкпоинт срабатвает еще раз если запустим команду `next`. ПОсмотрим что происходит в 5-ом итерации:

 **5-я итерация:**

```
rax            0x555555558085      0x555555558085  
rbx            0x7fffffffdc88      0x7fffffffdc88  
rcx            0x39                0x39  
rdx            0x555555558085      0x555555558085  
rsi            0x7fffffffdc88      0x7fffffffdc88  
rdi            0x7fffffffe066      0x7fffffffe066  
rbp            0x7fffffffdb70      0x7fffffffdb70  
rsp            0x7fffffffdb30      0x7fffffffdb30  
r8             0x555555555500      0x555555555500

rbp-4          0x00
rbp-8          0x00
```

- `rcx` = 0x39 (ascii '9')

в 5-ом итерации всё обнуляется, цикл завершается, только последняя значение записывается в rcx.

Мы приши к выводу что:

- `rax` - Текущий символ PIN-кода;
- `rdx` - Индекс цикла;
- `rcx` - hex-код текущего символа;
- `rbp-4` - Индекс цикла;
- `rbp-8` - Текущий символ PIN-кода;

На входе у нас `1234`, а на выходе (после выполнения операции внутри цикла) `6789`, то есть на это означает что чила сдвигаются на 5.

```
0 - 5
1 - 6
2 - 7
3 - 8
4 - 9
5 - 0
6 - 1
7 - 2
8 - 3
9 - 4
```

Возможно вам следует запустить программу несколько раз с разными параметрами и анализировать дамп памяти вместе с регистрами чтобы понять логику работы программы. Главное внимательно следите какие регистры, и как используются, какие участки памяти резервируется и что в нем хранится во вреия выполнения программы, анализируйте всё делая выводы.

### Небольшой разбор кода 

Сделаем небольшую разборку кода чтобы улучшить знания

```
0x00005555555553ba <+58>:    mov    rax,QWORD PTR [rbp-0x40]
0x00005555555553be <+62>:    add    rax,0x8
0x00005555555553c2 <+66>:    mov    rax,QWORD PTR [rax]
0x00005555555553c5 <+69>:    mov    rdi,rax
0x00005555555553c8 <+72>:    call   0x55555555238 <decode_pin>
```

**Контекст**

- **rbp** (Base Pointer): Это регистр, который обычно используется как базовый указатель стека. Он указывает на начало текущего фрейма стека.
- **rax**: Это регистр общего назначения, часто используется для хранения промежуточных значений.
- **rdi**: Этот регистр часто используется для передачи первого аргумента функции согласно соглашению о вызове x86_64 System V ABI.

**Разбор команд**

1. **mov rax, QWORD PTR [rbp-0x40]**
    
    - Команда загружает 8-байтовое значение (QWORD) из памяти по адресу `[rbp-0x40]` в регистр `rax`. Это значение, вероятно, указатель.

1. **add rax, 0x8**
    
    - Команда увеличивает значение в регистре `rax` на 8. Это указывает на то, что мы перемещаем указатель на 8 байтов вперёд.

1. **mov rax, QWORD PTR [rax]**
    
    - Команда загружает 8-байтовое значение из памяти по адресу, который сейчас находится в регистре `rax`, и сохраняет его в `rax`. Это значение, вероятно, другой указатель.

1. **mov rdi, rax**
    
    - Команда копирует значение из регистра `rax` в `rdi`. Это значение теперь будет передано как первый аргумент функции `decode_pin`.

1. **call 0x55555555238 <decode_pin>**
    
    - Команда вызывает функцию `decode_pin` по адресу `0x55555555238`. Значение в регистре `rdi` будет использоваться как первый аргумент функции.

### Итоговое описание

Этот фрагмент кода выполняет следующие действия:

1. Загружает значение из памяти по адресу `[rbp-0x40]` в регистр `rax`.
2. Смещает это значение на 8 байтов вперёд.
3. Загружает значение из памяти по новому адресу в регистр `rax`.
4. Копирует это значение в регистр `rdi`.
5. Вызывает функцию `decode_pin` с аргументом, переданным в `rdi`.

# Способ третий: Cutter

<h1 align="center">
AnanasCharles's Authorize by PIN
</h1>
![[image1.png]]


<h3 align="center">
Done by bang1338
</h3>

- crackmes.one ID: [`6617d3a5cddae72ae250c556`](https://crackmes.one/crackme/6617d3a5cddae72ae250c556)

## Challenge
- Enter your pin with this command: `./authorize [pin]` (no `sudo` required).
- Press enter. If correct, it should show the flag.

## Rulez
- No patching, of course
- No brute force?

## Detection

![[image2.png]]

> [!NOTE]
> This is for Linux 64-bit.

## Walkthrough

I will using Binary Ninja Pro for this.

> [!NOTE]
> Binary Ninja Free exist. I'm using pirated version.

> [!IMPORTANT]
> Please, I beg you!
> Do not pirate Binary Ninja Pro, Free version does the same!
> If you want Pro version, buy it! It cheaper (even more!) and better than IDA Pro.

Fire up Binary Ninja, drag n' drop `authorize`

![[image3.png]]

> [!TIP]
> Set it to "Pseudo C" for easier looking, if you know C

#### It Was Fine Until...

Let's go to `main`

![[image4.png]]

Very interesting, we have `decode_pin`, comparing with `8446`.

Let's try `8446`.

![[image5.png]]

Ой, это неправильно. Что случилось?

#### Why It Doesn't Work?

Это очень просто:


![[image6.png]]

But the problem is... what does `decode_pin` do?

![[image7.png]]

erm... I don't understand.

#### lazy way to understand is DEBUG!

 Вернитесь к главному, установите точку останова на decode_pin(argv[1]), нажав клавишу F2

![[image8.png]]

Перейдите в раздел "отладка", установите для аргумента командной строки значение 1234, затем 5678 и 7890.

![[image9.png]]

Accept and run a debugger.

![[image10.png]]

If you see this message:

![[image11.png]]

Просто нажмите "Да".

Мы должны быть здесь:

![[image12.png]]

Просто продолжите, нажав клавишу F9.

Добро пожаловать в нашу программу!

![[image13.png]]

Мы увидим rdi (скретч-регистр. Аргумент функции #1 в 64-разрядной версии Linux)

Перед нажатием клавиши F7 (шаг) возьмите ручку и бумагу.

Теперь нажимаем клавишу F7, пока не перейдем к адресу 00005555555555280

![[image14.png]]

Запишите подсказку из ecx или cl

Через некоторое время мы получили это:

![[image15.jpg]]

```
+=========+===+===+===+===+===+===+===+===+===+===+
|  Input  | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 |
+---------+---+---+---+---+---+---+---+---+---+---+
| Decoded | 6 | 7 | 8 | 9 | 0 | 1 | 2 | 3 | 4 | 5 |
+=========+===+===+===+===+===+===+===+===+===+===+
```

So, now we know how `decode_pin` work.

#### decode_pin, revealed
Just `i + 5`. If `i + 5 == 10`, we restart to `0`.

#### Getting Solution
Across to our table, we did this:

```
8 -> 3
4 -> 9
4 -> 9
6 -> 1
```

The pin is `3991`.

## Trying solution

Let's try `3991`
`./authorize 3991`

![[image16.png]]

It work! The flag is `JCTF{3nC0D1nG_15_FuN}`


```c
#include <stdio.h>

char transform(char inp)
{
  char one = inp - 53;
  if (one < 0)
  {
    one = inp - 43;
  }

  return one + 48;

}

int main() {
  char eight = '8';
  char four = '4';
  char six = '6';

  char pin[] = {'8', '4', '4', '6'};
  char pin_decoded[] = {'=', '9', '9', '1'};
  char inp = '9';

  for (int i = 0; i < 4; i++)
  {
    pin_decoded[i] = transform(pin_decoded[i]);
  }
   
  printf("need: %d %d %d %d\n", eight, four, four, six);
  printf("got: %d %d %d %d", pin_decoded[0], pin_decoded[1], pin_decoded[2], pin_decoded[3]);

  return 0;
}
```

## Some (final) note
- This crackme is easy for anyone who used Linux with Binary Ninja (or other debugger like `gdb`).
- Unprotected, yes.

## Credit
- Elvis, for cheering :hugs:
- xusheng (Binary Ninja dev), suggesting <3

## Tools used
- [Detect it Easy](github.com/horsicq/Detect-It-Easy)
- [Binary Ninja](binary.ninja)

## Bonus

![[img-bonus.png]]
