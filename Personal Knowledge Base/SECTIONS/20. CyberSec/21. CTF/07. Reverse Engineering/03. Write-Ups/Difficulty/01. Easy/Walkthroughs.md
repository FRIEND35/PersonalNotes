

# Golfer

**Плошадка:**  https://www.hackthebox.com/
**Уровень:** Easy

![[Pasted image 20240812141624.png]]

Когда вы пытаетесь его запустить, он действительно ничего не печатает. Если вы посмотрите на уровень кода ASM, там тоже мало что происходит.

![[Pasted image 20240812141644.png]]

Проанализируйте его с помощью радара2, и вы увидите большой скачок от первой строки до 0x08000127, пропуская множество функций.

Нам нужно изменить ASM, чтобы он не пропускал функцию. Это простое решение — изменить строку, определяющую функцию jmp.

Обратите внимание, что мы начинаем с адреса 0x0800004c и будем изменять этот конкретный адрес.

![[Pasted image 20240812141715.png]]

Фрагмент показывает, что мы открываем файл в режиме записи и перезаписываем инструкцию на «nop». nop по сути означает ничего не делать. Поэтому вместо того, чтобы переходить к другой функции, ничего не делайте.

Мой друг спросил, почему нам нужно использовать nop вместо удаления функции?:

![[Pasted image 20240812141730.png]]

Еще раз проверьте, правильно ли изменен «pd1», затем выйдите, введя «q». И запустите файл еще раз.

![[Pasted image 20240812141742.png]]

Вуаля, флаг.


---

# Kawaii Flesh

**Платформа:** https://crackmes.one
**Тип файла**: elf
**Уровень:** Easy

![[Pasted image 20240329155212.png]]

Это легкий вызов. Все, что нам нужно, это найти ключ и пасхалку. Загрузите этот файл, так как это исполняемый файл ELF. Я буду использовать Linux и замечательную утилиту, которая поможет нам решить эту проблему.

При попытке запустить программу с помощью утилиты **ltrace** мы можем четко видеть MD5, с которым сравнивается ввод пользователя.

![[Pasted image 20240329155251.png]]

> bd4c217637bc828982c090b2de41b84d

![[Pasted image 20240329155322.png]]

При попытке расшифровать этот хэш на сайте Md5 Decryptor. Нам предоставлен пароль.

![[Pasted image 20240329155334.png]]

---

# Bypass



![[Pasted image 20221228100406.png]]

**Платформа:** https://www.hackthebox.com/
**Тип файла**: exe
**Уровень:** Easy

https://www.security-hive.com/post/3-reversing-challenges

Вторая задача немного посложнее. После загрузки исполняемого файла с именем (bypass.exe) мы должны дать ему соответствующие разрешения для запуска, набрав –

```
chmod + x bypass.exe
```

при запуске исполняемого файла нам нужно вставить имя пользователя + пароль и, надеюсь, получить ключ. Но на этот раз strings.exe не будет нашим спасителем, а будет лишь первым шагом к решению этой проблемы —

```
GuidAttribute
AttributeUsageAttribute
ComVisibleAttribute
AssemblyTitleAttribute
AssemblyTrademarkAttribute
TargetFrameworkAttribute
AssemblyFileVersionAttribute
AssemblyConfigurationAttribute
AssemblyDescriptionAttribute
CompilationRelaxationsAttribute
AssemblyProductAttribute
AssemblyCopyrightAttribute
AssemblyCompanyAttribute
RuntimeCompatibilityAttribute
ReadSByte
HTBChallange.exe
```


Мы можем найти дополнительную информацию об исполняемом файле, например, о библиотеках, которые он использует, но все равно не можем получить ключ. Теперь, после того, как мы поняли, что этот исполняемый файл нужно анализировать динамически, мы отправим его в прекрасный Отладчик иммунитета ( https://www.immunityinc.com/products/debugger/ ) —

Откройте Bypass.exe в отладчике и убедитесь, что файл запущен, затем вставьте несколько строк во входные данные:

![[Pasted image 20221228100640.png]]

![[Pasted image 20221228100651.png]]

Затем найдите адрес, по которому вы написали строку, и следуйте дампу. Затем мы можем исследовать его и искать то, что мы можем найти —

![[Pasted image 20221228100712.png]]

В дампе найдем вывод HTB{SuP3rC00lFL4g} —

![[Pasted image 20221228100737.png]]

**Решение №2**

Bypass — это простая реверсивная задача на hackthebox.eu. Эта задача была выполнена на компьютере с Windows и использовала
следующие инструменты.

 - strings
 - dnSpy

Изменение значений во время выполнения — хороший навык. Знание того, как использовать точки останова, — еще лучший навык.
Базовое перечисление Мы скачали заархивированный файл с HTB и разархивировали его, в результате у нас появился один исполняемый файл с именем Bypass. 

Когда мы запустили исполняемый файл, мы, похоже, получили запрос на ввод имени пользователя и пароля в цикле.

![[Pasted image 20221228101641.png]]

Запуск строк в исполняемом файле обычно позволяет нам увидеть, сжат/упакован ли исполняемый файл каким-либо образом, поэтому мы запустили его. Строки также позволяют нам увидеть, какие буквенно-цифровые комбинации существуют в исполняемом файле, это дает нам некоторую информацию о содержании предварительно скомпилированного кода.

![[Pasted image 20221228101716.png]]

В последней паре строк строк мы видим интересный вывод. Одна из последних строк, кажется, предоставляет информацию о том, на каком языке была написана предварительно скомпилированная кодовая база.

![[Pasted image 20221228101752.png]]

Как вы могли догадаться из вывода строк, показанных на рис. 3, кодовая база была написана на .NET и, следовательно, на C#. Это
стало актуальным, когда мы попытались использовать исполняемый файл.

**Эксплуатация**

После некоторого времени попыток реверсировать исполняемый файл в Radare2 мы поняли, что ничего не добились. Некоторые исследования по реверсированию двоичных файлов .NET привели нас к инструменту под названием dnSpy. dnSpy позволяет декомпилировать код .NET и устанавливать точки останова во время выполнения так же, как Radare2.

Поиграв с dnSpy и убедившись, что мы используем правильную версию (32-битную, а не 64-битную), нам удалось начать делать некоторые когерентный смысл из бинарного.

![[Pasted image 20221228102701.png]]

Программа, похоже, имела набор функций, которые проверяли ввод пользователя по вторичному набору значений.

Глядя на логические значения flag и flag2, мы увидели, что они равны друг другу, а поскольку flag был равен выходу функции 1(), мы знали, что flag2 тоже будет равен. Посмотрев на функцию 1(), мы поняли, что именно здесь нам предлагали ввести имя пользователя и пароль, но была хитрость, функция всегда возвращала false. Поскольку функция 1() всегда возвращала false, мы никогда не могли добраться до строки 13 в функции 0() и поэтому никогда не могли перейти к вторичной проверке (которую мы обсудим позже). 

Наше решение этой проблемы состояло в том, чтобы изменить значение flag2 на лету, поэтому мы установили точку останова перед выполнением проверки if и изменили значение flag2. Точка останова показана красной точкой на рисунке 4.

![[Pasted image 20221228103734.png]]

С установленной точкой останова мы запустили программу и ввели значения имени пользователя и пароля.

Как вы можете видеть на рисунке 5, как только мы достигли точки останова, мы увидели то, что и ожидали: флаг и флаг2 были равны false. После изменения значения flag2 на true нам удалось передать оператор if и запустить функцию 2() (как показано в строке 13 на рис. 4).

![[Pasted image 20221228104221.png]]

В функции 2() нам было предложено ввести секретный ключ (строки 36-37 на рис. 6), и этот секретный ключ был сравнен с определенным значением. Если секретный ключ был равен заданному значению, то во флаге сохранялась истина, если нет, во флаге сохранялась ложь.

Отбросив предположение, что нам нужно найти значение, которое будет хранить true во флаге, мы приступили к работе. 

Благодаря нашей надежной точке останова в строке 39 мы увидели, что значение, с которым мы сравнивали наши входные данные, было «ThisIsAReallyReallySecureKeyButYouCanReadItFromSourceSoItSucks» (рис. 6).

![[Pasted image 20221228104641.png]]

Как только мы снова запустили исполняемый файл и ввели правильный ключ, мы получили флаг для HTB!

Успех! 

Если эта запись помогла вам, пожалуйста, не стесняйтесь зайти в мой профиль HTB и выразить мне уважение :))

---

# Behind the Scenes

Платформа: https://www.hackthebox.com/
**Уровень:** Easy

После долгих попыток защитить наши секретные строки мы, наконец, нашли решение нашей проблемы: усложнить декомпиляцию. Теперь должно быть невозможно понять, как работают наши программы! За кулисами — очень простая задача обратного проектирования.

Начните со скачивания файла `Behind the Scenes.zip`из испытания HackTheBox в вашу гостевую систему Kali Linux. Первое, что мы делаем, это запускаем код и смотрим, что происходит.

```
┌──(imuijtjens㉿kali)-[~/Downloads]
└─$ ./behindthescenes                  
./challenge <password>
```

Мы можем определить, что он ожидает от нас передачи аргумента пароля. Следующим шагом является проверка того, какую информацию `strings`показывает команда.

```
┌──(imuijtjens㉿kali)-[~/Downloads]
└─$ strings behindthescenes -d     
/lib64/ld-linux-x86-64.so.2
libc.so.6
strncmp
puts
__stack_chk_fail
printf
strlen
sigemptyset
memset
sigaction
__cxa_finalize
__libc_start_main
GLIBC_2.4
GLIBC_2.2.5
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
u+UH
[]A\A]A^A_
./challenge <password>
> HTB{%s}
:*3$"
```

Теперь мы узнали, что флаг должен быть `HTB{%s}`где значение для `%s`до сих пор неизвестно. Посмотрим, если `ltrace`дает нам больше информации. Возможно, мы можем использовать [ltrace](https://man7.org/linux/man-pages/man1/ltrace.1.html) , инструмент, который будет записывать вызовы библиотек, сделанные в исполняемом файле, чтобы увидеть, в каком контексте **strlen** и **strncmp .** используются библиотеки

```
┌──(imuijtjens㉿kali)-[~/Downloads]
└─$ ltrace ./behindthescenes
--- SIGILL (Illegal instruction) ---
--- SIGILL (Illegal instruction) ---
./challenge <password>
--- SIGILL (Illegal instruction) ---
+++ exited (status 1) +++
```

Мы получаем `SIGILL`, что является сигналом того, что программа пыталась выполнить недопустимую инструкцию. Интересно, что мы не можем извлекать библиотечные вызовы, как это `SIGILL (Illegal instruction)`вместо этого отображается. 

Я хотел бы увидеть программу в `hexeditor` чтобы раскрыть больше информации.


```
┌──(imuijtjens㉿kali)-[~/Downloads]
└─$ hexeditor behindthescenes
```

Ищем в шестнадцатеричном редакторе, нажимая CTRL + Вт и найдите текстовую строку `challenge`, аргумент, который мы нашли на первом шаге. Похоже, это раскрывает наш пароль и флаг HackTheBox.

```
00002000  01 00 02 00  2E 2F 63 68   61 6C 6C 65  6E 67 65 20       ...../challenge 
00002010  3C 70 61 73  73 77 6F 72   64 3E 00 49  74 7A 00 5F       <password>.Itz._
00002020  30 6E 00 4C  79 5F 00 55   44 32 00 3E  20 48 54 42       0n.Ly_.UD2.> HTB
00002030  7B 25 73 7D  0A 00 00 00   01 1B 03 3B  4C 00 00 00       {%s}.......;L...
```

Reveal Flag:

```
HTB{Itz_0nLy_UD2}
```


**Подробное решение** 

Прежде всего, давайте попробуем запустить исполняемый файл задачи.

![[Pasted image 20230222151206.png]]

Программа ожидает один аргумент с паролем. Аккуратный. Бег `strings`над исполняемым файлом ничего интересного не дали, поэтому давайте посмотрим на его внутренности с помощью Ghidra. 

Глядя на `main`функции, мы можем увидеть некоторые трюки с сигналами Unix в начале и бесконечный цикл с `invalidInstructionException();`в конце концов.


![[Pasted image 20240807234323.png]]

Декомпилируя функцию main(), мы видим `invalidInstructionException();` вызывается, давайте щелкнем по этому элементу, чтобы проверить соответствующий ассемблерный код.

![[Pasted image 20230222151219.png]]

Давайте воспользуемся Ghidra для декомпиляции и посмотрим на **инструкцию ud2**.

![[Pasted image 20240807234401.png]]

- После некоторого исследования я нашел этот [пост StackOverflow](https://stackoverflow.com/questions/18410344/program-received-signal-sigill-illegal-instruction) , в котором в основном описывалось, что SIGILL может быть вызван **инструкцией сборки ud2a** или **ud2** . **ud2** используется для генерации недопустимого кода операции, который обычно используется при тестировании программного обеспечения для целенаправленной генерации исключения.

- Ссылаясь на [Руководство разработчика программного обеспечения для архитектур Intel® 64 и IA-32, Vol. 2Б](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html) , `UD2`«генерирует исключение недопустимого кода операции. Эта инструкция предназначена для тестирования программного обеспечения, чтобы явно сгенерировать исключение недопустимого кода операции. Коды операций для этой инструкции зарезервированы для этой цели».  Ghidra прекращает дизассемблирование файла после первого появления `UD2`. Это имеет смысл, по умолчанию вся программа будет завершена из-за получения `SIGILL`Юникс сигнал. Однако после этой инструкции явно больше кода:

Интересно, мы можем увидеть `invalidInstructionException();`отвечает за **инструкцию сборки UD2** , и после этого ни одна сборка не разбиралась. Давайте выберем эти оставшиеся инструкции и `Right-click > Disassemble`для просмотра соответствующей сборки и декомпилированного кода.

Начнем с последнего. При выборе `invalidInstructionException();`инструкцию по декомпиляции, Ghidra выделяет следующую инструкцию по сборке:

```nasm
001012e6	0f 0b	UD2
```


![[Pasted image 20230222151246.png]]

Как мы видим, это действительно исполняемый код:

![[Pasted image 20230222151302.png]]

Теперь мы можем увидеть оставшийся ассемблерный код. Первая интересная функция, которую мы видим вызываемой, — это **strlen** , следующая строка ассемблера использует инструкцию CMP с регистром RAX и шестнадцатеричным 0xC. Мы можем предположить, что длина пароля будет сравниваться с шестнадцатеричным значением 0xC или 12.

Прокрутив дальше, мы теперь можем **увидеть strncmp в действии.** несколько раз

![[Pasted image 20240807235138.png]]

**strncmp** используется для сравнения первых n байтов строки. Я ясно вижу строку открытого текста, с которой начинается наш пароль: `Itz` , повторяя этот процесс для следующих 4 **вызовов библиотеки strncmp** , мы медленно создаем наш окончательный пароль, который будет `Itz******UD2`. 

>Примечание. Я скрыл содержимое средних 6 символов, чтобы не испортить флаг.

**Способ №2**

Заменим все вхождения `UD2`инструкция с `NOP`(их несколько десятков разбросано по `main`функция). После этого мы сразу видим, что их 4. `strcmp` s сравнение пользовательского ввода со строковыми константами. И флаг кажется конкатенацией этих констант:

![[Pasted image 20230222151339.png]]

Введя объединенное значение в программу, мы можем убедиться, что это правильный флаг. Легко, да?

![[Pasted image 20230222151403.png]]

**Но как это работает?

Хороший вопрос, давайте разберемся.

Как я упоминал ранее, операционная система посылает `SIGILL`сигнал программе, пытающейся выполнить недопустимую инструкцию. Но можем ли мы пропустить недопустимую инструкцию и продолжить выполнение? Ответ положительный, и это то, что делает программа, регистрируя собственный обработчик сигнала.

**Установка обработчика сигналов

Взглянем на декомпилированный фрагмент файла `main` снова:

![[Pasted image 20230222151557.png]]

Давайте разберем это:

-   Строка 6, свойство типа [`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html)определено. Для удобства я переименовал его в `sa`;
-   Строка 10, `sa`заполняется нулями, чтобы очистить выделенную память. Мы можем сделать обоснованное предположение, что изначально это выглядело как `memset(&sa, 0, sizeof(struct sigaction))`, но компилятор смог заменить `sizeof`вызов с постоянным значением;
-   Строка 11, `sa.sa_mask`уточняется по телефону [`sigemptyset`](https://pubs.opengroup.org/onlinepubs/7908799/xsh/sigemptyset.html)функция;
-   Строка 12, указатель на локальную функцию обработчика сигналов. `segill_sigaction`назначен на `sa.sa_sigaction`(названный Гидрой как `sa.__sigaction_handler`);
-   Строка 13, значение `SA_SIGINFO`флаг присваивается `sa.sa_flags`( `#define SA_SIGINFO 0x00000004`в [`signal.h`](https://sites.uclouvain.be/SystInfo/usr/include/asm-generic/signal.h.html));
-   Линия 14, построенная `sa`структура назначена в качестве обработчика для `SIGILL`сигнал ( `#define SIGILL 4`в [`signal.h`](https://sites.uclouvain.be/SystInfo/usr/include/asm-generic/signal.h.html)), позвонив в [`sigaction`](https://man7.org/linux/man-pages/man2/sigaction.2.html)функция (да, структура и функция называются одинаково).

**Обработка полученного сигнала

Следующим элементом головоломки является функция обработчика сигнала. `segill_sigaction`в нашем случае.  
Сигнатура функции-обработчика `void handler(int sig, siginfo_t *info, void *ucontext)`. Как [указано на странице sigaction(2)](https://man7.org/linux/man-pages/man2/sigaction.2.html) , эти три аргумента следующие:

-   **int sig** : номер сигнала, вызвавшего вызов обработчика;
-   **siginfo_t *info** : Указатель на `siginfo_t`, который представляет собой структуру, содержащую дополнительную информацию о сигнале;
-   **void *ucontext** : это указатель на `ucontext_t`структура, отлитая в `void *`. Структура, на которую указывает это поле, содержит информацию о контексте сигнала, которая была сохранена ядром в стеке пользовательского пространства.

Страница [sigaction(3p)](https://man7.org/linux/man-pages/man3/sigaction.3p.html) также указывает, что новые приложения должны явно приводить третий аргумент функции обработки сигнала к `ucontext_t *`.

Давайте перепишем 3-й параметр и посмотрим на декомпиляцию:

![[Pasted image 20230222151629.png]]

Прежде всего, давайте посмотрим на `ucontext_t`содержание структуры. Как [указано в Справочном руководстве по библиотеке GNU C](https://www.gnu.org/software/libc/manual/html_node/System-V-contexts.html) , оно должно включать как минимум следующие поля:

-   **ucontext_t *uc_link** : Это указатель на следующую структуру контекста, которая используется, если возвращается контекст, описанный в текущей структуре;
-   **sigset_t uc_sigmask** : набор сигналов, которые блокируются при использовании этого контекста;
-   **stack_t uc_stack** : Стек, используемый для этого контекста. Значение не обязательно должно быть (и обычно не является) указателем стека;
-   **mcontext_t uc_mcontext** : этот элемент содержит фактическое состояние процесса. `mcontext_t`type также определен в этом заголовке, но это определение следует рассматривать как непрозрачное. Любое использование знаний типа делает приложения менее переносимыми.

Ага, мы приближаемся. Давайте посмотрим на отрывок из [`glibc`исходники для архитектуры x86-64](https://code.woboq.org/gcc/include/sys/ucontext.h.html) , содержащие `mcontext_t`определение и некоторые из его вложенных типов данных:

```c
/* Context to describe the whole processor state.  */
typedef struct
{
    gregset_t __ctx(gregs);
    fpregset_t __ctx(fpregs);
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;

/* Container for all general registers.  */
typedef greg_t gregset_t[__NGREG];

/* Number of each register in the `gregset_t' array.  */
enum
{
  REG_R8 = 0,
# define REG_R8		REG_R8
  REG_R9,
# define REG_R9		REG_R9
  REG_R10,
# define REG_R10	REG_R10
  REG_R11,
# define REG_R11	REG_R11
  REG_R12,
# define REG_R12	REG_R12
  REG_R13,
# define REG_R13	REG_R13
  REG_R14,
# define REG_R14	REG_R14
  REG_R15,
# define REG_R15	REG_R15
  REG_RDI,
# define REG_RDI	REG_RDI
  REG_RSI,
# define REG_RSI	REG_RSI
  REG_RBP,
# define REG_RBP	REG_RBP
  REG_RBX,
# define REG_RBX	REG_RBX
  REG_RDX,
# define REG_RDX	REG_RDX
  REG_RAX,
# define REG_RAX	REG_RAX
  REG_RCX,
# define REG_RCX	REG_RCX
  REG_RSP,
# define REG_RSP	REG_RSP
  REG_RIP,
# define REG_RIP	REG_RIP
  REG_EFL,
# define REG_EFL	REG_EFL
  REG_CSGSFS,
# define REG_CSGSFS	REG_CSGSFS
  REG_ERR,
# define REG_ERR	REG_ERR
  REG_TRAPNO,
# define REG_TRAPNO	REG_TRAPNO
  REG_OLDMASK,
# define REG_OLDMASK	REG_OLDMASK
  REG_CR2
# define REG_CR2	REG_CR2
};
```

Как видим, поле `gregs`содержит все сохраненные регистры ЦП.

Теперь давайте вернемся к [sigaction(3p)](https://man7.org/linux/man-pages/man3/sigaction.3p.html) , в котором говорится, что «когда обработчик сигнала возвращается, принимающий поток возобновляет выполнение с того места, где он был прерван, если только обработчик сигнала не предпримет другие меры». В нашем случае мы намеренно хотим возобновить выполнение после пропуска недопустимой инструкции. Поскольку `UD2`операция имеет длину 2 байта, мы можем добиться этого, увеличив `RIP`зарегистрироваться до 2.

В C это будет выглядеть так:

```c
ucontext->uc_mcontext.gregs[REG_RIP] += 2;
```

> Важное примечание: это решение довольно хакерское и привязано к работе строго на x86-64 POSIX-совместимых системах. Не делайте этого ни в каком производственном коде.  
> Единственное возможное исключение, если вы намеренно пытаетесь сделать какую-то причудливую обфускацию, это может быть одним из ваших инструментов — поскольку у вас есть доступ ко всему сохраненному контексту, вы можете изменить значения регистров общего назначения, перейти к другому. адрес, изменив указатель инструкции, и сделать еще одну странную вещь (:

Сравните это с тем, что декомпилировал Гидра. Выглядит очень похоже, не так ли? :)

Единственная разница в том, что Ghidra не смогла вычислить имя регистра и просто предоставила его индекс в массиве, `0x10`. Мы можем вручную проверить, что это правильный индекс `REG_RIP`. В качестве альтернативы мы можем распечатать индекс `REG_RIP`запустив этот фрагмент кода, который, в свою очередь, выводит `0x10`:

```c
#define __USE_GNU
#define _GNU_SOURCE
#include <stddef.h>
#include <stdio.h>
#include <ucontext.h>

void main() {
    printf("0x%x\n", REG_RIP);
}
```

Другой способ сделать это - найти смещение во всем `ucontext_t`состав. Представьте, что у нас есть только ассемблерный листинг функции, который выглядит так:

![[Pasted image 20230222151653.png]]

После некоторой перетасовки аргументов адрес `ucontext`сохраняется в `local_ucontext`переменная. Его значение по смещению `0xa8`загружается в `RAX`, увеличивается на 2 и записывается обратно в структуру.

Для справки, декомпиляция функции выглядит так:

![[Pasted image 20230222151714.png]]

Делая обоснованное предположение, мы предполагаем, что функция увеличивает `RIP`регистр. Мы можем найти его смещение в структуре, выполнив следующий фрагмент кода:

```c
#define __USE_GNU
#define _GNU_SOURCE
#include <stddef.h>
#include <stdio.h>
#include <ucontext.h>

void main() {
   size_t rip_offset = offsetof(ucontext_t, uc_mcontext.gregs[REG_RIP]);
   printf("0x%x\n", rip_offset);
}
```

Он печатает `0xa8`, что соответствует смещению как в листинге сборки, так и в декомпиляции.

**Объединяя все это вместе мы получаем:**

Теперь давайте объединим все части головоломки вместе. Вот простая программа, которая концептуально работает так же, как и бинарная задача:

```c
#include <stdio.h>
#define __USE_GNU
#include <signal.h>
#include <string.h>

void sighandler (int signo, siginfo_t *info, void *context) {
    ucontext_t *uc = (ucontext_t *)context;

    int instruction_length = 2; // The length of the "instruction" to skip

    uc->uc_mcontext.gregs[REG_RIP] += instruction_length;
}

void main() {
	struct sigaction sa;
	memset(&sa, 0, sizeof(struct sigaction));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_SIGINFO;
	sa.sa_sigaction = sighandler;
	sigaction(SIGILL, &sa, NULL);

	printf("%s", "Reachable\n");

	asm("ud2"); // Adding an illegal opcode

	printf("%s", "Unreachable\n");
}
```

В целом полученный код очень похож на [принятый ответ на этот вопрос на Stack Overflow](https://stackoverflow.com/questions/9314755/in-a-sigill-handler-how-can-i-skip-the-offending-instruction) .

После компиляции и выполнения выдает следующее:

![[Pasted image 20230222151737.png]]


**Сравнение двоичных файлов

В заключение сравним декомпиляцию нашего воссозданного бинарника (слева, скомпилированного с `gcc (GCC) 12.1.0`) и один из задачи (справа):

![[Pasted image 20230222151757.png]]


![[Pasted image 20230222151803.png]]

Удивительно, насколько они похожи, и насколько близка декомпиляция к исходному коду!

Это все на сегодня. Спасибо за чтение и удачного взлома!

---

# Baby

**Плошадка:**  https://www.hackthebox.com/
**Уровень:** Easy

![[Pasted image 20221228100239.png]]

**Тип файла**: exe
**Уровень**: легкий

Это первое испытание в этой серии, и оно очень простое. После загрузки исполняемого файла с именем (baby.exe) мы должны дать ему соответствующие разрешения для запуска, набрав:

```
chmod +х baby
```
 
Затем запуск исполняемого файла выведет этот вывод на терминал —

```
┌──(root�
 �kali)-[/home/bull/Desktop/Reversing Chellenges]
└─# ./baby
Insert key:
asdasd
Try again later.
```

Теперь, когда исполняемый файл запрашивает «секретный пароль», мы можем найти его внутри самого кода, и иногда нам даже не потребуется использовать декомпилятор. Чтобы решить эту проблему, нам нужен только файл strings.exe, который является частью
SysInternals и позволяет нам сканировать файл, через который мы проходим, чтобы преобразовать в строки UNICODE длину по умолчанию из 3 или более символов UNICODE.

```
┌──(root�
 �kali)-[/home/bull/Desktop/Reversing Chellenges]
└─# strings baby
/lib64/ld-linux-x86-64.so.2
mgUa
libc.so.6
puts
stdin
fgets
__cxa_finalize
strcmp
__libc_start_main
GLIBC_2.2.5
_ITM_deregisterTMCloneTable
__gmon_start__
_ITM_registerTMCloneTable
u/UH
HTB{B4BYH
_R3V_TH4H
TS_Ef
[]A\A]A^A_
Dont run `strings` on this challenge, that is not the way!!!!
Insert key:
abcde122313
Try again later.
;*3$"
GCC: (Debian 9.2.1-8) 9.2.1 20190909
crtstuff.c
deregister_tm_clones
```

Внутри строк мы можем найти соответствующий ключ «abcde122313». Не запутайтесь с ключом HackTheBox, представленным в выводе. Мы получаем правильный ключ после ввода правильного исполняемого ключа —

```
┌──(root�
 �kali)-[/home/bull/Desktop/Reversing└─# ./baby
Insert key:
abcde122313
HTB{B4BY_R3V_TH4TS_EZ}
```

---

# ELF - 0 protection

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Решим первое задание для примера. Его название "ELF - 0 protection", в названии мы видим указание на формат файла (ELF - формат исполняемого файла под Linux)

Ссылка на задание: https://www.root-me.org/en/Challenges/Cracking/ELF-0-protection

Скачиваем файл задания. Получаем архив, в котором находится исполняемый файл.

Достаём исполняемый файл и открываем его с помощью IDA Pro (на канале был пост про базовое пользование IDA - https://t.me/hacker_sanctuary/45) Т.к. файл 32битный, нам потребуется 32-битная IDA.

После запуска IDA сразу же попробуем получить декомпилированный код функции main()

![[Pasted image 20230113155652.png]]

Видим, что в строке 9 происходит вызов некоторой функции getString(), предположим, что она считывает строку с клавиатуры в переменную s1. Далее переменная s1 сравнивается с помощью функции strcmp() с константной (постоянной) строкой "123456789". Эта строка и есть пароль. 

---

# ELF - x86 Basic

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка: https://www.root-me.org/en/Challenges/Cracking/ELF-Basic

Это статически связанный двоичный файл, и он не удаляется. В этом задании я использовала веревочки и мы получили ответ :) Но мне предстоит долгий путь. Я открою бинарный файл с помощью Cutter. Затем переходим в раздел декомпилятора. Опять же, как я уже говорил в предыдущих блогах, мне нравится использовать Ghidra. jsdec иногда раздражает анализ.

![[Pasted image 20240402025008.png]]

Давайте проанализируем код. Мы принимаем первый вход в iVar1, а затем происходит сравнение строк. Затем внутри условия «if» мы получаем второй ввод пользователя и сохраняем его в uVar3. Второй strcmp ясен. Он сравнивает uVar3 с «риппером» и сохраняет результат strcmp в iVar1. Но в первом strcmp отсутствует один параметр.

Нет сомнений в том, что в качестве второго параметра он принимает arg_ch. Но **действительно** ли это ? Итак, я попробовал использовать декомпилятор jdsec. Вы можете выбрать тип декомпилятора в Cutter, изменив опцию в правом нижнем углу.

![[Pasted image 20240402025024.png]]

Здесь использован второй параметр! Я попробовал это в GDB, и да, он использовал второй параметр :( На этот раз декомпилятор Ghidra меня подвел. Но в любом случае мы пытаемся ввести «Джон» и «Потрошитель» в качестве пользовательского ввода.

![[Pasted image 20240402025047.png]]

**Решение с п.м. IDA:**

Проводим аналогичные действия и получаем следующих декомпилированный код.

![[Pasted image 20230113155923.png]]

Теперь сравнений 2, а также мы не видим верный пароль (из-за некоторых особенностей декомпилятора). Можем перейти в ассемблерный вид и увидеть пароль.

![[Pasted image 20230113155942.png]]

Происходит передача двух аргументов в функцию printf() один из аргументов - пароль, а второй - строка, которую мы видим в декомпилированном виде. 

Ещё один вариант - это запустить исполняемый файл и ввести верные данные.

![[Pasted image 20230113160005.png]]

Получаем верный пароль: 987654321.

---

# Отладка и права доступа к файлам

**Плошадка:** https://tryhackme.com/
**Уровень:** Easy

Быстрый отказ от ответственности: я очень новичок в реверс-инжиниринге, и мой опыт работы с Radare2 заключался в выполнении задач [22](https://tryhackme.com/room/adventofcyber2) и [23]() AdventOfCyber2, поэтому я просто счастлив, что завершил комнату ;)~

Согласно обсуждению в задаче 1 , мы будем использовать Radare2 и предоставленный блок атаки. Если вы подписываетесь на TryHackMe, у вас есть доступ к блоку атак, к которому можно получить доступ через ваш браузер, подключенный к Интернету и внутренней среде обучения сети TryHackMe. Для меня это стоит подписки … Я могу делать комнаты с моего iPad! 

Хорошо… продолжайте с комнатой.

В следующих задачах комната предоставляет «Загрузить файлы задач», которые необходимо реконструировать. Для простоты использования я загружаю их все в свою



# ELF MIPS

**Плошадка:** https://root-me.org/
**Уровень:** Easy

Скачиваем и проверяем файл.

![[Pasted image 20240402012146.png]]

Это 32-x битный исполняемый файл для процессоров архитектуры MIPS. Для решения этого задания будем использовать Ghidra. Открываем гидру, создаем новый проект и добавляем в наш исполняемый файл.

Итак, перед нами обычный ELF, но он собран под MIPS. Можно, конечно, посидеть в дизассемблере и проанализировать MIPS код, разобрать что происходит, а можно упростить себе задачу и заодно попробовать новый инструмент от АНБ - дизассмеблер вместе с декомпилятором GHIDRA.

Вы можете использовать IDA или Ghidra на ваше усмотрение.

![[Pasted image 20240402012258.png]]


Теперь открываем исследуемый файл, и перемещаемся в окно Symbol Tree. В поиске набираем main, чтобы найти точку входа программы.

![[Pasted image 20240402012315.png]]

При выборе функции, она сразу открывается в декомпиляторе.

![[Pasted image 20240402012332.png]]

Давайте преобразуем код.

![[Pasted image 20240402012715.png]]

Видим, что в переменную local_54 считывается 64 байта, давайте переименнуем ее в input (hotkey L) и сделаем из нее char массив длинной 64 символа (hotkey Ctrl+L). Также можно переименовать переменную sVar1.

![[Pasted image 20240402012836.png]]

![[Pasted image 20240402012843.png]]

После некоторого преобразования, код стал выглядеть чуть красивее.

![[Pasted image 20240402012626.png]]

![[Pasted image 20240402012904.png]]

Перейдём в основную функцию и сразу увидим достаточной хороший вывод декомпилятора. Немного приблизим всё это дело, а также преобразуем некоторые переменные.

![[Pasted image 20240402013004.png]]

Анализируем код. Вводимая нами строка должна состоять из 19 символов. На какой позиции какой символ должен быть понятно из кода. При этом с 8-ой по 17-ю должен быть символ ‘i’. Восстанавливаем, сдаем пароль.

Код достаточно простой, есть сравнения с константами, а также сравнение внутри цикла символов пароля с 8 по 16.

Достаточно просто можно восстановить исходный пароль он будет таким "cantrunmiiiiiiiiips".


---
# Golang basic

**Плошадка:** https://root-me.org
**Уровень:** Easy

![[Pasted image 20240406154419.png]]

В данном задании нам предоставляют исполняемый файл написанный на языке Go. Можно даже выяснить какая версия. Я закидываю в IDA. Стоит сразу сказать, что основная функция не называется main, а называется main_main. Поэтому выполним поиск по функциям и перейдем на реальную основную.

![[Pasted image 20240406154430.png]]

Давайте разбирать код. Начнем с самого начала.

![[Pasted image 20240406154510.png]]

Присутствуют определения a, key, input. Левый блок отвечает за завершение функции main_main. Рассмотрим левый блок.

![[Pasted image 20240406154526.png]]

Функция fmt_Scanln предназначена для считывания строки из консоли. Также наблюдаем уже сохраненные в программе данные main_statictmp_2.

![[Pasted image 20240406154536.png]]

Далее вызывается функция runtime_stringtoslicebyte, по коду можно предположить, что она берет первые 6 байт со следующей строки.

![[Pasted image 20240406154546.png]]

На начало этого среза будет указывать key.ptr. Глянем что идет дальше.

![[Pasted image 20240406154608.png]]

Взависимости от сравнения обнуленного регистра r9 и регистра rsi, где расположена длина пользовательского ввода. Отсюда можно сделать вывод, что r9 будет скорее всего счетчиком. Давайте заглянем в правый блок, куда перейдет управление, после прохрода по введенной нами строке.

![[Pasted image 20240406154628.png]]

Вызывается функция bytes_Compare, которая взависимости от результата сравнения выводит одну из строк.

![[Pasted image 20240406154650.png]]

![[Pasted image 20240406154708.png]]

С выводом программы разобрались, теперь пойдем посмотрим на преодразования строк (по левой ветке).

![[Pasted image 20240406154726.png]]

В регистр r10 заносится символ из пользовательского ввода, а далее идет куча сложного кода для и сравнений для контроля исключений типа panic divide и panic index. Я подсветил ветку выполнения программы.

![[Pasted image 20240406154747.png]]

Таким образом, в EDX помещается байт из статически заданной строки и ксорится с r10, где находится байт из среза. Далее счетчик r9 увеличивается. Два средних смежных блока скорее всего нужны для контроля длины среза.

Совместим все воедино: введенная строка ксорится со срезом и сравнивается со статически заданной строкой. Давайте проксорим, чтобы узнать верный пароль.

![[Pasted image 20240406154802.png]]

Получаем ответ. Сложность реверса Go бинарников состоит в том, что там есть усложняющие факторы вроде отсутствия нулевого символа в конце строк, представление своих типов, сборщик мусора и т.п

---
# getting_started

**Плошадка:** https://crackmes.one
**Уровень:** Easy

**Описание:** Базовый взломать меня, используя базовую обфускацию. Идеально подходит для новичков.

Задача в действительности легкая. Закидываем файл в IDA и запускаем декомпилятор:

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int i; // [rsp+18h] [rbp-18h]
  int j; // [rsp+1Ch] [rbp-14h]
  _DWORD *v6; // [rsp+20h] [rbp-10h]
  char *s2; // [rsp+28h] [rbp-8h]

  v6 = malloc(0x18uLL);
  if ( argc <= 1 )
    goto LABEL_10;
  *v6 = 110;
  v6[1] = 96;
  v6[2] = 94;
  v6[3] = 109;
  v6[4] = 96;
  v6[5] = 111;
  for ( i = 0; i <= 4; ++i )
  {
    ++*v6;
    ++v6[1];
    ++v6[2];
    ++v6[3];
    ++v6[4];
    ++v6[5];
  }
  s2 = (char *)malloc(7uLL);
  for ( j = 0; j <= 6; ++j )
    s2[j] = v6[j];
  s2[6] = 0;
  if ( !strcmp(argv[1], s2) )
    puts("Welcome.");
  else
LABEL_10:
    puts("Denied.");
  return 0;
}
```

Нам интересно вот этот часть кода:

```c
 *v6 = 110;
  v6[1] = 96;
  v6[2] = 94;
  v6[3] = 109;
  v6[4] = 96;
  v6[5] = 111;
  for ( i = 0; i <= 4; ++i )
  {
    ++*v6;
    ++v6[1];
    ++v6[2];
    ++v6[3];
    ++v6[4];
    ++v6[5];
  }
```

IDA показывает нам символы в десятичном виде, для удобства можно перевести на шестнадцатеричный:

```c
 *v6 = 0x6E;
  v6[1] = 0x60;
  v6[2] = 0x5E;
  v6[3] = 0x6D;
  v6[4] = 0x60;
  v6[5] = 0x6F;
```

Тут особой разницы нет, кому как удобно. И что же у нас получается:

![[Pasted image 20240501030900.png]]

Нужно разобрать код:

```c
++*v6;
```

Это означает, что сначала разыменовывается указатель v6 (то есть получается значение, на которое указывает указатель), затем это значение инкрементируется на 1. Таким образом, значение, на которое указывает указатель v6, увеличивается на 1.

```c
++v6[5];
```

Это означает, что сначала разыменовывается указатель v6 (то есть получается значение, на которое указывает указатель), затем это значение инкрементируется на 1. Таким образом, значение, на которое указывает указатель v6, увеличивается на 1. И у нас как бы есть цикл. Всё что в блоке цикла, то и повторяется столько раз, сколько здано в цикле. Выходит у нас берутся байты, заполняются в массив из 6 элементов, затем в цикле 5 раз прибавляем к каждому элементу 1:

![[Pasted image 20240501031642.png]]

Получаем 73 - это s:

![[Pasted image 20240501031819.png]]

Дальше в таком же порядке к каждому байту. В итоге получаем ключ:

```
secret
```

![[Pasted image 20240501034658.png]]

---

# THM

**Плошадка:** https://tryhackme.com/
**Уровень:** Easy

Описание: Эта комната посвящена обучению основам сборки с помощью реверс-инжиниринга.

### crackme1

![[Pasted image 20230531082106.png]]

• hax0r

### crackme2

Я начал анализировать бинарник, введя

```
r2 -d crackme2.bin
aaa
pdf @main
```

![[Pasted image 20230531082202.png]]

Здесь в основной функции я должен ввести пароль, а с помощью функции «сканирования» ввод проверяется. Есть функция сравнения, которая сверяет переменную «var_ch» со значением «0x137c». Если локальная переменная равна этому значению, выводится «пароль действителен».

Теперь, чтобы узнать, какое значение мне нужно ввести, я скопировал его и использовал «rax2».

```
rax2 0x137c
```

![[Pasted image 20230531082346.png]]

- 4988

### crackme3

Начнем анализ с: 

![[Pasted image 20230531082428.png]]

Я установил точку останова, чтобы проверить сравнение. Для меня это было в 

> **db 0x555fafc0079b

Я запустил двоичный файл с «dc», чтобы ввести случайный ввод, например «123456789», и попал в точку останова. Здесь используется значение «var_28h», и я посмотрел на него с

>**px @rbp-0x28

![[Pasted image 20230531082606.png]]

Таким образом, похоже, что «азт» добавляется перед моим вводом и сравнивается с ним.

---
# Reverse Engineering

## Crackme1

**Плошадка:**
**Уровень:** Easy

При работе с двоичными файлами ELF я обычно всегда начинаю с запуска **ltrace** или **strace** .

Это позволяет мне видеть:

- логика и ход программы
- какие функции или системные вызовы используются
- любые скрытые строки или данные

В этом случае **вывод ltrace** показывает правильный пароль (отредактировано ниже):

```fallback
jason@lapras:/tmp$ ltrace ./crackme1.bin
puts("enter password"enter password
)                                                           = 15
\_\_isoc99\_scanf(0x7fd32ee008a3, 0x7ffffa955ef2, 0x7fd32e9ed8c0, 0x7ffff2161010hello
)   = 1
strcmp("hello", XXXXXX)                                                         = 4
puts("password is incorrect"password is incorrect
)                                                    = 22
+++ exited (status 0) +++
```

Запустите Crackme с правильным паролем, чтобы выиграть:

```fallback
jason@lapras:/tmp$ ./crackme1.bin
enter password
XXXXXX
password is correct
```

## Crackme2

Для второго испытания я снова запустил **ltrace** и **strace** , но пароль не был показан.

Итак, я открыл двоичный файл в **gdb** . Ниже приведен результат дизассемблирования функции main():

```fallback
jason@lapras:/tmp$ gdb -q crackme2.bin
Reading symbols from crackme2.bin...(no debugging symbols found)...done.
(gdb) disass main
Dump of assembler code for function main:
0x000000000000071a <+0>:     push   rbp
0x000000000000071b <+1>:     mov    rbp,rsp
0x000000000000071e <+4>:     sub    rsp,0x10
0x0000000000000722 <+8>:     mov    rax,QWORD PTR fs:0x28
0x000000000000072b <+17>:    mov    QWORD PTR \[rbp-0x8\],rax
0x000000000000072f <+21>:    xor    eax,eax
0x0000000000000731 <+23>:    lea    rdi,\[rip+0xec\]           # print "enter your password"
0x0000000000000738 <+30>:    call   0x5d0 <puts@plt>
0x000000000000073d <+35>:    lea    rax,\[rbp-0xc\]            # buffer for scanf to store our input
0x0000000000000741 <+39>:    mov    rsi,rax
0x0000000000000744 <+42>:    lea    rdi,\[rip+0xed\]           # "%d" format string for scanf
0x000000000000074b <+49>:    mov    eax,0x0
0x0000000000000750 <+54>:    call   0x5f0 <\_\_isoc99\_scanf@plt>
0x0000000000000755 <+59>:    mov    eax,DWORD PTR \[rbp-0xc\]  # our input stored here
0x0000000000000758 <+62>:    cmp    eax,0xXXXXX              # compare our input to the (redacted) value
0x000000000000075d <+67>:    jne    0x76d <main+83>          # branch if incorrect
0x000000000000075f <+69>:    lea    rdi,\[rip+0xd5\]           # print "password is valid"
0x0000000000000766 <+76>:    call   0x5d0 <puts@plt>
0x000000000000076b <+81>:    jmp    0x779 <main+95>          # branch if correct
0x000000000000076d <+83>:    lea    rdi,\[rip+0xd9\]           # print "password is incorrect"
0x0000000000000774 <+90>:    call   0x5d0 <puts@plt>
0x0000000000000779 <+95>:    mov    eax,0x0                  # return 0 for main
0x000000000000077e <+100>:   mov    rdx,QWORD PTR \[rbp-0x8\]
0x0000000000000782 <+104>:   xor    rdx,QWORD PTR fs:0x28
0x000000000000078b <+113>:   je     0x792 <main+120>
0x000000000000078d <+115>:   call   0x5e0 <\_\_stack\_chk\_fail@plt>
0x0000000000000792 <+120>:   leave
0x0000000000000793 <+121>:   ret
End of assembler dump.
(gdb)
```

Соответствующие инструкции по сборке я пометил комментариями. (Я почерпнул эту идею из одной из [статей](https://cplusperks.com/narnia/#level7) Криса Эванса ). Давайте разберем, что делает эта программа:

- прочитать целое число ("%d") от пользователя с помощью scanf
- сравнить значение пользователя с правильным паролем
- если равно, вывести «пароль действителен»
- иначе выведите «пароль неверный»

Поскольку правильный пароль жестко закодирован в шестнадцатеричном коде в строке <+62>, я использовал gdb для его вывода в десятичном виде (отредактировано ниже):

```fallback
(gdb) b \*main+62
Breakpoint 1 at 0x758
(gdb) r
Starting program: /tmp/crackme2.bin
enter your password
LET ME IN
Breakpoint 1, 0x0000000008000758 in main ()

(gdb) p 0xXXXXX
$1 = XXXX
```

Запустите программу с этим десятичным значением, чтобы выиграть:

```fallback
jason@lapras:/tmp$ ./crackme2.bin
enter your password
XXXXX
password is valid
```

---

## Crackme3

Финальный кракми был интересным и включал в себя зацикливание. Опять же, я запустил **gdb** , чтобы заглянуть под капот:

```fallback
jason@lapras:/tmp$ gdb -q crackme3.bin
Reading symbols from crackme3.bin...(no debugging symbols found)...done.
(gdb) disass main
Dump of assembler code for function main:
0x000000000000071a <+0>:     push   rbp
0x000000000000071b <+1>:     mov    rbp,rsp
0x000000000000071e <+4>:     sub    rsp,0x30
0x0000000000000722 <+8>:     mov    rax,QWORD PTR fs:0x28
0x000000000000072b <+17>:    mov    QWORD PTR \[rbp-0x8\],rax
0x000000000000072f <+21>:    xor    eax,eax
0x0000000000000731 <+23>:    mov    WORD PTR \[rbp-0x23\],0x7a61
0x0000000000000737 <+29>:    mov    BYTE PTR \[rbp-0x21\],0x74
0x000000000000073b <+33>:    lea    rdi,\[rip+0x112\]           # print "enter your password"
0x0000000000000742 <+40>:    call   0x5d0 <puts@plt>
0x0000000000000747 <+45>:    lea    rax,\[rbp-0x20\]            # buffer for scanf to store our input
0x000000000000074b <+49>:    mov    rsi,rax
0x000000000000074e <+52>:    lea    rdi,\[rip+0x113\]           # 0x868
0x0000000000000755 <+59>:    mov    eax,0x0
0x000000000000075a <+64>:    call   0x5f0 <\_\_isoc99\_scanf@plt>
0x000000000000075f <+69>:    mov    DWORD PTR \[rbp-0x28\],0x0  # loop counter initialized to 0
0x0000000000000766 <+76>:    jmp    0x797 <main+125>
0x0000000000000768 <+78>:    mov    eax,DWORD PTR \[rbp-0x28\]
0x000000000000076b <+81>:    cdqe
0x000000000000076d <+83>:    movzx  edx,BYTE PTR \[rbp+rax\*1-0x20\]
0x0000000000000772 <+88>:    mov    eax,DWORD PTR \[rbp-0x28\]
0x0000000000000775 <+91>:    cdqe
0x0000000000000777 <+93>:    movzx  eax,BYTE PTR \[rbp+rax\*1-0x23\]
0x000000000000077c <+98>:    cmp    dl,al                     # compare two characters
0x000000000000077e <+100>:   je     0x793 <main+121>          # continue if equal
0x0000000000000780 <+102>:   lea    rdi,\[rip+0xe4\]
0x0000000000000787 <+109>:   call   0x5d0 <puts@plt>          # print "password is incorrect"
0x000000000000078c <+114>:   mov    eax,0x0                   # set 0 return value for main
0x0000000000000791 <+119>:   jmp    0x7ae <main+148>          # branch to exit code
0x0000000000000793 <+121>:   add    DWORD PTR \[rbp-0x28\],0x1  # increment loop counter by 1
0x0000000000000797 <+125>:   cmp    DWORD PTR \[rbp-0x28\],0x2  # check if loop count == 2
0x000000000000079b <+129>:   jle    0x768 <main+78>           # if not, branch to start of loop
0x000000000000079d <+131>:   lea    rdi,\[rip+0xdd\]            # if it is, you win
0x00000000000007a4 <+138>:   call   0x5d0 <puts@plt>          # print "password is valid"
0x00000000000007a9 <+143>:   mov    eax,0x0
0x00000000000007ae <+148>:   mov    rcx,QWORD PTR \[rbp-0x8\]
0x00000000000007b2 <+152>:   xor    rcx,QWORD PTR fs:0x28
0x00000000000007bb <+161>:   je     0x7c2 <main+168>
0x00000000000007bd <+163>:   call   0x5e0 <\_\_stack\_chk\_fail@plt>
0x00000000000007c2 <+168>:   leave
0x00000000000007c3 <+169>:   ret
End of assembler dump.
```

Программа по сути является реализацией **strncmp** . Он циклически сравнивает первые три символа нашего ввода с первыми тремя символами правильного пароля.

Сравнение производится по строке <+98>

```fallback
0x000000000000077c <+98>:    cmp    dl,al
```

Он сравнивает значение в регистре **dl** с регистром **al** . Это младшие половины регистров **edx** и **eax** соответственно.

Я установил точку останова на этой строке и распечатал значения, хранящиеся в этих регистрах, на каждой итерации цикла. Это позволило мне собрать правильный трехбуквенный пароль.

Запустите программу с правильным паролем, чтобы выиграть:

```fallback
jason@lapras:/tmp$ ./crackme3.bin
enter your password
XXX
password is valid
```


## Заключение

Я получил массу удовольствия от этой комнаты, рекомендую ее всем, кто только начинает заниматься реверс-инжинирингом!

---

# Basic Malware RE

**Плошадка:** https://tryhackme.com/
**Уровень:** Easy

## **Вызов 1**

Этот исполняемый файл выводит на экран хэш MD5 при выполнении. Можете ли вы взять точный флаг?

**_Решение_**

Сначала вам нужно загрузить файл задачи и запустить его с помощью Ghidra. Ни при каких обстоятельствах не нужно запускать исполняемый файл, так как он вредоносный.

**Совет**. Поскольку файл задачи является исполняемым файлом, не используйте Windows для решения этой задачи. Используйте свою любимую ОС Kali/Parrot, потому что есть вероятность случайного открытия вами исполняемого файла. Мы люди, а люди ошибаются. Верно? **Вредоносное ПО для Windows не имеет власти над Linux!!!**

После запуска исполняемого файла интерфейс Ghidra будет выглядеть следующим образом. На чем нам нужно больше сосредоточиться, так это **на разделе «Дерево символов»** , так как он содержит все функции, импорт и экспорт кода.

![[Pasted image 20230531083625.png]]

На чем нам нужно больше сосредоточиться, так это на **разделе «Функции»**. Я расширил его и искал основную функцию. Однако основной функции нет. Но есть **функция входа.**

В компьютерном программировании точка входа — это место, где начинается выполнение инструкций программы и где программа имеет доступ к аргументам командной строки. Чтобы начать выполнение программы, загрузчик или операционная система передает управление ее точке входа. Это отмечает переход от времени загрузки ко времени выполнения.

![[Pasted image 20230531083646.png]]

Я дважды щелкнул функцию ввода, чтобы просмотреть ее исходный код. Наблюдая за исходным кодом, я наткнулся на строку, которая хешируется с помощью MD5, и я мог очень легко получить первый флаг из декомпилированного исходного кода следующим образом.

![[Pasted image 20230531083703.png]]

Совет — Флаг начинается со слова « **ФЛАГ** » и **НИКАКИХ цифр!!!** в флаге НЕ участвует

Это так же просто, как отобрать конфету у ребенка. Не так ли? Давайте погрузимся во вторую задачу. Однако это не так просто, как описано выше. Вам нужно знать, как работает стек, и иметь некоторые знания в области программирования.

## **Вызов 2**

Этот исполняемый файл выводит на экран хэш MD5 при выполнении. Можете ли вы взять точный флаг?

**_Решение_**

Такая же процедура применялась и для решения этой задачи.

При анализе функций я пришел к той же структуре, что и предыдущая.

![[Pasted image 20230531083729.png]]

Итак, я начал с функции входа, так как это была функция, где флаг был в предыдущем вызове. Декомпилированный исходный код функции входа выглядит следующим образом.

![[Pasted image 20230531083749.png]]

Он начинается с **переменной char** , а затем идет куча **неопределенных** переменных. Последняя переменная является **указателем на символ** .

![[Pasted image 20230531083804.png]]

Если мы посмотрим на раздел дизассемблера, то сможем получить представление о том, как эти переменные добавляются в стек. Мы ясно видим обратный порядок.

Последний указатель char, который является **local_8,** является первым, добавляемым в стек следующим образом.

![[Pasted image 20230531083821.png]]

Давайте просто запомним это и будем дальше наблюдать за декомпилятором.

Мы видим, что каждой переменной присваивается значение следующим образом. Первой переменной char, которая является **local_2c,** назначается « **F** », а всем неопределенным переменным присваиваются шестнадцатеричные значения.

![[Pasted image 20230531083853.png]]

Совет. Эти шестнадцатеричные значения должны быть символами ASCII, поскольку каждое значение представляет собой ровно один байт.

Если вы помните, мы обнаружили, что последняя определенная переменная, local_8, является указателем на символ. Теперь ему назначается хэш **строки** , начинающейся с адреса памяти переменной **char local_2c** , как показано ниже.

![[Pasted image 20230531083909.png]]

что он будет хешировать всю строку **стека** снизу вверх **Это означает ,** . Таким образом, нам нужно **преобразовать** каждый шестнадцатеричный символ, назначенный для переменных после **local_2c,** в символы ASCII, чтобы получить хешируемую строку.

Для этой цели вы можете использовать [https://www.rapidtables.com/convert/number/hex-to-ascii.html](https://www.rapidtables.com/convert/number/hex-to-ascii.html) . Вам будет предоставлен флаг в ASCII следующим образом.

![[Pasted image 20230531083930.png]]

Совет. Вам нужно добавить значение **local_2c** , которое равно **«F»,** в начале флага перед отправкой.

## Вызов 3

Этот исполняемый файл выводит на экран хэш MD5 при выполнении. Можете ли вы взять точный флаг?

**_Решение_**

Как и в предыдущих случаях, начните с анализа раздела функций следующим образом.

Он содержит функцию входа. Однако некоторые функции, которые можно было найти в предыдущих испытаниях, отсутствуют. Проанализируем функцию входа. На этот раз вы столкнетесь с более сложной функцией входа.

![[Pasted image 20230531084029.png]]

Как видите, есть некоторые внешние функции, такие как **FindResourceA()** и **LoadStringsA()** . Когда мы смотрим на ассемблерный код, мы видим, что FindResourceA() из библиотеки Kernel32, а LoadStringsA() из библиотеки User32.

![[Pasted image 20230531084109.png]]

![[Pasted image 20230531084051.png]]

Что делает LoadStringsA(), так это то, что он загружает строку из своей ссылки и сохраняет в переменной **local_4a4.** Итак, давайте найдем ссылку.

Как показано в приведенной выше функции ввода, мы знаем, что **параметр шестнадцатеричного значения 0x110** является идентификатором строки в вызове функции LoadStringsA().

Шестнадцатеричный 0x110 = Десятичный **272**

Откройте **Определенные строки** на ленте Ghidra (Окно → Определенные строки). Прокрутите вниз, и вы увидите таблицу FLAG, содержащую множество флагов.

![[Pasted image 20230531084132.png]]

Взгляните на эквивалентный код на дизассемблере, и вы найдете **идентификатор строки** в дальнем правом углу в десятичном виде. Итак, прокрутите вниз, пока не найдете строку с идентификатором 272.

![[Pasted image 20230531084146.png]]

Это даст вам последний флаг этого испытания CTF.

Когда дело доходит до статического анализа вредоносных программ в реальном мире, это может стать более сложной задачей по многим причинам, таким как:

- Дизассемблер не работает.
- Декомпилятор создает запутанный код.

В основном это связано со сложностью кода вредоносного ПО. Итак, на сцену выходит динамический анализ вредоносных программ. Динамический анализ проводится в закрытой системе (известной как **песочница** ), чтобы запустить вредоносную программу в безопасной среде и просто посмотреть, что она делает.


---

# The More The Werrier

**Плошадка:** https://247ctf.com/
**Уровень:** Easy

Один байт — это здорово. Но что, если вам нужно больше? Можете ли вы найти флаг, скрытый в этом двоичном файле?

![[Pasted image 20221226061058.png]]

Учитывая двоичный файл "the_more_the_merrier". Мы можем разобрать main() функционировать в:

```
1  38: int main (int argc, char **argv, char **envp);
2  ; var char *var_8h @ rbp-0x8
3  0x0000063a  push rbp
4  0x0000063b  mov rbp, rsp
5  0x0000063e  sub rsp, 0x10
6  0x00000642  lea rax, str.247CTF_6df2[redacted]b36c ; 0x6e8
7  0x00000649  mov qword [var_8h], rax
8  0x0000064d  lea rdi, str.Nothing_to_see_here.. ; 0x78c ; const char *s
9  0x00000654  call puts  ; sym.imp.puts ; int puts(const char *s)
10 0x00000659  mov eax, 0
11 0x0000065e  leave
12 0x0000065f  ret
 ```

Это означает: 


```c
#include <stdint.h>

int32_t main (void) {
   char * var_8h;
   rax = "247CTF{6df2[redacted]b36c}";
   var_8h = rax;
   puts ("Nothing to see here..");
   eax = 0;
   return rax;
}
```


Перед puts Инструкция, мы можем увидеть адрес `0x000006e8` хранится в rax регистр:

```
0x00000642  lea rax, str.247CTF_6df2[redacted]b36c ; 0x6e8 -> rax = "247CTF{6df2[redacted]b36c}";
```

Если мы проверим этот адрес, например, с помощью шестнадцатеричного редактора, мы увидим, что флаг хранится там байт
за байтом:

![[Pasted image 20221226061637.png]]

----

# The Encrypted Password

**Плошадка:** https://247ctf.com/
**Уровень:** Easy

Вы не найдете секретный пароль администратора в этом двоичном файле. Мы даже зашифровали его безопасным одноразовым блокнотом. Вы все еще можете восстановить пароль?

![[Pasted image 20221226061708.png]]

Учитывая двоичный файл "encrypted_password" Можем разобрать main() функционировать в:

```
int32_t2 main (void) {
   int64_t var_a8h;
   int64_t var_a4h;
   char * s;
   int64_t var_98h;
   int64_t var_90h;
   int64_t var_88h;
   int64_t var_80h;
   char * s2;
   int64_t var_68h;
   int64_t var_60h;
   int64_t var_58h;
   int64_t var_50h;
   char * s1;
   int64_t canary;
   rax = *(fs:0x28);
   canary = *(fs:0x28);
   eax = 0;
   rax = 0x3930343965353738;
   rdx = 0x3861623131383966;
   s = rax;
   var_98h = rdx;
   rax = 0x3665656562303635;
   rdx = 0x3264373763306266;
   var_90h = rax;
   var_88h = rdx;
   var_80h = 0;
   rax = *(0x00000a88);
   rdx = *(0x00000a90);
   s2 = rax;
   var_68h = rdx;
   rax = *(0x00000a98);
   rdx = *(0x00000aa0);
   var_60h = rax;
   var_58h = rdx;
   eax = *(0x00000aa8);
   var_50h = al;
   var_a8h = 0;
   while (rbx < rax) {
      eax = var_a8h;
      rax = (int64_t) eax;
      edx = *((rbp + rax - 0x70));
      eax = var_a8h;
      rax = (int64_t) eax;
      eax = *((rbp + rax - 0xa0));
      edx ^= eax;
      eax = var_a8h;
      rax = (int64_t) eax;
      *((rbp + rax - 0x70)) = dl;
      var_a8h++;
      eax = var_a8h;
      rbx = (int64_t) eax;
      rax = &s;
      rdi = rax;
      rax = strlen ();
   }
   puts ("Enter the secret password:");
   rax = &s1;
   fgets (rax, 0x21, *(stdin));
   rdx = &s2;
   rax = &s1;
   eax = strcmp (rax, rdx);
   if (eax == 0) {
      rax = &s2;
      rsi = rax;
      eax = 0;
      printf ("You found the flag!\n247CTF{%s}\n");
   }
   var_a4h = 0;
   while (rbx < rax) {
      eax = var_a4h;
      rax = (int64_t) eax;
      *((rbp + rax - 0x70)) = 0;
      var_a4h++;
      eax = var_a4h;
      rbx = (int64_t) eax;
      rax = &s;
      rdi = rax;
      rax = strlen ();
   }
   eax = 0;
   rcx = canary;
   rcx ^= *(fs:0x28);
   if (rbx != rax) {
     stack_chk_fail ();
   }
   return rax;
```


Это кажется сложнее, чем есть на самом деле, в основном мы должны сосредоточиться на следующих строках:

```
[... snip ...]
puts ("Enter the secret password:");
rax = &s1;
fgets (rax, 0x21, *(stdin));
rdx = &s2;
rax = &s1;
eax = strcmp (rax, rdx);
if (eax == 0) {
rax = &s2;
rsi = rax;
eax = 0;
printf ("You found the flag!\n247CTF{%s}\n");
}
[... snip ...]
```

Цель состоит в том, чтобы найти rax стоимость, представленная через fgets инструкция stdin, которая соответствует rdx регистрируемся,
если да, то флаг нам возвращается; сравнение проводится с strcmp, который сохраняется в eax регистр, и мы знаем, что строки равны, если возвращаемое значение равно 0. Бег ltrace против двоичного файла и отправки случайного значения как test , показывает нам, что наша строка сравнивается с хешем, подобным MD5:

![[Pasted image 20221226062324.png]]

Если мы запустим двоичный файл «encrypted_password» с этим хешем, флаг вернется к нам.

![[Pasted image 20221226062405.png]]

---
# Vectors

**Плошадка:**
**Уровень:** Easy

![[Pasted image 20230112103336.png]]

Исходя из названия задания можно предположить, что речь пойдёт про вектора в C++. Задание оказалось довольно простым, хотя его решило мало команд. 

Скачиваем архив и получаем 2 файла - бинарный и шифрованный.

![[Pasted image 20230112103400.png]]

Можно быстро найти функцию чтения шифрованного файла и посмотреть на алгоритм.

![[Pasted image 20230112103420.png]]


Видим, что это обычный XOR по ключу, при это ключ циклически накладывается. 

Зная форму флага мы можем попробовать поксорить шифрованный файл и посмотреть какие ключи получим. Напишем небольшой скрипт.

![[Pasted image 20230112105101.png]]

Запустим и посмотрим на вывод.

![[Pasted image 20230112105116.png]]

Видим повторение ключа, после 7 чисел. Попробуем использовать первые 7 чисел как ключ. Переделываем скрипт.

![[Pasted image 20230112105136.png]]

Запускаем и получаем флаг.

![[Pasted image 20230112105159.png]]

Задание действительно оказалось простым, даже не особо пришлось исследовать бинарник.


---

# RBOOM

**Плошадка:**
**Уровень:** Easy

![[Pasted image 20230112105652.png]]

Данное задание решило всего 8 команд (из ~500) хотя оно довольно простое.

В архиве нам даются 3 файла: 1 исполняемый, 1 шифрованный и файл с ключом.

Файл "la".

![[Pasted image 20230112105718.png]]

Файл "ll".

![[Pasted image 20230112105740.png]]

В функции main мы вводим пароль, который после сохраняется в файл lla, после на основе данного файла и файла la (в котором ключ) формируется файл res.

![[Pasted image 20230112105759.png]]

После файл res сравнивается с файлом ll.

![[Pasted image 20230112105816.png]]

Нужно, чтобы они оба были равны. Посмотрим функцию формирования файла res.

![[Pasted image 20230112105832.png]]

Считывается пароль и ключ, после передаётся в функцию формирования буфера для файла res.

![[Pasted image 20230112105854.png]]


Функция выглядит немного запутано, но разбирать её смысла нет, т.к. наш пароль используется только для XOR'а с заранее инициализированным буфером, который зависит только от ключа, который мы имеем и не контролируем.

Таким образом, мы можем сформировать пароль размером с шифрованный файл, получить файл res, который можно проксорить с файлом ll и получить верные ключи, которыми после проксорить файл ll и получить верный пароль.

Реализуем для этого скрипт.

![[Pasted image 20230112105946.png]]

Запустим и получим флаг.

![[Pasted image 20230112110002.png]]

Задание оказалось довольно простым, удивительно, что его решило так мало команд.


---

# Matrix of Hell

**Плошадка:**
**Уровень:** Easy

![[Pasted image 20230112124937.png]]

Данное задание решило 22 команды, но стоит отметить, что оно несколько сложнее задания с векторами.

Из названия видим намёк на использование матриц. Всё как обычно качаем бинарники загружаем его в IDA. На этот раз нам дан только бинарник.

![[Pasted image 20230112125004.png]]

В функции main сразу видим инициализацию матрицы, значения которой не зависят от нашего ввода, то есть если что мы сможем сдампить эти значения (имя переменной было дано руками, в бинарнике нет символьной информации).

![[Pasted image 20230112125027.png]]

Далее мы вводим пароль. Длина пароля должны быть равна 14 . После этого происходит поиск значений пароля внутри сгенерированной матрицы, и если значение было найдено то из индексов (строка, столбец) формируются 2 символа для
некоторого массива (строки 51-54). После этот массив проходит через XOR (строка 60) и сравнивается с некоторой переменной s1, которая заложена в памяти.

![[Pasted image 20230112125130.png]]

Отлично, мы можем обратить XOR и получить первоначальную строку, которая была получена от индексов из матрицы. После этого мы сможем узнать индексы и таким образом мы сможем узнать пароль.

Для начала нужно получить значения матрицы, для этого воспользуемся отладчиком.

![[Pasted image 20230112125157.png]]

Переведём это всё в список.

![[Pasted image 20230112125210.png]]

Теперь обратим этот алгоритм для получения изначального буфера.

![[Pasted image 20230112125225.png]]

Напишем простой код.

![[Pasted image 20230112125238.png]]

Итак, теперь нам осталось обратить данный алгоритм для получения индексов матрцы.

![[Pasted image 20230112125304.png]]

Реализуем обратный алгоритм на Python'e

![[Pasted image 20230112125321.png]]

Запустим и посмотрим, что выведется.

![[Pasted image 20230112125334.png]]

Получаем некоторую последовательность букв. Попробуем использовать её в качестве пароля при запуске бинарника.

![[Pasted image 20230112125402.png]]

Получаем некоторую строку (в данном задание формат флага не стандартный) которая и является ответом.


---

# Тестовый crackme от Лаборатории Касперского

**Плошадка:**
**Уровень:**

Приветствую сообщество! Давным давно, в 2013 году на Хабре был опубликован пост «Reverse engineering на собеседовании: как мы нанимаем на работу». В нём был предложен тестовый crackme для претендентов на позицию вирусного аналитика. Убедившись, что полного разбора тестового файла в интернете нет, я решил написать свой разбор. Итак, приступим. Crackme 64-разрядный. Запустим его в IDA Pro.

![[Pasted image 20230102084639.png]]

Видим слева в списке функций три функции: start — функция, с которой начинается выполнение программы, DialogFunc — эта функция общается с нами и некоторая функция sub_140001000. Рассмотрим диалоговую функцию. Декомпилируем её Hex Rays-ом.

![[Pasted image 20230102084723.png]]

В глаза бросается ветвление условий, согласно которому, если некоторая функция sub_140001000 вернет TRUE, то появится сообщение, информирующее нас о отлично проделанной работе, иначе неверно. Разберем нашу заветную функцию sub_140001000. Если мы пропустим её через декомпилятор, то увидим, что в качестве аргумента передается указатель всего на одно значение. Вероятно, это значение берется из диалогового окна и является вводимым ключом. Теперь рассмотрим ассемблерный листинг. Имеется первая проверка условия верности введенных данных. Если условие выполняется, то программа исполняется дальше, если не выполняется, то идет возврат из
подпрограммы.

![[Pasted image 20230102084903.png]]

Запустим наш crackme под отладчиком. Воспользуемся x64dbg. Поставим breakpoint на нашей первой проверке. В качестве вводимого ключа используем набор цифр 1234567.

![[Pasted image 20230102084951.png]]

Как видно, происходит проверка значения регистра edx и числа 13h (в десятичной системе исчисления это 19). Вероятно, это проверка на количество введенных знаков ключа (у нас их 7 и в регистре edx число 7). Попробуем ввести другое количество символов. Запустим
отладчик заново. Введем 9 цифр 123456789.

![[Pasted image 20230102085058.png]]

Похоже, что так оно и есть. Значит наш ключ должен содержать 19 символов. Вводим 19 символов 1234567890123456789 и переходим к следующему этапу проверки.

![[Pasted image 20230102085206.png]]

На этом шаге осуществляется проверка каждого пятого символа ключа на равенство значению 2Dh. Дело в том, что число 2Dh — это шестнадцатиричный код символа "-". Т.е. наш ключ должен иметь вид xxxx-xxxx-xxxx-xxxx. Используем в качестве ключа 1234-5678-9012-3456 и переходим к следующему шагу.

![[Pasted image 20230102085326.png]]

А на следующем шаге происходит проверка символов на числовую принадлежность. Порядок проверки такой: берется символ из ключа (в счет не идут каждый пятый символ ключа) и к его шестнадцатиричному коду прибавляется число -30 и полученный результат сравнивается с числом 9. Если меньше, то на проверку берется следующий символ ключа, если больше, то выводится сообщение, что ключ неверный. Идем дальше.

![[Pasted image 20230102085407.png]]

На этом шаге осуществляется проверка того, чтобы суммы чисел в блоках были равны. На рисунке выше выделен блок кода, который производит подсчет суммы чисел и область стека, куда эти суммы заносятся. Параллельно суммы блоков суммируются между собой и
заносятся в регистр r10. Далее идет деление результата в регистре r10 на 4 (shr r10d,2 — сдвиг на 2 разряда равносилен делению на 4) и сравнение значения из регистра r10 с ранее занесенными значениями в стеке. Отлично. Делаем так, чтобы суммы цифр каждого
блока ключа были равны (например 1122-0123-2112-0006) и двигаемся дальше на следующий шаг проверки.

![[Pasted image 20230102085443.png]]

Участок кода, выделенный на рисунке выше, проверяет, чтобы расположение символов в каждом последующем блоке ключа не совпадало с предыдущим. В итоге наш ключ имеет вид 1478-7814-1478-7814. Проверяем.

![[Pasted image 20230102085507.png]]

![[Pasted image 20230102085515.png]]