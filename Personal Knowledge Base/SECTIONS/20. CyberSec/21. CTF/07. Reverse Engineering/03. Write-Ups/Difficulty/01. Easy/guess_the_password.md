
**Платформа:** https://crackmes.one/
**Тип файла**: elf
**Уровень:** Easy

**Описание:** very easy

И так задача легкая, а для её решение мы будем использовать такие инструменты как IDA и Ghidra.

# Дизассемблирования

Вы можете дизассемблировать с п.м. **gdb**, **objdump**, **radare2** или использовать дизассемблеры **IDA** и **Ghidra**

```
           ; DATA XREF from entry0 @ 0x1118(r)  
┌ 189: int main (int argc, char **argv, char **envp);  
│           ; var int64_t canary @ rbp-0x8  
│           ; var char *s1 @ rbp-0x110  
│           0x000011e9      f30f1efa       endbr64  
│           0x000011ed      55             push rbp  
│           0x000011ee      4889e5         mov rbp, rsp  
│           0x000011f1      4881ec100100.  sub rsp, 0x110  
│           0x000011f8      64488b042528.  mov rax, qword fs:[0x28]  
│           0x00001201      488945f8       mov qword [canary], rax  
│           0x00001205      31c0           xor eax, eax  
│           0x00001207      488d05f60d00.  lea rax, str.What_is_the_password: ; 0x2004 ; "What is the password:"  
│           0x0000120e      4889c7         mov rdi, rax                ; const char *format  
│           0x00001211      b800000000     mov eax, 0  
│           0x00001216      e8b5feffff     call sym.imp.printf         ; int printf(const char *format)  
│           0x0000121b      488b15ee2d00.  mov rdx, qword [obj.stdin]  ; obj.__TMC_END__  
│                                                                      ; [0x4010:8]=0 ; FILE *stream  
│           0x00001222      488d85f0feff.  lea rax, [s1]  
│           0x00001229      be00010000     mov esi, 0x100              ; int size  
│           0x0000122e      4889c7         mov rdi, rax                ; char *s  
│           0x00001231      e8bafeffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)  
│           0x00001236      488d85f0feff.  lea rax, [s1]  
│           0x0000123d      488d15d60d00.  lea rdx, [0x0000201a]       ; "\n"  
│           0x00001244      4889d6         mov rsi, rdx                ; const char *s2  
│           0x00001247      4889c7         mov rdi, rax                ; const char *s1  
│           0x0000124a      e891feffff     call sym.imp.strcspn        ; size_t strcspn(const char *s1, const char *s2)  
│           0x0000124f      c68405f0feff.  mov byte [rbp + rax - 0x110], 0  
│           0x00001257      488d85f0feff.  lea rax, [s1]  
│           0x0000125e      4889c7         mov rdi, rax                ; char *arg1  
│           0x00001261      e840000000     call sym.check  
│           0x00001266      83f801         cmp eax, 1  
│       ┌─< 0x00001269      7511           jne 0x127c  
│       │   0x0000126b      488d05aa0d00.  lea rax, str.Correct        ; 0x201c ; "Correct"  
│       │   0x00001272      4889c7         mov rdi, rax                ; const char *s  
│       │   0x00001275      e826feffff     call sym.imp.puts           ; int puts(const char *s)  
│      ┌──< 0x0000127a      eb0f           jmp 0x128b  
│      ││   ; CODE XREF from main @ 0x1269(x)  
│      │└─> 0x0000127c      488d05a10d00.  lea rax, str.Incorrect      ; 0x2024 ; "Incorrect"  
│      │    0x00001283      4889c7         mov rdi, rax                ; const char *s  
│      │    0x00001286      e815feffff     call sym.imp.puts           ; int puts(const char *s)  
│      │    ; CODE XREF from main @ 0x127a(x)  
│      └──> 0x0000128b      b800000000     mov eax, 0  
│           0x00001290      488b55f8       mov rdx, qword [canary]  
│           0x00001294      64482b142528.  sub rdx, qword fs:[0x28]  
│       ┌─< 0x0000129d      7405           je 0x12a4  
│       │   0x0000129f      e81cfeffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)  
│       │   ; CODE XREF from main @ 0x129d(x)  
│       └─> 0x000012a4      c9             leave  
└           0x000012a5      c3             ret
```

Сначала идут адреса, потом опкоды, а после сами инструкции, или как их еще называют команды. Разберем каждую часть этого кода на ассемблере, чтобы понять его работу и назначение каждой переменной.

## Разбор кода 

### 1. Начало функции и подготовка стека:

```
0x000011e9      f30f1efa       endbr64
0x000011ed      55             push rbp
0x000011ee      4889e5         mov rbp, rsp
0x000011f1      4881ec100100.  sub rsp, 0x110
```

Ну тут всё просто, просто пролог процедуры.

- `endbr64`: Инструкция используется для обеспечения безопасности выполнения (Control-flow Enforcement Technology, CET).
- `push rbp`: Сохраняет значение регистра `rbp` на стек.
- `mov rbp, rsp`: Устанавливает регистр `rbp` на текущее значение регистра `rsp`, чтобы использовать его как базу для текущего фрейма стека.
- `sub rsp, 0x110`: Выделяет 0x110 (272) байт на стеке для локальных переменных.

### 2. Сохранение канарейки для защиты стека:

```
0x000011f8      64488b042528.  mov rax, qword fs:[0x28]
0x00001201      488945f8       mov qword [rbp-0x8], rax
```

- `mov rax, qword fs:[0x28]`: Считывает значение из регистра `fs` по смещению `0x28`, которое часто используется для хранения канарейки (значения для защиты стека).
- `mov qword [rbp-0x8], rax`: Сохраняет это значение в локальной переменной `canary` на стеке.

### 3. Вывод приглашения для ввода пароля:

```
0x00001207      488d05f60d00.  lea rax, str.What_is_the_password: ; 0x2004 ; "What is the password:"
0x0000120e      4889c7         mov rdi, rax                ; const char *format
0x00001211      b800000000     mov eax, 0
0x00001216      e8b5feffff     call sym.imp.printf         ; int printf(const char *format)
```

- `lea rax, [rip+0xdf6]`: Загружает адрес строки "What is the password:" в регистр `rax`.
- `mov rdi, rax`: Перемещает адрес строки в регистр `rdi` (первый аргумент для функции `printf`).
- `mov eax, 0`: Очищает регистр `eax`.
- `call sym.imp.printf`: Вызывает функцию `printf`, которая выводит строку.

Ну как можно понять вызывается функция `printf` и выводит строку, а параметры функции `printf` передаётся через регистры
### 4. Чтение ввода пользователя:

```
0x0000121b      488b15ee2d00.  mov rdx, qword [obj.stdin]
0x00001222      488d85f0feff.  lea rax, [rbp-0x110]
0x00001229      be00010000     mov esi, 0x100
0x0000122e      4889c7         mov rdi, rax
0x00001231      e8bafeffff     call sym.imp.fgets
```

- `mov rdx, qword [obj.stdin]`: Загружает указатель на стандартный ввод (stdin) в регистр `rdx`.
- `lea rax, [rbp-0x110]`: Загружает адрес локальной переменной `s1` (буфер для ввода) в регистр `rax`.
- `mov esi, 0x100`: Устанавливает размер буфера в 256 байт.
- `mov rdi, rax`: Устанавливает указатель на буфер в регистр `rdi`.
- `call sym.imp.fgets`: Вызывает функцию `fgets` для чтения строки из stdin.

### 5. Удаление символа новой строки:

```
0x00001236      488d85f0feff.  lea rax, [rbp-0x110]
0x0000123d      488d15d60d00.  lea rdx, [rip+0xdf6]       ; "\n"
0x00001244      4889d6         mov rsi, rdx                ; const char *s2
0x00001247      4889c7         mov rdi, rax                ; const char *s1
0x0000124a      e891feffff     call sym.imp.strcspn        ; size_t strcspn(const char *s1, const char *s2)
0x0000124f      c68405f0feff.  mov byte [rbp+rax-0x110], 0
```

- `lea rax, [rbp-0x110]`: Загружает адрес буфера `s1` в регистр `rax`.
- `lea rdx, [rip+0xdf6]`: Загружает адрес строки "\n" в регистр `rdx`.
- `mov rsi, rdx`: Устанавливает указатель на строку "\n" в регистр `rsi`.
- `mov rdi, rax`: Устанавливает указатель на буфер `s1` в регистр `rdi`.
- `call sym.imp.strcspn`: Вызывает функцию `strcspn`, которая возвращает позицию первого вхождения символа "\n" в строку `s1`.
- `mov byte [rbp+rax-0x110], 0`: Заменяет символ новой строки в `s1` на нуль-терминатор.
### 6. Валидация введенного пароля

```
0x00001257      488d85f0feff.  lea rax, [rbp-0x110]
0x0000125e      4889c7         mov rdi, rax
0x00001261      e840000000     call sym.check
0x00001266      83f801         cmp eax, 1
```

- `lea rax, [rbp-0x110]`: Загружает адрес буфера `s1` в регистр `rax`.
- `mov rdi, rax`: Устанавливает указатель на буфер в регистр `rdi`.
- `call sym.check`: Вызывает функцию `check` для проверки введенного пароля.
- `cmp eax, 1`: Сравнивает возвращаемое значение функции `check` с 1. Другими словами Сравнивает значение в регистре `eax` с 1. Регистр `eax` содержит результат вызова функции `check`.

#### Разбор функции **sym.check**

Сама функция **sym.check** проверяет правильность введенного пароля. Давайте разберем функцию `sym.check`, чтобы понять, что она делает. Эта функция принимает аргумент `arg1`, который является указателем на строку (пароль), и возвращает результат проверки.
##### 1. Пролог функции

```
0x000012a6      f30f1efa       endbr64
0x000012aa      55             push rbp
0x000012ab      4889e5         mov rbp, rsp
0x000012ae      4883ec20       sub rsp, 0x20
```

- `endbr64`: Специальная инструкция для обеспечения совместимости с механизмом ENDBRANCH64.
- `push rbp`: Сохраняет текущий базовый указатель кадра стека.
- `mov rbp, rsp`: Устанавливает новый базовый указатель кадра стека.
- `sub rsp, 0x20`: Выделяет 32 байта в стеке для локальных переменных.
##### 2. Сохранение аргумента и вычисление длины строки

```
0x000012b2      48897de8       mov qword [rbp-0x18], rdi          ; arg1
0x000012b6      488b45e8       mov rax, qword [rbp-0x18]
0x000012ba      4889c7         mov rdi, rax                       ; const char *s
0x000012bd      e8eefdffff     call sym.imp.strlen                ; size_t strlen(const char *s)
0x000012c2      8945fc         mov dword [rbp-0x4], eax
```

- `mov qword [rbp-0x18], rdi`: Сохраняет аргумент `arg1` в локальную переменную `s`.
- `mov rax, qword [rbp-0x18]`: Загружает указатель на строку `s` в регистр `rax`.
- `mov rdi, rax`: Устанавливает указатель на строку в регистр `rdi` для передачи в функцию `strlen`.
- `call sym.imp.strlen`: Вызывает функцию `strlen`, чтобы получить длину строки.
- `mov dword [rbp-0x4], eax`: Сохраняет длину строки в локальную переменную `var_4h`.
##### 3. Проверка длины строки и символов

```
0x000012c5      837dfc0a       cmp dword [rbp-0x4], 0xa
0x000012c9      7521           jne 0x12ec
```

- `cmp dword [rbp-0x4], 0xa`: Сравнивает длину строки с 10.
- `jne 0x12ec`: Если длина не равна 10, переходит к метке `0x12ec`, устанавливая `eax` в 0 (неудача).
##### 4. Проверка первого символа

```
0x000012cb      488b45e8       mov rax, qword [rbp-0x18]
0x000012cf      0fb600         movzx eax, byte [rax]
0x000012d2      3c31           cmp al, 0x31                     ; '1'
0x000012d4      7516           jne 0x12ec
```

- `mov rax, qword [rbp-0x18]`: Загружает указатель на строку в `rax`.
- `movzx eax, byte [rax]`: Загружает первый символ строки в `eax`.
- `cmp al, 0x31`: Сравнивает первый символ с '1'.
- `jne 0x12ec`: Если первый символ не равен '1', переходит к `0x12ec` (устанавливает `eax` в 0).
##### 5. Проверка пятого символа

```
0x000012d6      488b45e8       mov rax, qword [rbp-0x18]
0x000012da      4883c004       add rax, 4
0x000012de      0fb600         movzx eax, byte [rax]
0x000012e1      3c39           cmp al, 0x39                     ; '9'
0x000012e3      7507           jne 0x12ec
```

- `mov rax, qword [rbp-0x18]`: Загружает указатель на строку в `rax`.
- `add rax, 4`: Смещает указатель на 4 байта вперед (пятый символ строки).
- `movzx eax, byte [rax]`: Загружает пятый символ строки в `eax`.
- `cmp al, 0x39`: Сравнивает пятый символ с '9'.
- `jne 0x12ec`: Если пятый символ не равен '9', переходит к `0x12ec` (устанавливает `eax` в 0).
##### 6. Успешная проверка и возврат результата

```
0x000012e5      b801000000     mov eax, 1
0x000012ea      eb05           jmp 0x12f1
0x000012ec      b800000000     mov eax, 0
0x000012f1      c9             leave
0x000012f2      c3             ret
```

- `mov eax, 1`: Устанавливает `eax` в 1 (успешная проверка).
- `jmp 0x12f1`: Переход к завершению функции.
- `mov eax, 0`: Устанавливает `eax` в 0 (неудача).
- `leave`: Восстанавливает базовый указатель кадра стека и очищает стек.
- `ret`: Возвращает управление вызывающей функции.
##### Итоговая логика

Функция `sym.check` проверяет, что введенный пароль:

1. Имеет длину 10 символов.
2. Первый символ пароля - '1'.
3. Пятый символ пароля - '9'.

Если все условия выполняются, функция возвращает 1 (успех), иначе - 0 (неудача).

Пароль должен соответствовать всем условиям, проверяемым функцией `sym.check`. Давайте повторим эти условия:

1. Длина строки должна быть 10 символов.
2. Первый символ строки должен быть `'1'`.
3. Пятый символ строки должен быть `'9'`.

В итоге, пароль может быть любым, если он удовлетворяет этим условиям. Пример подходящего пароля:

```
1xxx9xxxxx
```

где `x` — любой допустимый символ (любая цифра, буква или другой символ).

Например, пароль может быть:

```
1abc9defgh
```

Этот пароль:

- Состоит из 10 символов.
- Начинается с `'1'`.
- Пятый символ - `'9'`.

Таким образом, вы можете придумать любой пароль, который удовлетворяет этим условиям.
### 7. Условный переход в зависимости от результата сравнения

```
0x00001269      7511           jne 0x127c
```

- `jne 0x127c`: Если значение в `eax` не равно 1, переход к метке `0x127c` (вывод строки "Incorrect").
#### Вывод строки "Incorrect"

```
0x0000127c      488d05a10d00.  lea rax, [rip+0xda1] ; "Incorrect"
0x00001283      4889c7         mov rdi, rax                ; const char *s
0x00001286      e815feffff     call sym.imp.puts           ; int puts(const char *s)
```

- `lea rax, [rip+0xda1]`: Загружает адрес строки "Incorrect" в регистр `rax`.
- `mov rdi, rax`: Устанавливает указатель на строку "Incorrect" в регистр `rdi`.
- `call sym.imp.puts`: Вызывает функцию `puts` для вывода строки "Incorrect".
#### Вывод строки "Correct" и переход к завершению

```
0x0000126b      488d05aa0d00.  lea rax, [rip+0xdaa] ; "Correct"
0x00001272      4889c7         mov rdi, rax                ; const char *s
0x00001275      e826feffff     call sym.imp.puts           ; int puts(const char *s)
0x0000127a      eb0f           jmp 0x128b
```

- `lea rax, [rip+0xdaa]`: Загружает адрес строки "Correct" в регистр `rax`.
- `mov rdi, rax`: Устанавливает указатель на строку "Correct" в регистр `rdi`.
- `call sym.imp.puts`: Вызывает функцию `puts` для вывода строки "Correct".
- `jmp 0x128b`: Переход к метке `0x128b` для завершения функции.

### 8. Завершение функции и проверка целостности стека

```
0x0000128b      b800000000     mov eax, 0
0x00001290      488b55f8       mov rdx, qword [rbp-0x8]
0x00001294      64482b142528.  sub rdx, qword fs:[0x28]
0x0000129d      7405           je 0x12a4
0x0000129f      e81cfeffff     call sym.imp.__stack_chk_fail
0x000012a4      c9             leave
0x000012a5      c3             ret
```

- `mov eax, 0`: Устанавливает значение регистра `eax` в 0 (код возврата).
- `mov rdx, qword [rbp-0x8]`: Загружает сохраненное значение канарейки из стека в регистр `rdx`.
- `sub rdx, qword fs:[0x28]`: Сравнивает значение канарейки с текущим значением из регистра `fs:[0x28]`.
- `je 0x12a4`: Если значения равны, переход к `0x12a4` (пропуск вызова `__stack_chk_fail`).
- `call sym.imp.__stack_chk_fail`: Если канарейка изменена, вызывается функция `__stack_chk_fail`, что приводит к аварийному завершению программы.
- `leave`: Восстанавливает значение регистра `rbp` и очищает стек.
- `ret`: Возвращает управление вызывающей функции.

Этот код реализует простую программу, которая запрашивает пароль у пользователя, проверяет его и выводит соответствующее сообщение ("Correct" или "Incorrect"). Также он включает защиту стека с использованием канареек для предотвращения переполнения буфера.


# Декомпиляция

Для более быстрой решении можно использовать декомпиляторы. Вот что на показывает декомпилятор Ghidra:

```c
undefined8 main(void)

{
  int iVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  char local_118 [264];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 40);
  printf("What is the password:");
  fgets(local_118,0x100,stdin);
  sVar2 = strcspn(local_118,"\n");
  local_118[sVar2] = '\0';
  iVar1 = check(local_118);
  if (iVar1 == 1) {
    puts("Correct");
  }
  else {
    puts("Incorrect");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

Этот C-программа представляет собой простой проверщик паролей с базовой защитой стека. Давайте разберем ее пошагово:

## 1. Объявление переменных:

```c
int iVar1;
size_t sVar2;
long in_FS_OFFSET;
char local_118 [264];
long local_10;
```
## 2. Настройка защиты стека:

```c
local_10 = *(long *)(in_FS_OFFSET + 40);
```

Эта строка является частью механизма защиты стека, который помогает предотвратить переполнение буфера, сохраняя значение "канарейки".

## 3. Запрос пароля:

```c
printf("What is the password:");
```

Эта строка выводит сообщение, запрашивающее у пользователя пароль.

## 4. Чтение ввода:

```c
fgets(local_118,0x100,stdin);
```

Эта функция считывает до 256 символов (0x100 в шестнадцатеричном формате) из стандартного ввода в массив `local_118`.

## 5. Замена символа новой строки на нулевой символ:

```c
sVar2 = strcspn(local_118,"\n");
local_118[sVar2] = '\0';
```

`strcspn` находит позицию символа новой строки и заменяет его нулевым символом, чтобы очистить строку ввода.
## 6. Проверка пароля:

```c
iVar1 = check(local_118);
```

Эта строка вызывает функцию `check` с пользовательским вводом в качестве аргумента, чтобы определить, правильный ли это пароль.
### Разбор функции проверки пароля 

Функция check имеет следующие содержание:

```c
undefined8 check(char *param_1)

{
  size_t sVar1;
  undefined8 uVar2;
  
  sVar1 = strlen(param_1);
  if ((((int)sVar1 == 10) && (*param_1 == '1')) && (param_1[4] == '9')) {
    uVar2 = 1;
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}
```

Функция `check` проверяет, соответствует ли введённый пароль определённым условиям. Давайте разберём её работу:

#### 1. Объявление переменных:

```c
size_t sVar1;
undefined8 uVar2;
```

Функция `check` принимает один параметр и это наш ввод. Работает это так:

1. То что ввел юзер, фнкция `fgets` считывает в переменную `local18`;
2. Вызывается функция check и она принимает один параметр и это перемення `local18`, а значить наш (пользовательский ввод);
3. Обьявляем два переменных:
     - `size_t sVar1` - Для проверки длинны пароля. То есть, объявляет переменную `sVar1` типа `size_t`, которая будет использоваться для сохранения длины строки param_1 (в параметре `param_1` содержится значение переменной `local18`, а там пользовательский ввод который был записан с п.м. функций `fgets()`).;
     - `undefined8 uVar2` - Эта переменная будет содержать результат проверки;
#### 2. Получение длины строки:

```c
sVar1 = strlen(param_1);
```

Эта строка вычисляет длину строки, переданной в функцию через `param_1`. То есть, используется для определения длины строки `param_1` (пользовательского ввода) с помощью функции `strlen`, которая возвращает количество символов в строке до завершающего нулевого символа. Скажу еще проще, c п.м. функции `strlen` мы вычисляем длину строки параметра функции, а в качестве параметра функции мы передали переменную которая содержит юзерский ввод. Это значить мы вычиляем длину строки пользовательского ввода и сохраняем его в переменной `sVar1`.
#### 3.Проверка условий:

```c
if ((((int)sVar1 == 10) && (*param_1 == '1')) && (param_1[4] == '9')) {
```

Эта строка проверяет три условия:

  1. Длина строки должна быть равна 10.
   2. Первый символ строки должен быть '1'.
   3. Пятый символ строки должен быть '9'.
#### 4. Возвращаемое значение:

   - `uVar2 = 1;` если все условия выполнены.
   - `Var2 = 0;` если хотя бы одно условие не выполнено.
#### 5. Возврат результата:

```c
return uVar2;
```

 Если все условия выполняются, тогда переменной uVar2 присваивается значение 1, что может быть интерпретировано как истина. Иначе, переменной uVar2 присваивается значение 0, что может быть интерпретировано как ложь. Наконец, возвращается значение uVar2 (0 или 1) в качестве результата выполнения функции check.

## 7. Вывод результата:

```c
if (iVar1 == 1) {
    puts("Correct");
}
else {
    puts("Incorrect"); 
}
```

В зависимости от возвращаемого значения функции `check` выводится "Correct" (правильный) или "Incorrect" (неправильный).
## 8. Проверка защиты стека:

```c
if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); }
```

Эта строка проверяет, изменилось ли значение "канарейки", что указывало бы на переполнение буфера. Если оно изменилось, вызывается __stack_chk_fail, которая обычно завершает выполнение программы.__
## 9. Возврат значения:

```c
return 0;
```

Эта строка возвращает 0, что указывает на успешное выполнение программы.

## Всё содержимое кода

Теперь, когда у нас есть реализация функции `check`, давайте посмотрим, как она работает вместе с основной программой.

Основная программа:

1. Запрашивает у пользователя пароль.
2. Считывает введённый пароль.
3. Удаляет символ новой строки.
4. Проверяет пароль с помощью функции `check`.
5. Выводит "Correct" (правильный) или "Incorrect" (неправильный) в зависимости от результата проверки.

Полный код программы вместе с функцией `check`:

```c
#include <stdio.h>
#include <string.h>

typedef unsigned long long undefined8;

undefined8 check(char *param_1)
{
  size_t sVar1;
  undefined8 uVar2;
  
  sVar1 = strlen(param_1);
  if ((((int)sVar1 == 10) && (*param_1 == '1')) && (param_1[4] == '9')) {
    uVar2 = 1;
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}

int main(void)
{
  int iVar1;
  size_t sVar2;
  long in_FS_OFFSET;
  char local_118[264];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 40);
  printf("What is the password:");
  fgets(local_118, 0x100, stdin);
  sVar2 = strcspn(local_118, "\n");
  local_118[sVar2] = '\0';
  iVar1 = check(local_118);
  if (iVar1 == 1) {
    puts("Correct");
  }
  else {
    puts("Incorrect");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
    __stack_chk_fail();
  }
  return 0;
}
```

### Объяснение

1. Программа запрашивает у пользователя пароль.
2. Введённый пароль считывается с помощью функции `fgets` в массив `local_118`.
3. `strcspn` находит позицию символа новой строки и заменяет его нулевым символом.
4. Функция `check` который в качестве параметра принимает переменную в которой храниться юзерский ввод для проверки. Он проверяет введённый пароль:

    - Длина строки должна быть 10 символов.
    - Первый символ строки должен быть '1'.
    - Пятый символ строки должен быть '9'.

Таким образом, любой пароль, соответствующий этим условиям, пройдет проверку. Примеры подходящих паролей:

- **1abc9efghi**
- **1defg9hijk**

Обратите внимание, что в этих примерах:

- Общая длина строки составляет 10 символов.
- Первый символ - '1'.
- Пятый символ - '9'.

Таким образом, пароль должен быть подобран таким образом, чтобы соответствовать всем вышеперечисленным условиям. Вы можете придумать любой пароль, удовлетворяющий этим условиям.

В зависимости от результата проверки выводится "Correct" (если все условия выполнены) или "Incorrect" (если хотя бы одно условие не выполнено).

