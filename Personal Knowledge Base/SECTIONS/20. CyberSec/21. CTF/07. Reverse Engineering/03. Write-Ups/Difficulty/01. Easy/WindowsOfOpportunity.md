Платформа: https://www.hackthebox.com/
**Уровень:** Easy

![[Pasted image 20240915161812.png]]

В результате этой задачи мы получаем zip-файл, содержащий двоичный файл. Сначала мы пытаемся запустить его и проверить, что делает файл.

![[Pasted image 20240915161834.png]]

Кажется, это типичная проблема с проверкой пароля или флага. Мы можем понять, как работает файл, с помощью некоторых основных инструментов обратного проектирования, таких как IDA или Ghidra. В этом посте я буду использовать IDA

![[Pasted image 20240915161859.png]]

На изображении представлен фрагмент программы на языке C, которая, по всей видимости, проверяет введенный пользователем пароль. Давайте разберем код:
### Переменные

- `char s[43];` — массив символов (строка) длиной 43 байта, куда записывается пользовательский ввод.
- `char v5;` — переменная, которая будет хранить результат сложения двух символов.
- `unsigned int i;` — счетчик для цикла `for`.

### Основной ход программы

1. **`puts("A voice comes from the window... 'Password?'");`** — программа выводит сообщение, прося пользователя ввести пароль.
    
2. **`fgets(s, 42, stdin);`** — считывает строку длиной до 42 символов (включая символ новой строки) из стандартного ввода (например, клавиатуры) и сохраняет ее в массив `s`.
    
### Цикл for
    
- Выполняется от 0 до 36 (0x24 — это 36 в шестнадцатеричной системе), то есть программа проверяет первые 37 символов строки.  

- **`v5 = s[i] + s[i + 1];`** — в каждой итерации два последовательных символа из строки `s` суммируются и сохраняются в переменную `v5`.

- **Проверка `if (v5 != arr[i])`** — полученное значение сравнивается с элементом массива `arr`. Если они не равны, программа выводит сообщение `"The window slams shut..."` и завершает выполнение с кодом ошибки `-1`.

- Если цикл завершится успешно (то есть все символы строки проходят проверку), программа выводит сообщение: **`"The window opens to allow you passage..."`** и возвращает 0, что указывает на успешное выполнение программы.

Оператор `v5 = s[i] + s[i + 1];` выполняет сложение двух символов строки, находящихся в массиве `s` на позициях с индексами `i` и `i + 1`. В результате получается сумма ASCII-кодов двух символов.

### Пояснение

1. Оператор `v5 = s[i] + s[i + 1];` выполняет сложение двух символов строки, находящихся в массиве `s` на позициях с индексами `i` и `i + 1`. В результате получается сумма ASCII-кодов двух символов.

2. Выражение `v = s[i] + s[i+1]` в Python складывает два элемента массива (или строки) `s`, расположенные на соседних индексах `i` и `i+1`. Давайте разберем это по шагам: 

1. 
   - **`s[i]`** — это символ строки на позиции `i` (первый символ в паре).
   - **`s[i + 1]`** — это следующий символ строки на позиции `i + 1` (второй символ в паре).
   - **`+`** — оператор сложения. Он складывает значения ASCII-кодов этих двух символов.
   - Результат записывается в переменную `v5`.

2. 
   - **`s[i]`** — это элемент массива или символ строки `s`, который находится на позиции с индексом `i`.
   - **`s[i+1]`** — это следующий элемент массива или символ строки, находящийся на позиции с индексом `i+1`.
   - Оператор `+` выполняет сложение двух элементов. Если это числа — происходит арифметическое сложение, если это строки — конкатенация (объединение) символов.

**Пример:**

Допустим, строка (массив `s`) содержит следующие символы:

```c
s = "hello123..."
```

- **На первой итерации цикла**, когда `i = 0`:
    
    - `s[i] = 'h'` (ASCII-код 104)
    - `s[i+1] = 'e'` (ASCII-код 101)
    - Таким образом, `v5 = 104 + 101 = 205`.
- **На второй итерации**, когда `i = 1`:
    
    - `s[i] = 'e'` (ASCII-код 101)
    - `s[i+1] = 'l'` (ASCII-код 108)
    - Таким образом, `v5 = 101 + 108 = 209`.

```python
//Пример с числовым массивом

s = [1, 2, 3, 4]
i = 1
v = s[i] + s[i+1]  # s[1] + s[2] = 2 + 3 = 5
print(v)  # 5
```

```python
//Пример со строкой
s = "Hello"
i = 1
v = s[i] + s[i+1]  # 'e' + 'l' = 'el'
print(v)  # 'el'
```


**Логика проверки:**

Значение переменной `v5`, представляющее собой сумму двух соседних символов строки, сравнивается с соответствующим значением из массива `arr[i]`:

```c
if (v5 != arr[i])
```

Если сумма не совпадает с элементом массива `arr[i]`, программа завершает выполнение и выводит сообщение `"The window slams shut..."`.

**Зачем складывать символы?**

Такой механизм может использоваться для проверки "скрытого" пароля. Пароль не проверяется напрямую по символам, а проверяется через их суммы, что может усложнить нахождение правильного пароля методом прямого перебора.

Кроме того, сложение символов делает проверку менее очевидной, потому что один и тот же результат суммы может быть достигнут разными комбинациями символов.

**Вывод:**

Программа сравнивает введенную строку (пароль) с некоторыми эталонными значениями, которые хранятся в массиве `arr`. Эти значения задаются не в коде, а, возможно, где-то за кадром. Логика проверки основана на сумме двух последовательных символов строки пароля.

---

Из результата декомпиляции основной функции мы видим, что эта программа будет проверять пользовательский ввод, обрабатываемый с помощью `arr` множество. Код сравнивает сумму последовательных элементов в `s` массив из пользовательского ввода с соответствующими элементами в `arr` множество. Если в какой-то момент эти суммы не соответствуют значениям в `arr`, программа выводит сообщение об ошибке и завершает работу с кодом возврата -1.

![[Pasted image 20240915163403.png]]

Итак, нам просто нужно выполнить тот же процесс, что и программа. К счастью, мы знаем, что формат флага — `HTB{.*?}`, поэтому мы можем выполнить процесс, начав со значения ascii HTB (которое равно 72), а затем сначала вычесть `arr` индекс с ним. Результат можно использовать для вычитания второго `arr` индекс и так далее

```python
arr = [
    156, 150, 189, 175, 147, 195, 148,  96, 162, 209,
    194, 207, 156, 163, 166, 104, 148, 193, 215, 172,
    150, 147, 147, 214, 168, 159, 210, 148, 167, 214,
    143, 160, 163, 161, 163,  86, 158
]

size = len(arr)
a = 72
print(chr(a), end="")

for i in range(size):
    result = arr[i] - a
    print(chr(result), end="")
    a = result
```

Этот код создает строку на основе массива чисел, используя арифметические операции для преобразования значений массива в символы. Он начинается с начального значения переменной a = 72 (что соответствует символу 'H' в ASCII), а затем для каждого элемента массива выполняет вычитание этого значения из текущего элемента массива, преобразовывая полученное число в символ с помощью функции chr(). После каждого шага новое значение становится основой для следующего вычитания.

`result = arr[i] - a` вычитает текущее значение переменной `a` из элемента массива `arr[i]` на каждой итерации цикла. Это ключевой шаг в создании последовательности символов на основе значений массива.

Вот что происходит на каждой итерации:

1. `arr[i]` — это элемент массива с индексом `i`.
2. `a` — это текущее значение переменной, которая на первой итерации равна 72 (ASCII-код символа `'H'`), а затем обновляется на каждом шаге цикла.
3. Разница между текущим элементом массива и значением `a` (`arr[i] - a`) — это новое число, которое интерпретируется как ASCII-код символа с помощью функции `chr(result)`.

Таким образом, эта операция преобразует массив чисел в символы, где значение каждого символа зависит от разности между текущим элементом массива и предыдущим результатом (или начальным значением `a` в первой итерации).

Пример на первых двух итерациях:

- Инициализация: `a = 72` (что равно символу `'H'`).
- 1-я итерация: `result = arr[0] - a = 156 - 72 = 84`, что соответствует символу `'T'`.
- 2-я итерация: Теперь `a = 84`. Следующий шаг: `result = arr[1] - a = 150 - 84 = 66`, что соответствует символу `'B'`.

И так далее, пока весь массив не будет обработан.

Процесс вычитания `result = arr[i] - a` в твоем коде выполняется для преобразования значений числового массива в символы. Вот как это работает:

1. **`arr[i]`** — это текущий элемент массива на итерации `i`.
2. **`a`** — это значение, с которым мы вычитаем текущий элемент массива. Изначально это 72 (что соответствует символу `'H'` в ASCII), а затем переменная обновляется на каждом шаге.

Когда выполняется вычитание `arr[i] - a`, результат этого вычитания используется для получения нового символа через функцию `chr(result)`. Это основная операция, которая позволяет интерпретировать числа в массиве как последовательность символов.

**Причина вычитания:**

- Начальное значение `a = 72`, что соответствует символу `'H'`.
- На каждой итерации мы берем текущий элемент массива и уменьшаем его на `a`, чтобы получить новый символ.
- После этого переменная `a` обновляется для использования в следующей итерации.

**Пример:**

Допустим, на первой итерации:

- `arr[0] = 156`
- `a = 72`

```python
result = arr[0] - a = 156 - 72 = 84
```

84 — это ASCII-код символа `'T'`, так что `chr(84)` даст `'T'`.

На следующей итерации:

- Теперь `a = 84` (результат предыдущего шага).
- Следующий элемент массива `arr[1] = 150`.

Теперь:

```python
result = arr[1] - a = 150 - 84 = 66
```

66 — это ASCII-код символа `'B'`, и так далее.

Этот процесс позволяет поэтапно генерировать строку, где каждый новый символ зависит от разности между текущим элементом массива и результатом предыдущего шага.

Например `156` — это элемент массива `arr`. Массив в данном случае содержит последовательность чисел, которые позже преобразуются в символы через арифметические операции.

Число `156` — это один из элементов массива, и оно участвует в процессе вычитания для создания символов строки.

Пример:

1. На первой итерации цикла из этого числа вычитается значение переменной `a`, которая изначально равна 72.
    
```python
result = 156 - 72 = 84
```

2. Затем полученное значение `84` интерпретируется как ASCII-код символа `'T'` (потому что `chr(84)` вернет символ `'T'`).

Таким образом, число `156` — это одно из чисел, которые код использует для построения последовательности символов. В этой задаче каждое число в массиве участвует в создании следующего символа строки, и оно зависит от текущего значения переменной `a` на каждом шаге.

Мы можем проверить результат, попытавшись еще раз вставить его в файл Windows.

![[Pasted image 20240915163501.png]]

![[Pasted image 20240915163511.png]]

---

### Небольшой разгон по алгоритму 

И так у нас есть последовательность числел, мы их получили сложив символ на позиции `i` с символом на позиции `i+1`. Сами последовательность символов - это наш флаг.

#### Процесс шифровки флага 

1. Первое число это `156`, а флаг формат нашего флага `HTB{}`.

    - 72 - **H**
    - 84 - **T**
    - 72 + 84 = 156

Всё сходится)

2. Второе число `150`

    - 84 - **T**
    - 66 - **B**
    - 84 + 66 = **150**

И мы получаем `HTB`.
#### Процесс дешифровки

1. Насколько мы знаем, формат нашего флага `HTB{}`. Первый символ `H` - 72. Раз у нас `s[i] + s[i+i]`, а нам нужно ввести обратный процесс, то есть `s[i] - s[i+1]`.  

    - 72 - **H** 
    - **156** - Первое число в нашей последовательности
    - **156** - **72** = 84
    - 84 - **T**

2. **84** (ascii - T) - Результат вычитания **H** (ascii) от 156 (Первое число нашей последовательности).
     - **150** - Второе число в нашей последовательности
     - **150** - **84** = **66**
     - 66 - **B**

В результате получаем **HTB** и так делаем дешифровку флага. Как можно понять, процесс дешифровки начинается с символа **T**, ведь зная формат пароля мы сначала вычитаем **H** от **B** и т.д. 





