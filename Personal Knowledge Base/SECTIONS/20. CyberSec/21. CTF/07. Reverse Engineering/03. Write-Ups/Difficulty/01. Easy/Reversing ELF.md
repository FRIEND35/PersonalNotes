
**Плошадка:** https://tryhackme.com/
**Уровень:** Easy

# Crackme1

> Давайте начнем с базовой разминки, можете ли вы запустить двоичный файл?

Решение

После загрузки файла начните с базового анализа.  
Бег

```bash
file crackme1 
```

![[Pasted image 20230616141929.png]]

Используя следующую команду, я смог сделать данный файл ELF _crackme1_ исполняемым и получить флаг.

```Linux
// Linux command
$ chmod +x crackme1
$ ./crackme1
flag
```

![[Pasted image 20230616141957.png]]


# Crackme2

> Найдите сверхсекретный пароль! и используйте его, чтобы получить флаг

Решение

начать с:

```
file crackme2
```

мы делаем файл исполняемым, запустив chmod +x crackme2  
При запуске ./crackme2 мы видим, что он требует пароль.  

После создания исполняемого файла _carackme2_ мне было предложено ввести пароль после имени файла. Используя _команду strings_ , я смог найти пароль.

```Linux
// Linux command
$ chmod +x crackme2
$ strings crackme2
$ ./crackme2 super_secret_password
flag
```

![[Pasted image 20230616142221.png]]

# Crackme3

> Используйте базовые навыки реверс-инжиниринга, чтобы получить флаг

Решение

мы делаем тот же процесс, что и предыдущий, то есть запускаем файл и делаем исполняемый двоичный файл.  
запустите файл ./crackme3, чтобы посмотреть, что он делает.

![[Pasted image 20230616142345.png]]


Используя _команду strings_ еще раз, я смог найти строку в кодировке base64 и нашел флаг после ее декодирования. Для этого также требуется пароль, поэтому мы снова запускаем строки, возможно, нам повезет и на этот раз.


![[Pasted image 20230616142412.png]]

В строках мы видим строку, которая закодирована в base64, мы пытаемся ее декодировать. Вы можете использовать декодеры онлайн, например, [cyberchef.](https://gchq.github.io/CyberChef/) , вы также можете использовать base64 -d в терминале Linux, чтобы получить декодированный текст, например:

```Linux
/ Linux command
$ chmod +x crackme3
$ strings crackme3
$ echo "base64_encoded_string_here" | base64 -d
flag
```

![[Pasted image 20230616142635.png]]

# Crackme4

> Проанализировать и найти пароль от бинарника?

Решение

## Решение с ltrace

Дальше разбираемся другим способом. Другой метод, такой же, как и для строк, — это команда ltrace. Вы можете прочитать больше о ltrace [здесь](https://man7.org/linux/man-pages/man1/ltrace.1.html)  

так как мы получили подсказку, что строка скрыта в strcmp(strcmp() сравнивает две строки посимвольно. Если строки равны, функция возвращает 0.)

![[Pasted image 20230616143319.png]]

Мы находим наш флаг в функции strcmp.


## Решение с radare2

проще использовать **Radare2** Я считаю, что для этой задачи . _aaa_ — один из трех этапов, используемых для анализа двоичного кода и поиска строк и функций. _afl_ используется для перечисления всех функций; Я нашел _основную_ функцию здесь _pdf @"функция"_ используется для просмотра конкретной функции; Я нашел _compare.pwd_ , который используется для сравнения двух строк.

```Linux
// Linux command
$ r2 -d crackme4
$ aaa
$ afl
0x00400540    1 41           entry0
0x00400510    1 6            sym.imp.__libc_start_main
0x00400570    4 41           sym.deregister_tm_clones
0x004005a0    4 57           sym.register_tm_clones
0x004005e0    3 28           sym.__do_global_dtors_aux
0x00400600    4 45   -> 42   entry.init0
0x004007d0    1 2            sym.__libc_csu_fini
0x0040062d    4 77           sym.get_pwd
0x004007d4    1 9            sym._fini
0x0040067a    6 156          sym.compare_pwd
0x00400760    4 101          sym.__libc_csu_init
0x00400716    4 74           main                              <------------------ This is the "main" function
0x004004b0    3 26           sym._init
0x00400530    1 6            loc.imp.__gmon_start__
0x004004e0    1 6            sym.imp.puts
0x004004f0    1 6            sym.imp.__stack_chk_fail
0x00400500    1 6            sym.imp.printf
0x00400520    1 6            sym.imp.strcmp
$ pdf@main
            ; DATA XREF from entry0 @ 0x40055d
┌ 74: int main (int argc, char **argv, char **envp);
│           ; var int64_t var_10h @ rbp-0x10
│           ; var int64_t var_4h @ rbp-0x4
│           ; arg int argc @ rdi
│           ; arg char **argv @ rsi
│           0x00400716      55             push rbp
│           0x00400717      4889e5         mov rbp, rsp
│           0x0040071a      4883ec10       sub rsp, 0x10
│           0x0040071e      897dfc         mov dword [var_4h], edi     ; argc
│           0x00400721      488975f0       mov qword [var_10h], rsi    ; argv
│           0x00400725      837dfc02       cmp dword [var_4h], 2
│       ┌─< 0x00400729      741b           je 0x400746
│       │   0x0040072b      488b45f0       mov rax, qword [var_10h]
│       │   0x0040072f      488b00         mov rax, qword [rax]
│       │   0x00400732      4889c6         mov rsi, rax
│       │   0x00400735      bf10084000     mov edi, str.Usage_:__s_password_nThis_time_the_string_is_hidden_and_we_used_strcmp_n ; 0x400810 ; "Usage : %s password\nThis time the string is hidden and we used strcmp\n"                              
│       │   0x0040073a      b800000000     mov eax, 0
│       │   0x0040073f      e8bcfdffff     call sym.imp.printf         ; int printf(const char *format)                                                             
│      ┌──< 0x00400744      eb13           jmp 0x400759
│      │└─> 0x00400746      488b45f0       mov rax, qword [var_10h]
│      │    0x0040074a      4883c008       add rax, 8
│      │    0x0040074e      488b00         mov rax, qword [rax]
│      │    0x00400751      4889c7         mov rdi, rax
│      │    0x00400754      e821ffffff     call sym.compare_pwd       <---------- It compares rdi and rax where rax is the input we put. 
│      │    ; CODE XREF from main @ 0x400744
│      └──> 0x00400759      b800000000     mov eax, 0
│           0x0040075e      c9             leave
└           0x0040075f      c3             ret
$pdf@sym.compare_pwd
            ; CALL XREF from main @ 0x400754
┌ 156: sym.compare_pwd (int64_t arg1);
│           ; var int64_t var_28h @ rbp-0x28
│           ; var int64_t var_20h @ rbp-0x20
│           ; var int64_t var_18h @ rbp-0x18
│           ; var int64_t var_10h @ rbp-0x10
│           ; var int64_t var_eh @ rbp-0xe
│           ; var int64_t var_8h @ rbp-0x8
│           ; arg int64_t arg1 @ rdi
│           0x0040067a      55             push rbp
│           0x0040067b      4889e5         mov rbp, rsp
│           0x0040067e      4883ec30       sub rsp, 0x30
│           0x00400682      48897dd8       mov qword [var_28h], rdi    ; arg1
│           0x00400686      64488b042528.  mov rax, qword fs:[0x28]
│           0x0040068f      488945f8       mov qword [var_8h], rax
│           0x00400693      31c0           xor eax, eax
│           0x00400695      48b8495d7b49.  movabs rax, 0x7b175614497b5d49
│           0x0040069f      488945e0       mov qword [var_20h], rax
│           0x004006a3      48b857414751.  movabs rax, 0x547b175651474157
│           0x004006ad      488945e8       mov qword [var_18h], rax
│           0x004006b1      66c745f05340   mov word [var_10h], 0x4053  ; 'S@'
│           0x004006b7      c645f200       mov byte [var_eh], 0
│           0x004006bb      488d45e0       lea rax, [var_20h]
│           0x004006bf      4889c7         mov rdi, rax
│           0x004006c2      e866ffffff     call sym.get_pwd
│           0x004006c7      488b55d8       mov rdx, qword [var_28h]
│           0x004006cb      488d45e0       lea rax, [var_20h]
│           0x004006cf      4889d6         mov rsi, rdx
│           0x004006d2      4889c7         mov rdi, rax
│           0x004006d5      e846feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)                                                 
│           0x004006da      85c0           test eax, eax
│       ┌─< 0x004006dc      750c           jne 0x4006ea
│       │   0x004006de      bfe8074000     mov edi, str.password_OK    ; 0x4007e8 ; "password OK"                                                                   
│       │   0x004006e3      e8f8fdffff     call sym.imp.puts           ; int puts(const char *s)                                                                    
│      ┌──< 0x004006e8      eb16           jmp 0x400700
│      │└─> 0x004006ea      488b45d8       mov rax, qword [var_28h]
│      │    0x004006ee      4889c6         mov rsi, rax
│      │    0x004006f1      bff4074000     mov edi, str.password___s__not_OK_n ; 0x4007f4 ; "password \"%s\" not OK\n"                                              
│      │    0x004006f6      b800000000     mov eax, 0
│      │    0x004006fb      e800feffff     call sym.imp.printf         ; int printf(const char *format)                                                             
│      │    ; CODE XREF from sym.compare_pwd @ 0x4006e8
│      └──> 0x00400700      488b45f8       mov rax, qword [var_8h]
│           0x00400704      644833042528.  xor rax, qword fs:[0x28]
│       ┌─< 0x0040070d      7405           je 0x400714
│       │   0x0040070f      e8dcfdffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)                                                              
│       └─> 0x00400714      c9             leave
└           0x00400715      c3             ret

```

Теперь мне нужно знать, что такое rdi, и мне нужно установить точку останова по адресу где находится инструкция _move rdi, rax_ с помощью команды _db 0x004006d2_ до вызова функции strcmp для их сравнения. Сначала откройте программу в режиме отладчика с любым аргументом. _хорошо "что угодно"_ Затем установите точку останова и запустите с _постоянным током._ Наконец, проверьте значение rdi.

```Linux
// Linux command
$ood 'anything'
$db 0x004006d2
$dc
$px @rdi
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7fff24aba610  6d79 5f6d 3072 335f 7365 6375 7233 5f70                         <---- Answer
0x7fff24aba620  7764 0000 0000 0000 0065 6a8c 7e63 798f    .......ej.~cy.
```


## Решение с gdb

```bash
gdb CrackMe4
```

перечислите все функции в двоичном файле.

```
(gdb) info functions
```

![[Pasted image 20230616143522.png]]

Судя по отображаемому сообщению, эта функция сравнивает ввод приложения с паролем.

Установите точку останова в **strcmp@plt**

```bash
(gdb) b *0x0000000000400520
```

С установленной точкой останова теперь я могу запустить двоичный файл в **gdb** с некоторыми тестовыми входными данными.

![[Pasted image 20230616143616.png]]

Далее я могу просмотреть текущее состояние регистров с помощью gdb.

```
(gdb) info registers
```

![[Pasted image 20230616143647.png]]

Глядя на вывод выше, я вижу имя регистра, значение регистра в шестнадцатеричном формате и значение регистра в формате, который gdb считает наиболее подходящим (шестнадцатеричный для указателей, десятичный для остальных). Я вижу, что регистры общего назначения **rax** и **rdx** имеют значения адреса памяти. Я могу использовать gdb для печати строк по этим адресам.

![[Pasted image 20230616143710.png]]

# Crackme5

> Что будет входным файлом, чтобы получить вывод _Хорошая игра_ ?

Решение

## Решение с gdb

Для этого двоичного файла ELF мне поручено ввести некоторые данные, которые выведут сообщение **Good game** .

```bash
GDB CrackMe4
```

перечислите все функции в двоичном файле.

```bash
(gdb) info functions
```

![[Pasted image 20230616145217.png]]

В отличие от Crackme4, бинарник теперь использует strcmp_ вместо strcmp@plt.

```gdb
 b *0x00000000004006d6
 run
 info registers
```

![[Pasted image 20230616145327.png]]

Глядя на значения строки адреса памяти для регистров rax и rcx, я получаю необходимые данные для получения выходного сообщения «Хорошая игра».

чтение регистров **rax** и **rdx**. 

Если хотите посмотреть значнеие в формате ASCII:

```gdb
 х/с 0x7ffffffffdf50
 х/с 0x7ffffffffdf70
```

Если хотите посмотреть сами значение:

```gdb
х/s 0x7ffffffffdf50
х/s 0x7ffffffffdf70
```

![[Pasted image 20230616145401.png]]

Этот же подход можно использовать и с **функцией strcmp_** для извлечения флага.


## Решение с  radare2

Я **решил это с помощью Radare2** также . Я просмотрел _основную_ функцию и обнаружил, что вызывается _sym.strcmp__.

```Linux
// Linux command
$ pdf @sym.strcmp_
...
│           0x00400761      4889ce         mov rsi, rcx
│           0x00400764      4889c7         mov rdi, rax     <----- Need to set a breaking point here.
│           0x00400767      e8f4fdffff     call sym.imp.strncmp        ; int strnc 
...
$ db 0x00400764
$ dc
Enter your input:
Doesn't matter what you enter here. We just want to run the program.
hit breakpoint at 0x400764
```

Я попытался просмотреть содержимое файла rdi. Однако это был не ответ. Я попробовал другие переменные, и у меня сработал rsi. Ответ на самом деле также отображается в rdi, но его просто не было в первых двух строках.

```Linux
// Linux command
$ px @rsi
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7ffcbff88cf0  4f66 646c 4453 417c 3374 5862 3332 7e58                             <----- Answer                                
0x7ffcbff88d00  3374 5840 7358 6034 7458 747a 0000 0000              ....
```



## Решение с ltrace

Такая же старая процедура и с этим бинарником. Мы видим, что двоичный файл запрашивает ввод, скажем, мы вводим тест. мы получаем «Всегда копай глубже».  Попробуйте снова запустить ltrace и в качестве ввода введите test. Мы видим команду, необходимую для запуска в strncmp:

![[Pasted image 20230616150549.png]]

Снова запускаем бинарник с найденной строкой, получаем хорошую игру. Это означает, что мы нашли наш флаг.



# Crackme6

> Проанализируйте двоичный файл для простого пароля

Решение

Запуск двоичного файла ELF без пароля представляет сообщение, в котором мне предлагается посмотреть исходный код.

Для этой задачи я буду использовать [Ghidra](https://ghidra-sre.org/) , набор инструментов для обратного проектирования программного обеспечения (SRE). Я загрузил бинарный файл crackme6 в [Ghidra](https://ghidra-sre.org/) , который декомпилирует бинарный файл и предоставляет мне исходный код. Я начал с рассмотрения основной функции.

> Ghidra — один из многих проектов программного обеспечения с открытым исходным кодом (OSS), разработанных в рамках Агентства национальной безопасности. Полный исходный код Ghidra вместе с инструкциями по сборке добавлен в репозиторий. Пожалуйста, прочтите обновленное руководство ПО СОТРУДНИЧЕСТВУ, чтобы узнать больше о том, как вы можете присоединиться к сообществу.

Также можно использовать IDA и другие инструменты для решение данной задачи.

![[Pasted image 20230618041351.png]]

Я вижу, что входные данные, полученные для пароля, передаются функции с именем **compare_pwd** , исходный код которой можно увидеть ниже.

![[Pasted image 20230618041408.png]]

Эта функция берет пароль и передает его другой функции с именем **my_secure_test** . Взглянув на исходный код этой функции, вы обнаружите блок **операторов if else** , которые проверяют, соответствует ли каждая буква во входных данных **заданному строковому значению** .

![[Pasted image 20230618041423.png]]

Повторная сборка этих указанных строковых значений в одну строку дает флаг 1,3,3,7 и т. д.

На этот раз я использую другой инструмент под названием **Ghidra** , потому что мне было намного проще его понять. Независимо от того, используете ли вы **Ghidra** или **Radare2** , вы придете к одному и тому же выводу, что _функция main_ -> _функция compare_pwd_ -> _функция my_secure_test_ . Однако **Ghidra** сразу же декомпилирует код для вас.

![[Pasted image 20230618041600.png]]

Как показано на снимке экрана, это всего лишь набор операторов if, которые проверяют введенный символ за символом.
# Crackme7

> Проанализируйте двоичный файл, чтобы получить флаг

Решение

Глядя на исходный код функции main, я вижу, что введенное пользователем число проверяется операторами if else, а затем выполняет действие на основе введенного значения.

![[Pasted image 20230618044240.png]]

Эта опция запускает метод с именем **giveFlag()** , который я обнаружил скрытым. Мне нужно ввести **0x7a69** в десятичной форме, то есть **31337** , чтобы активировать эту опцию.

![[Pasted image 20230618044257.png]]
# Crackme8

> Проанализируйте двоичный файл, чтобы получить флаг

Решение

Это еще один двоичный файл ELF, который запрашивает пароль для получения флага. Я вижу, что ввод передается функции **atoi()** перед проверкой ввода, если он равен **-0x35010ff3** .

![[Pasted image 20230618050850.png]]

./crackme8 -889262067

![[Pasted image 20230618050922.png]]

---