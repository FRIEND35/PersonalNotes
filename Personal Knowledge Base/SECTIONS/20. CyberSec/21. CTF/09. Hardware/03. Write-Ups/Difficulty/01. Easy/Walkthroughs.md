# Photon Lockdown

Плошадка: https://www.hackthebox.com/
**Уровень:** Easy

**Описание**

Мы определили местоположение противника и теперь должны обеспечить доступ к их оптическому сетевому терминалу, чтобы отключить их интернет-соединение. К счастью, у нас есть копия прошивки устройства, в которой, вероятно, содержатся зашитые учетные данные. Можешь ли ты извлечь из нее пароль?

Когда вы разархивируете файл, вы увидите еще 3 файла:

```bash
$  ls   
fwu_ver  hw_ver  rootfs   
```

Пропробуем понять что это за файлы чтобы понять что нужно сними делать. Итак, мы хотим знать, какие файлы и какова их природа. Мы использовали команду «file».

```bash
$ file fwu_ver    
fwu_ver: ASCII text  

$ file hw_ver    
hw_ver: X1 archive data  

$ file rootfs    
rootfs: Squashfs filesystem, little endian, version 4.0, zlib compressed, 10936182 bytes, 910 inodes, blocksize: 131072 bytes, created: Sun Oct  1 07:02:43 2023  
```

- **fwu_ver** содержит некоторые сведения о версии встроенного программного обеспечения (прошивки устройства) **3.0.5**;
- **hw_ver** содержит некоторые данные, которые я не понял, скорее всего, это название прошивки **X1**;
- **rootfs** - это сжатый файл;

**Squashfs** — это сжатая файловая система для Linux, доступная только для чтения. Squashfs сжимает файлы, индексные дескрипторы и каталоги.

Мы знаем что у нас под рукой сжатая файловая система Squashfs, и у нас два варианта:

1. Монтировать образ и потом перейти к анализу файловой системы;
2. Использование утилиты **unsquashfs**;

unsquashfs - это утилита командной строки в операционной системе Linux, которая используется для извлечения содержимого файловых систем, упакованных в формат SquashFS.

Чтобы восстановить файловую систему до более читаемого формата, нам нужно **извлечь** файловую систему из **rootfs** . Поэтому мы можем использовать здесь утилиту squshfs, чтобы указать конкретную unsquashfs, которая извлечет все содержимое файла rootfs.

**Решение с помощью монтирование:**

Сначало монтируем файл в нужное нам место, это может быть любое место на ваше усмотрение:

```bash
$ mkdir /mnt/mountpoint
$ mount rootfs /mnt/mountpoint
```

Потом переходим в то место где был смонтирован файловая система:

```bash
$ cd /mnt/mountpoint
```

И дальше можно искать флаг.

**Решение с помощью unsquashfs:**

Запускаем команду:

```bash
sudo unsquashfs rootfs
```

Если мы хотим сохранить извлеченные данные в определённый каталог:

```bash
sudo unsquashfs -d /path rootfs
```

И дальше можно искать флаг.

**GREP**

После монтирование или извлечение данных с помощью **unsquashfs** мы должный попытаться найти флаг. Итак, наша цель — найти флаг, который представляет собой пароль в виде открытого текста.

Я решил найти флаг, я бы просто использовал команду **grep** , чтобы найти регулярное выражение **HTB** , поскольку именно с него начинаются флаги HackTheBox. Объединив команду **grep** с **-l** (список файлов, содержащих совпадения) и **-r** (рекурсивный режим для обхода каталогов), я обыскал всю файловую систему в поисках выражения, содержащего **HTB** , которое будет начальными символами флага вызова.

![[Pasted image 20240518142334.png]]

Это дало три совпадающих файла: bin/ip , bin/tc и etc/config_default.xml . Использование cat для первых двух не дало ничего, кроме нечитаемого машинного кода. Однако третий ( etc/config_default.xml ) был в открытом тексте.

![[Pasted image 20240518142351.png]]

Затем я решил снова использовать **grep** для **HTB** , передав вывод **cat** в **config_default.xml** .

![[Pasted image 20240518142404.png]]

В результате мы получили искомый флаг, а также ценную информацию для входа.

```bash
grep --include=*.{txt,xml,php,py,conf,yml} -rnw '.' -ie 'HTB' 2>/dev/null
```

![[Pasted image 20240518142607.png]]

![[Pasted image 20240518142640.png]]

![[Pasted image 20240518142720.png]]

![[Pasted image 20240518142730.png]]

Или максимально по простому:

```bash 
grep -r "HTB"
```

Исходя из этого можно сказать что, мы можем использовать разные фильтры для поиска флага.


---
# Debugging Interface

Плошадка: https://www.hackthebox.com/
**Уровень:** Easy

Этот задание наc учить тому что мы можем раскрыть любые данные подбирая нужные инструменты и работая с ними.

**Описание**

Мы получили доступ к асинхронному последовательному интерфейсу отладки встроенного устройства, пока оно работало, и перехватили некоторые сообщения, которые передавались через него. Вы можете расшифровать их?

**Шаг 1: Получите файл debugging_interface_signal.sal

Загрузите zip-файл с портала испытаний и разархивируйте его. Пароль `hackthebox`. Ты увидишь `debugging_interface_signal.sal`

**Шаг 2. Разархивируйте файл .sal

Я начал свой анализ, запустив `file`команда на `debugging_interface_signal.sal`. Это показало, что файл содержит некоторые архивные данные.

```
└─$ file debugging_interface_signal.sal                                                                
debugging_interface_signal.sal: Zip archive data, at least v2.0 to extract, compression method=deflate
```

При распаковке debugging_interface_signal.sal я получил два дополнительных файла:

```
digital-0.bin
meta.json
```

В meta.json была куча данных, но ни одна из них не казалась особенно полезной. 

Как видите, есть два дополнительных файла: мета.json и двоичный файл. Итак, я поискал это в ChatGPT и получил вот это

> **цифровой-0.bin:**

- **Структура имени:** ◇ «digital-0» предполагает, что этот файл может быть связан с цифровыми данными, а расширение «bin» обычно указывает на двоичный файл, то есть он содержит машиночитаемые данные, а не текст, читаемый человеком.
- **Возможное содержимое:** ◇ В этом файле может храниться цифровая информация, которая может включать двоичные данные, изображения, аудио или другие типы цифрового контента. Конкретный характер данных будет зависеть от контекста, в котором используется этот файл.

> **мета.json:**

- **Структура имени:** ▪ «мета» обычно обозначает метаданные, то есть данные, предоставляющие информацию о других данных. Расширение «.json» предполагает, что файл имеет формат JSON (нотация объектов JavaScript), упрощенный формат обмена данными.
- **Возможное содержимое:** ▪ Вероятно, этот файл содержит метаданные, связанные с другими файлами или системой. Метаданные могут включать такую ​​информацию, как дата создания файла, автор, сведения о формате файла или любую другую описательную информацию. Будучи в формате JSON, структура данных, скорее всего, будет состоять из пар ключ-значение.


Итак, я перешел к digital-0.bin.

**Шаг 3: Анализ digital-0.bin

В начале анализа я запустил `strings`команда, чтобы получить представление о том, что находится в файле. Сразу увидел интересный заголовок.

```
└─$ strings digital-0.bin | head
<SALEAE>
<snip>
```

Я использовал команду «strings» для извлечения удобочитаемых текстовых строк из двоичных файлов (digital-0.bin) и увидел, что первая строка была «SALEAE».

Я погуглил:

![[Pasted image 20240310160021.png]]

Я попал на сайт, предлагающий программное обеспечение для анализа данных, полученных со встроенных устройств. Итак, я скачал его.

![[Pasted image 20240310160035.png]]


**Шаг 4. Использование SALEAE Logic Analyzer

SALEAE — логический анализатор. Итак, я скачал демо и импортировал файл .sal.

Я перешел к анализатору SALEAE, нажал на `Async Serial`, и выбрано `00. Channel 0`в качестве входного канала. Именно тогда я обнаружил, что мне также нужно значение скорости передачи данных (бит/с).

![[Pasted image 20230220145159.png]]

Я рассчитал битрейт, перейдя к началу данных. Я навел указатель мыши на первый блок данных и увидел значение `32.02 µs`. Однако это микросекунды, а SALEAE нужны секунды. Итак, я разделил 1 000 000 на 32,02, чтобы получить `31230 Bit/s`.

![[Pasted image 20230220145213.png]]

Затем я ввел это в анализатор Async Serial с другими значениями по умолчанию и щелкнул `Save`.

![[Pasted image 20230220145225.png]]

Это расшифровало данные. Чтобы прочитать его в текстовом виде, нажмите на кнопку `Terminal`кнопка. Флаг находится внизу (на картинке не показан)!

![[Pasted image 20230220145238.png]]

Удачного взлома :)

---
