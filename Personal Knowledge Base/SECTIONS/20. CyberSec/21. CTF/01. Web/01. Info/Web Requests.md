
**Платформа:** https://academy.hackthebox.com
**Уровень:** Fundamental
# HTTP Fundamentals
## HyperText Transfer Protocol (HTTP)

Сегодня большинство приложений, которые мы используем, постоянно взаимодействуют с Интернетом, как веб-приложения, так и мобильные приложения. Большинство интернет-коммуникаций осуществляется с помощью веб-запросов по протоколу HTTP. [HTTP](https://tools.ietf.org/html/rfc2616) — это протокол уровня приложения, используемый для доступа к ресурсам Всемирной паутины. Термин `hypertext` означает текст, содержащий ссылки на другие ресурсы и текст, который читатели могут легко интерпретировать.

HTTP-связь состоит из клиента и сервера, где клиент запрашивает у сервера ресурс. Сервер обрабатывает запросы и возвращает запрошенный ресурс. Порт по умолчанию для HTTP-связи — порт `80`, хотя его можно изменить на любой другой порт, в зависимости от конфигурации веб-сервера. Те же запросы используются, когда мы используем Интернет для посещения разных веб-сайтов. Мы вводим `Fully Qualified Domain Name` ( `FQDN`) как `Uniform Resource Locator` ( `URL`), чтобы перейти на нужный веб-сайт, например [www.hackthebox.com](http://www.hackthebox.com) .
### URL

Доступ к ресурсам через HTTP осуществляется через `URL`, который предлагает гораздо больше возможностей, чем просто указание веб-сайта, который мы хотим посетить. Давайте посмотрим на структуру URL:

![[Pasted image 20240803022451.png]]

Вот что означает каждый компонент:

|**Компонент**|**Пример**|**Описание**|
|---|---|---|
|`Scheme`|`http://` `https://`|Он используется для идентификации протокола, к которому обращается клиент, и заканчивается двоеточием и двойной косой чертой ( `://`)|
|`User Info`|`admin:password@`|Это необязательный компонент, который содержит учетные данные (разделенные двоеточием). `:`) используется для аутентификации на хосте и отделяется от хоста знаком ( `@`)|
|`Host`|`inlanefreight.com`|Хост означает расположение ресурса. Это может быть имя хоста или IP-адрес.|
|`Port`|`:80`|The `Port` отделен от `Host` через двоеточие ( `:`). Если порт не указан, `http` схемы по умолчанию для порта `80` и `https` по умолчанию порт `443`|
|`Path`|`/dashboard.php`|Это указывает на ресурс, к которому осуществляется доступ, который может быть файлом или папкой. Если путь не указан, сервер возвращает индекс по умолчанию (например, `index.html`).|
|`Query String`|`?login=true`|Строка запроса начинается со знака вопроса ( `?`) и состоит из параметра (например, `login`) и значение (например, `true`). Несколько параметров могут быть разделены амперсандом ( `&`).|
|`Fragments`|`#status`|Фрагменты обрабатываются браузерами на стороне клиента для поиска разделов основного ресурса (например, заголовка или раздела на странице).|

Не все компоненты необходимы для доступа к ресурсу. Основными обязательными полями являются схема и хост, без которых в запросе не будет ресурса для запроса.

### HTTP Flow

![[Pasted image 20240803022524.png]]

На диаграмме выше представлена ​​анатомия HTTP-запроса на очень высоком уровне. Когда пользователь впервые вводит URL-адрес ( `inlanefreight.com`) в браузер, он отправляет запрос на DNS-сервер (разрешение доменных имен) для разрешения домена и получения его IP-адреса. DNS-сервер ищет IP-адрес для `inlanefreight.com`и возвращает его. Все доменные имена должны быть разрешены таким образом, поскольку сервер не может обмениваться данными без IP-адреса.

**Примечание.** Наши браузеры обычно сначала просматривают записи в локальном ' `/etc/hosts`' файл, и если запрошенный домен не существует в нем, они будут обращаться к другим DNS-серверам. Мы можем использовать ' `/etc/hosts`', чтобы вручную добавить записи для разрешения DNS, добавив IP-адрес, а затем имя домена.

Как только браузер получает IP-адрес, связанный с запрошенным доменом, он отправляет запрос GET на HTTP-порт по умолчанию (например, `80`), просит рут `/`путь. Затем веб-сервер получает запрос и обрабатывает его. По умолчанию серверы настроены на возврат индексного файла при запросе `/` получено.

В этом случае содержимое `index.html`считываются и возвращаются веб-сервером в виде ответа HTTP. Ответ также содержит код состояния (например, `200 OK`), что означает, что запрос успешно обработан. Затем веб-браузер отображает `index.html` содержимое и представляет его пользователю.

**Примечание.** Этот модуль в основном ориентирован на веб-запросы HTTP. Дополнительную информацию о HTML и веб-приложениях можно найти в [модуле «Введение в веб-приложения»](https://academy.hackthebox.com/module/details/75) .
### cURL

В этом модуле мы будем отправлять веб-запросы через два наиболее важных инструмента для любого веб-тестера на проникновение: веб-браузер, такой как Chrome или Firefox, и `cURL` инструмент командной строки.

[cURL](https://curl.haxx.se/) (URL-адрес клиента) — это инструмент и библиотека командной строки, которая в основном поддерживает HTTP наряду со многими другими протоколами. Это делает его хорошим кандидатом для сценариев, а также для автоматизации, что делает его необходимым для отправки различных типов веб-запросов из командной строки, что необходимо для многих типов веб-тестов на проникновение.

Мы можем отправить базовый HTTP-запрос на любой URL-адрес, используя его в качестве аргумента для cURL,

```shell-session
Uliam@htb[/htb]$ curl inlanefreight.com

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
...SNIP...
```


Мы видим, что cURL не отображает код HTML/JavaScript/CSS, в отличие от веб-браузера, а печатает его в необработанном формате. Однако, как тестировщиков на проникновение, нас в основном интересует контекст запросов и ответов, который обычно становится намного быстрее и удобнее, чем веб-браузер.

Мы также можем использовать cURL для загрузки страницы или файла и вывода содержимого в файл с помощью `-O`флаг. Если мы хотим указать имя выходного файла, мы можем использовать `-o`флаг и укажите имя. В противном случае мы можем использовать `-O` и cURL будет использовать имя удаленного файла следующим образом:

Протокол передачи гипертекста (HTTP)

```shell-session
Uliam@htb[/htb]$ curl -O inlanefreight.com/index.html
Uliam@htb[/htb]$ ls
index.html
```

Как мы видим, на этот раз выходные данные не были распечатаны, а сохранены в `index.html`. Мы заметили, что cURL по-прежнему отображает некоторый статус при обработке запроса. Мы можем отключить статус с помощью `-s` флаг следующим образом:

Протокол передачи гипертекста (HTTP)

```shell-session
Uliam@htb[/htb]$ curl -s -O inlanefreight.com/index.html
```

На этот раз cURL ничего не печатал, так как выходные данные были сохранены в файле. `index.html`файл. Наконец, мы можем использовать `-h` флаг, чтобы увидеть, какие еще параметры мы можем использовать с cURL:

Протокол передачи гипертекста (HTTP)

```shell-session
Uliam@htb[/htb]$ curl -h
Usage: curl [options...] <url>
 -d, --data <data>   HTTP POST data
 -h, --help <category> Get help for commands
 -i, --include       Include protocol response headers in the output
 -o, --output <file> Write to file instead of stdout
 -O, --remote-name   Write output to a file named as the remote file
 -s, --silent        Silent mode
 -u, --user <user:password> Server user and password
 -A, --user-agent <name> Send User-Agent <name> to server
 -v, --verbose       Make the operation more talkative

This is not the full help, this menu is stripped into categories.
Use "--help category" to get an overview of all categories.
Use the user manual `man curl` or the "--help all" flag for all options.
```

Как упоминается в приведенном выше сообщении, мы можем использовать `--help all` чтобы распечатать более подробное меню справки, или `--help category` (например `-h http`), чтобы распечатать подробную справку по конкретному флагу. Если нам когда-нибудь понадобится прочитать более подробную документацию, мы можем использовать `man curl` чтобы просмотреть полную страницу руководства cURL.

В следующих разделах мы рассмотрим большинство из вышеперечисленных флагов и увидим, где следует использовать каждый из них.
### Questions

Чтобы получить флаг, запустите приведенное выше упражнение, затем используйте cURL для загрузки файла, возвращенного '/download.php' на показанном выше сервере.

Первая задача требует от нас загрузить файл, возвращаемый `/download.php`конечная точка на сервере. Мы можем добиться этого с помощью команды cURL:

```
curl http://94.237.56.140:38820/download.php    
HTB{64$!c_cURL_u$3r}%
```

---

## Hypertext Transfer Protocol Secure (HTTPS)

В предыдущем разделе мы обсудили, как отправляются и обрабатываются HTTP-запросы. Однако одним из существенных недостатков HTTP является то, что все данные передаются в виде открытого текста. Это означает, что любой, кто находится между источником и пунктом назначения, может выполнить атаку «Человек посередине» (MiTM) для просмотра переданных данных.

Чтобы решить эту проблему, [был создан протокол HTTPS (HTTP Secure)](https://tools.ietf.org/html/rfc2660) , в котором все сообщения передаются в зашифрованном формате, поэтому даже если третья сторона перехватит запрос, она не сможет извлечь из него данные. По этой причине HTTPS стал основной схемой для веб-сайтов в Интернете, а HTTP постепенно вытесняется, и вскоре большинство веб-браузеров не позволят посещать веб-сайты HTTP.

### HTTPS Overview

Если мы рассмотрим HTTP-запрос, мы увидим эффект отсутствия обеспечения безопасной связи между веб-браузером и веб-приложением. Например, следующее содержимое HTTP-запроса на вход:

![[Pasted image 20240803023553.png]]

Мы видим, что учетные данные для входа можно просмотреть в виде открытого текста. Это облегчит кому-либо в той же сети (например, общедоступной беспроводной сети) перехват запроса и повторное использование учетных данных в злонамеренных целях.

Напротив, когда кто-то перехватывает и анализирует трафик HTTPS-запроса, он увидит что-то вроде следующего:

![[Pasted image 20240803023608.png]]

Как мы видим, данные передаются в виде единого зашифрованного потока, что очень затрудняет перехват информации, такой как учетные данные или любые другие конфиденциальные данные.

Веб-сайты, использующие HTTPS, можно идентифицировать по `https://` в их URL-адресе (например, https://www.google.com), а также значке замка в адресной строке веб-браузера слева от URL-адреса:

![[Pasted image 20240803023622.png]]

Итак, если мы посетим веб-сайт, использующий HTTPS, например Google, весь трафик будет зашифрован.

**Примечание.** Хотя данные, передаваемые по протоколу HTTPS, могут быть зашифрованы, запрос все равно может раскрыть посещенный URL-адрес, если он обратился к DNS-серверу с открытым текстом. По этой причине рекомендуется использовать зашифрованные DNS-серверы (например, 8.8.8.8 или 1.1.1.1) или использовать службу VPN, чтобы обеспечить правильное шифрование всего трафика.

---
### HTTPS Flow

Давайте посмотрим, как работает HTTPS на высоком уровне:

![[Pasted image 20240803023702.png]]

Если мы напечатаем `http://` вместо `https://`Чтобы посетить веб-сайт, поддерживающий HTTPS, браузер пытается разрешить домен и перенаправляет пользователя на веб-сервер, на котором размещен целевой веб-сайт. Запрос отправляется в порт `80`во-первых, это незашифрованный протокол HTTP. Сервер обнаруживает это и перенаправляет клиента на защищенный порт HTTPS. `443`вместо. Это делается через `301 Moved Permanently` код ответа, который мы обсудим в следующем разделе.

Далее клиент (веб-браузер) отправляет пакет «client hello», предоставляющий информацию о себе. После этого сервер отвечает «Привет серверу», после чего происходит [обмен ключами](https://en.wikipedia.org/wiki/Key_exchange) для обмена SSL-сертификатами. Клиент проверяет ключ/сертификат и отправляет свой собственный. После этого инициируется зашифрованное [рукопожатие,](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake) чтобы подтвердить, правильно ли работают шифрование и передача.

После успешного завершения рукопожатия продолжается нормальное HTTP-соединение, которое после этого шифруется. Это очень общий обзор обмена ключами, который выходит за рамки данного модуля.

**Примечание.** В зависимости от обстоятельств злоумышленник может выполнить атаку с понижением версии HTTP, в результате которой связь HTTPS понижается до HTTP, в результате чего данные передаются в виде открытого текста. Это делается путем настройки прокси-сервера «Человек посередине» (MITM) для передачи всего трафика через хост злоумышленника без ведома пользователя. Однако большинство современных браузеров, серверов и веб-приложений защищают от этой атаки.

### cURL for HTTPS

cURL должен автоматически обрабатывать все стандарты связи HTTPS и выполнять безопасное рукопожатие, а затем автоматически шифровать и расшифровывать данные. Однако если мы когда-либо свяжемся с веб-сайтом с недействительным или устаревшим сертификатом SSL, то cURL по умолчанию не продолжит связь для защиты от ранее упомянутых атак MITM:

Безопасный протокол передачи гипертекста (HTTPS)

```shell-session
Uliam@htb[/htb]$ curl https://inlanefreight.com

curl: (60) SSL certificate problem: Invalid certificate chain
More details here: https://curl.haxx.se/docs/sslcerts.html
...SNIP...
```

Современные веб-браузеры будут делать то же самое, предупреждая пользователя о необходимости посещения веб-сайта с недействительным сертификатом SSL.

Мы можем столкнуться с такой проблемой при тестировании локального веб-приложения или веб-приложения, размещенного в практических целях, поскольку такие веб-приложения могут еще не внедрить действительный сертификат SSL. Чтобы пропустить проверку сертификата с помощью cURL, мы можем использовать `-k` флаг:

Безопасный протокол передачи гипертекста (HTTPS)

```shell-session
Uliam@htb[/htb]$ curl -k https://inlanefreight.com

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
...SNIP...
```

Как мы видим, запрос на этот раз прошел, и мы получили данные ответа.

---

## HTTP Requests and Responses

HTTP-коммуникации в основном состоят из HTTP-запроса и HTTP-ответа. HTTP-запрос делается клиентом (например, cURL/браузером) и обрабатывается сервером (например, веб-сервером). Запросы содержат всю информацию, которую мы требуем от сервера, включая ресурс (например, URL-адрес, путь, параметры), любые данные запроса, заголовки или параметры, которые мы указываем, а также многие другие параметры, которые мы обсудим в этом модуле.

Как только сервер получает HTTP-запрос, он обрабатывает его и отвечает, отправляя HTTP-ответ, который содержит код ответа, как обсуждается в следующем разделе, и может содержать данные ресурса, если запрашивающая сторона имеет к ним доступ.

### HTTP Request

Начнем с рассмотрения следующего примера HTTP-запроса:

![[Pasted image 20240803034232.png]]

На изображении выше показан HTTP-запрос GET к URL-адресу:

- `http://inlanefreight.com/users/login.html`

Первая строка любого HTTP-запроса содержит три основных поля, разделенных пробелами:

|**Поле**|**Пример**|**Описание**|
|---|---|---|
|`Method`|`GET`|Метод или команда HTTP, определяющая тип выполняемого действия.|
|`Path`|`/users/login.html`|Путь к ресурсу, к которому осуществляется доступ. К этому полю также можно добавить строку запроса (например, `?username=user`).|
|`Version`|`HTTP/1.1`|Третье и последнее поле используется для обозначения версии HTTP.|

Следующий набор строк содержит пары значений HTTP-заголовка, например `Host`, `User-Agent`, `Cookie`и многие другие возможные заголовки. Эти заголовки используются для указания различных атрибутов запроса. Заголовки завершаются новой строкой, которая необходима серверу для проверки запроса. Наконец, запрос может заканчиваться телом запроса и данными.

**Примечание.** HTTP версии 1.X отправляет запросы в виде открытого текста и использует символ новой строки для разделения различных полей и разных запросов. С другой стороны, HTTP версии 2.X отправляет запросы в виде двоичных данных в словарной форме.

### HTTP Response

Как только сервер обрабатывает наш запрос, он отправляет ответ. Ниже приведен пример HTTP-ответа:

![[Pasted image 20240803034325.png]]

Первая строка ответа HTTP содержит два поля, разделенные пробелами. Первым из них является `HTTP version` (например `HTTP/1.1`), а второй обозначает `HTTP response code` (например `200 OK`).

Коды ответов используются для определения статуса запроса, как будет описано в следующем разделе. После первой строки в ответе перечислены заголовки, аналогично HTTP-запросу. Заголовки запроса и ответа обсуждаются в следующем разделе.

Наконец, ответ может заканчиваться телом ответа, которое отделяется новой строкой после заголовков. Тело ответа обычно определяется как `HTML`код. Однако он также может отвечать другими типами кода, такими как `JSON`, ресурсы веб-сайта, такие как изображения, таблицы стилей или сценарии, или даже документ, например PDF-документ, размещенный на веб-сервере.

### cURL

В наших предыдущих примерах с cURL мы указывали только URL-адрес и получали взамен тело ответа. Однако cURL также позволяет нам просмотреть полный HTTP-запрос и полный HTTP-ответ, что может оказаться очень полезным при выполнении тестов на проникновение в Интернет или написании эксплойтов. Чтобы просмотреть полный HTTP-запрос и ответ, мы можем просто добавить `-v` подробный флаг для наших предыдущих команд, и он должен печатать как запрос, так и ответ:

HTTP-запросы и ответы

```shell-session
Uliam@htb[/htb]$ curl inlanefreight.com -v

*   Trying SERVER_IP:80...
* TCP_NODELAY set
* Connected to inlanefreight.com (SERVER_IP) port 80 (#0)
> GET / HTTP/1.1
> Host: inlanefreight.com
> User-Agent: curl/7.65.3
> Accept: */*
> Connection: close
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 401 Unauthorized
< Date: Tue, 21 Jul 2020 05:20:15 GMT
< Server: Apache/X.Y.ZZ (Ubuntu)
< WWW-Authenticate: Basic realm="Restricted Content"
< Content-Length: 464
< Content-Type: text/html; charset=iso-8859-1
< 
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>

...SNIP...
```

Как мы видим, на этот раз мы получаем полный HTTP-запрос и ответ. Запрос просто отправлен `GET / HTTP/1.1` вместе с `Host`, `User-Agent` и `Accept`заголовки. В свою очередь, ответ HTTP содержал `HTTP/1.1 401 Unauthorized`, что указывает на то, что у нас нет доступа к запрошенному ресурсу, как мы увидим в следующем разделе. Подобно запросу, ответ также содержал несколько заголовков, отправленных сервером, в том числе `Date`, `Content-Length`, и `Content-Type`. Наконец, ответ содержал тело ответа в формате HTML, то же самое, которое мы получали ранее при использовании cURL без `-v` флаг.

**:** Упражнение `-vvv`flag показывает еще более подробный вывод. Попробуйте использовать этот флаг, чтобы увидеть, какие дополнительные сведения о запросе и ответе отображаются с ним.

### Browser DevTools

Большинство современных веб-браузеров оснащены встроенными инструментами разработчика ( `DevTools`), которые в основном предназначены для разработчиков, тестирующих свои веб-приложения. Однако, как веб-тестерам на проникновение, эти инструменты могут быть жизненно важным активом в любой веб-оценке, которую мы проводим, поскольку браузер (и его DevTools) входят в число активов, которые мы, скорее всего, будем иметь в каждом упражнении по веб-оценке. В этом модуле мы также обсудим, как использовать некоторые базовые инструменты разработки браузера для оценки и мониторинга различных типов веб-запросов.

Всякий раз, когда мы посещаем какой-либо веб-сайт или обращаемся к любому веб-приложению, наш браузер отправляет несколько веб-запросов и обрабатывает несколько HTTP-ответов, чтобы отобразить окончательное представление, которое мы видим в окне браузера. Чтобы открыть инструменты разработчика браузера в Chrome или Firefox, мы можем нажать [ `CTRL+SHIFT+I`] или просто нажмите [ `F12`]. Инструменты разработчика содержат несколько вкладок, каждая из которых используется по-своему. В основном мы сосредоточимся на `Network` в этом модуле, так как он отвечает за веб-запросы.

Если мы щелкнем вкладку «Сеть» и обновим страницу, мы сможем увидеть список запросов, отправленных страницей:

![[Pasted image 20240803034419.png]]

Как мы видим, инструменты разработчика сразу показывают нам статус ответа (т. е. код ответа), используемый метод запроса ( `GET`), запрошенный ресурс (т. е. URL/домен), а также запрошенный путь. Кроме того, мы можем использовать `Filter URLs` для поиска конкретного запроса на случай, если веб-сайт загружает слишком много запросов, чтобы их можно было пройти.

**Упражнение:** попробуйте нажать на любой из запросов, чтобы просмотреть его подробную информацию. Затем вы можете нажать на `Response` вкладку, чтобы просмотреть текст ответа, а затем нажмите кнопку `Raw` Кнопка для просмотра необработанного (необработанного) исходного кода тела ответа.

### Questions

Чтобы выполнить третье задание, мы должны определить версию Apache сервера, просмотрев заголовки ответов. Мы можем сделать это, выполнив вызов GET на сервер и просмотрев заголовки возврата. Задача предполагает перехват запроса и определение используемого метода HTTP. Выполнив следующую команду cURL, мы можем проверить заголовок запроса и его ответа. Можно использовать curl, инструменты разработчика браузера или любой другой инструмент для просмотра http-запросов

```
curl 165.22.127.181:30029 -v  
*   Trying 165.22.127.181:30029...  
* Connected to 165.22.127.181 (165.22.127.181) port 30029 (#0)  
> GET / HTTP/1.1  
> Host: 165.22.127.181:30029  
> User-Agent: curl/7.88.1  
> Accept: */*  
>   
< HTTP/1.1 200 OK  
< Date: Fri, 07 Jul 2023 11:46:11 GMT  
< Server: Apache/2.4.41 (Ubuntu)  
< Vary: Accept-Encoding  
< Content-Length: 348  
< Content-Type: text/html; charset=UTF-8  
<   
<!DOCTYPE html>  
<html lang="en">  
  
<head>  
    <meta charset="UTF-8">  
    <meta http-equiv="X-UA-Compatible" content="IE=edge">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Blank Page</title>  
</head>  
  
<body>  
    This page is intentionally left blank.  
    <br>  
    Using cURL should be enough.  
</body>  
  
* Connection #0 to host 165.22.127.181 left intact  
</html>
```

1. Какой метод HTTP используется при перехвате запроса? (с учетом регистра)

```
GET
```

2. Отправьте запрос GET на указанный выше сервер и прочитайте заголовки ответа, чтобы найти версию Apache, работающую на сервере, а затем отправьте ее в качестве ответа. (формат ответа: XYZZ)

```
2.4.41
```

---

## HTTP Headers

В предыдущем разделе мы видели примеры HTTP-запросов и заголовков ответов. Такие заголовки HTTP передают информацию между клиентом и сервером. Некоторые заголовки используются только с запросами или ответами, тогда как некоторые другие общие заголовки являются общими для обоих.

Заголовки могут иметь одно или несколько значений, добавляемых после имени заголовка и разделенных двоеточием. Мы можем разделить заголовки на следующие категории:

1. `General Headers`
2. `Entity Headers`
3. `Request Headers`
4. `Response Headers`
5. `Security Headers`

Давайте обсудим каждую из этих категорий.

### General Headers

[Общие заголовки](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html) используются как в HTTP-запросах, так и в ответах. Они контекстуальны и используются для `describe the message rather than its contents`.

|**Заголовок**|**Пример**|**Описание**|
|---|---|---|
|`Date`|`Date: Wed, 16 Feb 2022 10:38:44 GMT`|Содержит дату и время создания сообщения. Предпочтительно преобразовать время в стандартный [часовой пояс UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time) .|
|`Connection`|`Connection: close`|Определяет, должно ли текущее сетевое соединение оставаться активным после завершения запроса. Два часто используемых значения для этого заголовка: `close` и `keep-alive`. `close` значение либо от клиента, либо от сервера означает, что они хотели бы разорвать соединение, в то время как значение `keep-alive` заголовок указывает, что соединение должно оставаться открытым для получения дополнительных данных и входных данных.|
### Entity Headers

Подобно общим заголовкам, [заголовки сущностей](https://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html) могут быть `common to both the request and response`. Эти заголовки используются для `describe the content`(сущность), передаваемая сообщением. Обычно их можно найти в ответах и ​​запросах POST или PUT.

| **Заголовок**      | **Пример**                    | **Описание**                                                                                                                                                                                                                                                  |
| ------------------ | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Content-Type`     | `Content-Type: text/html`     | Используется для описания типа передаваемого ресурса. Значение автоматически добавляется браузерами на стороне клиента и возвращается в ответе сервера. `charset` Поле обозначает стандарт кодировки, например [UTF-8](https://en.wikipedia.org/wiki/UTF-8) . |
| `Media-Type`       | `Media-Type: application/pdf` | The `media-type` похож на `Content-Type`и описывает передаваемые данные. Этот заголовок может сыграть решающую роль в том, чтобы сервер интерпретировал наши входные данные. `charset` Поле также может использоваться с этим заголовком.                     |
| `Boundary`         | `boundary="b4e4fbd93540"`     | Действует как маркер для разделения контента, если в одном сообщении их несколько. Например, в данных формы эта граница используется как `--b4e4fbd93540` для разделения различных частей формы.                                                              |
| `Content-Length`   | `Content-Length: 385`         | Содержит размер передаваемого объекта. Этот заголовок необходим, поскольку сервер использует его для чтения данных из тела сообщения и автоматически генерируется браузером и такими инструментами, как cURL.                                                 |
| `Content-Encoding` | `Content-Encoding: gzip`      | Перед передачей данные могут подвергаться множественным преобразованиям. Например, большие объемы данных можно сжать, чтобы уменьшить размер сообщения. Тип используемой кодировки следует указывать с помощью `Content-Encoding` заголовок.                  |
### Request Headers

Клиент отправляет [заголовки запроса](https://tools.ietf.org/html/rfc2616) в HTTP-транзакции. Эти заголовки `used in an HTTP request and do not relate to the content`сообщения. Следующие заголовки обычно встречаются в HTTP-запросах.

| **Заголовок**   | **Пример**                               | **Описание**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------- | ---------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`          | `Host: www.inlanefreight.com`            | Используется для указания хоста, к которому запрашивается ресурс. Это может быть доменное имя или IP-адрес. HTTP-серверы можно настроить для размещения различных веб-сайтов, которые отображаются на основе имени хоста. Это делает заголовок хоста важной целью перечисления, поскольку он может указывать на существование других хостов на целевом сервере.                                                                                                                                             |
| `User-Agent`    | `User-Agent: curl/7.77.0`                | The `User-Agent`заголовок используется для описания клиента, запрашивающего ресурсы. Этот заголовок может многое рассказать о клиенте, например о браузере, его версии и операционной системе.                                                                                                                                                                                                                                                                                                              |
| `Referer`       | `Referer: http://www.inlanefreight.com/` | Обозначает источник текущего запроса. Например, щелчок по ссылке из результатов поиска Google приведет к `https://google.com`реферер. Доверять этому заголовку может быть опасно, поскольку им легко манипулировать, что приводит к непредвиденным последствиям.                                                                                                                                                                                                                                            |
| `Accept`        | `Accept: */*`                            | The `Accept`заголовок описывает, какие типы мультимедиа может понять клиент. Он может содержать несколько типов мультимедиа, разделенных запятыми. `*/*` значение означает, что принимаются все типы носителей.                                                                                                                                                                                                                                                                                             |
| `Cookie`        | `Cookie: PHPSESSID=b4e4fbd93540`         | Содержит пары cookie-значений в формате `name=value`. Файл [cookie](https://en.wikipedia.org/wiki/HTTP_cookie) — это часть данных, хранящаяся на стороне клиента и на сервере, которая действует как идентификатор. Они передаются на сервер по запросу, тем самым сохраняя доступ клиента. Файлы cookie также могут служить другим целям, например, для сохранения пользовательских настроек или отслеживания сеансов. В одном заголовке может быть несколько файлов cookie, разделенных точкой с запятой. |
| `Authorization` | `Authorization: BASIC cGFzc3dvcmQK`      | Еще один метод идентификации клиентов сервером. После успешной аутентификации сервер возвращает уникальный для клиента токен. В отличие от файлов cookie, токены хранятся только на стороне клиента и извлекаются сервером по запросу. Существует несколько типов аутентификации в зависимости от используемого веб-сервера и типа приложения.                                                                                                                                                              |
Полный список заголовков запроса и их использование можно найти [здесь](https://tools.ietf.org/html/rfc7231#section-5) .

### Response Headers

[Заголовки ответов](https://tools.ietf.org/html/rfc7231#section-6) могут быть `used in an HTTP response and do not relate to the content`. Определенные заголовки ответов, такие как `Age`, `Location`, и `Server`используются для предоставления большего контекста ответа. Следующие заголовки обычно встречаются в ответах HTTP.

|**Заголовок**|**Пример**|**Описание**|
|---|---|---|
|`Server`|`Server: Apache/2.2.14 (Win32)`|Содержит информацию о HTTP-сервере, обработавшем запрос. Его можно использовать для получения информации о сервере, например его версии, и дальнейшего его перечисления.|
|`Set-Cookie`|`Set-Cookie: PHPSESSID=b4e4fbd93540`|Содержит файлы cookie, необходимые для идентификации клиента. Браузеры анализируют файлы cookie и сохраняют их для будущих запросов. Этот заголовок имеет тот же формат, что и `Cookie` заголовок запроса.|
|`WWW-Authenticate`|`WWW-Authenticate: BASIC realm="localhost"`|Уведомляет клиента о типе аутентификации, необходимой для доступа к запрошенному ресурсу.|

---

### Security Headers

Наконец, у нас есть [заголовки безопасности](https://owasp.org/www-project-secure-headers/) . С увеличением разнообразия браузеров и веб-атак стало необходимо определять определенные заголовки, повышающие безопасность. Заголовки безопасности HTTP `a class of response headers used to specify certain rules and policies` которые будут отслеживаться браузером при доступе к веб-сайту.

|**Заголовок**|**Пример**|**Описание**|
|---|---|---|
|`Content-Security-Policy`|`Content-Security-Policy: script-src 'self'`|Определяет политику веб-сайта в отношении внешних ресурсов. Это может быть код JavaScript, а также ресурсы скрипта. Этот заголовок указывает браузеру принимать ресурсы только из определенных доверенных доменов, что предотвращает такие атаки, как [межсайтовый скриптинг (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) .|
|`Strict-Transport-Security`|`Strict-Transport-Security: max-age=31536000`|Запрещает браузеру доступ к веб-сайту по протоколу HTTP в виде открытого текста и заставляет все коммуникации передаваться по защищенному протоколу HTTPS. Это не позволяет злоумышленникам перехватывать веб-трафик и получать доступ к защищенной информации, такой как пароли или другие конфиденциальные данные.|
|`Referrer-Policy`|`Referrer-Policy: origin`|Определяет, должен ли браузер включать значение, указанное с помощью `Referer`заголовок или нет. Это может помочь избежать раскрытия конфиденциальных URL-адресов и информации при просмотре веб-сайта.|

**Примечание.** В этом разделе упоминается только небольшое подмножество часто встречающихся заголовков HTTP. Существует множество других контекстных заголовков, которые можно использовать в HTTP-коммуникациях. Приложения также могут определять собственные заголовки в соответствии со своими требованиями. Полный список стандартных HTTP-заголовков можно найти [здесь](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) .


### cURL

В предыдущем разделе мы увидели, как использовать `-v`Флаг с cURL показывает нам полную информацию о HTTP-запросе и ответе. Если бы нас интересовали только заголовки ответов, мы могли бы использовать метод `-I` флаг для отправки `HEAD`запросить и отображать только заголовки ответа. Кроме того, мы можем использовать `-i`флаг для отображения заголовков и тела ответа (например, HTML-кода). Разница между ними в том, что `-I` отправляет `HEAD` запрос (как будет показано в следующем разделе), в то время как `-i` отправляет любой указанный нами запрос, а также печатает заголовки.

Следующая команда показывает пример вывода использования `-I` флаг:

HTTP-заголовки

```shell-session
Uliam@htb[/htb]$ curl -I https://www.inlanefreight.com

Host: www.inlanefreight.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/605.1.15 (KHTML, like Gecko)
Cookie: cookie1=298zf09hf012fh2; cookie2=u32t4o3tb3gg4
Accept: text/plain
Referer: https://www.inlanefreight.com/
Authorization: BASIC cGFzc3dvcmQK

Date: Sun, 06 Aug 2020 08:49:37 GMT
Connection: keep-alive
Content-Length: 26012
Content-Type: text/html; charset=ISO-8859-4
Content-Encoding: gzip
Server: Apache/2.2.14 (Win32)
Set-Cookie: name1=value1,name2=value2; Expires=Wed, 09 Jun 2021 10:18:14 GMT
WWW-Authenticate: BASIC realm="localhost"
Content-Security-Policy: script-src 'self'
Strict-Transport-Security: max-age=31536000
Referrer-Policy: origin
```

**Упражнение:** попробуйте просмотреть все приведенные выше заголовки и посмотрите, сможете ли вы вспомнить использование каждого из них.

Помимо просмотра заголовков, cURL также позволяет нам устанавливать заголовки запросов с помощью `-H`флаг, как мы увидим в следующем разделе. Некоторые заголовки, например `User-Agent` или `Cookie`заголовки имеют свои собственные флаги. Например, мы можем использовать `-A` чтобы установить наш `User-Agent`, следующее:

HTTP-заголовки

```shell-session
Uliam@htb[/htb]$ curl https://www.inlanefreight.com -A 'Mozilla/5.0'

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
...SNIP...
```

**Упражнение:** Попробуйте использовать `-I` или `-v` флаги в приведенном выше примере, чтобы убедиться, что мы изменили наш User-Agent с помощью `-A` флаг.

### Browser DevTools

Наконец, давайте посмотрим, как мы можем просмотреть заголовки HTTP с помощью инструментов разработчика браузера. Как и в предыдущем разделе, мы можем перейти к `Network`вкладка, чтобы просмотреть различные запросы, сделанные страницей. Мы можем нажать на любой из запросов, чтобы просмотреть его детали:

![[Pasted image 20240803035131.png]]

### Questions

http://94.237.53.113:43851/

Сервер выше загружает флаг после загрузки страницы. Используйте вкладку «Сеть» в инструментах разработчика браузера, чтобы увидеть, какие запросы делает страница, и найдите запрос к флагу

Четвертая задача включает в себя анализ сетевых запросов, сделанных веб-страницей, чтобы найти запрос, который извлекает флаг. Просматривая вкладку «Сеть» в инструментах разработчика браузера, мы можем определить интересующий нас запрос. 

**Walkthrough using Web Browser**

Сервер при отправке страницы также отправляет нам файл `flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt` (это можно посмотреть в разделе "сеть" инструменты разработчика браузера) в котором и содержится наш флаг. 

![[Pasted image 20240803062853.png]]

Дело в том что  в странице подключен js-файл:

```js
<script src='./jquery.min.js'></script>
<script src="./script.js"></script>
```

Cудя по всему скрипт `./script.js` и отправляет нам файл с флагом. Давайте это проверим указав в url путь к файлу:

```
http://94.237.53.113:43851/script.js
```

```js
$(".option").click(function () {
   $(".option").removeClass("active");
   $(this).addClass("active");

});

document.onload(fetch(`/flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt`));
```

Открываем файл с флагом. Это можно сделать:

1. Указатв путь к фалу в поле url;
2. Открыть отправленный файл через раздел "Сеть";

```
http://94.237.53.113:43851/flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt
```

```
HTB{p493_r3qu3$t$_m0n!t0r}
```

**Walkthrough using curl**:

```
curl http://94.237.53.113:43851/flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt
```

**Walkthrough using  burpsuite**:

1. Перехватим наш запрос

```http
GET / HTTP/1.1
Host: 94.237.53.113:36280
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 16 Jan 2023 14:12:19 GMT
If-None-Match: "c83-5f2622bcb16c0-gzip"
```

Отправляем в `Repeater` при отправки такого запроса, получаем код страницы с кодом 200. 

2. Укажем путь к js-скрипту:

Изучая исходный код страницы мы натыкаемся на js-код:

```js
<script src='./jquery.min.js'></script>
<script src="./script.js"></script>
```

- Загружает библиотеку JavaScript jQuery из файла jquery.min.js. jQuery - это популярная библиотека, которая упрощает взаимодействие с элементами DOM и обработку событий в веб-страницах.

- Загружает пользовательский скрипт JavaScript из файла script.js. Этот скрипт предположительно содержит пользовательский код JavaScript.

Укажем путь в http-запросе:

```http
GET /./script.js HTTP/1.1
Host: 94.237.53.113:36280
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 16 Jan 2023 14:12:19 GMT
If-None-Match: "c83-5f2622bcb16c0-gzip"
```

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 01:55:14 GMT
Server: Apache/2.4.41 (Ubuntu)
Last-Modified: Mon, 28 Mar 2022 20:43:47 GMT
ETag: "b2-5db4d5e7146c0-gzip"
Accept-Ranges: bytes
Vary: Accept-Encoding
Content-Length: 178
Connection: close
Content-Type: application/javascript

$(".option").click(function () {
   $(".option").removeClass("active");
   $(this).addClass("active");

});

document.onload(fetch(`/flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt`));
```

Опа, вот и участок кода где указывается отправка флага при загрузке страницы. Можем указать путь к флагу:

```http
GET /flag_327a6c4304ad5938eaf0efb6cc3e53dc.txt HTTP/1.1
Host: 94.237.53.113:36280
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Upgrade-Insecure-Requests: 1
If-Modified-Since: Mon, 16 Jan 2023 14:12:19 GMT
If-None-Match: "c83-5f2622bcb16c0-gzip"
```

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 02:05:48 GMT
Server: Apache/2.4.41 (Ubuntu)
Last-Modified: Tue, 22 Feb 2022 06:53:06 GMT
ETag: "1a-5d895cd153880"
Accept-Ranges: bytes
Content-Length: 26
Connection: close
Content-Type: text/plain

HTB{p493_r3qu3$t$_m0n!t0r}
```

---

# HTTP Methods

## HTTP Methods and Codes

HTTP поддерживает несколько методов доступа к ресурсу. В протоколе HTTP несколько методов запроса позволяют браузеру отправлять информацию, формы или файлы на сервер. Эти методы используются, среди прочего, для того, чтобы сообщить серверу, как обрабатывать отправленный нами запрос и как на него отвечать.

Мы видели различные методы HTTP, используемые в HTTP-запросах, которые мы тестировали в предыдущих разделах. С cURL, если мы используем `-v` для предварительного просмотра полного запроса первая строка содержит метод HTTP (например, `GET / HTTP/1.1`), а в инструментах разработчика браузера метод HTTP показан в `Method`столбец. Кроме того, заголовки ответа также содержат код ответа HTTP, который указывает статус обработки нашего HTTP-запроса.

---

### Request Methods

Ниже приведены некоторые из часто используемых методов:

|**Метод**|**Описание**|
|---|---|
|`GET`|Запрашивает определенный ресурс. Дополнительные данные могут быть переданы на сервер через строки запроса в URL-адресе (например, `?param=value`).|
|`POST`|Отправляет данные на сервер. Он может обрабатывать несколько типов входных данных, таких как текст, PDF-файлы и другие формы двоичных данных. Эти данные добавляются в тело запроса после заголовков. Метод POST обычно используется при отправке информации (например, форм/логинов) или загрузке данных на веб-сайт, таких как изображения или документы.|
|`HEAD`|Запрашивает заголовки, которые были бы возвращены, если бы на сервер был отправлен запрос GET. Он не возвращает тело запроса и обычно предназначен для проверки длины ответа перед загрузкой ресурсов.|
|`PUT`|Создает новые ресурсы на сервере. Разрешение этого метода без надлежащего контроля может привести к загрузке вредоносных ресурсов.|
|`DELETE`|Удаляет существующий ресурс на веб-сервере. Если не обеспечить надлежащую защиту, это может привести к отказу в обслуживании (DoS) из-за удаления важных файлов на веб-сервере.|
|`OPTIONS`|Возвращает информацию о сервере, например о принятых им методах.|
|`PATCH`|Применяет частичные изменения к ресурсу в указанном месте.|

В списке выделены лишь некоторые из наиболее часто используемых методов HTTP. Доступность того или иного метода зависит от сервера, а также конфигурации приложения. Полный список HTTP-методов можно посмотреть по этой [ссылке](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) .

**Примечание.** Большинство современных веб-приложений в основном полагаются на `GET` и `POST`методы. Однако любое веб-приложение, использующее REST API, также зависит от `PUT` и `DELETE`, которые используются для обновления и удаления данных в конечной точке API соответственно. см. в [модуле «Введение в веб-приложения» .](https://academy.hackthebox.com/module/details/75) Дополнительные сведения

---

### Response Codes

Коды состояния HTTP используются, чтобы сообщить клиенту статус его запроса. HTTP-сервер может возвращать пять типов кодов ответа:

|**Тип**|**Описание**|
|---|---|
|`1xx`|Предоставляет информацию и не влияет на обработку запроса.|
|`2xx`|Возвращается при успешном выполнении запроса.|
|`3xx`|Возвращается, когда сервер перенаправляет клиента.|
|`4xx`|Означает неправильные запросы `from the client`. Например, запрос несуществующего ресурса или запрос неправильного формата.|
|`5xx`|Возвращается, когда есть какие-то проблемы `with the HTTP server` сам.|

Ниже приведены некоторые часто встречающиеся примеры каждого из вышеуказанных типов методов HTTP:

|**Код**|**Описание**|
|---|---|
|`200 OK`|Возвращается в случае успешного запроса, а тело ответа обычно содержит запрошенный ресурс.|
|`302 Found`|Перенаправляет клиента на другой URL-адрес. Например, перенаправление пользователя на свою панель управления после успешного входа в систему.|
|`400 Bad Request`|Возвращается при обнаружении некорректных запросов, таких как запросы с отсутствующими символами завершения строки.|
|`403 Forbidden`|Означает, что у клиента нет соответствующего доступа к ресурсу. Он также может быть возвращен, когда сервер обнаруживает вредоносный ввод пользователя.|
|`404 Not Found`|Возвращается, когда клиент запрашивает ресурс, которого нет на сервере.|
|`500 Internal Server Error`|Возвращается, когда сервер не может обработать запрос.|

Полный список стандартных кодов ответа HTTP можно найти по этой [ссылке](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) . Помимо стандартных кодов HTTP, различные серверы и провайдеры, такие как [Cloudflare](https://support.cloudflare.com/hc/en-us/articles/115003014432-HTTP-Status-Codes) или [AWS,](https://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/APIError.html) реализуют свои собственные коды.

---

## GET

Всякий раз, когда мы посещаем какой-либо URL-адрес, наши браузеры по умолчанию отправляют запрос GET для получения удаленных ресурсов, размещенных по этому URL-адресу. Как только браузер получает начальную страницу, которую он запрашивает; он может отправлять другие запросы, используя различные методы HTTP. Это можно наблюдать на вкладке «Сеть» в инструментах разработчика браузера, как показано в предыдущем разделе.

**Упражнение:** выберите любой веб-сайт по вашему выбору и следите за вкладкой «Сеть» в инструментах разработчика браузера при его посещении, чтобы понять, какие функции выполняет страница. Этот метод можно использовать для полного понимания того, как веб-приложение взаимодействует со своей серверной частью, что может быть важным упражнением для любой оценки веб-приложения или поиска ошибок.

---

### HTTP Basic Auth

Когда мы посещаем упражнение, найденное в конце этого раздела, оно предлагает нам ввести имя пользователя и пароль. В отличие от обычных форм входа, которые используют параметры HTTP для проверки учетных данных пользователя (например, запрос POST), этот тип аутентификации использует `basic HTTP authentication`, который обрабатывается непосредственно веб-сервером для защиты определенной страницы/каталога без прямого взаимодействия с веб-приложением.

Чтобы получить доступ к странице, мы должны ввести действительную пару учетных данных, которые `admin`: `admin` в этом случае:

![[Pasted image 20240803043846.png]]

Как только мы введем учетные данные, мы получим доступ к странице:

![[Pasted image 20240803043922.png]]

Давайте попробуем получить доступ к странице с помощью cURL и добавим `-i` чтобы просмотреть заголовки ответов:

ПОЛУЧАТЬ

```shell-session
Uliam@htb[/htb]$ curl -i http://<SERVER_IP>:<PORT>/
HTTP/1.1 401 Authorization Required
Date: Mon, 21 Feb 2022 13:11:46 GMT
Server: Apache/2.4.41 (Ubuntu)
Cache-Control: no-cache, must-revalidate, max-age=0
WWW-Authenticate: Basic realm="Access denied"
Content-Length: 13
Content-Type: text/html; charset=UTF-8

Access denied
```

Как мы видим, мы получаем `Access denied` в теле ответа, и мы также получаем `Basic realm="Access denied"` в `WWW-Authenticate` заголовок, который подтверждает, что на этой странице действительно используется `basic HTTP auth`, как описано в разделе «Заголовки». Чтобы предоставить учетные данные через cURL, мы можем использовать `-u` флаг следующим образом:

ПОЛУЧАТЬ

```shell-session
Uliam@htb[/htb]$ curl -u admin:admin http://<SERVER_IP>:<PORT>/

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

На этот раз мы получаем страницу в ответе. Есть еще один метод, который мы можем предоставить `basic HTTP auth` учетные данные, которые передаются непосредственно через URL-адрес как ( `username:password@URL`), как мы обсуждали в первом разделе. Если мы попробуем то же самое с cURL или нашим браузером, мы также получим доступ к странице:

ПОЛУЧАТЬ

```shell-session
Uliam@htb[/htb]$ curl http://admin:admin@<SERVER_IP>:<PORT>/

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

Мы также можем попробовать посетить тот же URL-адрес в браузере, и нам также необходимо пройти аутентификацию.

**Упражнение.** Попробуйте просмотреть заголовки ответов, добавив -i к приведенному выше запросу, и посмотрите, чем аутентифицированный ответ отличается от неаутентифицированного.

---

### HTTP Authorization Header

Если мы добавим `-v` флаг для любой из наших предыдущих команд cURL:

GET

```shell-session
Uliam@htb[/htb]$ curl -v http://admin:admin@<SERVER_IP>:<PORT>/

*   Trying <SERVER_IP>:<PORT>...
* Connected to <SERVER_IP> (<SERVER_IP>) port PORT (#0)
* Server auth using Basic with user 'admin'
> GET / HTTP/1.1
> Host: <SERVER_IP>
> Authorization: Basic YWRtaW46YWRtaW4=
> User-Agent: curl/7.77.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Mon, 21 Feb 2022 13:19:57 GMT
< Server: Apache/2.4.41 (Ubuntu)
< Cache-Control: no-store, no-cache, must-revalidate
< Expires: Thu, 19 Nov 1981 08:52:00 GMT
< Pragma: no-cache
< Vary: Accept-Encoding
< Content-Length: 1453
< Content-Type: text/html; charset=UTF-8
< 

<!DOCTYPE html>
<html lang="en">

<head>
...SNIP...
```

Поскольку мы используем `basic HTTP auth`, мы видим, что наш HTTP-запрос устанавливает `Authorization` заголовок к `Basic YWRtaW46YWRtaW4=`, которое представляет собой значение в кодировке Base64 `admin:admin`. Если бы мы использовали современный метод аутентификации (например, `JWT`), `Authorization` будет типа `Bearer` и будет содержать более длинный зашифрованный токен.

Попробуем вручную установить `Authorization`, не предоставляя учетные данные, чтобы проверить, разрешает ли он нам доступ к странице. Мы можем установить заголовок с помощью `-H`флаг и будет использовать то же значение из приведенного выше HTTP-запроса. Мы можем добавить `-H` отметьте несколько раз, чтобы указать несколько заголовков:

ПОЛУЧАТЬ

```shell-session
Uliam@htb[/htb]$ curl -H 'Authorization: Basic YWRtaW46YWRtaW4=' http://<SERVER_IP>:<PORT>/

<!DOCTYPE html
<html lang="en">

<head>
...SNIP...
```

Как видим, это тоже дало нам доступ к странице. Это несколько методов, которые мы можем использовать для аутентификации на странице. Большинство современных веб-приложений используют формы входа, созданные с помощью внутреннего языка сценариев (например, PHP), которые используют запросы HTTP POST для аутентификации пользователей, а затем возвращают файл cookie для поддержания их аутентификации.

---

### GET Parameters

После аутентификации мы получаем доступ к `City Search` функция, в которой мы можем ввести поисковый запрос и получить список соответствующих городов:

![[Pasted image 20240803044058.png]]

Поскольку страница возвращает наши результаты, возможно, она обращается к удаленному ресурсу для получения информации и последующего отображения ее на странице. Чтобы убедиться в этом, мы можем открыть инструменты разработчика браузера и перейти на вкладку «Сеть» или использовать ярлык [ `CTRL+SHIFT+E`], чтобы перейти на ту же вкладку. Прежде чем мы введем поисковый запрос и просмотрим запросы, нам может потребоваться нажать на значок `trash` значок в левом верхнем углу, чтобы гарантировать, что мы удаляем все предыдущие запросы и отслеживаем только новые запросы:

![[Pasted image 20240803044121.png]]

После этого мы можем ввести любой поисковый запрос и нажать Enter, и мы сразу заметим, что на бэкэнд отправляется новый запрос:

![[Pasted image 20240803044147.png]]

Когда мы нажимаем на запрос, он отправляется на `search.php` с параметром GET `search=le`используется в URL. Это помогает нам понять, что функция поиска запрашивает другую страницу для получения результатов.

Теперь мы можем отправить тот же запрос напрямую `search.php` чтобы получить полные результаты поиска, хотя он, вероятно, вернет их в определенном формате (например, JSON) без HTML-макета, показанного на снимке экрана выше.

Чтобы отправить запрос GET с помощью cURL, мы можем использовать тот же URL-адрес, который показан на скриншотах выше, поскольку запросы GET помещают свои параметры в URL-адрес. Однако инструменты разработчика браузера предоставляют более удобный способ получения команды cURL. Мы можем щелкнуть правой кнопкой мыши по запросу и выбрать `Copy>Copy as cURL`. Затем мы можем вставить скопированную команду в наш терминал и выполнить ее, и мы должны получить точно такой же ответ:

ПОЛУЧАТЬ

```shell-session
Uliam@htb[/htb]$ curl 'http://<SERVER_IP>:<PORT>/search.php?search=le' -H 'Authorization: Basic YWRtaW46YWRtaW4='

Leeds (UK)
Leicester (UK)
```

**Примечание.** Скопированная команда будет содержать все заголовки, используемые в HTTP-запросе. Однако мы можем удалить большинство из них и оставить только необходимые заголовки аутентификации, такие как `Authorization` заголовок.

Мы также можем повторить точный запрос прямо в инструментах разработчика браузера, выбрав `Copy>Copy as Fetch`. Это скопирует тот же HTTP-запрос с использованием библиотеки JavaScript Fetch. Затем мы можем перейти на вкладку консоли JavaScript, нажав [ `CTRL+SHIFT+K`], вставьте нашу команду Fetch и нажмите Enter, чтобы отправить запрос:

![[Pasted image 20240803044241.png]]

### Questions

Кажется, что приведенное выше упражнение не работает, поскольку оно возвращает неверные результаты. Используйте инструменты разработчика браузера, чтобы узнать, какой запрос он отправляет при поиске, и используйте cURL для поиска «флага» и получения флага.

Пятая задача включает в себя устранение неработающей функциональности для получения флага. Наблюдая за поисковым запросом, сделанным сломанной функцией, мы можем имитировать запрос, используя cURL для поиска флага. 

И так, переходя по адресу нас просят  ввести логин и пароль, после у нас будет доступ к странице поиска. В общем, перейдите по URL-адресу… откроется поиск. В поиске введем `test` при отправке заглянем раздел "Сеть". 

![[bfrhwijbfw.jpeg]]

Выходит мы отправляем GET запрос на файл `search.php` параметром `search` со значением `test` - `search.php?search=search`. Нам нужно найти флаг. 

**Walkthrough using curl**

Мы можем отправить запрос с п.м. `curl` используя `cookie` пользователя:

```
curl http://94.237.56.140:33705/search.php\?search\=flag -H "Authorization: Basic YWRtaW46YWRtaW4="  
flag: HTB{curl_g3773r}
```

Или же можем вместо `cookie` использовать логин и пароль:

```
curl http://94.237.56.140:33705/search.php\?search\=flag -u admin:admin                               
flag: HTB{curl_g3773r}
```

**Walkthrough using BurpSuite**

Когда мы делаем поиск на сайте, мы отправляем GET запрос. При отправки GET запроса перехватим его и отправим в **Repeater**:

```http
GET /search.php?search=test HTTP/1.1
Host: 94.237.56.140:47663
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://94.237.56.140:47663/
Authorization: Basic YWRtaW46YWRtaW4=
Connection: close
Cookie: PHPSESSID=qnful7jhjf36kcdu6q5lgon03g
```

При отправке получаем вот такой ответ:

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 04:38:20 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Length: 15
Connection: close
Content-Type: text/html; charset=UTF-8

Please use cURL
```

Хм, сервер требует использовать `curl`, но как сервер знает что мы используем? Думаю `User-Agent` серверу предоставляет  информацию об этом.

```
User-Agent — это заголовок, который каждый клиент может установить в запросе на информирование. сервер, какой это пользовательский агент. Иногда серверы просматривают этот заголовок и определить, как действовать, исходя из его содержания.

Значение заголовка по умолчанию — «curl/[version]», как в `User-Agent: curl/7.54.1` для версии 7.54.1.

Вы можете установить любое значение, используя опцию `-A` или `--user-agent`плюс строку, которую нужно использовать, или, поскольку это всего лишь заголовок, `-H "User-Agent: foobar/2000"`.
```


Давайте используем `User-Agent` **curl**:

```http
GET /search.php?search=test HTTP/1.1
Host: 94.237.58.250:52639
User-Agent: curl/7.54.1
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://94.237.58.250:52639/
Authorization: Basic YWRtaW46YWRtaW4=
Connection: close
```

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 19:18:22 GMT
Server: Apache/2.4.41 (Ubuntu)
Cache-Control: no-cache, must-revalidate, max-age=0
Content-Length: 0
Connection: close
Content-Type: text/html; charset=UTF-8
```

Заметили? Сообщение про то что нужно использовать **curl** нет. Теперь найдем флаг. Давайте параметру `search` дадим значение `flag`:

```http
GET /search.php?search=flag HTTP/1.1
Host: 94.237.58.250:52639
User-Agent: curl/7.54.1
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://94.237.58.250:52639/
Authorization: Basic YWRtaW46YWRtaW4=
Connection: close
```

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 19:20:30 GMT
Server: Apache/2.4.41 (Ubuntu)
Cache-Control: no-cache, must-revalidate, max-age=0
Content-Length: 23
Connection: close
Content-Type: text/html; charset=UTF-8

flag: HTB{curl_g3773r}
```

БИНГО!  Мы достали флаг.

---

## POST

В предыдущем разделе мы видели, как `GET`запросы могут использоваться веб-приложениями для таких функций, как поиск и доступ к страницам. Однако всякий раз, когда веб-приложениям необходимо передать файлы или переместить пользовательские параметры из URL-адреса, они используют `POST` Запросы.

В отличие от HTTP `GET`, который помещает пользовательские параметры в URL-адрес, HTTP `POST`помещает пользовательские параметры в тело HTTP-запроса. Это имеет три основных преимущества:

- `Lack of Logging`: Поскольку запросы POST могут передавать большие файлы (например, загрузку файлов), для сервера было бы неэффективно регистрировать все загруженные файлы как часть запрошенного URL-адреса, как это было бы в случае с файлом, загруженным через запрос GET.
- `Less Encoding Requirements`: URL-адреса предназначены для совместного использования, а это означает, что они должны соответствовать символам, которые можно преобразовать в буквы. Запрос POST помещает данные в тело, которое может принимать двоичные данные. Единственные символы, которые необходимо закодировать, — это те, которые используются для разделения параметров.
- `More data can be sent`: максимальная длина URL-адреса варьируется в зависимости от браузера (Chrome/Firefox/IE), веб-серверов (IIS, Apache, nginx), сетей доставки контента (Fastly, Cloudfront, Cloudflare) и даже сокращателей URL-адресов (bit.ly, amzn.to). . Вообще говоря, длина URL-адресов не должна превышать 2000 символов, чтобы они не могли обрабатывать большой объем данных.

Итак, давайте посмотрим несколько примеров того, как работают POST-запросы и как мы можем использовать такие инструменты, как cURL или инструменты разработчика браузера, для чтения и отправки POST-запросов.

### Login Forms

Упражнение в конце этого раздела похоже на пример, который мы видели в разделе GET. Однако, посетив веб-приложение, мы видим, что оно использует форму входа PHP вместо базовой аутентификации HTTP:


![[Pasted image 20240803225549.png]]

Если мы попытаемся войти в систему с помощью `admin`: `admin`, мы заходим и видим функцию поиска, аналогичную той, которую мы видели ранее в разделе GET:

![[Pasted image 20240803225618.png]]

Если мы очистим вкладку «Сеть» в инструментах разработчика нашего браузера и попытаемся войти снова, мы увидим множество отправленных запросов. Мы можем фильтровать запросы по IP-адресу нашего сервера, чтобы он отображал только запросы, идущие к веб-серверу веб-приложения (т. е. отфильтровывая внешние запросы), и мы заметим отправку следующего запроса POST:

![[Pasted image 20240803225652.png]]

Мы можем нажать на запрос, нажать на кнопку `Request` вкладку (на которой показано тело запроса), а затем нажмите кнопку `Raw`Кнопка для отображения необработанных данных запроса. Мы видим, что следующие данные отправляются в качестве данных запроса POST:

Код: Баш

```bash
username=admin&password=admin
```

Имея под рукой данные запроса, мы можем попытаться отправить аналогичный запрос с помощью cURL, чтобы посмотреть, позволит ли это нам также войти в систему. Кроме того, как и в предыдущем разделе, мы можем просто щелкнуть запрос правой кнопкой мыши и выбрать `Copy>Copy as cURL`. Однако важно иметь возможность создавать POST-запросы вручную, поэтому давайте попробуем это сделать.

Мы будем использовать `-X POST` флаг для отправки `POST`запрос. Затем, чтобы добавить наши данные POST, мы можем использовать `-d` флаг и добавьте после него приведенные выше данные следующим образом:

ПОЧТА

```shell-session
Uliam@htb[/htb]$ curl -X POST -d 'username=admin&password=admin' http://<SERVER_IP>:<PORT>/

...SNIP...
        <em>Type a city name and hit <strong>Enter</strong></em>
...SNIP...
```

Если мы проверим HTML-код, мы не увидим код формы входа, но увидим код функции поиска, который указывает на то, что мы действительно прошли аутентификацию.

**Совет:** многие формы входа перенаправляют нас на другую страницу после аутентификации (например, /dashboard.php). Если мы хотим следовать перенаправлению с помощью cURL, мы можем использовать `-L` флаг.

### Authenticated Cookies

Если мы прошли успешную аутентификацию, мы должны были получить файл cookie, чтобы наши браузеры могли сохранить нашу аутентификацию, и нам не нужно было входить в систему каждый раз, когда мы посещаем страницу. Мы можем использовать `-v` или `-i` флаги для просмотра ответа, который должен содержать `Set-Cookie` заголовок с нашим аутентифицированным файлом cookie:

ПОЧТА

```shell-session
Uliam@htb[/htb]$ curl -X POST -d 'username=admin&password=admin' http://<SERVER_IP>:<PORT>/ -i

HTTP/1.1 200 OK
Date: 
Server: Apache/2.4.41 (Ubuntu)
Set-Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1; path=/

...SNIP...
        <em>Type a city name and hit <strong>Enter</strong></em>
...SNIP...
```

Благодаря нашему аутентифицированному файлу cookie мы теперь сможем взаимодействовать с веб-приложением без необходимости каждый раз предоставлять свои учетные данные. Чтобы проверить это, мы можем установить указанный выше файл cookie с помощью `-b` флаг в cURL следующим образом:

ПОЧТА

```shell-session
Uliam@htb[/htb]$ curl -b 'PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1' http://<SERVER_IP>:<PORT>/

...SNIP...
        <em>Type a city name and hit <strong>Enter</strong></em>
...SNIP...
```

Как мы видим, мы действительно прошли аутентификацию и добрались до функции поиска. Также возможно указать файл cookie в качестве заголовка следующим образом:

Код: Баш

```bash
curl -H 'Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1' http://<SERVER_IP>:<PORT>/
```

Мы также можем попробовать то же самое с нашими браузерами. Давайте сначала выйдем из системы, а затем вернемся на страницу входа. Затем мы можем пойти в `Storage` вкладка в инструментах разработчика с помощью [ `SHIFT+F9`]. в `Storage` вкладку, мы можем нажать на `Cookies`на левой панели и выберите наш веб-сайт, чтобы просмотреть текущие файлы cookie. У нас могут быть или не быть существующие файлы cookie, но если мы вышли из системы, наш файл cookie PHP не должен проходить аутентификацию, поэтому, если мы получим форму входа, а не функцию поиска:

![[Pasted image 20240803225711.png]]

Теперь давайте попробуем использовать наш ранее аутентифицированный файл cookie и посмотрим, сможем ли мы войти без необходимости предоставления наших учетных данных. Для этого мы можем просто заменить значение файла cookie нашим собственным. В противном случае мы можем щелкнуть правой кнопкой мыши файл cookie и выбрать `Delete All`, и нажмите на `+`значок, чтобы добавить новый файл cookie. После этого нам нужно ввести имя файла cookie, которое представляет собой часть перед `=` ( `PHPSESSID`), а затем значение файла cookie, которое является частью после `=` ( `c1nsa6op7vtk7kdis7bcnbadf1`). Затем, как только наш файл cookie будет установлен, мы сможем обновить страницу и увидим, что мы действительно аутентифицируемся без необходимости входа в систему, просто используя аутентифицированный файл cookie:

![[Pasted image 20240803225724.png]]

Как мы видим, наличия действующего файла cookie может быть достаточно для аутентификации во многих веб-приложениях. Это может быть важной частью некоторых веб-атак, таких как межсайтовый скриптинг.

### JSON Data

Наконец, давайте посмотрим, какие запросы отправляются, когда мы взаимодействуем с `City Search`функция. Для этого мы перейдем на вкладку «Сеть» в инструментах разработчика браузера, а затем щелкните значок корзины, чтобы очистить все запросы. Затем мы можем выполнить любой поисковый запрос, чтобы увидеть, какие запросы отправляются:

![[Pasted image 20240803225747.png]]

Как мы видим, форма поиска отправляет POST-запрос на `search.php`, со следующими данными:

Код: json

```json
{"search":"london"}
```

Данные POST представлены в формате JSON, поэтому в нашем запросе должен быть указан `Content-Type` заголовок будет `application/json`. Мы можем подтвердить это, щелкнув запрос правой кнопкой мыши и выбрав `Copy>Copy Request Headers`:

Код: Баш

```http
POST /search.php HTTP/1.1
Host: server_ip
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://server_ip/index.php
Content-Type: application/json
Origin: http://server_ip
Content-Length: 19
DNT: 1
Connection: keep-alive
Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1
```

Действительно, у нас есть `Content-Type: application/json`. Давайте попробуем повторить этот запрос, как мы делали ранее, но включим заголовки cookie и типа контента и отправим наш запрос по адресу `search.php`:

ПОЧТА

```shell-session
Uliam@htb[/htb]$ curl -X POST -d '{"search":"london"}' -b 'PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1' -H 'Content-Type: application/json' http://<SERVER_IP>:<PORT>/search.php
["London (UK)"]
```

Как мы видим, мы смогли напрямую взаимодействовать с функцией поиска без необходимости входа в систему или взаимодействия с интерфейсом веб-приложения. Это может оказаться важным навыком при проведении оценок веб-приложений или поиске ошибок, поскольку таким образом тестировать веб-приложения гораздо быстрее.

**Упражнение.** Попробуйте повторить приведенный выше запрос, не добавляя файлы cookie или заголовки типов контента, и посмотрите, как веб-приложение будет действовать по-другому.

Наконец, давайте попробуем повторить тот же самый запрос, используя `Fetch`, как мы это делали в предыдущем разделе. Мы можем щелкнуть правой кнопкой мыши по запросу и выбрать `Copy>Copy as Fetch`, а затем перейдите в `Console` tab и выполним там наш код:

![[Pasted image 20240803225803.png]]

Наш запрос успешно возвращает те же данные, которые мы получили с помощью cURL. `Try to search for different cities by directly interacting with the search.php through Fetch or cURL.`

### Questions

Получите файл cookie сеанса, указав действительный логин, а затем используйте файл cookie с cURL для поиска флага с помощью запроса JSON POST к «/search.php».

Шестая задача требует получения файла cookie сеанса с помощью действительного входа в систему, а затем использования этого файла cookie для поиска флага с помощью запроса JSON POST для `/search.php`. Во-первых, нам нужно получить файл cookie сеанса, посетив страницу входа в систему. Следующая команда cURL извлекает файл cookie:

Нам нужно получить `cookie` и использовать их для отправки `json` запроса с п.м. `curl`. Получаем значение `cookie`:

1. Раздел "Сеть" инструменты разработчика в браузере;
2. Перехвать запроса с п.м. `BurpSuite`;
3. Использовать `curl`;

Есть много других способов, но это мои любимые. 

Задача требует получения файла cookie сеанса с помощью действительного входа в систему, а затем использования этого файла cookie для поиска флага с помощью запроса JSON POST для `/search.php`. Во-первых, нам нужно получить файл cookie сеанса, посетив страницу входа в систему. Следующая команда cURL извлекает файл cookie:

![[Pasted image 20240803230803.png]]

**Walkthrough using curl**

```bash
curl http://138.68.155.223:32576/ -v  
*   Trying 138.68.155.223:32576...  
* Connected to 138.68.155.223 (138.68.155.223) port 32576 (#0)  
> GET / HTTP/1.1  
> Host: 138.68.155.223:32576  
> User-Agent: curl/7.88.1  
> Accept: */*  
>   
< HTTP/1.1 200 OK  
< Date: Fri, 07 Jul 2023 12:43:35 GMT  
< Server: Apache/2.4.41 (Ubuntu)  
< Set-Cookie: PHPSESSID=g2rfiv1ru3um1idqd4jb59g8si; path=/  
< Expires: Thu, 19 Nov 1981 08:52:00 GMT  
< Cache-Control: no-store, no-cache, must-revalidate  
< Pragma: no-cache  
< Vary: Accept-Encoding  
< Content-Length: 1167  
< Content-Type: text/html; charset=UTF-8  
<   
  
<!DOCTYPE html>  
<html lang="en">  
  
<head>  
    <meta charset="UTF-8">  
    <title>City Search</title>  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">  
    <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Roboto:400,500,700'>  
    <link rel='stylesheet' href='https://static.fontawesome.com/css/fontawesome-app.css'>  
    <link rel='stylesheet' href='https://pro.fontawesome.com/releases/v5.2.0/css/all.css'>  
    <link rel="stylesheet" href="./style.css">  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css">  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js"></script>  
</head>  
  
<body>  
        <div class="login">  
        <h1>Login</h1>  
        <form method="post">  
            <input type="text" name="username" placeholder="Username" required="required" />  
            <input type="password" name="password" placeholder="Password" required="required" />  
            <button type="submit" class="btn btn-primary btn-block btn-large">Login</button>  
        </form>  
    </div>  
          
</body>  
  
* Connection #0 to host 138.68.155.223 left intact  
</html>
```

Получив файл cookie, мы можем использовать его в последующем запросе для поиска флага. Следующая команда cURL выполняет поиск с использованием файла cookie сеанса:

```bash
curl -X POST -d '{"search":"flag"}' -b 'PHPSESSID=euvqgluu4mtasdeiachd0dufui' -H 'Content-Type: application/json' <http://138.68.155.223:32576/search.php>
```

Ответ возвращает флаг: `["flag: HTB{p0$t_r3p34t3r}"]`.

**Walkthrough using BurpSuite**

Поскольку сервер требует использовать `curl` для решения задачи, мы поменяем значение `User-Agent`, чтобы сервер думал что мы используем `curl`:

```http
POST /search.php HTTP/1.1
Host: 94.237.58.250:59193
User-Agent: curl/7.54.1
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: http://94.237.58.250:59193/
Content-Type: application/json
Content-Length: 17
Origin: http://94.237.58.250:59193
Connection: close
Cookie: PHPSESSID=ohdd5p3seeleiot6ncinfp3lpl

{"search":"flag"}
```

```http
HTTP/1.1 200 OK
Date: Sat, 03 Aug 2024 19:48:44 GMT
Server: Apache/2.4.41 (Ubuntu)
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 28
Connection: close
Content-Type: text/html; charset=UTF-8

["flag: HTB{p0$t_r3p34t3r}"]
```

---

## CRUD API

Мы видели примеры `City Search`веб-приложение, которое использует параметры PHP для поиска названия города в предыдущих разделах. В этом разделе будет рассмотрено, как такое веб-приложение может использовать API для выполнения той же задачи, и мы будем напрямую взаимодействовать с конечной точкой API.

---

### APIs

Существует несколько типов API. Многие API используются для взаимодействия с базой данных, поэтому мы можем указать запрошенную таблицу и запрошенную строку в нашем запросе API, а затем использовать метод HTTP для выполнения необходимой операции. Например, для `api.php` конечная точка в нашем примере, если мы хотим обновить `city` таблица в базе данных, а строка, которую мы будем обновлять, имеет название города `london`, то URL-адрес будет выглядеть примерно так:

Код: Баш

```bash
curl -X PUT http://<SERVER_IP>:<PORT>/api.php/city/london ...SNIP...
```

### CRUD

Как мы видим, с помощью таких API мы можем легко указать таблицу и строку, над которой хотим выполнить операцию. Затем мы можем использовать разные методы HTTP для выполнения разных операций над этой строкой. В целом API выполняют 4 основные операции над запрошенным объектом базы данных:

|Операция|HTTP-метод|Описание|
|---|---|---|
|`Create`|`POST`|Добавляет указанные данные в таблицу базы данных|
|`Read`|`GET`|Считывает указанную сущность из таблицы базы данных.|
|`Update`|`PUT`|Обновляет данные указанной таблицы базы данных.|
|`Delete`|`DELETE`|Удаляет указанную строку из таблицы базы данных.|

Эти четыре операции в основном связаны с общеизвестными API-интерфейсами CRUD, но тот же принцип также используется в API-интерфейсах REST и некоторых других типах API. Конечно, не все API работают одинаково, и контроль доступа пользователей будет ограничивать то, какие действия мы можем выполнять и какие результаты видим. Модуль « Введение [в веб-приложения»](https://academy.hackthebox.com/module/details/75) дополнительно объясняет эти концепции, поэтому вы можете обратиться к нему для получения более подробной информации об API и их использовании.

---

### Read

Первое, что мы будем делать при взаимодействии с API, — это считывать данные. Как упоминалось ранее, мы можем просто указать имя таблицы после API (например, `/city`), а затем укажите поисковый запрос (например, `/london`), следующее:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl http://<SERVER_IP>:<PORT>/api.php/city/london

[{"city_name":"London","country_name":"(UK)"}]
```

Мы видим, что результат отправляется в виде строки JSON. Чтобы правильно отформатировать его в формате JSON, мы можем передать вывод в `jq`утилита, которая правильно его отформатирует. Мы также отключим любой ненужный вывод cURL с помощью `-s`, следующее:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/london | jq

[
  {
    "city_name": "London",
    "country_name": "(UK)"
  }
]
```

Как мы видим, мы получили результат в красиво отформатированном виде. Мы также можем ввести поисковый запрос и получить все соответствующие результаты:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/le | jq

[
  {
    "city_name": "Leeds",
    "country_name": "(UK)"
  },
  {
    "city_name": "Dudley",
    "country_name": "(UK)"
  },
  {
    "city_name": "Leicester",
    "country_name": "(UK)"
  },
  ...SNIP...
]
```

Наконец, мы можем передать пустую строку, чтобы получить все записи в таблице:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/ | jq

[
  {
    "city_name": "London",
    "country_name": "(UK)"
  },
  {
    "city_name": "Birmingham",
    "country_name": "(UK)"
  },
  {
    "city_name": "Leeds",
    "country_name": "(UK)"
  },
  ...SNIP...
]
```

`Try visiting any of the above links using your browser, to see how the result is rendered.`

---

### Create

Чтобы добавить новую запись, мы можем использовать запрос HTTP POST, который очень похож на то, что мы выполняли в предыдущем разделе. Мы можем просто отправить наши данные JSON POST, и они будут добавлены в таблицу. Поскольку этот API использует данные JSON, мы также установим `Content-Type` заголовок в JSON следующим образом:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -X POST http://<SERVER_IP>:<PORT>/api.php/city/ -d '{"city_name":"HTB_City", "country_name":"HTB"}' -H 'Content-Type: application/json'
```

Теперь мы можем прочитать содержимое добавленного нами города ( `HTB_City`), чтобы проверить, было ли оно успешно добавлено:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/HTB_City | jq

[
  {
    "city_name": "HTB_City",
    "country_name": "HTB"
  }
]
```

Как мы видим, был создан новый город, которого раньше не существовало.

**Упражнение.** Попробуйте добавить новый город с помощью инструментов разработчика браузера, используя один из запросов Fetch POST, которые вы использовали в предыдущем разделе.

---

### Update

Теперь, когда мы знаем, как читать и записывать записи через API, давайте начнем обсуждать два других метода HTTP, которые мы до сих пор не использовали: `PUT` и `DELETE`. Как упоминалось в начале раздела, `PUT` используется для обновления записей API и изменения их данных, в то время как `DELETE` используется для удаления определенного объекта.

**Примечание:** HTTP `PATCH` метод также может использоваться для обновления записей API вместо `PUT`. Точнее, `PATCH` используется для частичного обновления записи (изменения только некоторых ее данных, «например, только имя_города»), в то время как `PUT`используется для обновления всей записи. Мы также можем использовать HTTP `OPTIONS`метод, чтобы увидеть, какой из двух принят сервером, а затем соответствующим образом использовать соответствующий метод. В этом разделе мы сосредоточимся на `PUT` метод, хотя их использование очень похоже.

С использованием `PUT` очень похоже на `POST`в данном случае с той лишь разницей, что нам нужно указать в URL-адресе имя объекта, который мы хотим редактировать, иначе API не будет знать, какой объект редактировать. Итак, все, что нам нужно сделать, это указать `city` имя в URL-адресе, измените метод запроса на `PUT`и предоставьте данные JSON, как мы это делали с POST, следующим образом:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -X PUT http://<SERVER_IP>:<PORT>/api.php/city/london -d '{"city_name":"New_HTB_City", "country_name":"HTB"}' -H 'Content-Type: application/json'
```

В приведенном выше примере мы видим, что мы сначала указали `/city/london` как наш город, и передал строку JSON, содержащую `"city_name":"New_HTB_City"`в данных запроса. Итак, Лондон-Сити больше не должен существовать, а должен появиться новый город с названием `New_HTB_City`должно существовать. Давайте попробуем прочитать оба, чтобы подтвердить:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/london | jq
```

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/New_HTB_City | jq

[
  {
    "city_name": "New_HTB_City",
    "country_name": "HTB"
  }
]
```

Действительно, мы успешно заменили старое название города на новое.

**Примечание.** В некоторых API `Update`Операция также может использоваться для создания новых записей. По сути, мы отправляем наши данные, и если они не существуют, они их создают. Например, в приведенном выше примере, даже если запись с `london`города не существовало, будет создана новая запись с переданными нами деталями. Однако в нашем примере это не так. Попробуйте обновить несуществующий город и посмотрите, что вы получите.

---

### DELETE

Наконец, давайте попробуем удалить город, что так же просто, как прочитать город. Мы просто указываем название города для API и используем HTTP `DELETE` метод, и он удалит запись следующим образом:

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -X DELETE http://<SERVER_IP>:<PORT>/api.php/city/New_HTB_City
```

необработанный API

```shell-session
Uliam@htb[/htb]$ curl -s http://<SERVER_IP>:<PORT>/api.php/city/New_HTB_City | jq
[]
```

Как мы видим, после того, как мы удалили `New_HTB_City`, мы получаем пустой массив при попытке его чтения, что означает, что он больше не существует.

**Упражнение:** попробуйте удалить любой из городов, добавленных вами ранее, с помощью POST-запросов, а затем прочитайте все записи, чтобы убедиться, что они были успешно удалены.

Благодаря этому мы можем выполнить все 4 `CRUD`операции через cURL. В реальном веб-приложении такие действия могут быть разрешены не всем пользователям, либо будет считаться уязвимостью, если кто-либо сможет изменить или удалить любую запись. Каждый пользователь будет иметь определенные привилегии в отношении того, что он может `read` или `write`, где `write`относится к добавлению, изменению или удалению данных. Чтобы аутентифицировать нашего пользователя для использования API, нам нужно будет передать файл cookie или заголовок авторизации (например, JWT), как мы это делали в предыдущем разделе. В остальном операции аналогичны тем, которые мы практиковали в этом разделе.

### Questions

Сначала попробуйте изменить название любого города на «flag». Затем удалите любой город. После этого найдите город с именем «flag», чтобы получить флаг.

В этой части мы будем использовать CRUD API, который позволяет нам манипулировать компонентами веб-страницы с помощью четырех основных операций. Эти четыре основные операции вместе называются CRUD, что означает создание, чтение, обновление и удаление. Понимание того, как действия CRUD связаны друг с другом, имеет решающее значение для разработчиков API и инженеров по обработке данных, поскольку вызовы REST API инициируют операции CRUD.

**Манипулирование данными посредством запросов API.**

Последняя задача включает в себя манипулирование данными посредством запросов API для получения флага. Нам нужно обновить название города на «флаг», удалить другой город, а затем найти город с именем «флаг», чтобы получить флаг.

Попробуем сначала отправить запрос:

```bash
curl http://94.237.49.212:51122/api.php/city  

[{"city_name":"London","country_name":"(UK)"},{"city_name":"Birmingham","country_name":"(UK)"},{"city_name":"Leeds","country_name":"(UK)"},{"city_name":"Glasgow","country_name":"(UK)"},{"cit  
y_name":"Sheffield","country_name":"(UK)"},{"city_name":"Bradford","country_name":"(UK)"},{"city_name":"Liverpool","country_name":"(UK)"},{"city_name":"Edinburgh","country_name":"(UK)"},{"ci  
ty_name":"Manchester","country_name":"(UK)"},{"city_name":"Bristol","country_name":"(UK)"},{"city_name":"Wakefield","country_name":"(UK)"},{"city_name":"Cardiff","country_name":"(UK)"},{"cit  
y_name":"Dudley","country_name":"(UK)"},{"city_name":"Wigan","country_name":"(UK)"},{"city_name":"Coventry","country_name":"(UK)"},{"city_name":"Belfast","country_name":"(UK)"},{"city_name":  
"Leicester","country_name":"(UK)"},{"city_name":"Sunderland","country_name":"(UK)"},{"city_name":"Doncaster","country_name":"(UK)"},{"city_name":"Stockport","country_name":"(UK)"},{"city_nam  
e":"Nottingham","country_name":"(UK)"},{"city_name":"Newcastle","country_name":"(UK)"},{"city_name":"Kingston","country_name":"(UK)"},{"city_name":"Bolton","country_name":"(UK)"},{"city_name  
":"Walsall","country_name":"(UK)"},{"city_name":"Plymouth","country_name":"(UK)"},{"city_name":"Rotherham","country_name":"(UK)"},{"city_name":"Stoke","country_name":"(UK)"},{"city_name":"Wo  
lverhampton","country_name":"(UK)"},{"city_name":"South","country_name":"(UK)"},{"city_name":"Derby","country_name":"(UK)"},{"city_name":"Swansea","country_name":"(UK)"},{"city_name":"Salfor  
d","country_name":"(UK)"},{"city_name":"New York","country_name":"(US)"},{"city_name":"Los Angeles","country_name":"(US)"},{"city_name":"Chicago","country_name":"(US)"},{"city_name":"Houston  
","country_name":"(US)"},{"city_name":"Phoenix","country_name":"(US)"},{"city_name":"Philadelphia","country_name":"(US)"},{"city_name":"San Antonio","country_name":"(US)"},{"city_name":"San  
Diego","country_name":"(US)"},{"city_name":"Dallas","country_name":"(US)"},{"city_name":"San Jose","country_name":"(US)"},{"city_name":"Austin","country_name":"(US)"},{"city_name":"Jacksonvi  
lle","country_name":"(US)"},{"city_name":"Fort Worth","country_name":"(US)"},{"city_name":"Columbus","country_name":"(US)"},{"city_name":"Indianapolis","country_name":"(US)"},{"city_name":"C  
harlotte","country_name":"(US)"},{"city_name":"San Francisco","country_name":"(US)"},{"city_name":"Seattle","country_name":"(US)"},{"city_name":"Denver","country_name":"(US)"},{"city_name":"  
Washington","country_name":"(US)"},{"city_name":"Nashville-Davidson","country_name":"(US)"},{"city_name":"Oklahoma City","country_name":"(US)"},{"city_name":"El Paso","country_name":"(US)"},  
{"city_name":"Boston","country_name":"(US)"},{"city_name":"Portland","country_name":"(US)"},{"city_name":"Las Vegas","country_name":"(US)"},{"city_name":"Detroit","country_name":"(US)"},{"ci  
ty_name":"Memphis","country_name":"(US)"},{"city_name":"Baltimore","country_name":"(US)"}]%
```

Для удобства используем `jq`:

```bash
curl http://94.237.49.212:51122/api.php/city | jq  
 % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current  
                                Dload  Upload   Total   Spent    Left  Speed  
100  2940  100  2940    0     0   7671      0 --:--:-- --:--:-- --:--:--  7676  
[  
 {  
   "city_name": "London",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Birmingham",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Leeds",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Glasgow",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Sheffield",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Bradford",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Liverpool",  
   "country_name": "(UK)"  
 },  
 {  
   "city_name": "Edinburgh",  
   "country_name": "(UK)"  
 },
```

![[Pasted image 20240804051959.png]]

Наша задача:

1. Изменить название любого города на flag;
2. Удалить любой город;
3. Найти город с наванием flag;

```bash
curl -X PUT <http://165.22.127.181:31910/api.php/city/Boston> -d  '{"city_name":"flag"}'  -H 'Content-Type: application/json'  
curl -X DELETE '<http://165.22.127.181:31910/api.php/city/london>'   
curl -X GET <http://165.22.127.181:31910/api.php/city/flag>
```

Ответ на последний запрос предоставляет флаг: `HTB{crud_4p!_m4n!pul4t0r}`.

Вот другой пример

![[Pasted image 20240804052515.png]]

