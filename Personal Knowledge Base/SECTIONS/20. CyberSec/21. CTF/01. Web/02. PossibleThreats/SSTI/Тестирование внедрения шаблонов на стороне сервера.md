https://owasp.org


## Резюме

Веб-приложения обычно используют технологии шаблонов на стороне сервера (Jinja2, Twig, FreeMaker и т. д.) для создания динамических HTML-ответов. Уязвимости внедрения шаблонов на стороне сервера (SSTI) возникают, когда пользовательский ввод встраивается в шаблон небезопасным образом и приводит к удаленному выполнению кода на сервере. Любые функции, которые поддерживают расширенную пользовательскую разметку, могут быть уязвимы для SSTI, включая вики-страницы, обзоры, маркетинговые приложения, системы CMS и т. д. Некоторые механизмы шаблонов используют различные механизмы (например, песочницу, список разрешений и т. д.) для защиты от SSTI.

### Пример — ветка

Следующий пример является выдержкой из проекта [Extreme Vulnerable Web Application](https://github.com/s4n7h0/xvwa) .

```
public function getFilter($name)
{
        [snip]
        foreach ($this->filterCallbacks as $callback) {
        if (false !== $filter = call_user_func($callback, $name)) {
            return $filter;
        }
    }
    return false;
}
```

В функции getFilter `call_user_func($callback, $name)`уязвим для SSTI: `name`параметр извлекается из запроса HTTP GET и выполняется сервером:

![[Pasted image 20230212140041.png]]



### Пример — Flask/Jinja2

В следующем примере используется механизм шаблонов Flask и Jinja2. `page`Функция принимает параметр «имя» из HTTP-запроса GET и отображает ответ HTML с `name`переменное содержимое:

```
@app.route("/page")
def page():
    name = request.values.get('name')
    output = Jinja2.from_string('Hello ' + name + '!').render()
    return output
```

Этот фрагмент кода уязвим для XSS, но также уязвим для SSTI. Используя следующее в качестве полезной нагрузки в `name`параметр:

```
$ curl -g 'http://www.target.com/page?name='
Hello 49!
```

## Цели теста

-   Обнаружение точек уязвимости внедрения шаблонов.
-   Определите механизм шаблонов.
-   Создайте эксплойт.

## Как проверить

Уязвимости SSTI существуют либо в текстовом, либо в кодовом контексте. В контексте открытого текста пользователям разрешено использовать «текст» произвольной формы с прямым HTML-кодом. В контексте кода пользовательский ввод также может быть помещен в оператор шаблона (например, в имя переменной).

### Выявление уязвимости внедрения шаблона

Первым шагом в тестировании SSTI в контексте открытого текста является создание общих шаблонных выражений, используемых различными механизмами шаблонов в качестве полезной нагрузки, и отслеживание ответов сервера, чтобы определить, какое шаблонное выражение было выполнено сервером.

Примеры общих шаблонных выражений:

```
a{{bar}}b
a{{7*7}}
{var} ${var} {{var}} <%var%> [% var %]
```

обширный [список тестовых строк/полезных нагрузок выражения шаблона .](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection) На этом этапе рекомендуется использовать

Тестирование SSTI в контексте кода немного отличается. Во-первых, тестер формирует запрос, который приводит либо к пустым ответам, либо к ответам с ошибками. В приведенном ниже примере параметр HTTP GET вставляется в переменную `personal_greeting`в заявлении шаблона:

```
personal_greeting=username
Hello user01
```

Используя следующую полезную нагрузку — ответ сервера пустой «Hello»:

```
personal_greeting=username<tag>
Hello
```

Следующим шагом является выход из оператора шаблона и вставка HTML-тега после него с использованием следующей полезной нагрузки.

```
personal_greeting=username}}<tag>
Hello user01 <tag>
```

### Определите механизм шаблонов

Основываясь на информации, полученной на предыдущем шаге, теперь тестировщик должен определить, какой механизм шаблонов используется, предоставив различные выражения шаблона. На основе ответов сервера тестер делает вывод об используемом механизме шаблонов. Этот ручной подход обсуждается более подробно в [этой](https://portswigger.net/blog/server-side-template-injection?#Identify) статье PortSwigger. Для автоматизации выявления уязвимости SSTI и механизма шаблонов доступны различные инструменты, включая [Tplmap](https://github.com/epinna/tplmap) или [расширение Backslash Powered Scanner Burp Suite](https://github.com/PortSwigger/backslash-powered-scanner) .

### Создайте эксплойт RCE

Основная цель на этом этапе — определить, как получить дальнейший контроль над сервером с эксплойтом RCE, изучив документацию по шаблону и проведя исследования. Ключевые области интересов:

-   **Для авторов шаблонов** разделы, посвященные основному синтаксису.
-   **Разделы , посвященные вопросам безопасности** .
-   Списки встроенных методов, функций, фильтров и переменных.
-   Списки расширений/плагинов.

Тестер также может определить, какие другие объекты, методы и свойства могут быть раскрыты, сосредоточив внимание на `self`объект. Если `self` объект недоступен и документация не раскрывает технических деталей, рекомендуется перебор имени переменной. Как только объект идентифицирован, следующим шагом будет цикл по объекту, чтобы определить все методы, свойства и атрибуты, доступные через механизм шаблонов. Это может привести к другим видам нарушений безопасности, включая повышение привилегий, раскрытие информации о паролях приложений, ключах API, конфигурациях и переменных среды и т. д.



## Инструменты

-   [Tplmap](https://github.com/epinna/tplmap)
-   [Backslash Powered Scanner Burp Suite extension](https://github.com/PortSwigger/backslash-powered-scanner)
-   [Template expression test strings/payloads list](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)