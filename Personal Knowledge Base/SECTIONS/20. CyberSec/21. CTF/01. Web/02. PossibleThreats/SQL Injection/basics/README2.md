
# Введение

SQL-инъекция — серьезная проблема в веб-приложениях. Это метод, который позволяет злоумышленникам вмешиваться в базу данных, подделывая запросы и отправляя их в базу данных. В этой статье мы поймем, что такое SQL-инъекция, как ее можно использовать и почему это проблема безопасности для разработчиков.

# **Что такое SQL-инъекция?**

SQL-инъекция, также известная как SQLi, представляет собой уязвимость безопасности, которая позволяет злоумышленникам манипулировать SQL-запросами, выполняемыми веб-приложением при запросе к базе данных. Это происходит, когда пользовательский ввод не очищается должным образом и непосредственно включается в запросы SQL. Злоумышленники могут использовать эту уязвимость для вмешательства в SQL-запросы приложения, потенциально предоставляя им несанкционированный доступ к базе данных или другие вредоносные действия.

# Типы SQL-инъекций:

1. In-Band (классический):
  - SQLi на основе ошибок
  - SQLi на основе объединений

2. Blind (слепой)
   - Логический (булевые) SQLi
   - SQLi на основе времени

3. Out of band

# Пример SQL-инъекции:

Давайте проиллюстрируем эту уязвимость на практическом примере, включающем злоумышленника, веб-сервер и базу данных с помощью функции аутентификации в веб-приложении.

Представьте себе сценарий, в котором пользователям необходимо ввести свое имя пользователя и пароль для входа в свои учетные записи. Когда пользователь отправляет эти учетные данные, веб-приложение создает запрос к базе данных, чтобы проверить существование предоставленного имени пользователя и пароля.

В этом сценарии входными векторами являются имя пользователя и пароль, введенные пользователем. Эти входные значения используются для создания запроса SQL.

# Использование уязвимости SQL-инъекции:

Чтобы проверить наличие SQL-инъекции, злоумышленник пытается манипулировать входными векторами, добавляя символы или код SQL. Например, вместо предоставления простого имени пользователя злоумышленник вводит имя пользователя как `admin'--`.

Обычно, когда мы добавляем имя пользователя без символов SQL, это приводит к следующему запросу:

```sql
SELECT * FROM USERS WHERE USERNAME='admin' AND PASSWORD='';
```

Но когда мы используем имя пользователя как `admin'--`этот ввод используется в запросе, в результате получается следующий запрос:

```sql
SELECT * FROM USERS WHERE USERNAME='admin'-- AND PASSWORD='';
```

В этом манипулируемом запросе одинарная кавычка, добавленная после имени пользователя admin, эффективно закрывает строку имени пользователя, а двойные дефисы (--) закомментируют остальную часть запроса. В результате запрос становится следующим:

```sql
SELECT * FROM USERS WHERE USERNAME='admin'
```

# Использование уязвимости

В манипулируемом запросе приложение не проверяет пароль, что позволяет злоумышленнику получить доступ к учетной записи администратора без необходимости ввода действительного пароля. Это демонстрирует, как SQL-инъекция может быть использована для компрометации безопасности веб-приложения и базовой базы данных.

# Предотвращение SQL-инъекций

Предотвращение SQL-инъекций имеет решающее значение для защиты веб-приложений и баз данных. Разработчики могут реализовать различные меры безопасности, такие как:

1. Проверка ввода: убедитесь, что вводимые пользователем данные проверены правильно и очищены перед использованием в запросах SQL.
2. Параметризованные запросы. Используйте параметризованные запросы или подготовленные операторы для отделения пользовательского ввода от кода SQL.
3. Новейшие технологии. Старые технологии веб-разработки не имеют защиты SQLi. Используйте новейшие веб-технологии и язык. Например, в PHP вместо MySQLi используйте PDO.


# ПРИМЕЧАНИЕ

Распространенной ошибкой при проверке приложения на предмет внедрения sql является забвение того, что определенные символы имеют особое значение в HTTP-запросах. Если вы хотите включить эти символы в свои полезные данные для атаки, вы должны закодировать их в URL-адресе, чтобы гарантировать, что они ведут себя так, как вы задумали.

- **& и = используются для объединения пар имя/значение для создания строки запроса и блока данных POST. Вам следует закодировать их, используя %26 и %3d соответственно.**

- **В строке запроса не допускаются литеральные пробелы. Если они будут отправлены, они фактически завершат всю строку. Вы должны закодировать их, используя + или %20.** **Символ + используется для объединения частей запроса в строке URL. В данном случае, он используется для разделения ключевых слов и значений запроса.**

- **Поскольку знак + используется для кодирования пробелов, если вы хотите включить в строку фактический знак +, вы должны закодировать его с помощью %2b.**

- **Точка с запятой используется для разделения полей cookie и должна кодироваться с помощью %3b.**

Эти кодировки необходимы независимо от того, редактируете ли вы значение параметра непосредственно из браузера, с помощью перехватывающего прокси-сервера или любым другим способом. Если вам не удастся правильно закодировать проблемные символы, вы можете аннулировать весь запрос или отправить данные, которые вы не собирались отправлять.

Это заставляет приложение выполнять следующий SQL-запрос:

```sql
SELECT * FROM products WHERE category = ‘Gifts’ OR 1=1--‘ AND released = 1
```

Это изменяет **предложение WHERE** запроса разработчика, добавляя второе условие. База данных проверяет каждую строку в **продуктов** **таблице** и извлекает каждую запись, в которой **категории** **столбец** имеет значение **«Подарки»** **ИЛИ** где **1 равно 1** . Поскольку 1 всегда равно 1, база данных возвращает каждую запись в **таблице продуктов** .

Исходный запрос также контролировал доступ только к выпущенным продуктам, используя ограничение Release=1. Внедрив последовательность комментариев, злоумышленник получил несанкционированный доступ к базе данных и получил доступ ко всем продуктам, выпущенным или нет.

_Приложение отображает 20 товаров независимо от категории и условия ограничения._

В этом упражнении показано, как можно обойти логику приложения, допуская недостаток контроля доступа, при котором злоумышленник может просматривать все продукты, а не только продукты, соответствующие разрешенному фильтру (показывающие выпущенные продукты).