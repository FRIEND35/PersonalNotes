
## Введение

SQL-инъекция, несомненно, одна из самых известных уязвимостей, существующая уже долгое время, продолжает сеять хаос в 2024 году. Она упоминается во многих наших ежегодных отчетах о тестах на проникновение.

Более того, по сравнению с 2022 годом, в 2023 году уязвимости SQL-инъекции были идентифицированы как [CVE 2159 раз](https://www.cvedetails.com/vulnerability-list/year-2023/opsqli-1/sql-injection.html) . А в последнем рейтинге OWASP Top 10, в котором перечислены наиболее критические и распространенные уязвимости в веб-приложениях, они занимают третье место.

В зависимости от случая, SQL-инъекция может быть утомительной для эксплуатации, чтобы оценить ее воздействие. К счастью, высококачественные инструменты, разработанные сообществом разработчиков ПО с открытым исходным кодом, такие как sqlmap, значительно облегчают задачу.

В этой статье мы рассмотрим принцип SQL-инъекций и дадим исчерпывающее представление о работе sqlmap, используя конкретные примеры.

## Краткое напоминание об SQL-инъекциях (SQLi)

Прежде всего, что означает SQL? **«Язык структурированных запросов» — это компьютерный язык, используемый для взаимодействия с базой данных и манипулирования хранимыми данными.**

Подавляющее большинство веб-приложений используют SQL для запросов к своей базе данных. Однако, в зависимости от реализации, могут возникнуть уязвимости типа SQL-инъекции, обычно называемые «SQLi».

### Что такое SQLi?

**SQL-инъекция — это атака, используемая для манипулирования реляционными базами данных веб-приложения, такими как MySQL, Oracle Database или Microsoft SQL Server** . Ее не следует путать с NoSQL-инъекциями, которые представляют собой атаки, используемые для манипулирования нереляционными базами данных, такими как MongoDB или CouchDB.

Например, рассмотрим следующий фрагмент PHP-кода:

![[Pasted image 20240731023205.png]]

Первая строка показывает, что переменная $id принимает значение параметра id в URL. Однако эта переменная $id напрямую объединяется в запросе SQL на следующей строке.

Поскольку параметром id может манипулировать любой пользователь, злоумышленник может внедрить SQL-код в параметр id URL-адреса и выполнить множество действий с базой данных веб-приложения.

Например, чтобы обеспечить внедрение, злоумышленник может внедрить 5-секундную задержку в параметр id URL-адреса:

![[Pasted image 20240731023219.png]]

На стороне сервера SQL-запрос будет следующим:

![[Pasted image 20240731023231.png]]

Таким образом, серверу потребуется 5 секунд, чтобы ответить и подтвердить SQL-инъекцию.

### Влияние SQLi

В большинстве случаев воздействие SQL-инъекции критическое. Если пользователь базы данных имеет достаточные права доступа, как это часто бывает, SQLi позволяет злоумышленнику извлечь всю базу данных из веб-приложения, а иногда даже получить контроль над сервером.

### Каковы различные типы SQLi и как их предотвратить?

Существует несколько типов SQL-инъекций. Это зависит от точки инъекции и техники, используемой для эксплуатации инъекции. Ниже приведен неполный список типов SQLi:

- на базе UNION
- Булевы слепые
- Основанный на ошибках
- Сложенные запросы
- Слепой, основанный на времени

Лучший способ защиты от SQL-инъекций — использовать «подготовленные операторы», которые определяют структуру SQL-запроса до включения переменных.

Таким образом, если переменная контролируется злоумышленником, последний не сможет внедрить себя в SQL-запрос, поскольку его структура уже будет определена заранее. Для получения дополнительной информации и примеров SQL-инъекций в целом, пожалуйста, обратитесь к нашей подробной статье: [SQL-инъекции (SQLi): принципы, последствия, эксплуатация и лучшие практики безопасности](https://www.vaadata.com/blog/sql-injections-principles-impacts-exploitations-security-best-practices/) .

## Как работает SQLmap?

Хотя можно воспользоваться SQL-инъекцией и извлечь содержимое базы данных вручную, гораздо проще и быстрее написать и использовать скрипт.

А если вы не хотите изобретать велосипед и хотите быть еще более эффективными, вам поможет sqlmap.

### Что такое SQLmap?

Sqlmap — это инструмент с открытым исходным кодом, который автоматизирует обнаружение и эксплуатацию SQL-инъекций. Это очень всеобъемлющий инструмент, предлагающий множество функций и опций, которые могут дойти до компрометации SQL-сервера, если позволяют условия.

_Прежде чем двигаться дальше, важно отметить, что sqlmap потенциально генерирует большой трафик и что его использование является незаконным без разрешения владельца тестируемой системы._

### Использование SQLi с помощью Sqlmap

Во время теста на проникновение sqlmap обычно используется после того, как SQLi был идентифицирован. Это гарантирует, что трафик не генерируется впустую. Затем необходимо выполнить несколько шагов, чтобы эксплуатировать SQL-инъекцию классическим способом.

Давайте рассмотрим это шаг за шагом.

#### Поиск полезной нагрузки, подходящей для типа SQLi

Первым шагом является поиск полезной нагрузки, подходящей для типа SQLi, которая будет использоваться для извлечения данных из базы данных на следующих этапах.

**Команда:**

![[Pasted image 20240731023254.png]]


Опция «-r» сообщает sqlmap файл, содержащий HTTP-запрос, содержащий точку инъекции. Если местоположение точки инъекции известно злоумышленнику, как в этом примере, его можно указать, добавив звездочку к точному местоположению, где должна произойти инъекция SQL:

![[Pasted image 20240731023310.png]]

В этом случае злоумышленник знает, что возможна инъекция SQL в значение cookie-файла «TrackingId».

Обратите внимание, что вместо указания URL-адреса можно использовать опцию «-u», если в параметре URL-адреса возможна инъекция SQL.

**Результат:**

После тестирования нескольких полезных нагрузок sqlmap наконец обнаружил тип SQL-инъекции:

![[Pasted image 20240731023323.png]]

Здесь тип SQL-инъекции — «слепой запрос со стековым временем», т. е. можно извлечь данные, играя с задержками, поскольку напрямую получить результат SQL-инъекции невозможно. Кроме того, инъекция выполняется новым запросом после исходного, отсюда и «стековый запрос».

В то же время sqlmap также определил используемую систему базы данных, которая является PostgreSQL. С этой информацией sqlmap теперь может использовать полезные нагрузки, которые учитывают тип инъекции и систему базы данных для извлечения данных.

#### Извлечение имен баз данных

Вторым шагом является эксфильтрация имен базы данных. Этот шаг можно выполнить одновременно с первым, чтобы сэкономить время.

**Команда:**

![[Pasted image 20240731023335.png]]

Чтобы перечислить базы данных, добавьте опцию «-dbs».

**Результат:**

![[Pasted image 20240731023348.png]]

Здесь обнаружена только одна база данных — «публичная».

#### Перечисление названий таблиц

На третьем этапе, теперь, когда мы знаем имя базы данных, мы можем составить список имен таблиц.

**Команда:**

![[Pasted image 20240731023406.png]]

Параметр « **-D** » указывает имя базы данных, в данном случае «public», а параметр « **-tables** » используется для перечисления имен таблиц, присутствующих в «public» базе данных.

**Результат:**

![[Pasted image 20240731023428.png]]

Были найдены две таблицы: «tracking» и «users». Вторая таблица выглядит интересной и может содержать данные, касающиеся пользователей платформы.

#### Выбор интересного стола

Четвертый шаг — выбрать интересную таблицу для изучения. Для этого перечислим ее столбцы.

**Команда:**

![[Pasted image 20240731023442.png]]

Параметр « **-T** » используется для указания таблицы «users», а параметр « **-columns** » — для вывода списка имен столбцов.

**Результат:**

![[Pasted image 20240731023454.png]]

#### Перечисление данных таблицы

Для пятого и последнего шага, теперь, когда у нас есть обзор таблицы «пользователи», мы можем выбрать перечисление всех данных в таблице или только данных в определенных столбцах. В нашем случае мы перечисляем данные в столбцах «имя пользователя» и «пароль».

**Команда:**

![[Pasted image 20240731023526.png]]

С опцией « **-C** » мы выбираем наши столбцы, разделенные запятой. Опция « **-dump** » используется для эксфильтрации данных таблицы.

**Результат:**

![[Pasted image 20240731023536.png]]

Итак, нам удалось узнать имя и пароль каждого пользователя на платформе с помощью sqlmap.

### Использование Sqlmap для получения системной информации

Чтобы пойти дальше и лучше понять среду, подвергающуюся атаке, всегда интересно получить информацию, связанную с системой базы данных. С помощью sqlmap вы можете получить:

- Пользователь системы, в данный момент использующий базу данных
- Имеет ли текущий пользователь системы роль DBA (администратора базы данных)
- Имя хоста
- Все системные пользователи базы данных
- Привилегии всех пользователей системы

Ниже приведены команды, используемые для получения этой информации, и их результаты:

**Пользователь системы, в данный момент использующий базу данных**

![[Pasted image 20240731023551.png]]

**Результат:**

![[Pasted image 20240731023601.png]]

**Является ли текущий пользователь системы администратором баз данных?**

![[Pasted image 20240731023612.png]]


**Результат:**

![[Pasted image 20240731023628.png]]

**Имя хоста**

![[Pasted image 20240731023652.png]]

**Результат:**

![[Pasted image 20240731023704.png]]

**Список пользователей системы в базе данных**

![[Pasted image 20240731023717.png]]

**Результат:**

![[Pasted image 20240731023729.png]]

**Привилегии пользователей системы базы данных**

![[Pasted image 20240731023750.png]]

**Результат:**

![[Pasted image 20240731023801.png]]

### Использование слепых SQL-инъекций с помощью Sqlmap

Результаты SQL-инъекции часто не возвращаются в ответ, как в случае слепых SQL-инъекций. Так как же sqlmap удается извлечь данные?

Если SQL-инъекция имеет слепой тип, вам нужно найти условие, которое возвращает другой ответ сервера в зависимости от того, является ли оно истинным или ложным. Например, в случае булевой слепой SQLi сервер ответит по-другому, если булево условие в инъецированном запросе ложно:

![[Pasted image 20240731023856.png]]

Если сервер отвечает по-другому, это можно использовать и извлечь имена баз данных посимвольно, затем таблицы, столбцы и, наконец, данные.

Например, с помощью следующей инъекции, если мы сохраним наш пример инъекции в идентификаторе продукта, мы можем узнать, равен ли первый символ пароля для пользователя «administrator» в столбце «password» таблицы «users» числу «5» или нет:


![[Pasted image 20240731023908.png]]

Таким образом, полный запрос на стороне сервера будет выглядеть следующим образом:

![[Pasted image 20240731023937.png]]

Поскольку пароль начинается с «5», сервер реагирует иначе, чем если бы мы ввели вместо него другую цифру или букву.

Мы можем перейти к следующим символам, увеличивая второй параметр функции SQL SUBSTRING(). Обратите внимание, что этот метод работает, поскольку мы знаем, что система базы данных — PostgreSQL, а тип SQLi — это слепой тип на основе булевых значений.

Сила sqlmap заключается в его способности автоматизировать и рассматривать большинство случаев SQL-инъекций. Инструмент sqlmap очень полный и полезен для эксплуатации многих других типов SQL-инъекций, а не только слепых. В следующем разделе мы рассмотрим некоторые из многочисленных «продвинутых» опций sqlmap, а также понятие «вмешательства».

### Расширенные параметры SQLmap

Не будет преувеличением сказать, что sqlmap — это полноценный инструмент SQLi. Попробуйте отобразить полную справку с опцией « **-hh** », и вы уже получите представление о мощи этого инструмента.

В этом разделе мы перечислим некоторые опции, которые могут пригодиться во время пентеста, но не ограничивайтесь ими, мы настоятельно рекомендуем вам самостоятельно изучить многочисленные нюансы этого инструмента.

#### –proxy=

Чтобы точно понять, что отправляет sqlmap, можно просмотреть каждый отправленный запрос и его ответ, указав прокси. Например, вы можете передать весь трафик, сгенерированный sqlmap, через [Burp Suite](https://www.vaadata.com/blog/introduction-to-burp-suite-the-tool-dedicated-to-web-application-security/) .

Это можно использовать для понимания и разрешения случаев, когда sqlmap работает не так, как ожидалось, путем непосредственного наблюдения за тем, как сервер отвечает на запросы, отправленные sqlmap.

#### –delay=

[](https://www.vaadata.com/blog/what-is-rate-limiting-how-it-works-and-implementation-techniques/)В некоторых веб-приложениях иногда применяется [ограничение скорости .](https://www.vaadata.com/blog/what-is-rate-limiting-how-it-works-and-implementation-techniques/)

Интенсивный трафик, генерируемый sqlmap, может активировать оповещения на сервере, которые будут блокировать любые новые запросы от нас. Чтобы обойти эту проблему, вы можете использовать опцию «–delay», которая указывает задержку в секундах между каждым запросом, отправляемым sqlmap.

Экспериментируя с этой задержкой, вы потенциально можете обойти ограничение скорости, но извлечение данных займет больше времени.

#### –force-ssl

Если сервер не принимает использование протокола HTTP и вы указываете файл запроса с опцией «-r», опция «–force-ssl» позволяет принудительно использовать HTTPS для отправленных запросов.

Это простая опция, но ее важно добавить в команду для безопасного извлечения данных.

#### –threads=

Если вы знаете, что сервер может обрабатывать большой трафик, хорошей идеей будет увеличить количество потоков в вашей команде sqlmap, чтобы быстрее извлекать данные. Однако будьте осторожны и не злоупотребляйте этим, так как это может привести к сбою SQL-сервера.

#### –dbms=

В целях оптимизации, если вы знаете систему базы данных, используемую сервером SQL, можно указать ее в sqlmap. Это сокращает время, необходимое для определения типа SQLi, поскольку sqlmap будет тестировать только полезные нагрузки, связанные с указанной СУБД.

#### –level=

Опция «–level» используется для указания sqlmap полноты выполняемых тестов. Значение варьируется от 1 до 5, по умолчанию оно равно 1. Чем выше значение, тем большее количество тестируемых полезных нагрузок.

Это практичный вариант для сложных случаев SQL-инъекции. Если sqlmap не находит полезную нагрузку для инъекции с первого раза, хорошей идеей будет увеличить значение этого параметра.

#### –risk=

Как и предыдущая опция, опция «–risk» может использоваться для указания приемлемого уровня риска от 1 до 3. Чем выше значение, тем больше полезных данных внедряет sqlmap, но и тем выше риск.

В зависимости от места инъекции в исходном SQL-запросе, увеличение риска может привести к нежелательным изменениям данных. По умолчанию это значение равно 1.

#### –string=

В случае SQL-инъекций на основе логических значений можно указать sqlmap строку символов, которую следует искать в ответе сервера, если внедренное условие истинно.

Как мы видели ранее, в случае булевой слепой функции ответ сервера отличается, если введенное условие истинно или ложно. Если оно истинно, то разница может быть такой же простой, как строка символов в ответе сервера, поэтому хорошей идеей будет указать ее в sqlmap.

#### –technique=

Можно указать sqlmap тип тестируемых полезных нагрузок и их порядок. SQL-инъекция может быть нескольких различных типов и может, например, быть одновременно и булевой, и временной слепой.

Однако слепая полезная нагрузка на основе булевых значений будет эксплуатироваться быстрее, чем слепая полезная нагрузка на основе времени. Используя опцию «–technique», вы можете указать sqlmap, какой тип SQLi искать и находить.

Ниже приведены значения, которые может принимать эта опция, и что они означают:

- B: слепой алгоритм на основе булевых значений
- E: Основанный на ошибках
- U: Объединение на основе запроса
- S: Сложенные запросы
- T: Слепой режим на основе времени
- В: Встроенные запросы

Вы можете выбрать только одно значение или все из них в определенном порядке, которому будет следовать sqlmap. Порядок по умолчанию: BEUSTQ.

#### –file-read=

В некоторых системах баз данных, таких как MySQL, PostgreSQL или Microsoft SQL Server, иногда случается так, что пользователь базы данных имеет достаточные права для чтения файлов в системе. С помощью опции «–file-read» вы можете указать путь к файлу, который нужно извлечь.

#### –os-cmd=

Как и в предыдущем варианте, опция «–os-cmd» используется для выполнения команды на сервере SQL. Эта опция работает только на СУБД MySQL, PostgreSQL или Microsoft SQL Server, и пользователь базы данных должен иметь достаточные права.

#### –flush-session

По умолчанию при использовании sqlmap для целевого объекта создается сеанс, относящийся к целевому объекту, который сохраняется в памяти вашего компьютера.

Таким образом, если вы дадите sqlmap тот же запрос, он сможет сразу же продолжить использование SQLi, поскольку вся необходимая информация уже будет в памяти (полезная нагрузка, уже найденная структура базы данных и т. д.), и ему не придется начинать с самого начала.

С другой стороны, если вы хотите, чтобы sqlmap начал работу с нуля на вашей целевой системе, используйте эту опцию один раз, чтобы удалить сохраненный сеанс.

#### –tamper=

Эта опция расширяет гибкость sqlmap. С помощью этой опции вы можете указать один или несколько скриптов, которые изменяют полезную нагрузку перед ее отправкой в ​​цель.

В следующем разделе мы разовьем понятие скриптов взлома и рассмотрим несколько конкретных примеров.

Более подробную информацию обо всех параметрах sqlmap можно найти в [вики](https://github.com/sqlmapproject/sqlmap/wiki/Usage) .

### Sqlmap искажает скрипты

Скрипты Tampers — это скрипты, используемые для изменения полезных данных, отправляемых sqlmap, чтобы обойти некоторые фильтры приложений или настройки WAF. Например, веб-приложение вполне может запретить использование пробелов в пользовательской записи.

Как только аудитор идентифицирует SQL-инъекцию в этой же записи, ему нужно будет найти способ обойти этот фильтр, чтобы использовать SQL-инъекцию. Здесь могут быть использованы скрипты tampers. Существуют скрипты, уже реализованные sqlmap, которые пользователь может использовать, но вполне возможно создать свой собственный для уникальных ситуаций. 

Чтобы получить список скриптов вмешательства, уже реализованных sqlmap, используйте следующую команду:

![[Pasted image 20240731024039.png]]

Среди примерно шестидесяти уже имеющихся тамперов можно упомянуть несколько:

#### space2comment.py

Этот скрипт заменяет все пробелы в полезной нагрузке на комментарии, такие как «/**/». Таким образом, открывая и закрывая комментарий немедленно, он может быть интерпретирован некоторыми системами баз данных как пробел. Таким образом, этот скрипт может быть использован для обхода простых фильтров «анти-SQLi», реализованных некоторыми веб-приложениями, которые блокируют только пользовательские записи, содержащие пробелы.

#### **randomcase.py**

Скрипт «randomcase.py» можно использовать для изменения регистра всех ключевых слов SQL, таких как «SELECT», «WHERE» и т. д. Например, «SELECT» может стать «SelEcT». Некоторые фильтры приложений или WAF проверяют, нет ли ключевых слов SQL в записях пользователя, чтобы защититься от SQL-инъекций. Однако, если этот фильтр реализован плохо, изменение регистра может потенциально обойти защиту.

#### **equaltolike.py**

Этот скрипт заменяет все знаки «=» в полезной нагрузке на эквивалент «LIKE», чтобы обойти фильтры приложения, которые запрещают использование знака равенства при вводе пользователем.

Важно отметить, что эти скрипты можно использовать одновременно для обхода нескольких фильтров одновременно.

## Заключение

Sqlmap — это необходимый инструмент для тех, кто хочет обнаружить и использовать SQL-инъекции. Он предоставляет ряд функций, которые могут удовлетворить как базовые, так и более продвинутые потребности. Все эти качества делают его мощным инструментом, необходимым для пентестеров.