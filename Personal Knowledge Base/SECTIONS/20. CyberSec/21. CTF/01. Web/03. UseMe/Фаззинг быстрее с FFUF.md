**Источник:** https://medium.com/quiknapp/fuzz-faster-with-ffuf-c18c031fc480

FFUF — один из новейших и, безусловно, самых быстрых инструментов фаззинга с открытым исходным кодом. Но прежде чем мы начнем, давайте сначала попытаемся понять, что такое фаззинг на самом деле.

Фаззинг — это автоматический процесс предоставления приложению случайных входных данных для поиска ошибок или неожиданного поведения. Но поиск скрытых каталогов и файлов на веб-сервере также можно отнести к категории фаззинга.

![[Pasted image 20240909173650.png]]

Инструмент универсален и может использоваться для самых разных целей. Вот некоторые из случаев его использования:

- Обнаружение общего каталога с возможностью фаззинга в любом месте URL-адреса.
- Обнаружение VHOST без записей DNS
- Фаззинг с использованием различных HTTP-методов.

Мы поговорим об установке, а затем перейдем к использованию инструмента.

**Установка**

1. Инструмент можно легко установить, загрузив совместимый двоичный файл в виде **файла tar.gz** со [**«Релизы»**](https://github.com/ffuf/ffuf/releases) страницы **ffuf** на **Github** .
2. Его также можно установить с помощью **_команды go get_** .

> иди на github.com/ffuf/ffuf

**Golang** Для использования этого метода необходим компилятор **_, который можно легко установить с помощью apt-get_** в Linux.

```bash
apt-get установить голанг
```

Не забудьте добавить каталог go/bin в **переменную PATH** , чтобы использовать инструмент из любого каталога.

**Использование**

![[Pasted image 20240909173703.png]]

Ffuf предлагает множество вариантов фаззинга.

Позиция, подлежащая фаззингу, должна обозначаться словом FUZZ в команде ffuf.

## Обнаружение каталогов и файлов

Каталоги на веб-сайте можно найти с помощью следующей команды, которая предоставляет ffuf **список слов** с **_флагом -w_** и **URL-адрес** с **_командой -u_** , которая содержит слово FUZZ, обозначающее позицию, подлежащую фаззингу.

```bash
 ffuf -w wordlist.txt -u [http://website.com/FUZZ](http://website.com/FUZZ)
```

Для обнаружения файлов можно использовать ту же команду, а для использования определенных расширений с записями списка слов **_-e ._** можно использовать флаг

```bash
ffuf -w wordlist.txt -u [http://website.com/FUZZ](http://website.com/FUZZ) -e .aspx,.html,.php,.txt
```

![[Pasted image 20240909173721.png]]

Ffuf также дает возможность получать выходные данные только ответов с определенным кодом состояния, количеством строк, размером ответа, количеством слов, а также ответом, который соответствует шаблону регулярного выражения.

Вот несколько примеров флагов для этого:

- _-mc: указать код состояния._
- _-ml: указать количество строк в ответе_
- _-mr: указать шаблон регулярного выражения_
- _-ms: указать размер ответа_
- _-mw: указать количество слов в ответе_

Вот несколько демонстраций, чтобы сделать это яснее и проще для понимания.

Для получения ответов только с кодами состояния 200 и 302 используйте:

```bash
 ffuf -w wordlist.txt -w [http://website.com/FUZZ](http://website.com/FUZZ) -e .aspx,.html -mc 200,302
```

Параметры URL-адреса, оканчивающиеся на FUZZ, также поддерживаются функцией рекурсии, которая при активации с помощью **_флага -recursion_** будет пытаться фаззить данный URL-адрес, а затем дополнительно фаззить внутри каталогов, которые он нашел в первичном фаззе.

Глубину рекурсии также можно указать с помощью **_флага -recursion-length_** .

Флаг **_-maxtime_** предлагает завершить текущий фаззинг по истечении указанного времени в секундах.

```bash
ffuf -w wordlist.txt -u [http://website.com/FUZZ](http://website.com/FUZZ) -maxtime 60
```

Приведенная выше команда будет работать в течение 60 секунд, а затем уничтожит себя, даже если список слов не завершен.

**_-maxtime-job_** используется с **_флагом -recursion_** и используется для указания времени (в секундах) для каждого нового задания, которое будет создано для каждого найденного каталога.

Количество потоков по умолчанию, в которых работает ffuf, равно **40** и может быть изменено с помощью **флага -t** в команде.

## Открытие VHOST

Этот инструмент способен находить поддомены без записей DNS с невероятной скоростью.

Инструмент использует **заголовок Host** в HTTP-запросе для поиска поддоменов. Флаг **_-H_** используется для указания заголовков HTTP-запроса. Обратите внимание, что **_-H ._** допускается использование нескольких флагов

```bash
ffuf -w subdomains.txt -u [http://website.com/](http://website.com/) -H «Хост: FUZZ.website.com»
```

Если инструмент выдает на выходе множество поддоменов и большинство из них отсутствуют в действительности, то можно использовать параметры фильтра, предлагаемые инструментом.

## Фильтрация результата

Обратите внимание на наиболее распространенный размер, слова или строки для ложноположительных ответов, а затем укажите их в фильтре. Использовать:

- **_-fw_** : фильтровать по количеству слов
- **_-fl_** : фильтровать по количеству строк
- **_-fs_** : фильтровать по размеру ответа
- **_-fc_** : фильтровать по коду состояния
- **_-fr_** : фильтровать по шаблону регулярного выражения

![[Pasted image 20240909173944.png]]

Как и на изображении выше, есть много ложных срабатываний, и большинство из них имеют **_размер: 12454_** _,_ **_слова: 3913_** _,_ **_строки: 421_** .

Таким образом, мы можем фильтровать эти ответы с помощью флагов фильтра.

```bash
ffuf -w sublists.txt -u [http://website.com/](http://website.com/) -H «Хост: FUZZ.website.com» -fw 3913
```

![[Pasted image 20240909202904.png]]

Параметр `-fw` в команде `ffuf` используется для фильтрации результатов на основе количества слов (`filter words`). Это означает, что если количество слов в HTTP-ответе совпадает с указанным значением, то такой ответ будет исключён из вывода. В данном случае вы используете `-fw 3913`, что означает, что все ответы, содержащие 3913 слов, будут отфильтрованы и не будут показаны в результатах.

Этот параметр часто используется для исключения ответов, которые являются одинаковыми для большинства запросов, например, страниц с ошибками или страниц, которые всегда возвращают один и тот же контент. Некоторые веб-сайты возвращают код ответа HTTP `200 OK`, даже если страница не найдена, и отображают сообщение об ошибке `404 Not Found` внутри HTML-контента. Это делается для того, чтобы усложнить автоматическое обнаружение несуществующих страниц.

В таких случаях параметр `-fw` полезен, так как он позволяет фильтровать ответы с одинаковым содержимым (например, страницы с шаблонным текстом "404" или другой версткой), несмотря на то, что они возвращают код `200 OK`.

Таким образом, даже если HTTP-статус указывает на успешный ответ, `ffuf` будет исключать такие страницы из результатов, если количество слов в ответе совпадает с указанным значением, что помогает сосредоточиться на действительно интересных ответах.

Параметр `-fw` в `ffuf` (Fuzz Faster U Fool) работает следующим образом:

1. **Запросы и ответы**: `ffuf` отправляет запросы на сервер по заданному списку слов или путей. В вашем случае инструмент использует слова из файла `sublists.txt` для подстановки в поле `FUZZ` в заголовке `Host`. Таким образом, он проверяет различные поддомены, например `subdomain1.website.com`, `subdomain2.website.com` и т.д.
    
2. **Получение ответов**: На каждый отправленный запрос сервер возвращает HTTP-ответ. Этот ответ содержит заголовки, статусный код (например, `200 OK`, `404 Not Found` и т.д.), а также тело ответа, которое может включать HTML-код страницы, JSON, текст или другой контент.
    
3. **Подсчёт слов в ответе**: Когда `ffuf` получает HTTP-ответ, он анализирует тело ответа и подсчитывает количество слов в нём. Для этого он разделяет текст на слова, используя пробелы и другие разделители, и считает их количество.
    
4. **Фильтрация по количеству слов**: Параметр `-fw` указывает `ffuf`, что нужно отфильтровать (то есть исключить из результатов) все ответы, в которых количество слов совпадает с заданным значением. В вашем примере, если количество слов в ответе равно `3913`, то этот ответ не будет отображён в результатах.
    

**Пример сценария использования**

Допустим, вы сканируете сайт, и большинство несуществующих поддоменов возвращает страницу, содержащую сообщение об ошибке `404`, но при этом сервер отвечает статусом `200 OK`. Эта страница может содержать, например, 3913 слов, включая HTML-разметку, скрипты и текст ошибки.

Если вы не используете фильтрацию, то такие ответы будут показаны в результатах и могут затруднить выявление интересных поддоменов, которые реально существуют. Используя `-fw 3913`, вы исключаете эти страницы из вывода и сосредотачиваетесь на тех, где количество слов отличается, что может указывать на настоящие, уникальные поддомены.

**Плюсы использования**

- **Исключение ложных срабатываний**: Вы убираете из результатов стандартные ошибки или страницы-заглушки.
- **Фокус на релевантных результатах**: Позволяет сосредоточиться на потенциально интересных ответах с уникальным содержимым.

Этот метод фильтрации особенно полезен, когда шаблонные страницы (например, страницы ошибки или редиректы) содержат одинаковое количество слов, независимо от содержимого запроса.

Давайте рассмотрим работу параметра `-fw` в `ffuf` ещё более подробно, пошагово, чтобы глубже понять, как происходит процесс фильтрации на основе количества слов в ответах.

**Шаг 1: Отправка запросов**

Когда вы запускаете `ffuf` с командой, подобной следующей:

```
ffuf -w sublists.txt -u http://website.com/ -H "Host: FUZZ.website.com" -fw 3913
```

`ffuf` использует список слов из файла `sublists.txt`. Например, если файл содержит слова:

```
admin 
blog
shop
```

`ffuf` создаст HTTP-запросы с подстановкой каждого из этих слов в заголовок `Host`. Например:

- `Host: admin.website.com`
- `Host: blog.website.com`
- `Host: shop.website.com`

Каждый такой запрос отправляется на сервер `website.com`.

**Шаг 2: Получение и анализ ответа**

На каждый запрос сервер возвращает HTTP-ответ. Этот ответ состоит из:

1. **Заголовки ответа**: Включают информацию о сервере, типе контента, коде статуса (например, `200 OK`), и другую метаинформацию.
    
2. **Тело ответа**: Основная часть ответа, которая содержит содержимое страницы или данные. Это может быть HTML-документ, JSON, текст и т.д.
    

Пример тела ответа:

```html
<!DOCTYPE html>
<html>
<head><title>404 Not Found</title></head>
<body>
<h1>Not Found</h1>
<p>The requested URL was not found on this server.</p>
</body>
</html>

```

**Шаг 3: Подсчёт слов**

После получения ответа `ffuf` анализирует тело ответа, чтобы подсчитать количество слов. Этот процесс включает следующие этапы:

1. **Извлечение тела ответа**: `ffuf` выделяет часть ответа, содержащую основной контент (HTML, текст, JSON и т.д.).
    
2. **Разделение на слова**: Тело ответа разбивается на слова, используя пробелы и другие разделительные символы (например, знаки препинания, символы новой строки и т.д.). В HTML-документе выше слова будут:
    

- `DOCTYPE`
- `html`
- `head`
- `title`
- `404`
- `Not`
- `Found`
- и т.д.

3. **Подсчёт слов**: `ffuf` подсчитывает количество слов в теле ответа. Предположим, что результат подсчёта для данного ответа — `3913` слов.

**Шаг 4: Фильтрация по количеству слов**

Теперь включается параметр `-fw 3913`. Он указывает `ffuf`, что если количество слов в ответе равно `3913`, такой ответ должен быть исключён из вывода.

- Если ответ содержит **точно** 3913 слов, `ffuf` не будет включать его в результаты.
- Если количество слов отличается от 3913, такой ответ будет показан в результатах сканирования.

**Почему это важно?**

Во многих случаях, особенно на защищённых или хорошо сконфигурированных сайтах, страницы, которые не существуют или недоступны (например, поддомены, которые не настроены), могут возвращать стандартный шаблонный ответ. Хотя HTTP-статус может быть `200 OK`, на самом деле это может быть страница с сообщением об ошибке `404 Not Found`, содержащая фиксированное количество слов. Используя параметр `-fw`, вы можете:

1. **Избежать ложных положительных результатов**: Шаблонные страницы-заглушки с одинаковым количеством слов исключаются, позволяя вам сосредоточиться на реальных, уникальных ответах.
    
2. **Сосредоточиться на важном**: Результаты, которые остаются после фильтрации, с большей вероятностью будут представлять интерес для дальнейшего анализа.
    

**Дополнительные параметры фильтрации**

Помимо `-fw`, `ffuf` также поддерживает другие параметры фильтрации, такие как:

- `-fc`: Фильтрация по HTTP-кодам (например, исключение всех ответов с кодом `404`).
- `-fs`: Фильтрация по размеру ответа в байтах.
- `-fl`: Фильтрация по количеству строк в ответе.

Эти параметры могут быть комбинированы для более точной настройки сканирования и исключения нежелательных результатов.

Параметр `-fw` в `ffuf` позволяет вам исключать из результатов сканирования ответы, которые имеют определённое количество слов, что полезно для фильтрации шаблонных или повторяющихся ответов. Это упрощает анализ результатов и помогает обнаруживать действительно важные и интересные страницы или поддомены.

То есть, если получаете ложные ответы, то можете просто фильтровать их по размеру, словам, строчкам и т.д.
## Разнообразие 

Этот инструмент также позволяет нам фаззить в любом месте, от URL до заголовков HTTP.

Чтобы разграничить URL-адрес определенным методом HTTP, просто добавьте **_флаг -X_** и укажите метод.

Например, для фаззинга URL-адреса методом POST используйте:

```bash
ffuf -w wordlist.txt -u [http://website.com/FUZZ](http://website.com/FUZZ) -X POST
```

Поскольку ffuf предлагает фаззинг в любом месте, мы также можем фаззить данные, которые будут отправлены в POST-запросе.

```bash
 ffuf -w wordlist.txt -X POST -d «username=admin\&password=FUZZ» -u [http://website.com/FUZZ](http://website.com/FUZZ)
```

Здесь **_флаг -d_** используется для указания данных, которые будут отправлены с помощью POST-запроса.

Инструмент можно использовать и таким образом.

```bash
ffuf -w wordlist.txt -u [http://website.com/FUZZ/backup.zip](http://website.com/FUZZ/backup.zip)
```

Этот инструмент также можно использовать для перебора страниц входа в систему, используя **_флаг -mode_** и выбирая тип атаки из **кластерной бомбы** и **вил** . Оба режима принимают два списка слов — _один для имени пользователя и один для пароля_ .

- В **режиме кластерной бомбы** каждое слово в списке слов имени пользователя будет использоваться в сочетании с каждым словом в списке слов пароля. Например, если в списке 1 есть 4 слова, а в списке 2 — 5, то всего будет 20 запросов.
- В **режиме вил** слово на первой позиции в списке имен пользователей будет использоваться со словом на первой позиции в списке паролей, аналогично слово на второй позиции в списке имен пользователей будет использоваться со словом на второй позиции в списке паролей. Если количество слов в обоих списках не одинаковое, атака прекратится, как только исчерпается список с меньшим количеством слов.

Флаг **-request** можно использовать для указания файла с необработанным HTTP-запросом, который будет соответствующим образом использоваться для FUZZ.

Чтобы перебрать форму входа с помощью **атаки кластерной бомбы** с помощью HTTP-запроса,

![[Pasted image 20240909174130.png]]

```bash
 ffuf -request req.txt -request-proto http -mode кластерная бомба -w usernames.txt:HFUZZ -w пароли.txt:WFUZZ
```

В файле запроса **HFUZZ** размещается по **адресу login_username** и передается в **usernames.txt** . Аналогично, **WFUZZ** размещается в **файле login_password** и передается в **файл паролей.txt** .

И да, **флаг -c** можно использовать для получения немного красочного вывода.

Этот инструмент превосходит все другие инструменты с точки зрения скорости, поскольку он написан на golang.

Люди путают wfuzz и ffuf, поскольку оба они предоставляют схожие функции, но ffuf превосходит wfuzz с точки зрения скорости, поскольку wfuzz написан на Python.

**Примечание. Эта статья предназначена только для образовательных целей. Вы сами несете ответственность за использование инструмента.**

Автор: [Адитья Верма](https://medium.com/u/97f9fb488758?source=post_page-----c18c031fc480--------------------------------)