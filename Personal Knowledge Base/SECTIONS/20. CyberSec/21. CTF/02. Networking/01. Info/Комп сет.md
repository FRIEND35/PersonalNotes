



### Сравнение пакетов и дейтаграмм

Термин пакет распространяется на любое сообщение, форматированное как пакет, тогда как термин дейтаграмма обычно используется для пакетов «ненадёжных» служб. «Надёжной» является служба, которая уведомляет пользователя, если доставка не удалась, тогда как «ненадёжная» такого уведомления пользователя не делает. Например, IP не обеспечивает надёжного сервиса, а TCP и IP вместе его обеспечивают, тогда как UDP с IP надёжного сервиса не обеспечивают. Все эти протоколы используют пакеты, но UDP-пакеты, как правило, называют дейтаграммами.

Когда сеть ARPANET впервые выступила с коммутацией пакетов, она обеспечивала надёжную процедуру доставки пакетов к серверам через свой интерфейс 1822. Сервер сети организует данные в пакет нужного формата, вставляет туда адрес компьютера назначения и посылает сообщение через интерфейс процессору передачи сообщений. Как только сообщение доставлено к серверу назначения, на посылающий сервер доставляется подтверждение. Если сеть не может доставить сообщение, на посылающий сервер будет послано извещение об ошибке.

Разработчики CYCLADES и ALOHAnet продемонстрировали, что можно построить эффективную компьютерную сеть, не обеспечивая надёжной передачи пакетов. Этот опыт позже был использован конструкторами Ethernet.


![[Pasted image 20240626032154.png]]

### Пример IP-пакета

IP-пакеты состоят из заголовки и полезной нагрузки (поля данных).. Максимальная длина пакета 65 535 байт Заголовок обычно имеет длину 20 байт и содержит информацию о сетевых адресах отправителя и получателя, о параметрах фрагментации, о времени жизни пакета, о контрольной сумме и некоторых других. В поле данных IP - пакета находятся сообщения более высокого уровня. Теперь давайте пройдемся по оставшимся полям заголовка IP-пакета. Будем двигаться слева направо и сверху вниз. Заголовок пакета IPv4 состоит из:

- Version (4 бита): Версия - Самое первое поле в заголовке IP пакета – это версия, под него выделено четыре бита, для протокола IPv4 здесь всегда неизменное значение – 4. Хочу заметить, что в IPv4 четверка не связана с количество октетов в IP-адресе, просто такое совпадение. Простыми словами, 4 бита содержат версию пакета: IPv4 или IPv6.

- Internet Header Length, IHL (4 бита): Длинна заголовка - Поле размер заголовка нужно для того, чтобы

Маршрутизатор или конечный узел понимали: где заканчивается заголовок и начинаются данные. Также мы помним, что поле Опции не является обязательным, собственно из-за этого и появилась необходимость в поле «Размер заголовка», под это поле выделено четыре бита и оно служит для указания количества слов в заголовке. Таким образом получается, что минимальный размер заголовка IP-пакет равен пяти словам, каждое слово 32 бита, следовательно, обычный заголовок без дополнительных опций равен 160 бит или 20 байт. Максимальное количество слов в заголовке равно пятнадцати. То есть, обычно заголовок IP-пакета имеет длину в 20 байт (пять 32-битовых слов), но при увеличении объема служебной информации эта длина может быть увеличена. Наибольший заголовок занимает 60 октетов.

- Type of Service (8 бита): Тип сервиса - указывает, как следует обрабатывать дейтаграмму. Первые 3 бита являются битами приоритета. На самом деле на данный момент поля Type of Service в IP заголовке нет, изначально поле ToS использовалось для указания приоритетов при обработке трафика, сейчас это поле заменено на два.


- Total Length (16 бита): Общая длинна - Это поле позволяет обрабатывающему устройству понять полный размер пакета, то есть заголовок плюс данные. Минимальный размер IP-пакета равен 20 байт, то есть это заголовок без опций и данных, а максимальный размер равен 65535 байт. Как мы и говорили, максимальная длина пакета ограничена разрядностью поля, определяющего эту величину, и составляет 65 535 байт, однако в большинстве компьютеров и сетей такие большие пакеты не используются. При передаче по сетям различного типа длина пакета выбирается с учетом максимальной длины пакета протокола нижнего уровня, несущего IP-пакеты. Если это кадры Ethernet, то выбираются пакеты с максимальной длиной в 1500 байт, умещающиеся в поле данных кадра Ethernet. В стандарте предусматривается, что все хосты должны быть готовы принимат пакеты вплоть до 576 байт длиной (приходят ли они целиком или по фрагментам). Существует такое правило: хостам рекомендуется отправлять пакеты размером более чем 576 байт, только если они уверены, что принимающий хост или промежуточная сеть готовы обслуживать пакеты такого размера. Тут стоит заметить, что одним из параметров канала связи является максимально возможный размер пакета (субъективные и объективные характеристики компьтюерной сети), который по этому каналу можно передавать. И, например, бывают ситуации, когда в канале связи можно передавать пакеты, размером, скажем (точные цифры сейчас не очень важны) 1000 байт, а узел генерирует пакеты размером 2000 байт, в этом случае перед отправкой данных в канал связи пакеты будут фрагментироваться, то есть разбиваться на более мелкие, это поведение по умолчанию в протоколе IP.

- Identification (16 бита): Идентификатор - Чаще всего это поле используется в тех ситуация, когда пакет фрагментируется, чтобы принимающая сторона понимала, как из полученных кусочков правильно собрать пакет. У фрагментированных пакетов значение в этом поле должны быть одинаковыми. Простыми словами используется для распознавания пакетов, образовавшихся путем фрагментации исходного пакета. Все фрагменты должны иметь одинаковое значение этого поля.

- Flags (3 бита): Флаги - Под поле флаги выделено три бита, этих три бита используются для контроля над фрагментацией пакетов. Немного отвлечемся непосредственно от флагов и заметим, что нумерация бит в поле начинается с нуля, крайний левый бит старший, а крайний правый – младший. Тогда у нас в поле Флаги получается следующая картина:

- Fragment Offset (13 бита): Смещение фрагмента - Это поле используется в тех случаях, когда выполняетс фрагментация пакетов, размер этого поля равен 13 бит. Нетрудно посчитать, что максимально возможное значение, которое можно записать в этом поле равно два в тринадцатой степени или 65528, смещение задается в байтах, то есть это поле говорит узлу или маршрутизатору на сколько байт нужно выполнять смещение от нуля (это для пакетов без фрагментации, в этом случае все тринадцать бит имеют значение 0) до 65528 байт (в этом случае все тринадцать бит выставлены в единицу). В том случае, если фрагментация выполняется, то первый пакет последовательности также имеет смещение равное нулю. У числовых значений, записываемых в поле «Смещение фрагмента» есть одно ограничение — это значение должно быть всегда кратно восьми.




### Протокол TCP — как происходит управление перегрузкой

Получатель, при отправке каждого подтверждения, указывает в сегменте размер окна, количество байт, которые он может принять. Отправлять больше данных в сеть не имеет смысла.

![[Pasted image 20240626230258.png]]


Но возможна и другая проблема. В буфере получателя может быть достаточно свободного места, но сеть, через которую передаются данные, перегружена.

![[Pasted image 20240626230310.png]]

**Управление скоростью передачи в TCP**


Оба типа окна, окно управления потоком и окно перегрузки, используются для решения более общей задачи — управление скоростью передачи данных в TCP. Если размер скользящего окна будет слишком маленьким, то сеть мы будем отправлять маленькое количество сегментов, сеть будет не загружена полностью, и скорость передачи будет маленькой, ниже чем возможно.

- другой стороны, если мы будем отправлять в сеть большое количество сегментов, то сеть может оказаться перегруженной, маршрутизаторы начнут отбрасывать наши сегменты, их нужно будет отправлять заново и скорость передачи данных опять окажется низкой. Таким образом нам нужно определить оптимальный размер окна, для того чтобы мы могли передавать данные по сети избегая загрузки, и приложение могло принять эт данные, и записать их в свой буфер.
    

**AIMD**

- TCP для определения размера окна перегрузки используется метод аддитивного увеличения, мультипликативного уменьшения. Суть метода заключается в том, что при получении каждого подтверждения, мы прибавляем к размеру окна некоторые значения, как правило это размер одного сегмента TCP, а если перегрузка произошла, то мы умножаем размер окна на некоторые значения. Как правило это 1/2, то есть в TCP при перегрузке, размер окна уменьшается в два раза.


![[Pasted image 20240626230338.png]]

**Размер окна AIMD**

Вот график работы метода аддитивного увеличения, мультипликативного уменьшения. Мы начинаем передавать данные, поступает подтверждение,размер окна увеличивается, происходит аддитивное увеличение. Затем в сети произошла перегрузка, размер окна уменьшается в два раза, произошло мультипликативное уменьшение.

![[Pasted image 20240626230404.png]]

Затем данные снова передаются, размера окна при получение каждого подтверждения увеличивается на один сегмент, аддитивные увеличения. И так происходит пока не произойдет следующая перегрузка. Таким образом, размер окна у нас напоминают зубья пилы.

**Сигнал о перезагрузке**

Как отправитель узнает, о том что в сети произошла перегрузка? Это достаточно сложная задача, потому что сеть может быть составной,

- перегрузка может происходить не на том сегменте сети, который подключен к отправителю, а на каком-то сегменте между отправителем и получателем, который находятся достаточно далеко от того и другого.

Чаще всего на практике, в качестве сигнала перегрузки используется потеря сегмента. Считается, что сейчас каналы связи уже хорошего качества и если произошла потеря сегмента, то не из-за ошибки канала, а из-за того, что сеть перегружена, поэтому нужно уменьшить размер окна, для того чтобы избежать дальнейшей перегрузки.

**Медленный старт**

Метод аддитивного увеличения мультипликативного уменьшения хорошо работал на медленных каналах связи, которые были во времена создания сети интернет, но у на современных, быстрых и надежных каналах связи, этот метод работает плохо. С помощью аддитивного увеличения, размер окна перегрузкой увеличивается очень медленно, для того чтобы решить эту проблему был предложен другой метод управления размером окна — медленный старт.

При медленном старте размер окна увеличивается на каждое подтверждение не на 1 сегмент, а на 2, благодаря этому происходит экспоненциальное увеличение размера окна. Сначала мы отправляем один сегмент, получили подтверждение, отправляем два сегмента, получили 2 подтверждения, на каждое подтверждение отправляем по два сегмента всего 4, потом 8, потом 16 и так далее. То есть несмотря на название медленный старт, размер окна увеличивается гораздо быстрее, чем при аддитивном увеличении, мультипликативном уменьшении.

Недостаток метода заключается в том, что если произошла потеря сегмента, то размер окна уменьшается до нуля. Таким образом медленный старт быстро разгоняется, но также быстро тормозится.

Буфер принимающей стороны можно представить себе в виде коробки, а поле данных приходящих пакетов виде кубиков, которые принимающая сторона складывает в свою коробку. Если говорить о компьютерах, то сейчас у них достаточно производительности и памяти, чтобы считать размеры коробки (буфера) не ограниченными, с транзитными маршрутизаторами дела обстоят иначе, ведь их задача заключается не в том чтобы собирать из кусочков единое целое, а в том, чтобы пересылать пакеты, поэтому нужно смотреть документацию к устройству, с которым вы работаете. Условно будем считать, что наш компьютер может выделить для фрагментированного пакета 65515 байт памяти (если вы еще не забыли, то 65535 байт – это максимально допустимый размер IP-пакета). Более наглядно ситуацию демонстрирует рисунок ниже.

![[Pasted image 20240626230630.png]]

Получается следующая ситуация: компьютер получает первый пакет, анализирует его заголовок и по полю флагов видит, что это не просто пакет, а фрагментированный пакет, по полю смещение компьютер видит, что это самый первый пакет из неизвестно насколько большой цепочки пакетов, а значит нужно выделять память и ждать, что там еще пришлют, при этом поле данных из самого первого пакета нужно поместить на самый верх буфера. Затем компьютеру пришел второй пакет, анализируя «Флаги» и "Смещение "он понимает, что это второй пакет из цепочки, в смещение он видит значение 1480 байт, а это значит, что нужно отсчитать 1480 байт от верхней границы буфера и туда поместить информацию из поля данных первого пакета. При этом нам даже не так уж страшна ситуация, при которой после второго пакета придет четвертый, компьютер просто бы отсчитал от верхней границы 4440 байт и записал бы фрагмент данных на это место, а когда придет трети пакет, то его поле данных попадет в интервал между вторым и четвертым.

Более страшной будет ситуация, при которой один из фрагментированных пакетов будет потерян, в этом случае передатчику нужно будет заново сформировать большой пакет, а при отправке его в сеть снова порезать на более мелкие пакеты, принимающая сторона также будет вынуждена повторить все свои действия.

На самом деле рисунок сверху показывает не всё, что в реальности происходит с пакетами, он нужен лишь для того, чтобы продемонстрировать, что происходит с данными на принимающей стороне в случае с фрагментацией. Например, естественно, что заголовок первого пакета не удаляется, ведь в нем много полезной информации, которой в дальнейшем придется оперировать узлу получателю, чтобы послать ответ. Про фрагментацию IP-пакетов мы поговорим отдельно и там разберем этот процесс более детально.

- Time to Live, TTL (8 бита): Время жизни - Следующее поле имеет размер один байт или восемь бит и называется оно время жизни пакета, данное поле нужно, чтобы пакет не блуждал по сети до бесконечности в том случае, если конфигурация транзитных узлов некорректная и произошла петля маршрутизации. Для нас TTL – это число в диапазоне от 0 до 255, это число определяет максимально допустимое число узлов, через которое может пройти пакет перед тем, как он будет уничтожен. Время жизни для пакета задается узлом источником и изначально оно измерялось в секундах (то есть максимально возможное время жизни IP пакета раньше было 255 секунд), но дело в том, что современные маршрутизаторы обрабатывают пакеты гораздо быстрее, чем за секунду, поэтому сейчас TTL – это значение, которое определяет число транзитных узлов Таким образом получается следующее: первый узел сформировал пакет и задал для него значение TTL равное 20, первый маршрутизатор, получивший этот пакет, вычтет единицу из двадцати, получит 19, запишет новое значение в поле TTL и отправит пакет дальше. Процесс вычитание и передачи будет происходить до тех пор, пока пакет не будет доставлен получателю, либо пока значение TTL не будет равным нулю, тот маршрутизатор, на котором TTL стало равным нулю, уничтожит пакет. Воспользуемся Cisco Packet Tracer и посмотрим на этот процесс более наглядно (если вы не знакомы с Cisco Packet Tracer, то вот вам несколько материалов в помощь: установка Cisco Packet Tracer на Windows, установка Packet Tracer на Linux, как пользоваться Cisco Packet Tracer, стандартные физические компоненты компьютерной сети). На рисунке PC0 формирует пакет в сторону PC1 и отправляет его в сеть из трех маршрутизаторов. И так простыми словами, TTL это максимальное время, в течении которого пакет перемещаться по сети. Каждый маршрутизатор, при маршрутизации должен уменьшить TTL на единицу. По словам можно понять что TTL - это максимально количество прыжков от одной сети к другой до которого пакет может дойти до целевого узла. Например, если TTL=32, то это значить что пакет может пройти 32 узла, чтобы дойти до цели, а потом уничтожиться. Такой подход помогает чтобы в сети не создавался мусорный трафик. На рисунке PC0 формирует пакет в сторону PC1 и отправляет его в сеть из трех маршрутизаторов.

![[Pasted image 20240626230702.png]]

Как видим из Рисунка, узел задал для пакета TTL=128 и отправил его на Router0. Когда пакет придет на входной интерфейс Router0, его TTL не изменится, это показано на следующей рисунке.

![[Pasted image 20240626230920.png]]

Но как только Router0 поймет куда отправлять этот пакет дальше, он вычет из 128 единицу и отправит пакет в выходной интерфейс в сторону Router1, показано на следующей рисунке.

![[Pasted image 20240626230938.png]]

Следующие роутеры будут поступать с пакетом аналогичным образом. Узел получатель PC1 примет этот пакет с TTL=125 и уже не будет вычитать единицу. Теперь давайте убедимся в том, что маршрутизатор, который получит пакет с TTL равным единице, просто прибьет бедолагу. Для этого со стороны PC0 я сформировал пакет с TTL=2 и направил его в сторону PC1, а это означает, что Router1 должен уничтожить пакет, показано на следующей рисунке.

![[Pasted image 20240626230956.png]]

К теме TTL , маршрутизации и петле маршрутизации мы еще вернемся.

- Protocol (8 бита): Протокол - Иначе еще это поле называют «Протокол верхнего уровня» (хотя такое название неверно отображает суть поля), для этого поля выделено 8 байт. Вы же помните, что протокол IP используют в качестве транспорта протоколы транспортного уровня, в частности TCP и UDP, кроме того, в поле данных IP-пакета могут быть запакованы сообщения протоколов других уровней. Это поле нужно для того, чтобы конечный узел мог понять, какому процессу отдавать на обработку принятые IP-пакеты. И понятно, что в поле «Протокол» записывается не название протокола, а его цифровой код, таблицу кодов вложений в IP можно найти на сайте IANA.

Так, например, если внутри IP-пакета будет передаваться UDP-дейтаграмма, то в поле протокол будет записано значение 17 или 00010001 в двоичной системе счисления, а для протокола TCP используется десятичное число 6,

- двоичной системе счисления 00000110. Простыми слоавми, занимает 1 байт и указывает, какому протоколу верхнего уровня принадлежит информация, размещенная в поле данных пакета.

- Header Checksum (16 бита): Контрольная сумма - Под это поле выделено два байта и как понятно из названия: протокол IP не имеет механизма проверки целостности данных, поскольку поле «Контрольная сумма заголовка» не учитывает поле данных при проверке. Не забываем, что TTL меняется от узла к узлу, а это значит, что и контрольная сумма будет меняться от узла к узлу, то есть каждый транзитный маршрутизатор сперва принимает IP-пакет, вычисляет его контрольную сумму, сравнивает со значением, записанным в поле «Контрольная сумма заголовка», затем вычитает единицу из значения поля TTL, вычисляет новую контрольную сумму и отправляет пакет следующему соседу.

Стоит отметить, что если значение контрольной суммы, которую посчитал узел отличается от контрольной суммы, которая записана в пакете, то он просто отбрасывается. Простыми словами, занимает 2 байта и рассчитывается только по заголовку. Поскольку некоторые поля заголовка меняют свое значение в процессе передачи пакета по сети (например, время жизни), контрольная сумма проверяется и повторно рассчитывается при каждой обработке IP- заголовка. Контрольная сумма - 16 бит - подсчитывается как дополнение к сумме всех 16-битовых слов заголовка. При вычислении контрольной суммы значение самого поля "контрольная сумма" устанавливается в нуль. Если контрольная сумма неверна, то пакет будет отброшен, как только ошибка будет обнаружена. Простыми словами, получатель может использовать контрольную сумму для проверки наличия ошибок в заголовке, и если контрольная сумма заголовка не совпадает, пакет будет отброшен.

- Source IP Address (32 бита): IP-адрес источника - Поле IP-адрес источника имеет размер 32-а бита и не изменяется при передаче пакета по сети, для передачи пакетов без различного рода фильтраций трафика, это поле нужно только конечному узлу, когда маршрутизаторы принимают решение о том, куда отправить пакет, они смотрят лишь только на поле IP-адрес назначения.

А по полю IP-адрес источника узел-получатель сможет понять кому нужно ответить, тут, кстати, стоит отметить такой момент: поле IP-адрес назначения определяет каким маршрутом пойдет пакет «туда», а поле IP-адрес источника определяет каким маршрутом пакет пойдет «обратно». И далеко не всегда маршрут «туда совпадает с маршрутом «обратно».

- Destination IP Address (32 бита): IP-адрес назначения - Данное поле имеет размер 4-е байта, в него записывается IP-адрес конечного узла, для которого пакет предназначен, роутеры смотрят на этот поле при принятии решения о том куда направлять пакет. Поля IP-адрес источника (Source IP Address) и IP-адрес назначени (Destination IP Address) имеют одинаковую длину - 32 бита - и одинаковую структуру.

- IP Options (): Поле Опции - является необязательным и используется обычно только при отладке сети. Механизм опций предоставляет функции управления, которые необходимы или просто полезны при определенных ситуациях, однако он не нужен при обычных коммуникациях. Это поле состоит из нескольких подполей, каждое из которых может быть одного из восьми предопределенных типов. В этих подполях можно указывать точный маршрут прохождения маршрутизаторов, регистрировать проходимые пакетом маршрутизаторы, помещать данные системы безопасности, а также временные отметки. Так как число подполей может быть произвольным, то в конце поля Опции должно быть добавлено несколько байт для выравнивания заголовка пакета по 32-битной границе.

- Padding ():Поле Выравнивание - используется для того, чтобы убедиться в том, что IP- заголовок заканчивается на 32-битной границе. Выравнивание осуществляется нулями.

Опция IP : это поле используется нечасто, является необязательным и имеет переменную длину в зависимости от используемых опций. При использовании этого поля значение в поле длины заголовка будет увеличиваться. Примером возможного варианта является «исходный маршрут», когда отправитель запрашивает определенный путь маршрутизации.

**Доставка не гарантируется**

Многие сети не гарантируют доставку, отсутствие дубликатов пакетов и порядок их доставки, как например, протокол UDP в сети Интернет. Тем не менее, это можно сделать в верхней части пакета услуг транспортного уровня, который может обеспечить такую защиту. TCP и UDP являются лучшими примерами 4-го транспортного уровня, одного из семи уровней сетевой модели OSI.

Заголовок пакета определяет тип данных, номер пакета, общее количество пакетов и IP-адреса отправителя и получателя.

Иногда используется термин «кадр» для обозначения пакетов в точности так, как он используется при передаче сигнала по проводам или радио.

# Возможности TCP/IP

Некоторые из наиболее важных особенностей протокола управления передачей:

**1. Система нумерации сегментов**

- TCP отслеживает передаваемые и получаемые сегменты, присваивая номера каждому из них.

- Определенный номер байта назначается байтам данных, которые должны быть переданы, в то время как сегментам назначаются порядковые номера .

- номера подтверждения Полученным сегментам присваиваются
    
**2. Управление потоком**

- Управление потоком ограничивает скорость, с которой отправитель передает данные. Это делается для обеспечения надежной доставки.

- Получатель постоянно сообщает отправителю, сколько данных может быть получено (используя скользящее окно).
    
**3. Проверка ошибок**

- TCP реализует механизм контроля ошибок для надежной передачи данных.
    
- Контроль ошибок ориентирован на байты
    
- Сегменты проверяются на наличие ошибок
    
- Управление ошибками включает поврежденными и потерянными сегментами, неупорядоченными сегментами, повторяющимися сегментами и т.
    
**4. Контроль перегрузки**

- TCP учитывает уровень загруженности сети
    
- Уровень перегрузки определяется объемом данных, отправленных отправителем.
    

**Преимущества**

- Это надежный протокол
    
- Он предоставляет механизм проверки ошибок, а также механизм восстановления.
    
- Это дает контроль над потоком
    
- Это гарантирует, что данные достигают надлежащего места назначения в точном порядке, в котором они были отправлены.
    

  

- Открытый протокол, не принадлежащий какой-либо организации или частному лицу
    
- Он назначает IP-адрес каждому компьютеру в сети и доменное имя каждому сайту, что делает каждый сайт устройства различимым в сети.
    

**Недостатки**

- TCP создан для глобальных сетей, поэтому его размер может стать проблемой для небольших сетей с небольшими ресурсами.
    
- TCP работает на нескольких уровнях, поэтому может снизить скорость сети.
    
- Он не носит общего характера. Это означает, что он не может представлять какой-либо другой стек протоколов, кроме набора TCP/IP. Например, он не может работать с соединением Bluetooth.
    
- Никаких модификаций с момента их разработки около 30 лет назад.
    

**Итог**

- TCP — надежный протокол. То есть, приемник всегда отправляет отправителю положительное или отрицательное подтверждение о пакете данных, так что отправитель всегда имеет яркое представление о том, достигнут ли пакет данных адресату или ему нужно повторно отправить его.
    
- TCP гарантирует, что данные достигнут назначенного адресата в том же порядке, в котором он был отправлен.
    
- TCP ориентирован на соединение. TCP требует установления соединения между двумя удаленными точками перед отправкой фактических данных.

- TCP обеспечивает механизм проверки и восстановления ошибок.

- TCP обеспечивает сквозную связь.

- TCP обеспечивает контроль потока и качество обслуживания.

- TCP работает в режиме «точка-точка» Client / Server.

- TCP обеспечивает полный дуплексный сервер, т. Е. Он может выполнять роли как получателя, так и отправителя.

![[Pasted image 20240626231540.png]]

# Заголовок TCP



![[Pasted image 20240626231721.png]]

**Примечание**



- Acknowledgement number, ACK (32 бита): Номер подтверждения - это поле содержит следующий порядковый номер, ожидаемый отправителем. Флаг ACK (в поле «Flags») является предварительным условием действительности. Простыми словами, когда установлен флаг ACK, это число содержит следующий порядковый номер ожидаемого байта данных и работает как подтверждение предыдущих полученных данных. Когда сообщение содержит флаг ACK, то значение в номере подтверждения должно соответствовать следующему порядковому номеру (SYN), которое отправитель сообщения с флагом ACK ожидает получить от передающей системы. Таким образом, отправка одного номера подтверждения способна подтвердить получение всех байтов с информацией, полученных до этого.
    
- Data offset (4 бита): Длина заголовка, известная также как смещение данных - Содержит размер заголовка TCP, измеряемый в 32-битных сегментах. Минимальный размер заголовка TCP составляет пять 32-битных сегментов (всего 20 байт), а максимальный — пятнадцать 32-битных сегмента (или 60 байт). Простыми словами, в этом поле подразумеваются как размер заголовка TCP (32-разрядные слова), так и смещение данных в текущем пакете во всем сегменте TCP. Длина заголовка определяет смещение полезных данных относительно начал сегмента. Например, Data offset равное 11112 говорит о том, что заголовок занимает пятнадцать 32-битных слова (`15 строк*32 бита в каждой строке/8 бит = 60 байт`).
    
- Reserved (3 бита): Зарезервировано - зарезервировано для будущего использования, пока просто забивается нулями. На данный момент осталось три незадействованных бита, в то время как еще три ранее зарезервированных бита уже используются как флаги. Просто знайте, что для будущего использования и должно устанавливаться в ноль.
    
**Flags, 9 бит (флаги или управляющие биты):**
    

- NS (1 бит): одноразовая сумма (Nonce Sum). Используется для улучшения работы механизма явного уведомления о перегрузке (Explicit Congestion Notification, ECN). Простыми словами, используется сигнальным процессом Явного сообщения о перегрузке.

- CWR (1 бит): окно перегрузки уменьшено (Congestion Window Reduced). Данный флаг устанавливается отправителем, чтобы показать, что TCP-фрагмент был получен с установленным полем ECE. Таким образом, это является подтверждением получения пакета данных с флажком ECE от хоста получателя и включением отправителем механизма уменьшения перегрузки (Congestion Control), позволяющим оптимизировать отправку пакетов с данными в перегруженных сетях, избежав серьезных задержек из-за отбрасывания пакетов.

- ECE (1 бит): ECN-Эхо (ECN-Echo). Выполняет двойственную роль, в зависимости от значения флага SYN. При установленном флаге SYN это указывает на то, что отправитель пакета поддерживает ECN. Если флаг SYN сброшен (SYN=0), а ECE установлен, то это означает, что пакет с установленным флагом CE (Congestion Experienced, Подтвержденная перегрузка) был получен в заголовке IP во время обычной передачи. Таким образом, это служит индикатором перегрузки сети (или предстоящей перегрузки) для TCP-отправителя.

- URG (1 бит). Устанавливается, если необходимо передать ссылку на поле указателя срочности (Urgen pointer).

- ACK (1 бит). Устанавливается, когда пакет содержит значение номера подтверждения в поле подтверждения. Все пакеты после стартового пакета SYN будут иметь установленный флаг ACK.  Если ACK очищен до 0, это означает, что пакет не содержит подтверждения.

- PSH (1 бит). Делает этот пакет пакетом PUSH (проталкивания). При нормальном потоке передачи данных система получателя не будет подтверждать получение каждого пакета сразу же после его получения. Вместо этого система получателя в течении некоторого времени будет собирать и хранить полученные данные в буфере, пока не передаст их приложению пользователя. Пакет PUSH инструктирует систему получателя немедленно передать все полученные ранее данные из буфера в приложение пользователя и сразу же отправить сообщение с подтверждением. То есть, если установлено, это запрос на принимающую станцию на данные PUSH (как только это произойдет) в принимающее приложение без его буферизации.

- RST (1 бит): сброс данного соединения. Отправкой пакета RST одна из сторон сообщает о немедленном разрыве соединения. При этом соединение обрывается, а буфер очищается. Самые распространенные причины отправки пакета с установленным флагом RST — ответ на пакет, полученный для закрытого сокета; пользователь сам прервал соединение (например, закрыв браузер, не дожидаясь ответа); соединение не было нормально закрыто, но находится в неактивном состоянии некоторое время.

- SYN (1 бит). Начинает соединение и синхронизирует порядковые номера. Первый пакет, отправленный с каждой стороны, должен в обязательном порядке иметь установленным этот флаг.

- FIN (1 бит). Одна из конечных точек отправляет пакет с установленным флагом FIN для другой конечной точки, чтобы сообщить, что все пакеты были отправлены, и соединение пора завершить.



- Window size (16 бит): размер окна приема. В нем указывается количество байт данных, считая от последнего номера подтверждения, которые готов принять отправитель данного пакета. Другими словами, отправитель данного пакета в этом поле сообщает другой стороне, каким доступным на данный момент размером буфера приема данных он располагает.
    
- Checksum (16 бит): контрольная сумма. Используется для проверки на наличие ошибок при передаче и/или приеме отправленного пакета. Рассчитывается с учетом заголовка (все поля заголовка, кроме самой контрольной суммы), полезной нагрузки (неслужебные данные с полезной информацией, которая, собственно, и передается), а также псевдо-заголовка (IP-адрес источника, IP-адрес назначения, номер протокола и длина TCP-сегмента, в которой учитывается как длина полей заголовка, так и длина данных полезной нагрузки). Более детально о расчете контрольной суммы вы можете прочитать здесь (http://www.tcpipguide.com/free/t_TCPChecksumCalculationandtheTCPPseudoHeader-2.htm).
    

- Urgent pointer (16 бит): указатель срочности. Если установлен флаг URG, то это означает, что поле указателя срочности содержит численное значение положительного смещения от порядкового номера в сообщении, указывающее на последний байт срочных данных. После получения TCP-сегмента с флагом URG, установленным в значение «1», приемное устройство смотрит на поле указателя срочности и по его значению определяет, какие данные в сегменте являются срочными. Затем эти срочные данные сразу же направляются в приложение пользователя с указанием того, что отправитель пометил данные как срочные. Остальные данные в данном сегменте, как, к слову, и накопившиеся до этого в буфере приема, обрабатываются в нормальном режиме. Этим принцип обработки в сообщении флага URG отличается от обработки флага PSH, при получении которого вся информация из буфера, а не только срочная из сообщения, немедленно передается в приложение пользователя.

**Адресация**

Связь TCP между двумя удаленными хостами выполняется с помощью номеров портов (TSAP). Номера портов могут варьироваться от 0 до 65535, которые делятся как:

- Порты системы (0 — 1023)
    
- Порты пользователей (1024 — 49151)
    
- Частные / динамические порты (49152 — 65535)

# TCP-рукопожатие

Чтобы установить надежное соединение, TCP использует процесс, называемый термином “трехстороннее рукопожатие” (three-way handshake). Установленное соединение будет полнодуплексным, то есть оба канала могут передавать информацию одновременно, а также они синхронизируют (SYN) и подтверждают (ACK) друг друга. Обмен выполняется следующим образом:

1. Клиент отправляет сегмент с установленным флагом SYN. При этом сегменту присваивается произвольный порядковый номер (sequence number) в интервале от 1 до 232 (т.н. initial sequence number), относительно которого будет вестись дальнейший отсчет последовательности сегментов в соединении.
    
2. Сервер получает запрос и отправляет ответный сегмент с одновременно установленными флагами SYN+ACK, при этом записывает в поле «номер подтверждения» (acknowledgement number), полученный порядковый номер, увеличенный на 1 (что подтверждает получение первого сегмента), а также устанавливает свой порядковый номер, который, как и в SYN-сегменте, выбирается произвольно.
    
3. После получения клиентом сегмента с флагами SYN+ACK соединение считается установленным, клиент, в свою очередь, отправляет в ответ сегмент с флагом ACK, обновленными номерами последовательности, и не содержащий полезной нагрузки.
    
4. Начинается передача данных.
    
- процессе передачи данных клиент и сервер обмениваются сегментами с установленными флагами ACK или PSH+ASK, поочередно подтверждая число полученных пакетов путем увеличения счетчиков порядкового номера (sequence number) и подтверждения (acknowledgement number).
    
Этапы 1, 2 определяют параметр подключения (порядковый номер) для одного направления, и подтверждают его. Этапы 2, 3 определяют параметр подключения для другого направления, и также подтверждают его. С их помощью устанавливается полнодуплексная связь.

Интересно, что начальные параметры SYN выбираются случайным образом при установлении соединений между клиентом и сервером.

Заключение стоит добавить, что проверка номеров последовательности приходящих пакетов и принципов, используемых при 3-way handshake, позволяют реализовать простейшие методы фильтрации DDoS-атак.

![[Pasted image 20240626232940.png]]

Для того чтобы обеспечить гарантия доставки данных, TCP использует подтверждение получение сообщение. Например, отправитель отправляет получателю сегмент данных, получатель получает данные и посылает отправителю подтверждение (Acknowledgment, ACK), который говорить о том, что сегмент данных получен, после отправляется следующий сегмент данных, клиент снова подтверждает и так далее. Что происходит, если при передаче данных произошла ошибка? Сегмент данных потерян в сети, он не доходить до получателя, а получатель не отправляет подтверждение сообщение. Отправитель, при отправке сегмента данных устанавливает таймер, который задаёт время ожидание подтверждение, если в течение этого времени подтверждение не пришло, таймер срабатывает и тот же самый сегмент отправляется повторно, предположим что в этот раз сегмент дошел до получателя, получатель отправляет подтверждения, а отправитель может передавать следующий сегмент данных. Конечно подтверждается не каждый сегмент, а несколько сегментов отпрошенных друг за другом, этот механизм называется скользящий окно. Но подтверждение и повторное отправки данных недостаточно для обеспечения надёжной передачи потока байта, это защищает только от потери сегментов, но не обеспечивает сохранение порядка следование сообщений. Какие проблемы могут произойти? Протокол IP не сохраняет порядок следований сообщений, и поэтому сегменты могут прийти к получателю не в том порядке в котором они были отправлены, кроме того, некоторые сегменты могут прийти два и более раза (дублирование сегментов). Пример один из возможности дублирование сегментов: И так, предположим, что отправитель отправил сегмент данных получателю, получатель принял этот сегмент, и передал отправителю подтверждения. Но при передаче подтверждения произошла ошибка, отправитель не получил подтверждения, сработал таймер, и тот же самый сегмент данных был отправлен второй раз - это один из возможных вариантов, на самом деле таких вариантов еще очень много. Поэтому в протоколе TCP встроен механизм защиты от дублирования и нарушение порядка следование сообщений.

![[Pasted image 20240626233000.png]]

Механизм очень простой, все сообщение нумеруются. В протоколе TCP нумеруются не сегменты( так как разные сегменты могут иметь разные размер), а байты. В нашем примере 4 сегмента, первый сегмент содержит байты от 0 до 1023, второй от 1024 до 2047, третий от 2048 до 3071 и четвертый сегмент от 3072 и так далее.

![[Pasted image 20240626233018.png]]

При передаче отправитель включает в сегмент номер первого байта данных, в котором в нем содержится, например сегмент данных байт 0 он содержит байт с нулевого до 1023. Получатель отправляет подтверждение, и в подтверждении включает номер следующего байта который ожидается - байт 1024 ( в нашем случае ). Отправитель передаёт следующий сегмент данных включая в него номер первого байта - 1024 ( в нашем случае ) содержит данные до номера байта 2047 ( в нашем случае ). Получатель отправляет подтверждение, что он ждёт байт с номером 2048 ( в нашем случае ). Если сегменты придут в неправильном порядке, то получатель по номерам байта всегда сможет выставить их в правильный последовательность

Давайте рассмотрим как решаются ситуации с дублированием сегментов:

![[Pasted image 20240626233050.png]]

Отправитель включает в сегмент номер первого передаваемого байта (в нашем случае 1024), получатель отправляет подтверждение где говорить что ждёт 2048 ( в нашем случае ). Но так как подтверждение не доходить по какой-то причине до отправителя, отправитель отправляет тот же самый сегмент ( 1024 - в нашем случае Однако получатель видит что этот сегмент у него уже есть, поэтому он этот сегмент сбрасывает и снова отправляет подтверждение где говорить что он ожидает байт 2048 ( в нашем случае ).

В протоколе TCP, для передачи данных используют соединение. Соединение нужно установить перед тем как начать передачу данных, а после того как передача данных завершился, соединение разрывается.

Задача соединениеь заключается:

- Убедится, что отправитель и получатель хотят передавать данные друг другу
    
- Договорится о нумерации потока байт
    
- Договорится о параметрах соединения ( максимальный размер сегмента и т.д)
    

Как мы знаем, соединение устанавливается с помощью трёхстороннее рукопожатие:

- Одна сторона запрашивает - Йоу бро, я могу начать передачу? ( это сообщения называется SYN)
    
- Вторая сторона подтверждает это и говорить - Ну давай начнем ( это сообщения называется SYN ACK )
    
- Первая сторона радуется и отвечает в сообщении ACK супер, погнали
    
После чего начинается передача данных.

# Завершение TCP Сеанса

  

TCP требует 3 секции для установления соединения и 4 секции для завершения соединения.

  

Чтобы закрыть соединение, флаг управления FIN (Финиш) в заголовке сегмента должен быть установлен. Чтобы закончить каждый односторонний сеанс TCP, используется двухстороннее квитирование , состоящее из сегмента FIN и сегмента ACK. Поэтому для завершения одного TCP диалога необходимо обменяться четырьмя сегментами, чтобы закончить оба сеанса.

Примечание : В описании ниже термины клиент и сервер используются для простоты, однако процесс завершения сеанса может инициироваться любыми двумя узлами, закрывающими TCP сессию:

1. Когда у клиента больше нет данных, которые следует передать в потоке, он отправляет сегмент с установленным флагом FIN.
    
2. Сервер отправляет ACK, чтобы подтвердить получение FIN для завершения сеанса от клиента к серверу.
    
3. Сервер отправляет FIN клиенту, чтобы завершить сессию от сервера к клиенту.
    
4. Клиент отвечает ACK, чтобы подтвердить FIN от сервера.
    

Когда у клиентская сторона сеанса больше не имеет данных для передачи, она устанавливает флаг FIN в заголовке сегмента. Затем, серверная сторона соединения отправит нормальный сегмент, содержащий данные с установленным флагом ACK, используя номер подтверждения, указывая, что все байты данных были получены. Когда все сегменты были подтверждены, сеанс закрывается.

Сеанс в другом направлении закрывается, используя тот же самый процесс. Получатель указывает, что нет больше данных, которые надо передать, устанавливая флаг FIN в заголовке сегмента, отправленного источнику. Возвращенное подтверждение удостоверяет, что все байты данных были получены и что сеанс, в свою очередь, закрывается. Простыми словами, Эта четырехсторонняя последовательность завершения проста и использует дополнительный флаг, называемый битом FIN. (FIN - это сокращение от "finished", как вы могли догадаться.) Одно интересное замечание: перед тем, как устройство справа отправит третий сегмент TCP в последовательности, оно уведомляет приложение о том, что соединение прерывается. Затем он ожидает подтверждения от приложения перед отправкой третьего сегмента на рисунке. На случай, если приложению потребуется некоторое время, чтобы ответить, ПК справа отправляет второй поток на рисунке, подтверждая, что другой ПК хочет разорвать соединение. В противном случае ПК слева может повторно отправить первый сегмент.

![[Pasted image 20240626233338.png]]

# Настройка максимального размера сегмента TCP

Максимальный размер пакетов, отправляемых протоколом TCP, в значительной степени влияет на пропускную способность, так как эффективность работы возрастает с увеличением размера пакетов.

Протокол TCP задает этот максимальный размер, который также называется Максимальный размер сегмента (MSS), для каждого соединения TCP. В случае сетей с непосредственным подключением TCP рассчитывает MSS на основе размера MTU сетевого интерфейса, из которого затем вычитаются размеры заголовков протокола. Например, для Ethernet, MTU которого равен 1500, после вычитания 20 байт заголовка IPv4 и 20 байт заголовка TCP размер MSS будет равен 1460.

Протокол TCP позволяет конечным системам в ходе создания соединения согласовывать оптимальное значение максимального размера сегмента (MSS). Каждая сторона указывает предлагаемый размер MSS в поле опций заголовка пакета TCP. Будет принято наименьшее из двух значений. Если конечная система не указывает MSS, то применяется значение 536 байт, не позволяющее получить высокую производительность.

Проблема заключается в том, что каждой конечной системе TCP известен только MTU сети, к которой она подключена. Размеры MTU других промежуточных сетей системе не известны. Таким образом, протокол TCP знает правильное значение MSS только в том случае, если обе конечные системы расположены в одной сети. В связи с этим способ оповещения о MSS, применяемый в TCP, зависит от конфигурации сети, что позволяет избежать фрагментации пакетов IP, передаваемых по сетям с меньшим размером MTU.

При выборе значения MSS, предлагаемого уровнем TCP при настройке соединения, учитывается взаимное расположение систем: в одной физической сети (адреса сети систем совпадают) или в разных (удаленных) сетях.

# UDP

  

UDP (англ. User Datagram Protocol — протокол пользовательских датаграмм) - транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP -сети. UDP один из ключевых элементов набора сетевых протоколов для Интернета. С UDP компьютерные приложения могут посылать сообщения (в данном случае называемые датаграммами) другим хостам по IP-сети без необходимости предварительного сообщения для установки специальных каналов передачи или путей данных. Протокол был разработан Дэвидом П. Ридом в 1980 году и официально определён в RFC 768.

UDP использует простую модель передачи, без явных «рукопожатий» для обеспечения надёжности, упорядочивания или целостности данных. Датаграммы могут прийти не по порядку, дублироваться или вовсе исчезнуть без следа, но гарантируется, что если они придут, то в целостном состоянии. UDP подразумевает, что проверка ошибок и исправление либо не нужны, либо должны исполняться в приложении. Чувствительные ко времени приложения часто используют UDP, так как предпочтительнее сбросить пакеты, чем ждать задержавшиеся пакеты, что может оказаться невозможным в системах реального времени. При необходимости исправления ошибок на сетевом уровне интерфейса приложение может задействовать TCP или SCTP, разработанные для этой цели. UDP очень быстрый протокол, поскольку в нем определен самый минимальный механизм, необходимый для передачи данных. Конечно, он имеет некоторые недостатки. Сообщения поступают в любом порядке, и то, которое отправлено первым, может быть получено последним. Доставка сообщений UD вовсе не гарантируется, сообщение может потеряться, и могут быть получены две копии одного и того же сообщения. Последний случай возникает, если для отправки сообщений в один адрес использовать два разны маршрута.

UDP не требует открывать соединение, и данные могут быть отправлены сразу же, как только они подготовлены. UDP не отправляет подтверждающие сообщения, поэтому данные могут быть получены или потеряны. Если при использовании UDP требуется надежная передача данных, ее следует реализовать в протоколе более высокого уровня.UDP — это быстрый протокол, не гарантирующий доставки. Если требуется поддержание порядка сообщений и надежная доставка, нужно использовать TCP. UDP главным образом предназначен для широковещательной и групповой передачи. Протокол UDP определен в RFC 786.

Напоминаю, что оба протокола TCP и UDP работают на транспортном уровне модели OSI или TCP/IP, и понимание того чем они отличаются очень важно.

# Разница между протоколами TCP и UDP

  

Разница между протоколами TCP и UDP – в так называемой “гарантии доставки”. TCP требует отклика от клиента, которому доставлен пакет данных, подтверждения доставки, и для этого ему необходимо установленное заранее соединение. Также протокол TCP считается надежным, тогда как UDP получил даже именование “протокол ненадежных датаграмм. TCP исключает потери данных, дублирование и перемешивание пакетов, задержки. UDP все это допускает, и соединение для работы ему не требуется. Процессы, которым данные передаются по UDP, должны обходиться полученным, даже и с потерями. TCP контролирует загруженность соединения, UDP не контролирует ничего, кроме целостности полученных датаграмм.

  

C другой стороны, благодаря такой не избирательности и бесконтрольности, UDP доставляет пакеты данных (датаграммы) гораздо быстрее, потому для приложений, которые рассчитаны на широкую пропускную способность и быстрый обмен, UDP можно считать оптимальным протоколом. К таковым относятся сетевые браузерные игры, а также программы просмотра потокового видео и приложения для видеосвязи (или голосовой):

От потери пакета, полной или частичной, ничего не меняется, повторять запрос не обязательно, зато загрузка происходит намного быстрее. Протокол TCP, как более надежный, с успехом применяется даже в почтовых программах, позволяя контролировать не только трафик, но и длину сообщения и скорость обмена трафиком.

**Приложения для TCP**

Протокол TCP используют следующие приложения:

- HTTP;
    
- FTP;
    
- Telnet;
    
- SMTP.


![[Pasted image 20240626233618.png]]

Из этого следует, что протокол TCP пользуется популярностью среди приложений, работающих с массивом данных, разрыв которых нужно полностью исключить. Программы для загрузки файлов, отправки сообщений – это лишь малая часть программного обеспечения, построенного на базе протокола TCP.

В рамках протокола UDP данные передаются между узлами с помощью специальных пакетов данных, не требующих проверки. При этом гарантии их получения не требуется. Данная технология не предусматривает удаление дубликатов пакетов, мониторинг и контроль их текущего расположения.

С одной стороны, специалисты в области компьютерных сетей вполне заслуженно считают UDP ненадежным протоколом. С другой, это не просто важное, а незаменимое решение для приложений, работающих в режиме реального времени, интернет-телевидения, технологии VOIP, IP-камеры, онлайн игры, социальные сети и так далее. Благодаря возможностям протокола UDP пропадает необходимость проводить первичную проверку соединения, соблюдения целостности и порядка структуры данных. Если какая-либо датаграмма (пакет без проверки) потеряется, происходит ее автоматический сброс. Это положительно сказывается на скорости передачи данных через сеть интернет.


**Приложения для UDP**

Протокол UDP незаменим для приложений, с помощью которых происходит передача мультимедийной информации, включая интернет-телевидение, интернет-телефонию и так далее. Некоторое количество данных все же может быть потеряно, но это будет сложно заметить на практике. Яркий пример – изменение качества видеоряда и звука в худшую сторону. Вот почему популярные специализированные программы заранее предлагают своим пользователям выбрать оптимальное разрешение.

![[Pasted image 20240626233652.png]]

**Применение TCP**

Из сказанного выше следует, что TCP – это протокол повышенной сложности, работа которого сопровождается большими тратами времени. Причиной этого является механизм синхронизации между узлами. При этом основное преимущество данного протокола заключается в гарантии доставки пакетов, благодаря чему эта функциональность не включается в структуру прикладного протокола.

Кроме того, применение протокола TCP является гарантией надежности доставки. В случае некорректной отправки сообщения пользователь всегда получит соответствующее уведомление в виде окна с информацией о возникшей ошибке.


**Применение UDP**

UDP, в свою очередь, является протоколом, обладающим высокой скоростью передачи данных. Все дело в том, что в его основу заложен минималистичный механизм, без которого не обходится ни одна передача данных. Естественно, для него характерен целый ряд недостатков. Поступление передаваемых данных происходит в хаотичном порядке – не факт, что первый пакет из общего списка не окажется последним.

Гарантии доставки передаваемой информации нет, поэтому не исключено, что в ответ пользователь получит один пакет в виде двух копий. Возникновение подобной ситуации возможно в том случае, если один адрес для отправки сопровождается двумя разными маршрутами.


**Tcp Udp отличия**

Давайте рассмотрим основные отличия tcp от udp.

1. TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.
    
2. TCP нумерует пакеты при передаче, а UDP нет
    
3. TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.
    
4. TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.
    
5. UDP обеспечивает более высокую скорость передачи данных.
    
6. TCP надежнее и осуществляет контроль над процессом обмена данными.
    
7. UDP предпочтительнее для программ, воспроизводящих потоковое видео, видеофонии и телефонии, сетевых игр.
    
8. UPD не содержит функций восстановления данных
    

**Выводы**

UDP – протокол, который обеспечивает высокую скорость отправки пакетов данных, но без гарантии их доставки. Если для конечного пользователя важна надежность доставки с сохранением порядка отправки данных, придется переходить на использование протокола TCP. Применение протокола UDP актуально, если проводится групповая и широковещательная передача данных. Вот почему он пользуется большой популярностью в области потокового интернет-видео, а также в игровой индустрии.

---

# ICMP

ICMP (англ. Internet Control Message Protocol ) - это протокол третьего уровня модели OSI, который используется для диагностики проблем со связностью в сети. Говоря простым языком, ICMP помогает определить может л достичь пакет адреса назначения в установленные временные рамки. Обычно, ICMP “юзают" маршрутизаторы и устройства третьего уровня. Можно представить ряд ситуаций, когда протокол IP не может доставить пакет адресату, например истекает время жизни пакета, в таблице маршрутизации отсутствует маршрут к заданному в пакете адресу назначения, пакет не проходит проверку по контрольной сумме, шлюз не имеет достаточно места в своем буфере для передачи какого-либо пакета и т. д.

Как мы не раз отмечали, протокол IP доставл данные, руководствуясь принципом «по возможности», то есть не предпринимает мер для гарантированной передачи данных адресату. Это свойство «необязательности» протокола IP компенсируется протоколами более высоких уровней стека TCP/IP, например TCP на транспортном уровне и в какой-то степени DNS на прикладном уровне. Они берут на себя обязанности по обеспечению надежности, применяя такие известные приемы, как нумерация сообщений, подтверждение доставки, повторная посылка данных.

Протокол ICMP также служит дополнением, компенсирующим ненадежность протокола IP, но несколько другого рода. Он не предназначен для исправления возникших при передаче пакета проблем: если пакет потерян, ICMP не может послать его заново. Задача ICMP другая — он является средством оповещения отправителя о «несчастных случаях», произошедших с его пакетами. Пусть, например, протокол IP, работающий на каком-либо маршрутизаторе, обнаружил, что пакет для дальнейшей передачи по маршруту необходимо фрагментировать, но в пакете установлен признак DF (не фрагментировать). Протокол IP, обнаруживший, что он не может передать IP-пакет далее по сети, прежде чем отбросить пакет, должен отправить диагностическое ICMP-сообщение конечному узлу-источнику.

Для передачи по сети ICMP-сообщение инкапсулируется в поле данных IP-пакета. IP-адрес узла-источника определяется из заголовка пакета, вызвавшего инцидент. Основная цель ICMP это отчетность об ошибках. При соединении двух девайсов в сети, если часть данных н доходит до адреса назначения, теряется или превышает допустимые таймауты - ICMP генерирует ошибки.

Второе, и, пожалуй, одно из самых популярных применений ICMP это утилиты ping и traceroute. Термин “пинговать" как - раз связан с протоколом ICMP и “пинговать" хост - означает отправлять ICMP пакеты с целью понять, отвечает ли на них целевое устройство.

**Про трассировку**

Так и с “трассировкой". Когда говорят “сделайте трассировку маршрута" это означает, что мы хотим увидеть полный маршрут между хостом, на котором выполняется трассировка до хоста назначения. Трассировка покажет каждый из маршрутизаторов на пути до цели и время обработки и прохождения каждого из участков маршрута. Кстати, такой маршрут называется “хопом". Часто говорят: если от узла отправления до узла назначения на пути встретиться 7 маршрутизаторов, то говорят на пути будет 7 хопов. А если на 6 маршрутизаторе пакет обрабатывается дольше обычного, то в среде инженеров говорят “на 6 хопе повышенная задержка". Это один из базовых инструментов того, как можно понять, какой из сетевых узлов на маршруте пакет “сбоит". Именно в этом нам помогает протокол ICMP.

Про пинг

Теперь про ping. Можно сказать, это самый базовый инструмент инженера, который позволяет понять “"А жив ли хост?". Помимо прочего, пинг поможет понять как долго пакет доходит до адреса назначения и, соответственно, поможет измерить задержку.

Работает ping предельно просто:

1. Источник отправляет запрос вида ICMP echo request. Это выглядит как вопрос “бро, ты живой?"
    
2. Получатель отправляет ответ источнику ICMP echo reply. Это звучит как ответ вида “да, бро, я жив, спасибо!"
    
3. Время с момента отправки вопроса до получения ответа суммируется и считается за время пинга
    
Об ошибках можно информировать с помощью сообщений ICMP. Сообщения ICMP используются для отправки ответной реакции о состоянии сети. Например, маршрутизатор, не найдя подходящего элемента для сети в таблице маршрутизации, отправляет сообщение ICMP "недостижимый пункт назначения". Найдя лучший путь, маршрутизатор может послать сообщение ICMP "перенаправить". Если по пути передачи с IP-пакетам что-то произойдет, то никакое действие не предпринимается, сообщение об ошибке не отправляется, попыток передать снова этот же пакет не предпринимается. Это потому что, протокол IP предоставляет сервис передачи данных без гарантии доставки. Информация о возникающий об ошибках в сети передается не по протоколу IP, а по протокору ICMP. Также протокол ICMP используют для диагностики сети.

## Заголовки ICMP

![[Pasted image 20240626234234.png]]

Заголовок ICMP-сообщения состоит из 8 байт:

- тип (1 байт) — числовой идентификатор типа сообщения. В этом поле задается тип сообщения ICMP. Это поля говорить о том, что произошло в сети, какая ошибка или какое действие по диагностики пытаются выполнить. Например, значение типа, равное 3, означает, что пункт назначения недостижим, 11 определяет, что время истекло, 12 — обнаружены некорректные параметры заголовка;

- код (1 байт) — числовой идентификатор, более тонко дифференцирующий тип ошибки. Код предоставляет дополнительную информацию о типе сообщения. Для типа "недостижимый пункт назначения" код указывает, что именно недостижимо: сеть (0), хост (1), протокол (2) или порт (3). Простыми словами, в этом поле более подробно описывается тип ошибки или ее причина или же диагностическая действие;

- контрольная сумма (2 байта) — подсчитывается для всего ICMP-сообщения. Это поле используется для проверки правильности доставки.

- зависит от типа (4 байта) – В последних 4 байтах заголовка ICMP может предоставляться дополнительную (служебную) информация, зависящая от типа сообщения.

- поле данных – В это поле включается фрагмент пакета при передаче которого произошла ошибка.
    

Содержимое оставшихся четырех байтов в заголовке и поле данных зависит от значений полей типа и кода. Эти сообщения можно разделить на две группы (помеченные на рисунке условными символами):

- сообщения об ошибках;
    
- сообщения запрос-ответ.

Сообщения типа запрос-ответ связаны в пары: эхо-запрос — эхо-ответ, запрос маски -ответ маски, запрос времени — ответ времени. Отправитель сообщения-запроса всегда рассчитывает на получение соответствующего сообщения-ответа.

![[Pasted image 20240626234820.png]]


![[Pasted image 20240626234938.png]]

Cообщения, относящиеся к группе сообщений об ошибках, конкретизируются уточняющим кодом. На рисунке показан фрагмент таблицы кодов для сообщения об ошибке недостижимости узла назначения, имеющей тип 3. Из таблицы мы видим, что это сообщение может быть вызвано различными причинами, такими как неверный адрес сети или узла (код О или 1), отсутствием на конечном узле-адресате необходимого протокола прикладного уровня (код 2 — «протокол недостижим») или открытого порта UDP/TCP (код 3 — «порт недостижим»). Узел (или сеть) назначения может быть также недостижим по причине временной неработоспособности аппаратуры или из-за того, что маршрутизатор не имеет данных о пути к сети назначения. Всего таблица содержит 15 кодов. Аналогичные таблицы кодов существуют и для других типов сообщений об ошибках.

Если вы не можете достичь какого-либо хоста с использованием команды ping, то это не означает, что его нельзя достичь с помощью других протоколов. ICMP-сообщения "эхо"могут блокироваться маршрутизаторами или брандмауэрами.

На самом деле, с помощью ICMP можно провести атаки на сеть. Эти атаки связаны с отказом устройства в обслуживании (denial-of-service, DoS). Например “флуд - атака", суть которой заключается в отправке огромного количества пинг (ICMP) - запросов на хоста назначения с разных источников. В итоге устройство отвечает кучей пакетов на разные адреса и перегружает собственные мощности и сетевой адаптер.

Так же, раньше была популярна атака Ping of Death. Если кратко, ее суть заключалась в следующем: злоумышленник намеренно отправляет пакет больше максимального размера. Такой пакет фрагментируется на сети на несколько частей, прилетает в буфер устройства и попадает в очередь на сборка пакета “воедино". Переполнение этой очереди приводило к подвисанию хоста и полному отказу в работе.


# DNS

Как мы уже знаем, у каждого подключенного к интернету устройства есть свой номер, который на профессиональном языке называется IP-адресом. Он состоит из четырех чисел, идущих через точку. Каждое находится в диапазоне от 0 до 255. Например, 91.189.116.43 или 31.177.80.4 — это примеры реально существующих IP-адресов.

IP-адреса нужны для того, чтобы устройства в интернете могли идентифицировать себя и передавать данные друг другу. Благодаря им браузер может найти нужный сайт среди миллионов других, зарегистрированных в интернете. Запомнить эти наборы цифр сложно, поэтому придумали DNS (Domain Name System — система доменных имен) — технологию, которая связывает домен с IP-адресом. Часто DNS сравнивают с телефонной книгой, где записаны контакты (доменные имена) и номера телефонов (IP-адреса). Простыми словами DNS позволяет нам найти сайт не по IP-адресу, а по его доменное имя. Это сильно упрощает нам задачу, только представьте что, при каждом входе на какой либо веб-сайт, вы введёте IP-адрес, и вам пришлось бы запоминать все эти IP-адреса.

Знаком ли тебе IP - адрес 172.217.7.206? Наверняка нет. И нам нет. А это один из IP - адресов, на который обращается твой браузер, при вводе youtube.ru в адресной строке. И да, нам определенно не нужно знать наизусть эту информацию, ведь у нас есть DNS - Domain Name System

### DNS-сервер 

Информацию о доменных именах и IP-адресах нужно где-то хранить. Для этих целей используют целую систему DNS-серверов, расположенных в разных точках планеты. Именно на один из таких серверов приходит запрос, когда пользователь вводит имя домена в адресную строку. Сервер находит IP-адрес искомого сайта и отправляет его на пользовательское устройство.

Один конкретный сервер не знает IP-адреса всех доменных имен в мире, поэтому вторая функция DNS-серверов — это временное хранение информации других серверов или кеширование. Благодаря этому обработка запроса ускоряется, и нужная страница загружается быстрее. Только стоит учитывать, что информация в кеше хранится ограниченное количество времени, которое зависит от настроек сервера. 

![[Pasted image 20230612044555.png]]

Сначала несколько слов о кэшировании. Выяснять связь между названием сайта и его IP-адресом требуется при каждом обращении к этому веб-сайту. Если сайт, который вы хотите посетить, находится достаточно далеко, многочисленные запросы к далёкому первичному DNS-серверу могут отнять много времени и замедлить загрузку веб-страниц. Чтобы избежать задержек, ближайший к вашему компьютеру DNS-сервер (обычно находящийся у вашего интернет-провайдера), сохраняет сведения о ранее запрошенных IP-адресах, и при повторном обращении к тому же сайту он сообщит его адрес очень быстро, так как будет хранить его в своём кэше.

Но чтобы что-то кэшировать, нужно иметь источник кэшируемого. Таким источником служат первичные DNS-сервера, хранящие изначальные связи между доменами и их IP-адресами. Для регистрации доменного имени достаточно его придумать. Но для того, чтобы оно начало «работать», вы должны сообщить регистратору доменное имя DNS-сервера, который будет хранить подробные данные о регистрируемом вами домене. Об этих данных будет сказано чуть позже.

Обычно используют два DNS-сервера: первичный и вторичный. Но их может быть и больше. Большее число DNS-серверов повышает надёжность доступа к вашему домену: если один окажется недоступен, ответит другой. В реальном мире двух — вполне достаточно.

![[Pasted image 20230612044641.png]]


NS (Name Server) – это имя сервера в котором хранится вся необходимая информация о домене, для еоректной работы сайта. На ns сервере указывают доменное имя, доменное зона и другие информации. Как получить ns сервер? Когда вы покупаете хостинг, вместе с панель управление высылаются и нужные записи о ns-сервере.Рассмотрим процесс полностью Набрав адрес www.example.com в браузере и нажав enter, вы не сразу попадаете на DNS-сервер.

Сначала ваш девайс проверит кэш браузера или операционной системы. Ведь если вы до этого посещали сайт, то запись о нем останется
локально в кэше, чтобы в последующие разы не тратить время на поиск, гоняя туда-сюда пакеты. Если ты частый гость в нашей IT базе
знаний, то так оно и работает. А вот если сайт оказался новым, тогда мы шлем запрос так называемому resolver (распознающему) DNS серверу. Обычно этот сервер находится у нашего интернет провайдера, но мы можем поменять его на другой, например, использовать, известные сервера четыре восьмерки (8.8.8.8) и четыре единицы (1.1.1.1). 

8.8.8.8 и 8.8.4.4 – это бесплатные, публичные DNS-серверы от Google. Называются они Google Public DNS. Эти DNS-серверы разработала
компания Google. Они с закрытым исходным кодом. Их может использовать любой желающий, просто прописав их на своем компьютере,
телефоне, роутере. Он также делает сопоставление пришедшего имени сайта и его адреса в своем кэше. Если находит, то отвечает нам, а если не находит, то мы начинаем наш поход в поисках адреса и резолвер шлет запрос к корневому root-серверу.

![[Pasted image 20230612044733.png]]

![[Pasted image 20230612044739.png]]

Это сервер, который находится на самом верху DNS иерархии. Можно сказать, Шао Кан во вселенной DNS. Важно сказать, что рут сервер
не один, их множество. Но этот сервер нам IP - адреса не скажет. Он лишь скажет нам к какому серверу обратиться дальше. Как регистратура, в поликлинике.

Администрирование системы доменных имен (DNS) организовано в виде иерархии с использованием различных управляемых областей
или «зон» , при этом корневая зона находится на самом верху этой иерархии. Корневые серверы — это DNS-серверы имен, которы
работают в корневой зоне. Эти серверы могут напрямую отвечать на запросы о записях, хранящихся или кэшированных в корневой зоне, а
также могут направлять другие запросы на соответствующий сервер домена верхнего уровня (TLD) . Серверы TLD — это группа DNS-
серверов, расположенная на одну ступень ниже корневых серверов в иерархии DNS, и они являются неотъемлемой частью разрешения
DNS-запросов.

Во время некешированного DNS-запроса всякий раз, когда пользователь вводит веб-адрес в свой браузер, это действие запускает поиск
DNS, и все запросы DNS начинаются с корневой зоны. Как только поиск попадает в корневую зону, поиск затем перемещается вниз по
иерархии системы DNS, сначала затрагивая серверы TLD, затем серверы для определенных доменов (и, возможно, субдоменов), пока
наконец, он не достигнет авторитетного сервера имен для правильного домена. который содержит числовой IP-адрес разыскиваемого веб-сайта. Затем этот IP-адрес возвращается клиенту. Интересно, что, несмотря на количество необходимых шагов, этот процесс можетКорневые серверы являются неотъемлемой частью инфраструктуры Интернета; веб-браузеры и многие другие интернет-инструменты не будут работать без них. Существует 13 различных IP-адресов, которые обслуживают корневую зону DNS, и по всему миру существуют сотни резервных корневых серверов для обработки запросов к корневой зоне.

Это нужно для разветвления поиска, чтобы не искать IP в общей куче, а уйти в нужную ветку. Находясь в книжном магазине, чтобы найти новый роман стивена кинга, явно нужно искать не в отделе детской литературы или кулинарии, так ведь? Это нужно для разветвления поиска, чтобы не искать IP в общей куче, а уйти в нужную ветку. Находясь в книжном магазине, чтобы найти новый роман стивена кинга, явно нужно искать не в отделе детской литературы или кулинарии, так ведь? А дальше нам нужно обратиться к нужному серверу верхнего уровня или TLD (top level domain) серверу. Домены верхнего уровня - это то что идет после последней точки .com, .org, .ru, .net. Кстати, существуют Generic Top Level Domain (gTLD), которые не привязаны к стране, например, .edu (образование), .com (коммерческие веб сайты), и ai (организации, связанные с искусственным интеллектом), а также есть Country Code Top Level Domain (ccTLD), которые привязаны к стране: .ru (Россия), .us (США) и .uk (Британия) Получается: к root приходит запрос "Что скажешь про wiki.merionet.ru, бро?", на что он отвечает: "Спроси у ccTLD сервера, так как домен верхнего уровня это ".ru" Подуставший резолвер теперь идет к ccTLD и спрашивает: "Ну что там дальше то?" А дальше его отправляют на уровень ниже - к серверу авторитативных имен (Authoritative nameserver), который уже скажет нам нужный IP-адрес. Успех! Ну или нет. Он так же может ничего не найти и ответить, что - то в формате "извините, ваш сайт поглотила черная дыра."

Теперь резолвер ответит твоему девайсу, что у сайта wiki.merionet.ru такой-то IP - адрес. А еще резолвер запишет адрес в кэш, чтобы снова не проходить по той же цепочке. В терминологии DNS существует три типа запросов:

 - Recursive (рекурсивный) - это запрос формата: "Пришли мне IP-адрес сайта wiki.merionet.ru"
 - Iterative (итеративный) - это запрос формата: "Пришли мне IP-адрес сайта wiki.merionet.ru либо авторитативный DNS сервер"
 - Inverse (обратный) - спрашивает все наоборот: "Какое доменное имя у такого-то IP - адреса?"

![[Pasted image 20230612045032.png]]

### Какие функции выполняет name-сервер?

- Привычные пользователям домены не являются настоящими адресами хостов в сети, для идентификации которых на практике используются IP-адреса. Работа с ними неудобна для пользователей, поэтому применяется система DNS-серверов. Они выполняют несколько базовых функций.

 - Преобразуют введенное в адресную строку доменное имя в IP-адрес или наоборот (обратное преобразование).

 - Сообщают об ошибках, если запросы направлены к несуществующей адресам.

 - Предоставляют информацию о сервере, отвечающем за дочернюю зону (поддомены).

 - Кэшируют записи, полученные с других name-серверов. Кэширование помогает увеличить скорость доступа к сайтам. Запросы к удаленному DNS-серверу занимают много времени, поэтому DNS-сервер провайдера хранит адреса ранее запрошенных сайтов в кэше.

Существует 3 основных типа DNS-серверов:

 - Первичный (Primary, master), хранит файл зоны домена с информацией о всех ресурсных записях.

 - Вторичный (Secondary, slave), загружает и хранит копию файла зоны с первичного DNS-сервера. Используется для повышения
   отказоустойчивости службы DNS. 

 - Кэширующий. Предназначен только для кэширования, применяется для разгрузки первичных и вторичных серверов, а также для повышения скорости доступа к сайтам.

### Что такое дочерние NS-серверы?


Дочерние DNS-серверы настраиваются на основе используемого родительского домена. Например, для example.net дочерние NS будут
выглядеть так:

 - ns1.example.net
 - ns2.example.net

или:

 - primary.example.net
 - secondary.example.net

Дочерние DNS-серверы позволяют расположить DNS-серверы для домена на его поддоменах. При делегировании домена с использованием дочерних DNS-серверов потребуется помимо их имен указать и IP-адреса. 

### Что такое DNS-зоны?

В этой статье мы рассматриваем лишь вариант «один домен — один IP-адрес». На самом деле, ситуация может быть и сложнее. Так, с
определенным доменным именем может быть связано несколько ресурсов — сайт и почтовый сервер. У этих ресурсов вполне могут быть
разные IP-адреса, что дает возможность повысить надежность и эффективность работы сайта или почтовой системы. Есть у сайтов и
поддомены, IP-адреса которых тоже могут быть разными.

Вся эта информация о связи сайта, поддоменов, почтовой системы хранится в специальном файле на DNS-сервере. Его содержимое
называется DNS-зона. Файл содержит следующие типы записей:

 - А — адрес веб-ресурса, который привязан к конкретному имени домена.
 - MX — адрес почтового сервера.
 - CNAME — чаще всего этот тип записи используется для подключения поддомена.
 - NS — адрес DNS-сервера, который отвечает за содержимое других ресурсных записей.
 - TXT — любая текстовая информация о доменном имени.
 - SPF — данные с указанием списка серверов, которые входят в список доверенных для отправки писем от имени указанного домена.
 - SOA — исходная запись зоны, в которой указаны сведения о сервере и которая содержит шаблонную информацию о доменном имени.

---

# DHCP

DHCP (Dynamic Host Configuration Protocol) - Это протокол прикладного уровня модели TCP/IP, служит для назначения IP-адреса клиенту. Все устройствам в сети нужна IP-адреса, так как они их получают? Первый способ - это сисадмин который руками их задаёт его IP-адрес, это еще называется статический IP, если у вас пару компьютеров, то это терпима, но что если нужно подключить целый офис или этажи здание? Тут еще сисадмин может ошибиться в настройках, так себе решение.

Второй способ - DHCP, который всё корректно раз рулит и раздаст правильные IP-адреса в автоматическом режиме. DHCP работает по принципу клиент/сервер, это означает что, есть DHCP-сервер - тот кто раздаёт IP-адреса, а есть DHCP-клиент - тот кто IP-адрес запрашивает и получает. Сегодняшние DHCP-сервера закусается не только на выделанных машинах ну и например на роутерах. На DHCP-сервере задаётся диапазон адресов, который он может раздавать клиентам, этот диапазон адресов еще называется "ПУЛ", а также сервер раздаёт клиенту маску подсети, шлюз по умолчанию и может сообщить DNS-сервера.


## Принцип работы DHCP

Из вступления ясно, какие функции предоставляет DHCP, но по какому принципу он работает? Получение адреса проходит в четыре шага. Этот процесс называют DORA по первым буквам каждого шага: Discovery, Offer, Request, Acknowledgement. Давайте подробнее рассмотрим DORA — принцип работы DHCP.

![[Pasted image 20230620055908.png]]

## Протокол DHCP, получение адреса IP — DORA

### 1. Discovery, или поиск

Изначально клиент находится в состоянии инициализации (INIT) и не имеет своего IP-адреса. Поэтому он отправляет широковещательное
(broadcast) сообщение DHCPDISCOVER на все устройства в локальной сети. В той же локальной сети находится DHCP-сервер. DHCP-
сервер — это, например, маршрутизатор или коммутатор, существуют также выделенные DHCP-серверы. DHCPDISCOVER может звучать так: Хэй всем привет, тут есть DHCP-сервер, мне бы IP-шник получить.

Не всегда одну сеть обслуживает один DHCP-сервер, нередко организации устанавливают сразу несколько. Какие порты использует
DHCP? Сервер всегда слушает 67 порт, ожидает широковещательное сообщение от клиента, а после его получения отправляет ответное
предложение — DHCPOFFER. Клиент принимает сообщение на 68 порту. 

То есть, когда клиент загружается (или хочет присоединиться к сети), он начинает четырехэтапный процесс для получения аренды. Он
запускает процесс с широковещательным (broadcast) сообщением DHCPDISCOVER со своим собственным MAC-адресом (для связи
сервером) для обнаружения доступных серверов DHCPv4. Поскольку у клиента нет способа узнать подсеть, к которой он принадлежит, у
сообщения DHCPDISCOVER в поле адрес назначения IPv4 адреса -255.255.255.255. А поскольку у клиента еще нет настроенного адреса
IPv4, то исходный IPv4-адрес - 0.0.0.0.

Сообщение DHCPDISCOVER находит серверы DHCPv4 в сети. Поскольку клиент не имеет IPv4 информации при загрузке, он использует
широковещательные адреса 2 и 3 уровня для связи с сервером.


### 2. Offer, или предложение

DHCP-сервер отвечает на поиск предложением, он сообщает IP, который может подойти клиенту. IP выделяются из области (SCOPE
доступных адресов, которая задается администратором. Если имеются адреса, которые не должны быть назначены DHCP-сервером, область можно ограничить, указав только разрешенные адреса.

Например, администратор может задать диапазон используемых IP-адресов от 192.0.0.10 до 192.0.0.255. Бывает и так, что не все доступные адреса должны быть назначены клиентам. Например, администратор может исключить (exclude) диапазон 192.0.0.100 — 192.0.0.200 из используемой области. Такое ограничение называется исключением. 

DHCP выделяет доступные IP-адреса из области только временно (об этом позже), поэтому нет гарантии, что при следующем
подключении у данного клиента останется прежний IP. Но есть возможность назначить какому-либо клиенту определенный IP навсегда. К
примеру, забронировать 192.0.0.10 за компьютером системного администратора. Такое сохранение IP для отдельных клиентов называют
резервацией (reservation).

DHCPOFFER содержит IP из доступной области, который предлагается клиенту отправкой широковещательного (broadcast, «если вы тот,
кто запрашивал IP-адрес, то доступен вот такой») или прямого (unicast, «вы запрашивали IP, предлагаю вот такой») сообщения. При этом,
поскольку нужный клиент пока не имеет IP, для отправки прямого сообщения он идентифицируется по MAC-адресу. Простыми словами,
Когда DHCPv4-сервер получает сообщение DHCPDISCOVER, он резервирует доступный IPv4-адрес для аренды клиенту. Сервер такж
создает запись ARP, состоящую из MAC-адреса клиента и арендованного IPv4-адреса DHCP сервер отправляет связанное сообщение
DHCPOFFER запрашивающему клиенту, как одноадресная передача (unicast), используя MAC-адрес сервера в качестве исходного адреса и
MAC-адрес клиента в качестве адреса доставки.


### 3. Request, или запрос

Клиент получает DHCPOFFER, а затем отправляет на сервер сообщение DHCPREQUEST. Этим сообщением он принимает предлагаемый
адрес и уведомляет DHCP-сервер об этом. Широковещательное сообщение почти полностью дублирует DHCPDISCOVER, но содержит в
себе уникальный IP, выделенный сервером. Таким образом, клиент сообщает всем доступным DHCP-серверам «да, я беру этот адрес», а
сервера помечают IP как занятый. То есть, Когда клиент получает DHCPOFFER с сервера, он отправляет обратно сообщение
DHCPREQUEST. Это сообщение используется как для получения, так и для продления аренды. Когда используется для получения
аренды, DHCPREQUEST служит в качестве уведомления о принятии выбранных сервером параметров, которые он предложил, и
отклонении предложения от других серверов. Многие корпоративные сети используют несколько DHCP серверов, и сообщение
DHCPREQUEST отправляется в виде широковещательной передачи, чтобы информировать все серверы о принятом предложении. После
того как DHCP-клиент получил IP-адрес, то DHCP-сервер убирает этот IP-адрес из свободного ПУЛА.


### 4. Acknowledgement, или подтверждение

Сервер получает от клиента DHCPREQUEST и окончательно подтверждает передачу IP-адреса клиенту сообщением DHCPACK. Это
широковещательное или прямое сообщение утверждает не только владельца IP, но и срок, в течение которого клиент может использовать
этот адрес. То есть, при получении сообщения DHCPREQUEST сервер проверяет информацию об аренде с помощью ICMP-запроса на
этот адрес, чтобы убедиться, что он уже не используется и создает новую ARP запись для аренды клиента, а затем отвечает одноадресным
DHCPACK-сообщением. Это сообщение является дубликатом DHCPOFFER, за исключением изменения поля типа сообщения. Когда
клиент получает сообщение DHCPACK, он регистрирует информацию и выполняет поиск ARP для назначенного адреса. Если ответа на
ARP нет, клиент знает, что адрес IPv4 действителен и начинает использовать его как свой собственный.

Со схемой отправки сообщений разобрались, но, если в сети несколько DHCP-серверов, пославших предложение, какое из них выберет
клиент? Хороший вопрос. В состоянии INIT, если клиент получает адрес впервые, он будет принимать только первое предложение IP.
Однако, если клиент уже общался ранее с определенным DHCP-сервером, он отдаст предпочтение этому серверу и, наоборот, серве
выберет знакомого клиента.



### Срок аренды

Когда DHCP-сервер выделяет IP из области, он оставляет запись о том, что этот адрес зарезервирован за клиентом с указанием срока действия IP. Этот срок действия называется срок аренды (lease time). Срок аренды может составлять от 24 часов до нескольких дней, недель или даже месяцев, он задается в настройках самого сервера. 

Предоставление адреса в аренду, а не на постоянной основе необходимо по нескольким причинам. Во-первых, это разумное использование IP-адресов — отключенные или вышедшие из строя клиенты не резервируют за собой адрес. Во-вторых, это гарантия того, что новые клиенты при необходимости смогут получить уникальный адрес. После получения адреса из области, клиент берет его в аренду на время, называемое T. Клиент переходит в связанное (BOUND) состояние и продолжает нормальную работу, пока не наступит время половины срока аренды — T1.

По наступлении T1 клиент инициализирует процедуру получения нового IP или обновления адреса — состояние RENEWING. Процесс повторного получения происходит по упрощенной схеме: клиент прямым сообщением запрашивает (DHCPREQUEST), а сервер подтверждает (DHCPACK) запрос. Время аренды начинает отсчитываться заново. Если подтверждение (DHCPACK) от сервера не поступает, клиент снова запрашивает адрес, но только когда истекает половина T1. Если запрос адреса остается без ответа второй раз, клиент отправляет еще одно сообщение, когда истекает половина от T1/2 (25% от полного срока аренды). Следующий запрос будет отправлен после истечения еще половины оставшегося времени, потом еще половины. И так далее, пока не наступит T2, которое
равняется 87,5%, или 7/8 от всего времени аренды. После T2 все попытки продлить аренду IP будут широковещательными. Это значит, что, если первый сервер по какой-то причине недоступен, на запрос адреса сможет ответить любой другой, и работа не будет прервана. Если котортко то: 

  1) Когда срок аренды истек, клиент отправляет сообщение DHCPREQUEST непосредственно DHCP серверу, который первоначально предлагал адрес. Если DHCPACK не получен в течение определенного периода времени, то клиент передает другой DHCPREQUEST, чтобы один из других доступных серверов DHCPv4 мог продлить аренду.

   2) При получении сообщения DHCPREQUEST сервер проверяет информацию об аренде, возвращая DHCPACK.

---

# MAC-адрес

На самом деле, чего только не происходит в компьютерных сетях. Разобраться сложно, а особенно сложно, когда речь заходит об адресации и приеме/передаче данных. Вопрос усложняется тем, что каждый из адресов функционирует на своем уровне модели OSI (Open Systems Interconnection). 

MAC (Media Access Control) - это уникальный идентификатор, назначаемый контроллеру сетевого интерфейса (NIC) для использования в качестве сетевого адреса при обмене данными в сегменте сети. Это использование распространено в большинстве сетевых технологий IEEE 802, включая Ethernet, Wi-Fi и Bluetooth. 

MAC - адрес представляет собой уникальную комбинацию цифр и букв длиной 48 символов. Фактически, это аппаратный номер оборудования (компьютера, сервера, роутера, порта коммутатора, да чего угодно), который, внимание, присваивается сетевой карте устройства еще на фабрике, то есть в момент производства. Да - да, MAC - адрес устройства это вам не IP - адрес устройства, который можно легко поменять. Этот адрес вшит аппаратно. Хотя, конечно, надо быть честными - как специалисты из Мытищ в гаражных условиях "перебьют" VIN номер автомобиля, так и MAC - адрес можно "перебить".MAC - адрес еще называют уникальным физическим адресом устройства, помогающим идентифицировать устройство среди миллионов других устройств. В стандарте IEEE 802, канальный (второй, Data Link) уровень модели OSI разделен на два подуровня:

●Logical Link Control (LLC) или подуровень управления логической связью;
●Media Access Control (MAC) или подуровень управления доступом к среде;

И как раз, как можно догадаться, MAC - адрес используется на втором подуровне, Media Access Control, который является частью канального уровня модели OSI. А теперь поговорим про то, как выглядит MAC - адрес из из чего он состоит. Берем лист А4 и маркер - начинаем рисовать.

![[Pasted image 20230720170639.png]]

Стандартный MAC выглядит примерно вот так: 00-50-B6-5B-CA-6A.

Смотрите: мак - адрес это 12 - значное шестнадцатеричное число, или 6 - байтовое двоичное число. Чаще всего MAC-адрес представляют именно в шестнадцатеричной системе. 

На картинки мы изобразили 6 октетов (неких групп), из которых состоит MAC. Каждый из октетов состоит из 2 знаков, итого получается 12 - значное число. Первые 6 цифр (к примеру 00-50-B6) обозначают производителя сетевой карты. Его также называют OUI (Organizational Unique Identifier) - мы отобразили эту часть на картинке выше.
Вот, например, известные MAC OUI популярных вендоров:

●CC:46:D6 - Cisco
●3C:5A:B4 - Google, Inc.
●3C:D9:2B - Hewlett liackard
●00:9A:CD - HUAWEI TECHNOLOGIES CO.,LTD

И, собственно, вторые 6 цифр (6 цифр справа) уникальны и идентифицируют NIC (Network Interface Controller). Часто, MAC адреса записывают по-разному: через тире, двоеточие, или точки. Например:

●00-50-B6-5B-CA-6A - самая распространенная и привычная для всех форма записи;
●00:50:B6:5B:CA:6A - форма записи используется части всего в Linux системах;
●005.0b6.5bc.a6a - такой формат записи MAC - адреса используется компанией Cisco.

# HTTP

HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») – протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных. Протокол HTTP лежит в основе обмена данными в Интернете. Протокол передачи гипертекста (HTTP) является основой всемирной паутины и используется для загрузки веб страниц с использованием гипертекстовых ссылок. HTTP — это прикладного уровня , предназначенный для передачи информации между сетевыми устройствами и работающий поверх других уровней стека сетевых протоколов. Типичный поток через HTTP включает в себя клиентскую машину, делающую запрос к серверу, который затем отправляет ответное сообщение.


Связь между клиентскими компьютерами и веб-серверами осуществляется путем отправки HTTP-запросы и получение HTTP-ответов

**HTTP-запрос/ответ**

Связь между клиентами и серверами осуществляется с помощью запросов и ответов :

1. Клиент (браузер) отправляет HTTP-запрос в Интернет
    
2. Веб-сервер получает запрос
    
3. Сервер запускает приложение для обработки запроса
    
4. Сервер возвращает HTTP-ответ (выход) в браузер.
    
5. Клиент (браузер) получает ответ
    
Каждый раз, когда вы посещаете страницу в интернете, ваш компьютер использует протокол передачи гипертекста (HTTP) для загрузки этой страницы. HTTP — это набор правил для передачи файлов: текста, изображений, звука, видео и других мультимедиа. HTTP работает поверх набора протоколов TCP/IP, которые составляют основу интернета. Как мы уже знаем, в HTTP-протоколе есть две разные роли: сервер и клиент. Запрос всегда инициирует клиент, а сервер на него отвечает. Клиентом может быть как браузер, так и, к примеру, поисковый робот, который просматривает страницы в интернете и индексирует их согласно релевантности ключевого запроса. HTTP основан на тексте — сообщения между клиентом и сервером по сути представляют собой фрагменты текста, хотя в теле сообщения могут быть другие элементы: видео, фото, аудио и т.д.

![[Pasted image 20240626235630.png]]

Каждый запрос (англ. request) отправляется серверу, который обрабатывает его и возвращает ответ (англ. response). Между этими запросами и ответами как правило существуют многочисленные посредники, называемые прокси, которые выполняют различные операции и работают как шлюзы или кэш, например.

![[Pasted image 20240626235702.png]]

Обычно между браузером и сервером гораздо больше различных устройств-посредников, которые играют какую-либо роль в обработке запроса: маршрутизаторы, модемы и так далее. Благодаря тому, что Сеть построена н основе системы уровней (слоёв) взаимодействия, эти посредники "спрятаны" на сетевом и транспортном уровнях.

  

- этой системе уровней HTTP занимает самый верхний уровень, который называется "прикладным" (или "уровнем приложений"). Знания об уровнях сети, таких как представительский, сеансовый, транспортный, сетевой, канальный и физический, имеют важное значение для понимания работы сети и диагностики возможных проблем, но не требуются для описания и понимания HTTP. Протокол HTTP использует TCP для передачи данных. Веб-сервер работает на порту 80, а для клиента, номер порта генерируется автоматически.

**По итогу у нас получается:**

Клиент — это любой инструмент, который действует от имени пользователя. В основном эту роль выполняет веб-браузер, но помимо браузера это быть программы, используемые инженерами или веб-разработчиками для отладки своих приложений. Клиент всегда инициирует запрос, это никогда не делает сервер.

**Веб-сервер**

На другой стороне канала связи находится сервер, который обслуживает документ по запросу клиента. Хотя для пользователя сервер выглядит как одна виртуальная машина, на самом деле это может быть набор серверов, разделяющих нагрузку. С другой стороны, несколько серверов могут быть расположены на одной и той же машине. При HTTP/1.1 и заголовке Host они могут даже использовать один и тот же IP-адрес.

**Прокси**

Прокси-серверы — это серверы, компьютеры или другие машины уровня приложений, которые находятся между клиентским устройством и непосредственно сервером. Они ретранслируют HTTP-запросы и ответы. Обычно для каждого взаимодействия клиент-сервер используется один или несколько прокси.

**Веб-разработчики могут использовать прокси для следующих целей:**

- Кэширование. Кэш-серверы сохраняют веб-страницы или другой контент локально, для более быстрого поиска информации и снижения требований к пропускной способности сайта.
    
- Аутентификация. Для контроля прав доступа к приложениям и онлайн-информации.
    
- Логирование. Нужен для хранения данных, таких как IP-адреса клиентов, отправивших запросы на сервер.
    
- Веб-фильтрация. Контролирует доступ к веб-страницам, которые могут быть небезопасными или содержать неприемлемый контент.
    
- Балансировка нагрузки. Позволяет обрабатывать клиентские запросы не одному серверу, а сразу нескольким.
    

**Что находится в HTTP-запросе?**

HTTP-запрос — это способ, с помощью которого платформы интернет-коммуникаций, такие как веб-браузеры запрашивают информацию, необходимую им для загрузки веб-сайта.

Каждый HTTP-запрос, сделанный через Интернет, несет в себе ряд закодированных данных, которые несут различные типы информации. Типичный HTTP-запрос содержит:

1. Тип HTTP-версии
    
2. URL-адрес
    
3. метод HTTP
    
4. Заголовки HTTP-запроса
    
5. Необязательное тело HTTP.

Давайте более подробно рассмотрим, как работают эти запросы и как можно использовать содержимое запроса для обмена информацией.


**Что такое метод HTTP?**

  

Для того, чтобы указать серверу на то, какое действие мы хотим произвести с ресурсом, используется тип HTTP-запроса, который также называется HTTP метод. Существует несколько HTTP методов, которые описывают действия с ресурсами. Наиболее часто используемыми являются GET и POST.

Метод HTTP, иногда называемый глаголом HTTP, Например, как мы и сказали два наиболее распространенных метода HTTP — это «GET» и «POST»; запрос «GET» ожидает информацию в ответ (обычно в форме веб-сайта), в то время как запрос «POST» обычно указывает, что клиент отправляет информацию на веб-сервер (например, информацию формы, например, отправленное имя пользователя и пароль). ).

**Метод GET**

Метод GET запрашивает информацию из указанного источника и не влияет на его содержимое. Запрос доступен для кеширования данных и добавления в закладки. Длина запроса ограничена (макс. длина URL - 2048).

**Примечание: Строка запроса (имя/значение) отправляется в URL**

```
/login-check.php?argument1=value1&argument2=value2
```

**Синтакс кода**

```html
<form method="get">

    First name: <input type="text" placeholder="Your name"><br/>
    <input type="submit" value="Submit">

</form>
```

**Метод POST**

Метод POST используется для отправки данных, что может оказывать влияние на содержимое ресурса. В отличие от метода GET запросы POST не могут быть кешированы, они не остаются в истории браузера и их нельзя добавить в закладки. Запросы POST не ограничиваются в объеме.

Примечание: Отправляемые данные содержатся в теле запроса.

```
POST /login-check.php HTTP/1.1
Host: w3docs.com
argument1=value1&argument2=value2
```

**Синтакс кода**

```
<form method="post">

    First name: <input type="text" placeholder="Your name"><br/> 
    <input type="submit" value="Submit">

</form>
```

![[Pasted image 20240627000122.png]]

**Что такое заголовки HTTP-запроса?**

Заголовки HTTP содержат текстовую информацию, хранящуюся в парах ключ-значение, и они включаются в каждый HTTP-запрос (и ответ, подробнее об этом позже). Эти заголовки передают основную информацию, например, какой браузер использует клиент, какие данные запрашиваются.

Пример заголовков HTTP-запроса на вкладке сети Google Chrome:

![[Pasted image 20240627000139.png]]

**Что находится в теле запроса HTTP?**

  

Тело запроса — это часть, которая содержит «тело» информации, которую передает запрос. Тело HTTP-запроса содержит любую информацию, отправляемую на веб-сервер, такую как имя пользователя и пароль, или любые другие данные, введенные в форму.

Пример

Когда вы вводите URL-адрес в адресной строке, ваш браузер отправляет HTTP-запрос, и он может выглядеть так:

```
GET /tutorials/other/top-20-mysql-best-practices/ HTTP/1.1 Host: net.tutsplus.com

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120
Pragma: no-cache
Cache-Control: no-cache
```

Первая строка - это "Request Line", которая содержит некоторую базовую информацию по запросу. Остальные - HTTP заголовки.

**Что находится в ответе HTTP?**

HTTP-ответ — это то, что веб-клиенты (часто браузеры) получают от интернет-сервера в ответ на HTTP-запрос.

Эти ответы передают ценную информацию на основе того, что было запрошено в HTTP-запросе.

  

- Типичный ответ HTTP содержит:
    
- код состояния HTTP
    
- Заголовки ответа HTTP
    
- необязательное тело HTTP Давайте разберем их:


**Что такое код состояния HTTP?**

Коды состояния HTTP — это трехзначные коды, которые чаще всего используются для обозначения того, успешно ли выполнен HTTP-запрос. Коды состояния разбиты на следующие 5 блоков:

- 1xx Информационное
- 2xx Успех
- 3xx перенаправление
- 4xx Ошибка клиента
- 5xx Ошибка сервера
    

«xx» относится к разным числам от 00 до 99.

Коды состояния, начинающиеся с цифры «2», указывают на успех. Например, после того, как клиент запрашивает веб-страницу, наиболее часто встречающиеся ответы имеют код состояния «200 OK», указывающий на то, что запрос был выполнен правильно.

Если ответ начинается с «4» или «5», это означает, что произошла ошибка, и веб-страница не будет отображаться. Код состояния, начинающийся с «4», указывает на ошибку на стороне клиента (очень часто встречается код состояния «404 NOT FOUND» при опечатке в URL-адресе). Код состояния, начинающийся с «5», означает, что что-то пошло не так на стороне сервера. Коды состояния также могут начинаться с «1» или «3», что указывает на информационный ответ и перенаправление (redirect) соответственно.


**Что такое заголовки ответа HTTP?**

Подобно HTTP-запросу, HTTP-ответ содержит заголовки, которые передают важную информацию, такую как язык и формат данных, отправляемых в теле ответа.

Пример заголовков ответа HTTP на вкладке сети Google Chrome:

![[Pasted image 20240627000420.png]]

После этого запроса ваш браузер получает ответ HTTP, который может выглядеть так:

  
```

HTTP/1.x 200 OK
Transfer-Encoding: chunked
Date: Sat, 28 Nov 2009 04:36:25 GMT
Server: LiteSpeed
Connection: close
X-Powered-By: W3 Total Cache/0.8
Pragma: public
Expires: Sat, 28 Nov 2009 05:36:25 GMT
Etag: "pub1259380237;gz"
Cache-Control: max-age=3600, public
Content-Type: text/html; charset=UTF-8
Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT
X-Pingback: https://net.tutsplus.com/xmlrpc.php
Content-Encoding: gzip
Vary: Accept-Encoding, Cookie, User-Agent


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http -equiv="Content-Type" content="text/html; charset=utf-8" /> <title>Top 20+ MySQL Best Practices - Nettuts+</title> <!-- ... rest of the html ... -->
```

Первая строка - это «Строка состояния», за которой следуют «HTTP-заголовки», до пустой строки. После этого начинается «содержимое» (в данном случае - HTML вывод).

Когда вы смотрите на исходный код веб-страницы в своём браузере, вы видите только часть HTML, а не заголовки HTTP, хотя они фактически были переданы вместе.

Эти HTTP-запросы также отправляются и принимаются для других вещей, таких как изображения, CSS-файлы, файлы JavaScript и т. д. Именно поэтому я сказал ранее, что ваш браузер отправил не менее 40 или более HTTP-запросов, поскольку вы загрузили только эту страницу статьи.

## Что находится в теле ответа HTTP?

HTTP поток

Когда клиент хочет взаимодействовать с сервером, являющимся конечным сервером или промежуточным прокси, он выполняет следующие шаги:


1. Открытие TCP соединения: TCP-соединение будет использоваться для отправки запроса (или запросов) и получения ответа. Клиент может открыть новое соединение, переиспользовать существующее или открыть несколько TCP-соединений к серверу.

2. Отправка HTTP-сообщения: HTTP-сообщения (до HTTP/2) являются человекочитаемыми. Начиная с HTTP/2, простые сообщения инкапсулируются во фреймы, делая невозможным их чтение напрямую, но принципиально остаются такими же.
  
```
GET / HTTP/1.1

Host: developer.mozilla.org
Accept-Language: fr
```

3. Читает ответ от сервера:

```  
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```

4. Закрывает или переиспользует соединение для дальнейших запросов.

Если активирован HTTP-конвейер, несколько запросов могут быть отправлены без ожидания получения первого ответа целиком. HTTP-конвейер тяжело внедряется в существующие сети, где старые куски ПО сосуществуют с современными версиями. HTTP-конвейер был заменён в HTTP/2 на более надёжные мультиплексные запросы во фрейме.

**HTTP сообщения**

Подробнее в отдельной статье «Сообщения HTTP»

HTTP/1.1 и более ранние HTTP сообщения человекочитаемые. В версии HTTP/2 эти сообщения встроены в новую бинарную структуру, фрейм, позволяющий оптимизации, такие как компрессия заголовков и мультиплексирование. Даже если часть оригинального HTTP сообщения отправлена в этой версии HTTP, семантика каждого сообщения не изменяется и клиент воссоздаёт (виртуально) оригинальный HTTP-запрос. Это также полезно для понимания HTTP/2 сообщений в формате HTTP/1.1.

Существует два типа HTTP сообщений, запросы и ответы, каждый в своём формате.

**Запросы**

Примеры HTTP запросов:

![[Pasted image 20240627022201.png]]

Запросы содержат следующие элементы:

- HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
    
- Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без протокола (http://), домена (здесь developer.mozilla.org), или TCP порта (здесь 80).
    
- Версию HTTP-протокола.
    
- Заголовки (опционально), предоставляющие дополнительную информацию для сервера.
    
- Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.


**Ответы**

Примеры ответов:

![[Pasted image 20240627022241.png]]

Ответы содержат следующие элементы:

- Версию HTTP-протокола.
    
- HTTP код состояния, сообщающий об успешности запроса или причине неудачи.
    
- Сообщение состояния — краткое описание кода состояния.
    
- HTTP заголовки, подобно заголовкам в запросах.
    
- Опционально: тело, содержащее пересылаемый ресурс.

![[Pasted image 20240627022309.png]]

![[Pasted image 20240627022316.png]]

![[Pasted image 20240627022324.png]]

![[Pasted image 20240627022347.png]]

Пример запроса-ответа HTTP

**1) Запрос**

![[Pasted image 20240627022421.png]]

Рассмотрим примеры запроса и ответа и HTTP, HTTP работают в тестовом режиме. Нам необходимо подключиться к веб-сервер например www.asozykin.ru к порту 80 по протоколу TCP. Вы можете попробовать сделать это вручную используя клиенты например telnet под linux или пути под windows. Дальше мы пишем запрос используем метод GET. Хотим получить ресурс courses/network страницу на моем сайте посвященную курсу по компьютерным сетям и указываем версию протокола по которой мы хотим работать HTTP 1.1. Так как мы используем версию 1.1 нам необходимо указать заголовок Hosy доменной имя сервера с которым мы работаем www.asozykin.ru. Этого вполне достаточно для того, чтобы веб-сервер нам ответил.

2. **Ответ**
![[Pasted image 20240627022504.png]]

Ответ веб-сервер начинается со статуса 200 OK - обработка запроса произошла успешно. Также вначале указывается версия протокола которые используются - HTTP 1.1. Затем идут несколько заголовков реализация веб сервера тип передаваемых страницы текста системы кадыров UTF-8 длина страницы - 5161 тысяча байт. Такж здесь могут идти и другие заголовки которые вам передал сервер. Затем идет пустая строка и код веб страницы. После передачи веб страницы соединения эти цепи разрываются. Можно оставить соединения открытым для последующей работы, но, но для этого необходимо использовать дополнительный заголовок.

Cовременный веб устроен гораздо более сложно. Вместо статистических веб страниц которые записаны на диск сервера могут использоваться программы, которые генерируют веб страницу. При этом они могут соединиться с базами данных или с другими ве сервисами для получения необходимых данных. Современные веб-страницы очень сложные. Они включают большое количество дополнительных элементов таких как картинки данные из других веб-сервер ов или программы, которые выполняются на клиента. Кроме того достаточно часто необходимо отслеживать состояние работы пользователя. Например, если вы работаете с сайтами интернет магазина положили какие-то товары в корзину они должны сохраняться даже, если вы переходите на другие страницы и просматривая эти другие товары протоколы HTTP включают возможности для реализации всех этих функций.

**Что мы знаем о HTTP?**

**HTTP-запросы**

HTTP-запрос выполняется клиентом к именованному хосту, который находится на сервере. Целью запроса является доступ к ресурсу на сервер.

Чтобы сделать запрос, клиент использует компоненты URL (Uniform Resource Locator), который включает в себя информацию, необходимую для доступа к ресурсу. Компоненты URL-адреса объясняют URL-адреса.

Правильно составленный HTTP-запрос содержит следующие элементы:

- Строка запроса.
    
- Серия заголовков HTTP или полей заголовков.
    
- Тело сообщения, если необходимо.
    
За каждым заголовком HTTP следует перевод строки возврата каретки (CRLF). После последний из заголовко HTTP, используется дополнительный CRLF (чтобы дать пустой строка), а затем начинается любое тело сообщения.

**Строка запроса**

Строка запроса - первая строка в сообщении запроса. Он состоит как минимум из трех пунктов:

Метод _ . Метод представляет собой команду из одного слова, которая сообщает серверу что он должен делать с ресурсом. Например, сервер может быть запрошен отправить ресурс клиенту.

Компонент пути URL-адреса для запроса. Путь идентифицирует ресурс на сервере.

Номер версии HTTP, показывающий спецификацию HTTP, к которой клиент пытался заставить сообщение соответствовать.

Пример строки запроса:

GET /software/htp/cics/index.html HTTP/1.1

этот пример:
    
-  метод GET
- путь /software/htp/cics/index.html
- HTTP-версия HTTP/1.1

  

Строка запроса может содержать некоторые дополнительные элементы:

– Строка запроса. Это предоставляет строку информации, которую ресурс можно использовать для каких-то целей. Он следует за путем, и ему предшествует вопрос отметка.

– Схема и хост-компоненты URL-адреса, помимо пути. Когда местоположение ресурса

указывается таким образом, оно называется абсолютным УРИ . Для HTTP/1.1 эта форма используется при прохождении запроса прокси-сервер. Также для HTTP/1.1, если хост-компонент URL-адреса не включена в строку запроса, она должна быть включена в сообщение в Host заголовок.

**HTTP-заголовки**

Заголовки HTTP пишутся в сообщении предоставить получателю информацию о сообщении, отправителе и способ, которым отправитель хочет общаться с получателем. Каждый Заголовок HTTP состоит из имени и значения. Спецификации протокола HTTP определить стандартный набор заголовков HTTP и описать, как их правильно использовать. Сообщения HTTP также могут включать заголовки расширений, которые не являются частью Спецификации HTTP/1.1 или HTTP/1.0.

Заголовки HTTP для клиентского запрос содержит информацию, которую сервер может использовать, чтобы решить, как ответить к запросу. Например, следующую серию заголовков можно использовать для указать, что пользователь хочет прочитать запрошенный документ только на французском языке или немецкий, и что документ следует отправлять только в том случае, если он изменился с дата и время последнего получения клиентом:  

```
Accept-Language: fr, de
If-Modified-Since: Fri, 10 Dec 2004 11:22:13 GMT

```

Пустая строка (то есть только CRLF) помещается в сообщение запроса после серии заголовков HTTP, чтобы разделить заголовки от тело сообщения.

**Тело сообщения**

Содержимое тела любого HTTP-сообщения может называться телом сообщения или телом объекта . Технически, тело сущности — это фактическое содержимое сообщения. Тело сообщения содержит тело объекта, которое может находиться в исходном состоянии или может быть закодировано в какой-либо способ транспортировки например, путем разбиения на фрагменты (фрагментированное кодирование передачи). Тело сообщения запроса может для удобства называться запросом. тело.

Тела сообщений подходят для некоторых методов запроса и не подходят для других. Например, запрос с методом POST, который отправляет ввод данные на сервер, имеет тело сообщения, содержащее данные. Запрос с метод GET, который запрашивает у сервера отправку ресурса, не имеет тело сообщения.

# SMTP

**Что такое почтовый сервер и как он работает**

Почтовый сервер (сервер электронной почты) — это агент, который отвечает за прием и передачу сообщений в системе пересылки электронной почты. Чтобы лучше понять роль почтового сервера в этой системе, рассмотрим, как она устроена. Система пересылки построена на взаимодействии нескольких сущностей — веб-интерфейса (или почтового клиента) отправителя и сервера отправителя, а также веб-интерфейса (или почтового клиента) получателя и сервера получателя. Веб-интерфейс — это графический интерфейс электронного ящика. С его помощью отправитель формирует письмо, пишет текст, прикрепляет файлы и указывает адрес, а получатель просматривает содержимое письма и может определить адресата. Веб-интерфейс работает через браузер и требует подключения к сети. Примеры веб-интерфейсов: Mail.ru, Gmail, Яндекс.Почта. Почтовый клиент — это программа, с помощью которой можно контролировать несколько электронных ящиков и работать с ними из одного места. Для работы почтовый клиент не требует подключения к интернету. Примеры клиентов: Thunderbird, Mailbird Lite, Microsoft Outlook,TouchMail. То есть почтовый клиент и веб-интерфейс – это разные способы попасть в тот или иной электронный почтовый ящик.

За любым почтовым ящиком закреплены определенные почтовые серверы. Например, за почтовыми ящиками Mail.ru закреплены серверы компании Mail.ru Group, а за почтовыми ящиками Gmail – серверы компании Google.

Рассмотрим работу системы пересылки на примере. Допустим, ваш электронный адрес — test-site@mail.ru. Чтобы отправить сообщение, вы заходите в веб-интерфейс Mail.ru, пишете текст, указываете адрес и нажимаете «Отправить». После этого письмо попадает на один из серверов Mail.ru Group. Сначала сервер проверит письм на спам. Затем он определит, какой из серверов соответствует адресу получателя и передаст ему письмо. Допустим, адрес получателя — test@gmail.ru. Значит письмо попадёт на один из серверов Google. Google-сервер также сначала проверит содержание сообщения, а затем отправит на Gmail. Только после этого получатель сможет посмотреть письмо.

![[Pasted image 20240627023423.png]]

Если адресат test@gmail.ru захочет ответить на письмо отправителя test-site@mail.ru, произойдёт то же самое, только в обратном порядке. При этом в пересылке письма могут участвовать уже совершенно другие сервер-отправитель и сервер-получатель. Поскольку между почтовым адресом и сервером нет конкретной привязки, клиент может выбрать любой из серверов системы, который соответствует критерию «входящий» или «исходящий».


**Чем отличаются входящий и исходящий серверы**

Любой сервер можно настроить по-разному. Выбор настроек будет зависеть от количества используемых машин, общей нагрузки и конкретных целей. Варианты настроек:

- только на прием сообщений,

- только на отправление сообщений,

- на прием и отправление сообщений одновременно.

Как узнать, сервер входящей или исходящей почты используется? На это укажет тип протокола. В системе пересылки электронных сообщений серверы взаимодействуют между собой с помощью протоколов передачи данных. Сервер входящих сообщений работает благодаря протоколам POP3 и IMAP, а сервер исходящих благодаря протоколу SMTP. По типу протокола можно определить, какие настройки выставлены для машины.

SMTP ( англ. Simple Mail Transfer Protocol — простой протокол передачи почты) — это широко используемый сетевой протокол, предназначенный для передачи электронной почты в сетях TCP/IP.

сетевой протокол SMTP отвечает за отправление писем. Серверы, которые работают с помощью этого протокола, называются серверами исходящей почты. Их задачи:

Простыми словами, простой протокол связи (SMTP), применяется с целью пересылки электронных писем с сервера отправителя на сервер получателя. Этот протокол не рассчитан на обработку входящих сообщений, ег используют для отправки и последующей доставки писем адресату. Преимущественно с помощью SMTP отправляют массовые и транзакционные рассылки.

Иногда протокол SMTP путают с IMAP или POP. Но между ними есть существенная разница. SMTP применяют для пересылки писем, тогда как POP или IMAP используют для обработки этих писем после получения.

![[Pasted image 20240627023722.png]]

SMTP-сервер — сервер, который работает по протоколу SMTP. Его главная задача — выступать ретранслятором (передатчиком) между серверами отправителя и адресата. Каждый SMTP-сервер обладает собственным адресом в формате smtp.serveraddress.com. Это позволяет безошибочно определять нужный сервер при пересылке почты.

Чтобы передать сообщение, SMTP-серверу сначала нужно установить контакт с сервером получателя (входящим сервером). Для этого серверы обмениваются командами через TCP-соединение. Такой обмен называют SMTP-сессией. Каждая сессия может состоять из одной или нескольких команд. Основные команды сессии:

- MAIL FROM — команда, которая помогает узнать обратный адрес. Сервер использует его в тех случаях, когда письма приходится возвращать обратно.
    
- RCPT TO — позволяет определить получателя сообщения. Если получателей несколько, SMTP отправляет команду несколько раз.
    
- DATA — команда, которая отвечает непосредственно за передачу письма. Она запускает двухэтапное взаимодействие. На первом этапе входящий сервер сообщает о готовности принять сообщение. На втором этапе исходящий сервер отсылает само сообщение — заголовок и содержание письма (текст и файлы).
    
Для работы SMTP использует три типа портов: 25 и 587 — для соединения без шифрования и 465 порт SSL SMTP (или SMTPS) — в случае защищенного шифрованного соединения.

![[Pasted image 20240627023759.png]]

Электронное письмо состоит из трёх частей:

- Конверт
    
- заголовки
    
- тело письма
    

Команды протокола SMTP находятся только в конверте, именно конверт используется при передачах почты между серверами и почтовыми клиентами. И данные в конверте определяет, как почта будет передаваться.

Начнём с отправки. Как только ты дописал своё письмо и нажал на кнопку “Отправить”, твой почтовый клиент (Outlook, Thunderbird, Gmail или Yandex Mail) отправит его на сервер по протоколу SMTP - Simple Mail Transfer Protocol, что переводится как простой протокол передачи почты. И тут начинаются первые проблемы. Дело в том, что этот протокол действительно “простой”. Он увидел свет аж в 1982 году, а как ты помнишь, тогда на безопасность было вообще пофиг, поэтому все письма отправлялись в открытом виде, пользователи никак не аутентифицировались, а хакеры успешно применяли его для рассылки спама.

Поэтому, в 2008 году ему решили добавить фич в виде поддержки шифрования, авторизации, 8-битных наборов символов и ещё много всего полезного и назвали это все ESMTP, где Е означает extended, то есть расширенный. Но даже после этого протокол называют просто - SMTP.

Короче, SMTP работает по клиент серверной модели. Он передает на почтовый сервер команды и получает от него ответы с результатами их обработки.

Ответы от сервера - это кодовые значения, которые делятся на 5 типов. Те у которых код 200, означают что всё ок, а те что с кодом 500 - не ок.

Ничего не напоминает? Да, очень похоже на HTTP. При стандартной отправке письма происходит следующее:

1. Твой клиент подключается к серверу

2. Сервер выдаёт ему список доступных команд

3. Твой клиент отправляет команды, которые содержат адрес отправителя, получателя и собственно само сообщение

4. Сервер помещает твоё сообщение в очередь на отправку и если всё ок - отправляет его.

В случае если ты сын маминой подруги и позаботился о безопасности, клиент также пройдёт процедуру аутентификации и шифрования, прежде чем отправить письмо.  Кстати, ты можешь указать в адресе отправителя что угодно и тебе за это ничего не будет. Дело в том, что в SMTP нет встроенных проверок подлинности отправителя, для этого используются внешние механизмы. Самый простой - это сопоставление домена и IP-адреса отправителя через DNS-запрос. Так что если ты решишь прикинуться Илоном Маском и написать кому нибудь письмо с просьбой отсыпать немножко биткоинов, то скорее всего оно попадёт в спам.

SMTP используется не только для отправки писем от клиента к серверу, но и для передачи твоего письма между почтовыми серверами.

Допустим, если ты напишешь Илону, то сначала твоё письмо попадёт на твой локальный сервер, который скорее всего не находится в домене spacex.com, поэтому твой сервер будет по тому же DNS искать в Интернетах почтовый сервер, отвечающий за маршрутизацию электронной почты домена Space X. Это кстати называется MX-запись. Когда эта информация будет найдена, то сервер пульнёт туда твоё письмо по протоколу SMTP.

Для работы SMTP был зарезервирован TCP порт 25, но есть ещё 2 порта - это 465 и 587, оба они предназначены для связи клиента с сервером по защищенным механизмам, а 25 предназначался только для связи между собой почтовых серверов.

Отлично, теперь твоё письмо, пройдя все системы антиспама и проверки лежит на почтовом сервере получателя и дожидается когда же его прочитают, а мы переходим ко второму действию - получение.

**Команды SMTP**


Оттуда SMTP-клиент использует команды, чтобы сообщить серверу, что делать, и передать данные, такие как адрес электронной почты отправителя, адрес электронной почты получателя и содержимое электронной почты. Агент передачи почты или агент передачи сообщений (MTA) проверяет, принадлежат ли оба адреса электронной почты одному домену электронной почты, например gmail.com:

- Если они есть, он сразу же отправляет электронное письмо
    
- Если нет, сервер использует систему доменных имен (DNS) для идентификации домена получателя, а затем отправляет его на нужный сервер.
    
Команды SMTP состоят из четырёх символов, никакой особой причины для этого нет, просто разработчики протокола выбрали такую длину команд.

Основные SMTP-команды

  

Как мы упоминали ранее, SMTP-команды представляют собой набор кодов, которые обеспечивают передачу сообщений электронной почты между серверами. Вот основные команды SMTP, о которых вы должны знать:

- HELO или EHLO (Hello): Команда HELO с одной L, так как длина команды SMTP четыре символа. это важная команда для начала всего процесса отправки электронной почты. Почтовый клиент идентифицирует себя на SMTP-сервере. Это начало диалога, и обычно сервер отправляет команду HELO вместе со своим доменны именем/IP-адресом. Например: HELO example.com. Простыми словами, этот команда используется для установки соединения.
    

- MAIL FROM: После команды идентификации отправитель поделится кодом, указывающим, от кого отправлено письмо. Это обрисовывает в общих чертах адрес электронной почты и сообщает SMTP-серверу, что новая транзакция вот-вот начнется. Отсюда сервер сбрасывает все и готов принять адрес электронной почты. После принятия он ответит кодом ответа 250 OK. Протсыми словами, это поле указывает на адрес отправителя. Например: MAIL FROM: sender@example.com

- RCPT TO (получатель): следующая команда следует за кодом ответа 250 OK, определяющим, кому отправляется электронное письмо. Опять же, SMTP-сервер отвечает тем же кодом, после чего можно отправить другую команду RCPT TO с другим адресом электронной почты получателя. Это может повторяться столько раз, сколько потребуется, в зависимости от того, сколько людей получит электронное письмо. Простыми словами, это поле используется для указание адрес получателя. Например: RCPT: recipient@example.com
    
- DATA: Это запускает передачу данных между клиентом и сервером. Все содержимое сообщения будет перемещено на SMTP-сервер, который ответит кодом ответа 345. Содержимое сообщений передается на сервер, где одна точка отправляется в строке сама по себе, чтобы сигнализировать об окончании сообщения.
    

Если он принят и готов к доставке, сервер отправляет еще один код 250 OK. В этот момент сообщение находится на пути к получателям. Простыми словами, это команда используется, чтобы сообщить принимающему серверу что, конверт закончился, дальше идёт письмо.

- QUIT: когда электронное письмо отправлено, клиент отправляет команду ВЫЙТИ на сервер, разрывая соединение. Если он был успешно закрыт, сервер ответит кодом 221. Простыми словами, это команда служить для разрыва соединие с сервером после того как передача письма завершился.
    
- RSET (Reset): эта команда отправляется на сервер, когда почтовая транзакция должна быть прервана. Он н закрывает соединение, но сбрасывает все и удаляет все предыдущие данные об электронной почте и вовлеченных сторонах. Вы обычно будете использовать это, когда произошла ошибка, например, ввод неправильной информации о получателе, и процесс необходимо перезапустить.
    

Представьте эти команды как язык, который позволяет почтовым серверам общаться друг с другом. Их чат будет выглядеть примерно так:

![[Pasted image 20240627024347.png]]

Существуют и другие команды SMTP, которые выполняют аутентификацию и повышают безопасность, например AUTH и STARTTLS. Если вам интересно узнать о них или увидеть примеры работы SMTP, прочтите это руководство по командам SMTP.

Ответы SMTP

![[Pasted image 20240627024409.png]]

Так же как и протокол HTTP, SMTP используют ответы состоящие из двух частей:

1. код сообщения которое говорит о том что произошло
    
2. некоторые текстовые сообщения поясняют что именно произошло и больше предназначены для людей чем для серверов.
    

Коды сообщений которые начинаются на двойку говорят о том что предыдущая команда выполнена успешно. Код сообщения которые начинаются на тройку говорит о том что текущее состояние успешное, но для продолжения работы требуются дополнительные данные например ответ с кодом 354 выдается после того как клиент вел команду Digital сервер приглашает клиентов вводить письмо и закончить письмо строчкой где находится одна точка сообщения которые начинаются на 5 говорят о том что произошла какая-то ошибка например код сообщения 502 означает использование нереализованные команды, а 503 неправильную последовательность команд, так как текст сообщений которые должны быть в ответе не входит в стандарт, а для автоматической обработки используются только коды то некоторые реализации сервер.

Заголовки письма

![[Pasted image 20240627024438.png]]

Заголовки письма. Формально они не являются частью стандарта SMTP и теперь наверняка большинство этих заголовков вам уже знакомо. Заголовок **FROM** используется для указания отправителя. Причем в отличие от команды **MAIL FROM** протокола SMTP.В заголовке письма **FROM** можно указывать не только почтовый адрес, но и имя отправителя. Заголовок TO используется для указания получателя **CC** получателя копии письма. **BCC** указывает такого получателя кому нужно отправить копию, но при этом скрыть от других получателей, что копия письма была ему отправлена. Заголовок **Reply-To** используется для того чтобы указать адрес на который нужно отвечать. Этот адрес может отличаться от того адреса который указан в заголовке **FROM**. **Subject** используется для указания темы письма, а **DATE** указания даты отправки письма.

Пример сеанса SMTP

Рассмотрим пример сеанса SMTP которые используются для отправки письма.

![[Pasted image 20240627024503.png]]

Подключаемся к почтовым сервер по адресу smtp.example.ru на 25-й порт выдаем команду в которой указывае свой домен в примере asozykin.ru сервер отвечает сообщением со статусом 250. Это означает что соединение установлено и в тестовом сообщении сервер еще раз пишет свое доменное имя выдаем команду MAIL FROM для указания адреса отправителя - andrey@asozykin.ru сервер снова отвечает сообщением со статусом 250 текстовую часть сообщения OK. Команда выполнена успешно. Затем задаем адрес получателя письма с помощью команд RCPT TO: reciever@example.com. Сервер снова отвечает сообщением 250 ок. И мы выдаем команду DATA для ввода письма. Ответ сервера 354 приглашение вводить текст письма которое должно закончиться отдельной строкой содержащей одну точку.

![[Pasted image 20240627024518.png]]

Само письмо состоит из двух частей заголовок и тело сообщения, тело сообщение должно быть отделено от заголовка пустой строкой. Здесь мы используем заголовок FROM - адрес отправителя. Причем указываем не только почтовый адрес, но и имя. И заголовок, который используется для указания темы. Пример SMTP пустая строк отделяет заголовки от тела сообщения. Тело состоит из двух строк Hello, email world! и Hello SMTP!. Завершается письмо строкой в которой находится одна точка эта строка не является частью письма и будет удалена при передаче если вам по какой-то причине нужна в письме строка в которой находится всего лишь одна точка. Вы должны указать две точки одна из этих точек будет удалена при передаче. После того как введена точка сервер понимает что письмо закончено и выдает сообщение со статусом 250OK.

![[Pasted image 20240627024532.png]]

# IMAP или POP3

Протокол SMTP используется при передаче электронной почты. Возможны два варианта использования протокола

SMTP:

1. При передаче почты от агента пользователя почтовом серверу
    
2. При передаче писем между почтовым и серверами.

Для чтения почты используются не протокол SMTP , a другие протоколы - POP3 и IMAP в стеке протоколов TCP/IP протокол SMTP находится на прикладном уровне. Теоретически может работать с любыми протоколами транспортного уровня TCP, UDP или даже какой нибудь другой протокол.

**Почтовый протокол POP3 (Post Office Protocol, version 3)**

POP3 (англ. Post Office Protocol Version 3 — протокол почтового отделения, версия 3) — стандартный интернет-протокол прикладного уровня, используемый клиентами электронной почты для получения почты с удалённого сервера по TCP-соединению. Простыми словами, POP3 — протокол для приема сообщений электронной почты. При просмотре почты с использованием протокола POP3 все электронные письма скачиваются пользователю на компьютер и автоматически удаляются с сервера (хотя это можно отключить). Все дальнейшие действия с письмами будут производиться именно на компьютере пользователя. Протокол POP3 может быть удобен, если почтовым ящиком пользуется лишь один человек с одного-единственного компьютера, а доступ в интернет ограничен или непостоянен. Используя протокол POP3, Вы имеете возможность загружать письма на жесткий диск компьютера и работать с ними уже там. Некоторые провайдеры предоставляют доступ к почте только на основании протокола POP3, игнорируя IMAP соединения.

**Чем хорош POP3 — преимущества**

- Так как сообщения хранятся на компьютере, то и письма постоянно под рукой, даже когда Вы не имеете доступа в интернет.
    
- Открывать вложения в подавляющей части почтовых клиентов стало гораздо легче потому, что вложения загружаются одновременно с сообщением.
    
- Поскольку сообщения загружаются на жесткий диск компьютера, то дисковое пространство почтового ящика ограничивается только размерами самого жесткого диска.
    

**Недостатки POP3**

- Присутствуют повышенные риски, что вредоносный javascript, вирусы и прочие зловредные программы заразят компьютер из-за того, что сообщения сохраняются на жесткий диск.
    
- Если Ваш компьютер располагает только одной копией электронной корреспонденции, а Вы не выполняет резервирование данных должным образом, то Вы рискуете потерять информацию в результате сбоя в работе жесткого диска. В этом плане серверы отличаются более надежными бэкапами.
    
- Почтовые клиенты, использующие POP3, разрешается настраивать таким образом, чтобы сообщения хранились на сервере, но по мере роста содержимого в Вашем электронном ящике, почтовому приложению понадобится много времени для проверки новой почты (сначала почтовому клиенту требуется проверить, что он уже загрузил с сервера, а затем загружать новые сообщения).
    
- Протокол POP3 остается по прежнему востребованным протоколом для электронной почты из-за легкости использования базовой конфигурации и надежности. Чем сложнее протокол или приложение, тем вероятне возникновение трудноразрешимых ситуаций, требующих вмешательства технической поддержки.

**Почтовый протокол IMAP (Internet Message Access Protocol)**

В вычислительной технике протокол доступа к сообщениям в Интернете ( IMAP ) представляет собой стандартный интернет- протокол, используемый почтовыми клиентами для получения электронной почты с почтового сервера через соединение TCP/IP . IMAP был разработан с целью обеспечения полного управления ящиком электронной почты несколькими почтовыми клиентами, поэтому клиенты обычно оставляют сообщения на сервере до тех пор, пока пользователь явно не удалит их. Сервер IMAP обычно прослушивает порт с номером 143. IMAP через SSL/TLS ( IMAPS ) назначается номер порта 993.

При использовании протокола IMAP электронные письма всегда находятся на сервере и синхронизируются с локальными клиентами. Это очень удобно, когда необходим доступ к почтовому ящику с нескольких устройств (компьютер, ноутбук, телефон, планшет), или когда доступ должны иметь несколько человек — все операции с письмами, которые произведены на одном устройстве (пометка письма как прочтенное, перемещение писем между папками, удаление и т. п.) отобразятся на остальных. Если вы планируете наряду с почтовым клиентом использовать и веб-интерфейс, почтовый клиент надо также настраивать через IMAP.

Недостатком IMAP можно назвать чуть большее количество потребляемого интернет-трафика.

Доступ по протоколам POP3 и IMAP предоставляется только при подключении услуги «Почтовый сервис» в разделе «Почта / Услуги». Эта услуга позволит только принимать входящую почту, а отправлять письма через веб-интерфейс или сторонний SMTP-сервер.

**Причины выбать IMAP — преимущества**

- Вся почта хранится на сервере.
    
- Каждый раз устанавливая новый почтовый клиент, сообщения неизменно приходят по адресу и их не требуется перемещать.
    
- Вы в состоянии переключаться между email клиентом и службой электронной почты (webmail), а почта продолжит приходить на оба почтовых канала.
    
- В случае, если компьютер ломается и Вы теряете данные, хранящиеся на жестком диске, Ваши электронные письма никуда не исчезнут, поскольку они размещаются на сервере.
    
- Протокол упрощает доступ к электронной почте со смартфона, потому что сообщения с сервера не удаляются.

**Недостатки IMAP**

- Ваша почта размещается исключительно на сервере, поэтому в случае отсутствия Интернет соединения, у Вас не получится загрузить уже полученные сообщения. Некоторые почтовые клиенты располагают дополнительными параметрами, разрешающими данную проблему (почта будет получена, как только появится доступ к интернету).
    
- В случае серьезной поломки серверного оборудования, Вы рискуете потерять часть электронной почты (но Вы также рискуете попасть в подобную ситуацию, когда используете POP3 для загрузки сообщений на собственный компьютер).
    
- Используя IMAP вместо POP3 в почтовой программе Вы увидите, что почтовые каталоги отображаются по другому. Это объясняется тем, что каталоги размещаются не на компьютере, а на сервере.

Большинство современных webmail интерфейсов используют IMAP для отображения email аккаунтов.

# ARP


ARP (англ. Address Resolution Protocol — протокол определения адреса) — протокол в компьютерных сетях, предназначенный для определения MAC-адреса другого компьютера по известному IP-адресу. ARP - это очень простой протокол, используемый для решения проблемы межуровневого обнаружения, не полагаясь на сервер любого типа. Рисунок ниже будет использован для объяснения работы ARP.

В сети мы обычно взаимодействуем с компьютерами с помощью IP адресов или с помощью доменных имен которые службой DNS которые все равно преобразуется в IP адреса. Но в реальности данные передаются с помощью какой-либо технологии канального уровня. Например, eternet. Коммутатор ethernet ничего не знают об ip адресах и для передачи данных используют mac адреса. Следовательно, нам необходимо какое-то средство которое позволяет по IP адресу компьютера определить его MAC-адрес.

Самое простое средство это таблица соответствия. Мы создаем какую то табличку в котором пишем IP адрес и соответствующий ему MAC-адрес. И такое средство действительно используется на практике. Например, в Linux такая табличка хранится файле /etc/ethers. Однако в крупной сети такой подход не работает.

![[Pasted image 20240627024858.png]]

Протокол ARP который мы изучаем как раз и позволяет автоматически определить MAC-адрес компьютера по его IP-адресу. Протокол работает в режиме запрос-ответ.

![[Pasted image 20240627024941.png]]

Компьютер, который хочет узнать МАК-адрес по известному IP-адресу, направляет ARP запрос “У кого IP 192.168.10.43?” Запрос отправляется на широковещательный МАК-адрес (FF:FF:FF:FF:FF:FF).

![[Pasted image 20240627024955.png]]

Запрос отправляется на широковещательный MAС адрес и этот запрос получают все компьютеры в сети.

![[Pasted image 20240627025025.png]]

Как мы и сказали, этот запрос получают все компьютеры в сети. Тот компьютер, который узнал в запросе свой IP-адрес подготавливает и отправляет ARP ответ. В ответ включается IP-адрес компьютера (IP:192.168.10.43) и его МАК-адрес (MAC: 54:BE:F7:88:15:47).

Отправитель ARP запроса получает ответ, извлекает из него МАК-адрес и использует его для передачи данных по технологии канального уровня.

Формат ARP-запроса

Сейчас мы рассмотрим формат ARP пакета. ARP разрабатывался как протокол общего назначения с возможностью применять его не только в ethernet и не только для IP адресов. Поэтому в начале ARP пакета идет служебная информация которая позволяет определить с каким типом сетевого оборудования и с каким протоколом сетевого уровня мы работаем.

![[Pasted image 20240627025053.png]]

- Первое поле “тип сети”, говорит о том, какое оборудование мы используем в сети, 1 — соответствует Ethernet. 

- Второе поле “тип протокола” в нем указывается протокол сетевого уровня 2048 означает IP.

- Дальше идет “длина локального адреса”, в нашем случае МАК-адреса 6 байт, “длина глобального адреса в нашем случае IP-адреса” 4 байта.

- Следующее поле код операции, 1 — соответствует ARP запросу, а 2 — ARP ответу.

- Затем идет полезная информация о локальных (1С:75:08:D2:49:45) и глобальных адресах (192.168.10.15). Указывается МАК-адрес и IP-адрес отправителя, для того, чтобы получатель знал, кому отправлять ответ.

- Глобальный адрес получателя (192.168.10.43).

- Локальный адрес получателя неизвестен (00:00:00:00:00:00)

**Формат ARP-ответа**

Формат ARP ответа точно такой же, только в поле “операция” стоит значение 2 и адрес, который мы ищем находится в поле локальный адрес отправителя.

![[Pasted image 20240627025227.png]]

**Место в модели OSI**
  
В модели взаимодействия открытых систем OSI протокол ARP находится между канальным и сетевым уровнем. Пакеты ARP вкладываются напрямую в кадры Ethernet без IP.

![[Pasted image 20240627025302.png]]

Из-за того, что ARP находится ниже сетевого уровня, пакеты ARP не проходят через маршрутизаторы. Таким образом, с помощью ARP можно узнать только МАК-адреса компьютеров, которые находятся в одной подсети, а адреса компьютеров, которые находятся в другой подсети отделенные маршрутизатором узнать нельзя.

![[Pasted image 20240627025315.png]]

  

Почему так происходит? ARP запрос отправляется на широковещательный адрес который получают все компьютеры внутри сети, но широковещательный трафик не проходит через маршрутизаторы, поэтому компьютеры в другой подсети за маршрутизатором ARP запрос не получат и не смогут отправить на него ответ.

![[Pasted image 20240627025328.png]]

**ARP-таблица**

После того, как МАК-адрес получателя найден, он кэшируется на компьютеры отправителя в ARP-таблице для того, чтобы не запрашивать МАК-адрес каждый раз по протоколу ARP.

![[Pasted image 20240627025347.png]]

Таблица состоит из 3-х полей — IP -адрес, MAC-адрес и Тип записи в ARP таблице. Есть статическая запись, которая внесена в таблицу вручную и динамическая запись, которая появилась в результате работы протокола ARP. Динамические записи имеют срок жизни после которого они удаляются, это нужно для того, чтобы отслеживать изменения IP-адресов в компьютерах.

**Оптимизация ARP**

ARP запрос отправляется на широковещательный адрес и его получают все компьютеры в сети, кроме ip-адреса для которого необходимо получить мак-адрес в ARP запрос. Отправитель также включает свой ip-адрес и свой мак-адрес, эти данные могут быть записаны всеми компьютерами в сети в ARP-таблицу, чтобы использовать когда они понадобятся.

**Добровольный ARP-запрос (Gratuitous ARP)**

Это запрос по ARP собственного ip-адреса, он используется для двух целей. Первая цель, быстрое оповещение всех компьютеров в сети от том, что у компьютера появился новый ip-адрес.

Другая цель это проверка использования данного ip-адреса другим компьютером. Если на добровольный ARP запрос пришел ответ, это значит, что какой-то компьютер в сети уже использует этот ip-адрес и назначать его компьютеру отправителя нельзя.
Посмотреть ARP таблицу на компьютере можно с помощью команды arp -a.

![[Pasted image 20240627025420.png]]

Предположим, A хочет отправить пакет C. Зная IPv4-адрес C, 203.0.113.12 недостаточно, чтобы A правильно сформировал пакет и поместил его на канал связи по направлению к C. Чтобы правильно построить пакет, A также должен знать:

- Находится ли C на том же канале связи, что и A
- MAC или физический адрес C

Без этих двух частей информации A не знает, как инкапсулировать пакет в канал связи, поэтому C фактически получит пакет, а B проигнорирует его. Как можно найти эту информацию? На первый вопрос, находится ли C на том же канале вязи, что и A, можно ответить, рассмотрев IP-адрес локального интерфейса, IP-адрес назначения и маску подсети.

ARP решает вторую проблему, сопоставляя IP-адрес [назначения с MAC-адресом назначения](https://wiki.merionet.ru/seti/28/chto-takoe-mac-adres-i-kak-ego-uznat/), с помощью следующего процесса:

- Хост A отправляет широковещательный пакет каждому устройству в сети, содержащему адрес IPv4, но не MAC-адрес. Это запрос ARP; это запрос A на MAC-адрес, соответствующий 203.0.113.12.

- B и D получают этот пакет, но не отвечают, поскольку ни один из их локальных интерфейсов не имеет адреса 203.0.113.12.

- Хост C получает этот пакет и отвечает на запрос, снова используя unicast пакет. Этот ответ ARP содержит как IPv4-адрес, так и соответствующий MAC-адрес, предоставляя A информацию, необходимую для создания пакетов в направлении C.

Когда A получает этот ответ, он вставляет сопоставление между 203.0.113.12 и MAC-адресом, содержащимся в ответе, в локальном кэше ARP. Эта информация будет храниться до истечения времени ожидания; правила тайм-аута записи кэша ARP различаются в зависимости от реализации и часто могут быть настроены вручную. Продолжительность кэширования записи ARP - это баланс между слишком частым повторением одной и той же информации в сети в случае, когда сопоставление IPv4-адресов с MAC-адресами не меняется очень часто, и отслеживанием любых изменений в расположении устройство в случае, когда конкретный адрес IPv4 может перемещаться между хостами.

Когда A получает этот ответ, он вставляет сопоставление между 203.0.113.12 и MAC-адресом, содержащимся в ответе, в локальный кэш ARP. Эта информация будет храниться до тех пор, пока не истечет время ожидания; правила для тайм-аута записи кэша ARP варьируются в зависимости от реализации и часто могут быть настроены вручную. Продолжительность кэширования записи ARP - это баланс между тем, чтобы не повторять одну и ту же информацию слишком часто в сети, в случае, когда сопоставление IPv4-MAC-адресов меняется не очень часто, и идти в ногу с любыми изменениями в местоположении устройства, в случае, когда конкретный IPv4-адрес может перемещаться между хостами.

Любое устройство, получающее ответ ARP, может принять пакет и кэшировать содержащуюся в нем информацию. Например, B, получив ответ ARP от C, может вставить сопоставление между 203.0.113.12 и MAC-адресом C в свой кэш ARP. Фактически, это свойство ARP часто используется для ускорения обнаружения устройств, когда они подключены к сети. В спецификации ARP нет ничего, что требовало бы от хоста ожидания запроса ARP для отправки ответа ARP. Когда устройство подключается к сети, оно может просто отправить ответ ARP с правильной информацией о сопоставлении, чтобы ускорить процесс начального подключения к другим узлам на том же проводе; это называется gratuitous ARP. Gratuitous ARP также полезны для Duplicate.

Пример 2

Компьютер А (IP -адрес 10.0.0.1) и компьютер Б (IP-адрес 10.22.22.2) соединены сетью [Ethernet](https://ru.wikipedia.org/wiki/Ethernet). Компьютер А желает переслать пакет данных на компьютер Б, IP-адрес компьютера Б ему известен. Однако сеть Ethernet, которой они соединены, не работает с IP-адресами. Поэтому компьютеру А для осуществления передачи через Ethernet требуется узнать адрес компьютера Б в сети Ethernet (MAC-адрес в терминах Ethernet). Для этой задачи и используется протокол ARP. По этому протоколу компьютер А отправляет широковещательный запрос, адресованный всем компьютерам в одном с ним широковещательном домене. Суть запроса: «компьютер с IP-адресом 10.22.22.2, сообщите свой MAC-адрес компьютеру с МАС-адресом (напр. a0:ea:d1:11:f1:01)». Сеть Ethernet доставляет этот запрос всем устройствам в том же сегменте Ethernet, в том числе и компьютеру Б. Компьютер Б отвечает компьютеру А на запрос и сообщает свой MAC-адрес (напр. 00:ea:d1:11:f1:11) Теперь, получив MAC-адрес компьютера Б, компьютер А может передавать ему любые данные через сеть Ethernet.

Существуют следующие типы сообщений ARP: запрос ARP (ARP request) и ответ ARP (ARP reply). Система-отправитель при помощи запроса ARP запрашивает аппаратный адрес системы-получателя, который приходит внутри ответа ARP.

Перед тем, как передать пакет сетевого уровня через сегмент Ethernet, сетевой стек проверяет кэш ARP, чтобы выяснить, не зарегистрирована ли уже в его таблице нужная информация об узле-получателе. Если такой записи в кэше ARP нет, то выполняется широковещательный запрос ARP. Этот запрос для устройств в сети имеет следующий смысл: «Кто-нибудь знает физический адрес устройства, обладающего таким-то адресом IP?» Когда хост с этим адресом IP примет такой пакет запроса, он должен ответить: «Да, это мой адрес IP и мой аппартный адрес такой-то». После этого отправитель запроса сохранит аппаратный адрес получателя в свой кэш ARP и сможет адресно передать информацию получателю.


**Выводы по протоколу ARP**

ARP — протокол разрешения адресов, который позволяет по IP-адресу определить MAC-адрес компьютера в сети. ARP работает в режиме запрос-ответ. Запрос отправляется на широковещательный адрес и его получают все компьютеры в сети, а отвечает только тот компьютер, который узнал свой ip-адрес и в ответ он вкладывает искомый мак-адрес. Результаты ARP запросов для повышения производительности записываются в ARP-таблицу.


# Модель OSI

Модель Open Systems Interconnection (OSI) – это скелет, фундамент и база всех сетевых сущностей.Модель OSI полностью описывает как работает сетевые устройства и она совершенно необходима для понимания того как работают компьютерные сети. Говоря простыми словами, модель OSI - это процесс передачи данных которое разделили на семь частей, каждый из которых отличает за выполнение определённой функции.
  
Модель определяет сетевые протоколы, распределяя их на 7 логических уровней. Важно отметить, что в любом процессе, управление сетевой передачей переходит от уровня к уровню, последовательно подключая протоколы на каждом из уровней. Сетевая модель OSI имеет семь уровней, иерархически расположенных от большего к меньшему. То есть, самым верхним является седьмой (прикладной), а самым нижним — первый (физический).

Модель OSI разрабатывалась еще в 1970-х годах, чтобы описать архитектуру и принципы работы сетей передачи данных. Важно помнить, что данные передаются не только по сети интернет, но и в локальных сетях с помощью проводных или беспроводных соединений.

В процессе передачи данных всегда участвуют устройство-отправитель, устройство-получатель, а также сами данные, которые должны быть переданы и получены. С точки зрения рядового пользователя задача элементарна — нужно взять и отправить эти данные. Все, что происходит при отправке и приеме данных, детально описывает семиуровневая модель OSI.

![[Pasted image 20240627030102.png]]

**Первый, физический уровень (physical layer, L1)**

На первом уровне модели OSI происходит передача физических сигналов (токов, света, радио) от источника к получателю. На этом уровне мы оперируем кабелями, контактами в разъемах, кодированием единиц и нулей, модуляцией и так далее.

Среди технологий, которые живут на первом уровне, можно выделить самый основной стандарт - Ethernet. Он есть сейчас в каждом доме.

Отметим, что в качестве носителя данных могут выступать не только электрические токи. Радиочастоты, световые или инфракрасные волны используются также повсеместно в современных сетях.

Сетевые устройства, которые относят к первому уровню это концентраторы и репитеры – то есть «глупые» железки, которые могут просто работать с физическим сигналом, не вникая в его логику (не декодируя).

  

**Вывод:**

Первый уровень (физический) отвечает за обмен физическими сигналами между физическими устройствами, «железом». Компьютерное железо не понимает, что такое картинка или что на ней изображено, железу картинка понятна только в виде набора нулей и единиц, то есть бит. В данном случае бит является блоком данных протокола, сокращенно PDU (Protocol Data Unit).

Каждый уровень имеет свои PDU, представляемые в той форме, которая будет понятна на данном уровне и, возможно, на следующем до преобразования. Работа с чистыми данными происходит только на уровнях с пятого по седьмой.

Устройства физического уровня оперируют битами. Они передаются по проводам (например, через оптоволокно) или без проводов (например, через Bluetooth или IRDA, Wi-Fi, GSM, 4G и так далее).

**Второй уровень, канальный (data link layer, L2)**

Представьте, мы получили физический сигнал с первого уровня – физического. Это набор напряжений разной амплитуды, волн или радиочастот. При получении, на втором уровне проверяются и исправляются ошибки передачи. На втором уровне мы оперируем понятием «фрейм», или как еще говорят «кадр». Тут появляются первые идентификаторы – MAC – адреса. Они состоят из 48 бит и выглядят примерно так: 00:16:52:00:1f:03.

Канальный уровень сложный. Поэтому, его условно говоря делят на два подуровня: управление логическим каналом (LLC, Logical Link Control) и управление доступом к среде (MAC, Media Access Control).

На этом уровне обитают такие устройства как коммутаторы и мосты. Кстати! Стандарт Ethernet тоже тут. Он уютно расположился на первом и втором (1 и 2) уровнях модели OSI.

**Вывод:**

Когда два пользователя находятся в одной сети, состоящей только из двух устройств — это идеальный случай. Но что если этих устройств больше?

Второй уровень решает проблему адресации при передаче информации. Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). Задача здесь — сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.

У канального уровня есть два подуровня — это MAC и LLC. MAC (Media Access Control, контроль доступа к среде) отвечает за присвоение физических MAC-адресов, а LLC (Logical Link Control, контроль логической связи) занимается проверкой и исправлением данных, управляет их передачей.

На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса.

**Третий уровень, сетевой (network layer, L3)**

Идем вверх! Сетевой уровень вводит термин «маршрутизация» и, соответственно, IP – адрес. Кстати, для преобразования IP – адресов в MAC – адреса и обратно используется протокол ARP.

Именно на этом уровне происходит маршрутизация трафика, как таковая. Если мы хотим попасть на сайт wiki.merionet.ru, то мы отправляем [DNS – запрос](https://wiki.merionet.ru/servernye-resheniya/3/chto-takoe-dns/), получаем ответ в виде IP – адреса и подставляем его в пакет. Да–да, если на втором уровне мы используем термин фрейм/кадр, как мы говорили ранее, то здесь мы используем пакет.

Из устройств здесь живет его величество маршрутизатор :)


**Вывод:**


На третьем уровне появляется новое понятие — маршрутизация. Для этой задачи были созданы устройства третьего уровня — маршрутизаторы (их еще называют роутерами). Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.

На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот, тем самым обеспечивается инкапсуляция и декапсуляция данных.

**Четвертый уровень, транспортный (transport layer, L4)**

Транспортный уровень, как можно понять из названия, обеспечивает передачу данных по сети. Здесь две основных рок – звезды – TCP и UDP. Разница в том, что различный транспорт применяется для разной категории трафика. Принцип такой:

- Трафик чувствителен к потерям - нет проблем, TCP (Transmission Control Protocol)! Он обеспечивает контроль за передачей данных;
    
- Немного потеряем – не страшно - по факту, сейчас, когда вы читаете эту статью, пару пакетов могло и потеряться. Но это не чувствуется для вас, как для пользователя. UDP (User Datagram Protocol) вам подойдет. А если бы это была телефония? Потеря пакетов там критична, так как голос в реальном времени начнет попросту «квакать»;


**Вывод:**

Все семь уровней модели OSI можно условно разделить на две группы:

Четвертый уровень — это посредник между Host Layers и Media Layers, относящийся скорее к первым, чем к последним, его главной задачей является транспортировка пакетов. Естественно, при транспортировке возможны потери, но некоторые типы данных более чувствительны к потерям, чем другие. Например, если в тексте потеряются гласные, то будет сложно понять смысл, а если из видеопотока пропадет пара кадров, то это практически никак не скажется на конечном пользователе. Поэтому, при передаче данных, наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации.

Для мультимедийных файлов небольшие потери не так важны, гораздо критичнее будет задержка. Для передачи таких данных, наиболее чувствительных к задержкам, используется протокол UDP, позволяющий организовать связь без установки соединения.

При передаче по протоколу TCP, данные делятся на сегменты. Сегмент — это часть пакета. Когда приходит пакет данных, который превышает пропускную способность сети, пакет делится на сегменты допустимого размера. Сегментация пакетов также требуется в ненадежных сетях, когда существует большая вероятность того, что большой пакет будет потерян или отправлен не тому адресату. При передаче данных по протоколу UDP, пакеты данных делятся уже на датаграммы. Датаграмма (datagram) — это тоже часть пакета, но ее нельзя путать с сегментом.

Главное отличие датаграмм в автономности. Каждая датаграмма содержит все необходимые заголовки, чтобы дойти до конечного адресата, поэтому они не зависят от сети, могут доставляться разными маршрутами и в разном порядке. Датаграмма и сегмент — это два PDU транспортного уровня модели OSI. При потере датаграмм или сегментов получаются «битые» куски данных, которые не получится корректно обработать.


Первые четыре уровня — специализация сетевых инженеров, но с последними тремя они не так часто сталкиваются, потому что пятым, шестым и седьмым занимаются разработчики.

**Пятый уровень, сеансовый (session layer, L5)**

Попросите любого сетевого инженера объяснить вам сеансовый уровень. Ему будет трудно это сделать, инфа 100%. Дело в том, что в повседневной работе, сетевой инженер взаимодействует с первыми четырьмя уровнями – физическим, канальным, сетевым и транспортным. Остальные, или так называемые «верхние» уровни относятся больше к работе разработчиков софта :) Но мы попробуем!

Сеансовый уровень занимается тем, что управляет соединениями, или попросту говоря, сессиями. Он их разрывает. Помните мем про «НЕ БЫЛО НИ ЕДИНОГО РАЗРЫВА»? Мы помним. Так вот, это пятый уровень постарался :)


**Вывод:**


Пятый уровень оперирует чистыми данными; помимо пятого, чистые данные используются также на шестом и седьмом уровне. Сеансовый уровень отвечает за поддержку сеанса или сессии связи. Пятый уровень оказывает услугу следующему: управляет взаимодействием между приложениями, открывает возможности синхронизации задач, завершения сеанса, обмена информации.

Службы сеансового уровня зачастую применяются в средах приложений, требующих удаленного вызова процедур, т.е. чтобы запрашивать выполнение действий на удаленных компьютерах или независимых системах на одном устройстве (при наличии нескольких ОС).  

Примером работы пятого уровня может служить видеозвонок по сети. Во время видеосвязи необходимо, чтобы два потока данных (аудио и видео) шли синхронно. Когда к разговору двоих человек прибавится третий — получится уже конференция. Задача пятого уровня — сделать так, чтобы собеседники могли понять, кто сейчас говорит.

**Шестой уровень, представления данных (presentation layer, L6)**

На шестом уровне творится преобразование форматов сообщений, такое как кодирование или сжатие. Тут живут JPEG и GIF, например. Так же уровень ответственен за передачу потока на четвертый (транспортный уровень).
  

**Вывод**:

О задачах уровня представления вновь говорит его название. Шестой уровень занимается тем, что представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне.
  
Шестой уровень также занимается представлением картинок (в JPEG, GIF и т.д.), а также видео-аудио (в MPEG, QuickTime). Помимо перечисленного, шестой уровень занимается шифрованием данных, когда при передаче их необходимо защитить.

**Седьмой уровень, прикладной (application layer)**

На седьмом этаже, на самой верхушке айсберга, обитает уровень приложений! Тут находятся сетевые службы, которые позволяют нам, как конечным пользователям, серфить просторы интернета. Гляньте, по какому протоколу у вас открыта наша база знаний? Правильно, HTTPS. Этот парень с седьмого этажа. Еще тут живут простой HTTP, FTP и SMTP.

  

**Вывод**:

Седьмой уровень иногда еще называют уровень приложений, но чтобы не запутаться можно использовать оригинальное название — application layer. Прикладной уровень — это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму.

Все услуги, получаемые седьмым уровнем от других, используются для доставки данных до пользователя. Протоколам седьмого уровня не требуется обеспечивать маршрутизацию или гарантировать доставку данных, когда об этом уже позаботились предыдущие шесть. Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.

Протоколы здесь используют UDP (например, DHCP, FTP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS). Прикладной уровень является самым верхним по иерархии, но при этом его легче всего объяснить.

Процесс, когда информация отправляется и переходит из данных в биты, называется инкапсуляцией. Обратный процесс, когда информация, полученная в битах на первом уровне, переходит в данные на седьмом, называется декапсуляцией. 2- Процесс, когда данные передаются с верхних уровней на нижние называется инкапсуляцией данных, а когда наоборот, наверх, с первого, физического к седьмому, то этот процесс называется декапсуляцией данных. На каждом из семи уровней информация представляется в виде блоков данных протокола — PDU (Protocol Data Unit).

Рассмотрим на примере: пользователь 1 отправляет картинку, которая обрабатывается на седьмом уровне в виде данных, данные должны пройти все уровни до самого нижнего (первого), где будут представлены как биты. Этот процесс называется инкапсуляцией. Компьютер пользователя 2 принимает биты, которые должны снова стать данными. Этот обратный процесс называется декапсуляция. Что происходит с информацией на каждом из семи уровней, как и где биты переходят в данные мы разберем в этой статье.

**Инкапсуляция данных**

Инкапсуляция данных - это процесс, в котором некоторая дополнительная информация добавляется к элементу данных, чтобы добавить к нему некоторые функции. В нашей сети мы используем модель OSI или TCP/IP, и в этих моделях передача данных происходит через различные уровни. Инкапсуляция данных добавляет к данным информацию протокола, чтобы передача данных могла происходить надлежащим образом. Эта информация может быть добавлена в заголовок (header) или в конец (footer или trailer) данных.

  

Данные инкапсулируются на стороне отправителя, начиная с уровня приложения и заканчивая физическим уровнем. Каждый уровень берет инкапсулированные данные из предыдущего слоя и добавляет некоторую дополнительную информацию для их инкапсуляции и некоторые другие функции с данными. Эти функции могут включать в себя последовательность данных, контроль и обнаружение ошибок, управление потоком, контроль перегрузки, информацию о маршрутизации и так далее.

**Деинкапсуляция данных**

  

Деинкапсуляция данных - это процесс, обратный инкапсуляции данных. Инкапсулированная информация удаляется из полученных данных для получения исходных данных. Этот процесс происходит на стороне получателя. Данные деинкапсулируются на том же уровне на стороне получателя, что и инкапсулированный уровень на стороне отправителя. Добавленная информация заголовка и футера удаляется из данных в этом процессе.

На рисунке показано, как футер и хедер добавляются и удаляются из данных в процессе инкапсуляции и деинкапсуляции соответственно.

![[Pasted image 20240627030538.png]]

Данные инкапсулируются на каждом уровне на стороне отправителя, а также деинкапсулируются на том же уровне на стороне получателя модели OSI или TCP/IP.

![[Pasted image 20240627030554.png]]

**Процесс инкапсуляции (на стороне отправителя)**

Шаг 1. Уровень приложения, представления и сеанса в модели OSI принимает пользовательские данные в виде потоков данных, инкапсулирует их и пересылает данные на транспортный уровень. Тут не обязательно добавится к данным какой-либо хедер или футер - это зависит от приложения.

Шаг 2. Транспортный уровень берет поток данных с верхних уровней и разделяет его на несколько частей. Транспортный уровень инкапсулирует данные, добавляя соответствующий заголовок к каждой части. Эти фрагменты данных теперь называются сегментами данных. Заголовок содержит информацию о последовательности, так что сегменты данных могут быть повторно собраны на стороне получателя.

Шаг 3. Сетевой уровень берет сегменты данных с транспортного уровня и инкапсулирует их, добавляя дополнительный заголовок к сегменту данных. Этот заголовок данных содержит всю информацию о маршрутизации для правильной доставки данных. Здесь инкапсулированные данные называются пакетом данных или дейтаграммой.

Шаг 4: Канальный уровень берет пакет данных или дейтаграмму с сетевого уровня и инкапсулирует ее, добавляя дополнительный заголовок и нижний футер. Заголовок содержит всю информацию о коммутации для правильной доставки данных соответствующим аппаратным компонентам, а футер содержит всю информацию, связанную с обнаружением ошибок и контролем. Здесь инкапсулированные данные называются фреймом данных.

Шаг 5: Физический уровень берет кадры данных с уровня канала передачи данных и инкапсулирует их, преобразовывая их в соответствующие сигналы данных или биты, соответствующие физической среде.


  
**Процесс деинкапсуляции (на стороне получателя)**

Шаг 1: Физический уровень принимает инкапсулированные сигналы данных или биты от отправителя и деинкапсулирует их в форме кадра данных, который будет перенаправлен на верхний уровень, то есть на канальный уровень.

Шаг 2: Канальный уровень берет кадры данных с физического уровня. Он деинкапсулирует фреймы данных и проверяет заголовок фрейма, скоммутирован ли фрейм данных на правильное оборудование или нет. Если кадр пришел в неправильное место назначения, он отбрасывается, иначе он проверяет информацию в футере. Если есть какая-либо ошибка в данных, запрашивается повторная передача данных, если нет, то они деинкапсулируются, и пакет данных пересылается на верхний уровень.

Шаг 3. Сетевой уровень принимает пакет данных или дейтаграмму из канального уровня. Он деинкапсулирует пакеты данных и проверяет заголовок пакета, направлен ли пакет в правильное место назначения или нет. Если пакет направляется в неправильный пункт назначения, пакет отбрасывается, если все ок, то он деинкапсулируется, и сегмент данных пересылается на верхний уровень.

Шаг 4: Транспортный уровень берет сегменты данных с сетевого уровня и деинкапсулирует их. Сначала он проверяет заголовок сегмента, а затем повторно собирает сегменты данных для формирования потоков данных, а затем эти потоки данных пересылаются на верхние уровни.

Шаг 5: Уровень приложения, представления и сеанса в модели OSI берет инкапсулированные данные с транспортного уровня, деинкапсулирует их, и данные, относящиеся к конкретному приложению, пересылаются в приложения.

![[Pasted image 20240627030647.png]]

![[Pasted image 20240627030702.png]]

работа инкапсуляции:

- Дополнительная информация не будет добавлена в​ пользовательские данные на прикладном уровне в модели TCP/IP или на прикладном, презентационном, сеансовом уровнях в модели OSI.
      
- Затем сеансовый уровень отправляет данные на транспортный уровень.
    
- На транспортном уровне данные разбиваются на разные части. Он добавляет заголовок к каждому из поврежденных данных, который содержит такую информацию,​ как исходный порт, порт назначения, порядковый номер и т. д. Теперь все объединено в новую форму.
      
- Инкапсулированные данные на транспортном уровне называются сегментами или дейтаграммами. Если передача использует TCP, то она называется сегментами, а UDP называется дейтаграммой.
# Фрагментация и Сборка IP пакетов в Компьютерных Сетях

Напомню, что протокол IP работает на [сетевом уровне модель взаимодействия открытых систем](https://zvondozvon.ru/tehnologii/setevoi-osi), и одна из задач этого уровня объединения сетей построенных на основе разных технологий.

Одно из возможных различий в сетях, это максимальный размер передаваемых данных или Maximum Tranmission Unit, MTU. Для Ethernet это 1 500 байт, для Token Ring 4 464 байта, для FDDI 4 352 байта, а также раньше встречались сети и с другим размером в MTU. Что делать, если на маршрутизатор пришел пакет, размер которого больше, чем может передать сеть?

  
В этом случае используется фрагментация, разделение пакета на отдельные части, так называемые фрагменты, каждый из которых меньше чем MTU сети.

Формат заголовок IP-пакета 

В протоколе IP для реализации фрагментации используются три поля заголовка. Идентификатор пакета, флаги и смещение фрагмента.

![[Pasted image 20240627031015.png]]

**Пакет**

Идентификатор пакета задает номер пакета, который разбит на фрагменты, это поле должно быть одинаковое во всех фрагментах пакета.

**Флаги**

Размер поля 3 бита, но на практике используется только два. Флаг DF (Don’t Fragment) означает запрет фрагментирования. Флаг MF или (More Fragments), говорит о том что полученный фрагмент пакета не последний, будут еще пакеты.

**Смещение фрагмента**

  

Из [статьи про протокол](https://zvondozvon.ru/tehnologii/protokoli/ip) IP, мы помним, что сети IP не обеспечивают гарантию доставки и сохранения порядка следования сообщений, поэтому фрагменты пакета могут прийти в разном порядке. Например, сначала может прийти фрагмент, который вы отправили первым, затем третий фрагмент, и после этого второй.

- протоколе IP, для того чтобы определить в каком порядке собирать фрагменты в один большой пакет, используется поле смещение фрагмента. Причем в протоколе IP смещение измеряется не в байтах, а в 8-ми байтовых блоках.
    

Давайте рассмотрим пример, чтобы лучше понять.

- У нас есть большой пакет размером 4 тысячи байт, в этом пакете 20 байт, это заголовок IP, а полезных данных 3980 байт.
    
- Мы хотим передать полученные пакет по сети Ethernet, у который максимальный размер передаваемых данных 1 500 байт. Опять же с 1500 байт, 20 байт отдается под заголовок IP, и 1480 байт под полезные данные.
    
- Таким образом, исходные данные размером 3 980 байт, будут разделены на три фрагмента, от 0 до 4179 байт, от 1480 до 2959, от 2960 до 3890.
    
- Для того чтобы получить смещение каждого фрагмента, мы должны взять значение первого байта (это 0, 1480 и 2960), и разделить на 8, таким образом смещение получается 0 для первого фрагмента, 185 для второго фрагмента, и 370 для третьего фрагмента.
    

**Фрагментация**

Рассмотрим, как работает фрагментация на том же самом примере, большого пакета размером 4000 байт, который нужно передать через сеть Ethernet MTU 1500 байт.

![[Pasted image 20240627031058.png]]

Формируется первый фрагмент, здесь показаны поля IP заголовка, которые имеют отношение к фрагментации.

![[Pasted image 20240627031110.png]]

Маршрутизатор сгенерировал номер пакета 81, номер может быть любой, главное чтобы этот номер был одинаковым во всех фрагментов. Смещение фрагмента равно нулю это означает, что во фрагменте находится самое начало большого пакета. Устанавливается поле More Fragments, и затем записывается первая порция данных 1480 байт.

После этого формируется второй фрагмент с тем же самым номером пакета, значение смещения фрагмента равно 185, 1480 разделенное на 8, и поле More Fragments говорит о том, что будут ещё фрагменты

![[Pasted image 20240627031135.png]]

Формируется третий пакет с тем же самым номером пакетов 81, смещением 370 и так как это последний фрагмент, то поле More Fragments устанавливается в 0.

![[Pasted image 20240627031147.png]]

**Сборка пакета**

Сборка пакета происходит в обратном порядке, принимающий маршрутизатор должен определить, что он получил не полный пакет, а фрагмент. Для этого маршрутизатор используют либо поле More Fragments, если поле установлено в единицу, значит это фрагмент. Другим признакам фрагментации является ненулевое значение в поле смещения фрагмента, например, 185 или 370.

![[Pasted image 20240627031202.png]]

Когда маршрутизатор принимает фрагмент пакета, он сохраняют его в память, и затем сохраняет все фрагменты с тем же самым номером, в нашем случае 81. После того как пришел последний фрагмент, маршрутизатор может посчитать размер большого пакета 4000 байт, затем из отдельных фрагментов используя смещение собираются большой пакет.

![[Pasted image 20240627031218.png]]

**Флаг DF**

  

Флаг DF или Don’t Fragment заголовка IP используется для того чтобы запретить фрагментацию на маршрутизатор. Если этот флаг установлен, то маршрутизатор не имеет право фрагментировать пакет. Что же будет, если размер пакета больше, чем максимальный размер пакета, который может передать данная сеть. В этом случае маршрутизатор просто отбросит пакет и отправит получателю ICMP сообщений с типом 3, кодом 4, это означает что заданный узел недоступен, необходима фрагментация, но установлен флаг DF запрещающий эту фрагментацию.

**Заключение**

Фрагментация — это разбиение IP пакет на несколько частей, фрагментов для передачи по сети с маленьким MTU. Фрагментации используются для объединения сетей построенных на основе разных технологий, у которых отличается MTU.

В заголовке Ip пакета для фрагментации используются три поля: идентификатор пакета, флаги и смещение фрагмента. Следует отметить, что в следующей версии протокола ipv6 отказались от фрагментации на маршрутизаторах, в IPv6 узлы отправителей должны сами подобрать максимальный размер пакета с помощью технологии Path MTU Discovery.
