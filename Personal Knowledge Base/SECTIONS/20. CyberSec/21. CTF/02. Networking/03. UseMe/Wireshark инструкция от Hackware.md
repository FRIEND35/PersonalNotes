# Фильтры Wireshark для начинающих  

У [Wireshark](https://kali.tools/?p=1407) просто огромное количество разнообразных фильтров. И по этим фильтрам есть огромная документация, в которой не так просто разобраться. Я собрал самые интересные для меня и самые часто используемые фильтры Wireshark. Для начинающих пользователей это может стать чем-то вроде справочника по фильтрам Wireshark, отправной точкой для изучения. Также здесь в комментариях предлагаю вам делиться ходовыми фильтрами, которые вы часто используете, а также интересными находками — я добавлю их в этот список.

Помните, что в Wireshark есть фильтры отображения и фильтры захвата. Здесь я рассматриваю фильтры отображения, которые вводятся в главном окне программы в верхнем поле сразу под меню и иконками основных функций.

Чтобы в полной мере понимать значение фильтров и что именно он показывает, необходимо понимание работы сети. Для знакомства с принципами работы сети и протоколов, рекомендуется изучить цикл о работе компьютерных сетей, первая статья цикла «[Компьютерные сети: Часть 1. Как работают компьютерные сети](https://hackware.ru/?p=6290)» (остальные части в процессе подготовки).

Некоторые фильтры здесь написаны в общей форме, а некоторые выполнены в качестве конкретных примеров. Помните, что вы в любом случае можете подставить свои данные, например, изменить номер порта на любой вас интересующий, а также сделать то же самое с IP адресом, MAC-адресом, значением времени и пр.

Если вы только начинаете знакомиться с Wireshark, то обратитесь к статье «[Как использовать Wireshark для захвата, фильтрации и проверки пакетов](https://zawindows.ru/%d0%ba%d0%b0%d0%ba-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d1%8c-wireshark-%d0%b4%d0%bb%d1%8f-%d0%b7%d0%b0%d1%85%d0%b2%d0%b0%d1%82%d0%b0-%d1%84%d0%b8%d0%bb%d1%8c%d1%82/)».

## Операторы фильтров Wireshark  

Фильтры могут иметь различные значения, например, это может быть строка, шестнадцатеричный формат или число.

Если ищется неточное вхождение (лучше подходит для нечисловых значений) то используется **contains**. Например, чтобы показать TCP пакеты, содержащие строку hackware нужен следующий фильтр:

```
tcp contains hackware
```

Для поиска точных значений используются операторы. Рассмотрим их:

| Оператор | Описание         |
| -------- | ---------------- |
| ==/eq    | Равно            |
| !=/ne    | Не равно         |
| </lt     | Меньше чем       |
| <=/le    | Меньше или равно |
| >/gt     | Больше чем       |
| >=/ge    | Больше или равно |

Как можно видеть, имеется по два варианта написания, например, если мы хотим указать, что значение фильтра равно чему-либо, то мы можем использовать **==** или **eq**.

Из фильтров с применением логических операндов можно строить довольно сложные конструкции, но, видимо, если один и тот же фильтр использовать дважды с операторами сравнения, например, как здесь в попытке сделать фильтрацию не по одному порту, а по диапазону портов:

```
tcp.port>=8000 && tcp.port<=8180
```

то значение фильтра (в данном случае tcp.port) перезаписывается последним значением, поэтому в результате вместо ожидаемого поведения, мы получаем результат работы только последней части, в данном случае это

```
tcp.port<=8180
```

Помните об этом баге!
При использовании с == (равно) этот баг отсутствует.

## Логические операторы фильтров Wireshark  

Логические операторы позволяют создавать детальные фильтры с использованием сразу нескольких условий. Рекомендуется дополнительно использовать скобки, поскольку в противном случае вы можете получить не то значение, которое ожидаете.

|Оператор|Описание|
|---|---|
|and/&&|Логическое И, данные выводятся если они соответствуют обоим частям фильтра. Например, фильтр **ip.src==192.168.1.1 and tcp** покажет только пакеты, которые исходят от 192.168.1.1 и которые ассоциированы с протоколом TCP. Будут показаны только данные, совпадающие с обоими условиями.|
|or/\||Логическое ИЛИ, достаточно чтобы только одно условие было истинным; если оба являются истинной, то это тоже подходит. Например фильтр **tcp.port==80 or tcp.port==8080** покажет TCP пакеты, которые связаны (являются источником или пунктом назначения) с портом 80 или 8080.|
|not/!|Логическое НЕ используется, когда мы хотим исключить некоторые пакеты. То есть будут показаны все пакеты, кроме удовлетворяющие условию, следующему после НЕ. Например фильтр **!dns** покажет все пакеты, кроме DNS.|

Примеры комбинирования:

Показать HTTP **или** DNS трафик:

```
http or dns
```

Показать любой трафик, кроме ARP, ICMP и DNS:

```
!(arp or icmp or dns)
```

## Фильтр интерфейсов  

Показать пакеты только отправленные или полученные на интерфейсе wlan0:

```
frame.interface_name == "wlan0"
```

## Трафик протоколов канального уровня  

**Для показа ARP трафика:**

```
arp 
```

![[Pasted image 20240312231750.png]]

Показать фреймы ARP протокола, отправленные с устройства, имеющего MAC-адрес 00:c0:ca:96:cf:cb:

```
arp.src.hw_mac == 00:c0:ca:96:cf:cb
```

Показать фреймы ARP протокола, отправленные с устройства, имеющего IP адрес 192.168.50.90:

```
arp.src.proto_ipv4 == 192.168.50.90
```

Показать фреймы ARP протокола, отправленные на устройство, имеющего MAC-адрес 00:00:00:00:00:00 (этот адрес используется когда протокол пытается узнать целевой MAC-адрес. Ещё один популярный адрес, который может вас смутить, это ff:ff:ff:ff:ff:ff, этот адрес является широковещательным, то есть сообщения с этим адресом предназначены для всех устройств локальной сети):

```
arp.dst.hw_mac == 00:00:00:00:00:00
```

Показать фреймы ARP протокола, отправленные на устройство, имеющего IP адрес 192.168.50.1:

```
arp.dst.proto_ipv4 == 192.168.50.1
```

**Показать Ethernet трафик:**

```
eth
```

Показать фреймы (вообще все фреймы, а не только ARP, как это было в предыдущих примерах), отправленные с устройства, имеющего MAC-адрес 00:c0:ca:96:cf:cb:

```
eth.src == 00:c0:ca:96:cf:cb
```

Показать фреймы, отправленные на устройство, имеющего MAC-адрес 78:cd:8e:a6:73:be:

```
eth.dst == 78:cd:8e:a6:73:be
```

## Трафик протоколов межсетевого уровня  

#### Фильтрация IPv4 протокола

Показать IP трафик (сюда относятся TCP, UDP, а также протоколы уровня приложений DNS, HTTP — то есть практически всё, кроме протоколов канального уровня, которые не используют IP адреса для передачи данных (в локальных сетях Ethernet в качестве адресов доставки они используют MAC-адреса)):
#### IP

Если быть более точным, имеется ввиду трафик протокола IPv4, который обычно называют просто IP (Internet Protocol).

Показать трафик, связанный с определённым IP адресом (впишите его вместо x.x.x.x). Будут показаны пакеты, в которых этот IP адрес является источником данных ИЛИ получателем:

```
ip.addr == x.x.x.x
```

Показать трафик, связанный с данными двумя IP адресами. По единственно возможной логике, один из этих адресов будет источником, а второй — адресом доставки.

```
ip.addr == x.x.x.x && ip.addr == y.y.y.y
```

Показать трафик, источником которого является хост с IP адресом 138.201.81.199:

```
ip.src == 138.201.81.199
```

Показать трафик, адресатом которого является хост с IP адресом 138.201.81.199:

```
ip.dst == 138.201.81.199
```

Обратите внимание, IP протокол оперирует IP адресами, но не оперирует портами. Порты являются частью протоколов TCP и UDP. IP протокол отвечает только за маршрутизацию трафика между хостами.

#### Фильтрация подсетей и диапазонов IP в Wireshark

Вы можете вместо одного IP адреса указать подсеть:

```
ip.addr == 192.168.1.0/24
```

Фильтрация трафика, отправленного с определённого диапазона IP. Если нужно отфильтровать трафик, источником которого является подсеть, то используйте фильтр вида:

```
ip.src == 192.168.1.0/24
```

Фильтрация трафика, предназначенного для отправки на определённый диапазон IP. Если нужно отфильтровать трафик, пунктом назначения которого является подсеть, то используйте фильтр вида:

```
ip.dst == 192.168.1.0/24
```

#### Фильтрация IPv6 протокола

Показать трафик IPv6 (Internet Protocol шестой версии):


```
ipv6
```

Фильтрация по IPv6 адресу. Для фильтрации по IPv6 адресу используйте фильтр:

```
ipv6.addr == 2604:a880:800:c1::2ae:d001
```

#### Фильтрация подсетей и диапазонов IPv6 в Wireshark

Вы можете вместо одного IPv6 адреса указать подсеть для фильтрации:

```
ipv6.addr == 2604:a880:800:c1::2ae:d000/64
```

Если нужно отфильтровать трафик, источником которого является определённый IPv6 адрес:

```
ipv6.src == 2604:a880:800:c1::2ae:d001
```

Если нужно отфильтровать трафик, отправленный на определённый IPv6 адрес:

```
ipv6.dst == 2604:a880:800:c1::2ae:d001
```

Фильтрация трафика, отправленного с определённого диапазона IPv6. Если нужно отфильтровать трафик, источником которого является подсеть, то используйте фильтр вида:

```
ipv6.src == 2604:a880:800:c1::2ae:d000/64
```

Фильтрация трафика, предназначенного для отправки на определённый диапазон IPv6. Если нужно отфильтровать трафик, пунктом назначения которого является подсеть, то используйте фильтр вида:

```
ipv6.dst == 2604:a880:800:c1::2ae:d000/64
```

Фильтрация ICMPv6 (Internet Control Message Protocol — протокол межсетевых управляющих сообщений шестой версии) в Wireshark делается фильтром:

```
icmpv6
```

Как отфильтровать пакеты ARP протокола для IPv6 в Wireshark? Для IPv6 протокол ARP не требуется, поскольку его роль выполняет протокол обнаружения соседей (Neighbor Discovery Protocol, NDP) средствами ICPM6 — подробности объяснены в статье «IPv6 аналог для «arp -an» в IPv4».

Для того, чтобы увидеть пакеты, которые выполняют роль ARP для IPv6, используйте фильтр:

```
icmpv6.type == 133 or icmpv6.type == 134 or icmpv6.type == 135 or icmpv6.type == 136 or icmpv6.type == 137
```

Другие фильтры с IP адресом аналогичны для IPv6 и IPv4.

## Трафик протоколов транспортного уровня  

**Чтобы увидеть только трафик TCP:**

```
tcp
```

Показать трафик, источником или портом назначения которого является определённый порт, например 8080:

```
tcp.port==8080
```

Показать трафик, источником которого является порт 80:

```
tcp.srcport == 80
```

Показать трафик, который отправляется службе, прослушивающей порт 80:

```
tcp.dstport == 80
```

Показать TCP пакеты с включённым флагом SYN:

```
tcp.flags.syn==1
```

Показать TCP пакеты с включённым флагом SYN и отключённым флагом ACK:

```
tcp.flags.syn==1 && tcp.flags.ack==0
```

Аналогично и для других флагов:

SYN

```
tcp.flags.syn==1
```

ACK

```
tcp.flags.ack==1
```

RST

```
tcp.flags.reset==1
```

FIN

```
tcp.flags.fin==1
```

CWR

```
tcp.flags.cwr==1
```

ECE

```
tcp.flags.ecn==1
```

URG

```
tcp.flags.urg==1
```

PSH

```
tcp.flags.push==1
```

NS

```
tcp.flags.ns==1
```

Также можно использовать синтаксис вида tcp.flags == 0x0XX, например:

- FIN это **tcp.flags == 0x001**
- SYN это **tcp.flags == 0x002**
- RST это **tcp.flags == 0x004**
- ACK это **tcp.flags == 0x010**
- Установленные одновременно ACK и FIN это **tcp.flags == 0x011**
- Установленные одновременно ACK и SYN это **tcp.flags == 0x012**
- Установленные одновременно ACK и RST это **tcp.flags == 0x014**

Длина заголовка (смещение данных):

```
tcp.hdr_len == 32
tcp.hdr_len == 52
tcp.hdr_len > 32
```

Пакеты с установленными зарезервированными битами:

```
tcp.flags.res == 1
```

Размер окна:

```
tcp.window_size_value == 11
tcp.window_size_value == 4468
tcp.window_size_value > 65000
tcp.window_size_value < 100
```

Вычесленный размер окна:

```
tcp.window_size == 45056
tcp.window_size == 11
```

Фактор масштабирования размера окна:

```
tcp.window_size_scalefactor == 4096
```

tcp.window_size_value — это необработанное значение размера окна, считываемое непосредственно из заголовка TCP, тогда как tcp.window_size — это вычисленный размер окна, который основан на том, применимо ли масштабирование окна или нет. 

Если масштабирование окна не используется или коэффициент масштабирования равен 1 или неизвестно, применимо ли масштабирование окна или нет, потому что трёхэтапное рукопожатие TCP не было захвачено, тогда эти два значения будут одинаковыми. 

С помощью tcp.window_size_scalefactor вы можете определить, какое из этих условий применимо — если его значение равно -1, то оно неизвестно, если его значение равно -2, тогда масштабирование окна не используется, а все остальные значения представляют фактический размер фактора масштабирования окна.

Чтобы показать пакеты, содержащие какую либо строку, например, строку hackware:

```
tcp contains hackware
```

![[Pasted image 20240312232908.png]]

Следовать потоку TCP с номером X:

```
tcp.stream eq X
```

Фильтровать по номеру потока:

```
tcp.seq == x
```

Показать повторные отправки пакетов. Помогает прослеживать замедление производительности приложений и потери пакетов:

```
tcp.analysis.retransmission
```

Этот фильтр выведен проблемные пакеты (потерянные сегменты, повторную отправку и другие. Этот фильтр проходят пакеты TCP Keep-Alive, но они не являются показателем проблем.

```
tcp.analysis.flags
```

#### Фильтры для оценки качества сетевого подключения

Следующие характеристики относятся к TCP фреймам. Причём они не основываются на заголовках фрейма — рассматриваемые характеристики (пропуск данных, дубли) присвоены программой Wireshark исходя из анализа.

Фильтр выводит информацию о фреймах с флагом ACK, которые являются дублями. Большое количество таких фреймов может говорить о проблемах связи:

```
tcp.analysis.duplicate_ack_num == 1
```

Фильтр показа фреймов для которых не захвачен предыдущий сегмент:

```
tcp.analysis.ack_lost_segment
```

**Это нормально в начале захвата данных — поскольку информация перехватывается не с самого начала сессии.**

Для показа фреймов, которые являются ретрансмиссией (отправляются повторно):

```
tcp.analysis.retransmission
```

Вывод фреймов, которые получены не в правильном порядке:

```
tcp.analysis.out_of_order
```

Чтобы увидеть только трафик UDP:

```
udp
```

**Для UDP не используются флаги. Для этого протокола можно только указать порт.**

Показать трафик, источником которого является порт 53:

```
udp.srcport == 53
```

Показать трафик, который отправляется службе, прослушивающей порт 53:

```
udp.dstport == 53
```

UDP пакет, в котором встречается определённая строка, например, строка hackware:

```
udp contains hackware
```

Порт назначения ИЛИ исходный порт:

```
udp.port == 53
udp.port > 40000
udp.port < 30
```

Длина пакета:

```
udp.length == 60
udp.length > 50000
```

Время между пакетами (для выявления проблем сети):

```
udp.time_delta > 1.5
```

Номер потока (запрос-ответ):

```
udp.stream == 5
```

Пакеты трассировки:

```
udp.possible_traceroute
```

Чтобы увидеть только трафик ICMP:

```
icmp
```

Чтобы увидеть только трафик ICMP v6 (шестой версии):

```
icmpv6
```

Показать все ответы на пинг:

```
icmp.type==0
```

![[Pasted image 20240312233402.png]]

Показать все пинг запросы:

```
icmp.type==8
```

Показать все ошибки недоступности/запрета хостов и портов

```
icmp.type==3
```

Показать все попытки перенаправить маршрутизацию с использованием ICMP:

```
icmp.type==8
```

Другие типы ICMP, а также варианты CODE здесь: https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TCPOPTIONS

Пример использования значения CODE, следующий фильтр покажет сообщения о недоступности порта:

```
icmp.type==3 && icmp.code==3
```

## Трафик протоколов прикладного уровня  

Для протоколов приклодного уровня HTTP, DNS, SSH, FTP, SMTP, RDP, SNMP, RTSP, GQUIC, CDP, LLMNR, SSDP, VNC, RDP и пр. имеются фильтры, которые называются как и сами протоколы, но пишутся маленькими буквами.

**Например, чтобы увидеть HTTP трафик:**

```
http
```

Чтобы увидеть трафик нового протокола HTTP/2:

```
http2
```

Помните, что при принятии решения, к какому протоколу относятся передаваемые данные, программа исходит из номера используемого порта. Если используется нестандартный порт, то программа не сможет найти нужные данные. Например, если было выполнено подключение к SSH по порту 1234, то фильтр ssh не найдёт SSH трафик.

Фильтр, который показывает только данные, переданные методом POST:

```
http.request.method == "POST"
```

Фильтр, который показывает только данные, переданные методом GET:

```
http.request.method == "GET"
```

Поиск запросов к определённому сайту (хосту):

```
http.host == "<URL>"
```

Поиск запросов к определённому сайту по части имени:

```
http.host contains "здесь.частичное.имя"
```

Фильтр для вывода HTTP запросов, в которых передавались кукиз:

```
http.cookie
```

Запросы, в которых сервер установил кукиз в браузер пользователя.

```
http.set_cookie
```

Для поиска любых переданных изображений:

```
http.content_type contains "image"
```

Для поиска определённых видов изображений:

```
http.content_type contains "gif"
http.content_type contains "jpeg"
http.content_type contains "png"
```

Для поиска файлов определённого типа:

```
http.content_type contains "text"
http.content_type contains "xml"
http.content_type contains "html"
http.content_type contains "json"
http.content_type contains "javascript"
http.content_type contains "x-www-form-urlencode"
http.content_type contains "compressed"
http.content_type contains "application"
```

Поиск в Wireshark запросов на получения файлов определённого типа. Например, для поиска переданных ZIP архивов:

```
http.request.uri contains "zip"
```

Вместо http.request.uri для большей точности можно использовать фильтры http.request.uri.path или http.request.uri.query, например, для поиска запросов на скачивание файлов JPG (ссылки на картинки):

```
http.request.uri.path contains "jpg"
```

Также вы можете отфильтровать запросы, содержащие определённое значение HTTP заголовка REFERER (реферер). Например, для поиска запросов, в которых реферером является ru-board.com:

```
http.referer contains "ru-board.com"
```

Поиск запросов с любой авторизацией. Аналогично с помощью contains можно искать определённые виды авторизации:

```
http.authorization
```

Поиск файлов в HTTP потоке:

```
http.file_data
```

Чтобы увидеть, какие HTTP данные получены с задержкой, используется следующая конструкция:

```
http.time>1
```

Она покажет трафик, полученный позднее чем через 1 секунду.

Для исследования проблем, можно анализировать статус HTTP кодов ответа. Например, следующий фильтр покажет трафик, при котором получена ошибка 404 Not Found (страница не найдена):

```
http.response.code==404
```

Следующий фильтр очень интересный. Во-первых, он показывает какие сложные конструкции можно строить из отдельных фильтров. Во-вторых, он позволяет исследовать HTTP запросы и в целом веб активность, исключая лишние данные. С помощью этого фильтра вы можете просматривать веб-активность высокого уровня. Правила внутри скобок исключают изображения, файлы Javascript и таблицы стилей — всё, что страница запрашивает внутри себя. Если исследуемые страницы содержат другие встроенные объекты, то исключите их похожим образом:

```
http.request && !(http.request.uri contains ".ico" or http.request.uri contains ".css" or http.request.uri contains ".js" or http.request.uri contains ".gif" or http.request.uri contains ".jpg")
```

Фильтрация полей HTTP заголовков: некоторые из рассмотренных чуть выше фильтров уже относятся к фильтрам HTTP заголовков, рассмотрим ещё несколько примеров.

Помните, что можно использовать фильтр не указав искомое значение, например:

```
http.host
```

В этом случае будут показаны все соединения, имеющие любое значение поля Host в HTTP заголовке.

Можно указать точное значение:

```
http.host == "www.archlinux.org"
```

Или указать часть искомой строки:

```
http.host contains "archlinux.org"
```

Фильтр по полю Host в HTTP заголовке:

```
http.host == "www.archlinux.org"
```

Фильтр по полю Content-Type в HTTP заголовке:

```
http.content_type == "text/plain"
```

Фильтр по полю Server в HTTP заголовке:

```
http.server == "nginx"
```

Фильтры по полю Cookie в HTTP заголовке:

```
http.cookie
http.cookie_pair
```

Фильтр по полю User Agent в HTTP заголовке:

```
http.user_agent == "Mozilla/5.0 (X11; Linux x86_64; rv:82.0) Gecko/20100101 Firefox/82.0"
```

Фильтр по полю X-Powered-By в HTTP заголовке:

```
http.x_forwarded_for
```

Для поиска переадресаций (поле Location):

```
http.location
```

Для поиска сайтов, с которых сделан переход на страницу (поле Referer):

```
http.referer contains "hackware.ru"

```

Фильтра запросов:

```
http.request
http.request.uri
http.request.uri.path
http.request.uri.query.
http.request.uri.query.parameter
http.request.method
```

Фильтры ответов:

```
http.response
```

Поиск по коду ответа:

```
http.response.code == 404
http.response.code != 200
```

На самом деле, этот список далеко не полный. Вы можете использовать подсказки, которые появляются при вводе названия фильтров, либо ориентироваться на имена полей HTTP заголовков, которые похожи на имена фильтров.

Чтобы показать только трафик на основе TLS (зашифрованные данные):

```
tls
```

Рукопожатие протокола:

```
tls.handshake
```

Сертификаты:

```
tls.handshake.certificates
```

Поиск по содержимому сертификатов:

```
tls.handshake.certificate contains "*.hackware.ru"
```

Имеется много фильтров TLS, но нужно понимать, что мы не можем искать по содержимому передаваемых зашифрованных данных (по очевидным причинам — данные зашифрованы). Можно выполнять поиск по различным свойствам, а также по содержимому, передающемуся в незашифрованном виде, например, по сертификатам.

Чтобы увидеть все DNS запросы и ответы:

```
dns
```

Чтобы увидеть, какие DNS запросы заняли много времени:

```
dns.time>1
```

**Будут показаны ответы, пришедшие более чем через секунду после отправки запроса.**

Этот фильтр показывает, какие dns запросы не могут быть правильно разрешены:

```
dns.flags.rcode != 0
```

Показать только DNS запросы:

```
dns.flags.response == 0
```

Показать только DNS ответы:

```
dns.flags.response == 1
```

Показать запросы и ответы на них, в котором ищется IP для google.com:

```
dns.qry.name == "google.com"
```

Показать DNS запросы и ответы касаемые записи A:

```
dns.qry.type == 1
```

Показать DNS запросы и ответы касаемые записи AAAA:

```
dns.qry.type == 28
```

Показать ответы, в которых для записи A в качестве IP отправлен 216.58.196.3:

```
dns.a == 216.58.196.3
```

Показать ответы, в которых для записи AAAA в качестве IP отправлен 2a01:4f8:172:1d86::1:

```
dns.aaaa == 2a01:4f8:172:1d86::1
```

Показать записи с CNAME apollo.archlinux.org:

```
dns.cname == "apollo.archlinux.org"
```

Показать ответы длиной более 30:

```
dns.resp.len > 30
```

Показать запросы с длиной более 25:

```
dns.qry.name.len >25
```

Показать ответы DNS серверов на которых доступна рекурсия:

```
dns.flags.recavail == 1
```

Показать ответы DNS серверов на которых не доступна рекурсия:

```
dns.flags.recavail == 0
```

Желательна ли рекурсия (если запрошенный DNS сервер не имеет информацию об имени хоста, должен ли он опрашивать другие DNS сервера в поисках этой информации):

```
dns.flags.recdesired == 1
```

**Если в запросе стоит 1, значит рекурсия нужна, если 0 — значит она не желательна.**

Принимать ли неаутентифицированные данные (0 означает не принимать, 1 означает принимать):

```
dns.flags.checkdisable == 0
```

Чтобы увидеть, как назначаются IP адреса по протоколу DHCP:

```
udp.dstport==67
```

Или так:

```
bootp.option.dhcp
```

Чтобы показать DHCP запросы:

```
bootp.option.dhcp == 3
```

Чтобы показать DHCP Discover:

```
bootp.option.dhcp == 1
```

SMB фильтр. Этот фильтр в колонке Info показывает всё дерево (шару) соединений, открытых директорий и открытых файлов в трассировке.

```
smb2.cmd==3 or smb2.cmd==5
```

#### NetBIOS фильтры

Фильтр Wireshark для службы имён (NetBIOS-NS):

```
nbns
```

Фильтр Wireshark для службы рассылки дейтаграмм (NetBIOS-DGM):

```
nbdgm
```

Фильтр Wireshark для службы сеанса (NetBIOS-SSN):

```
nbss
VNC
```

Чтобы показать только трафик VNC сессий:

```
vnc
```

VNC challenge (вызов):

```
vnc.auth_challenge
```

VNC response (ответ):

```
vnc.auth_response
```

Результат попытки аутентификации на VNC сервере:

```
vnc.auth_result
```

Вызов, ответ и результат попытки аутентификации на VNC сервере:

```
vnc.auth_challenge or vnc.auth_response or vnc.auth_result
```

Имя компьютера с VNC сервером:

```
vnc.desktop_name
```

Позиция кнопок мыши:

```
vnc.button_1_pos
vnc.button_2_pos
…………...
vnc.button_8_pos
```

Выбранный тип безопасности:

```
vnc.client_security_type
```

Тип кодирования:

```
vnc.client_set_encodings_encoding_type
```

Версия VNC протокола клиента:

```
vnc.client_proto_ver
```

Версия VNC протокола сервера:

```
vnc.server_proto_ver
```

Ширина Framebuffer:

```
vnc.width
```

Клавиша:

```
vnc.key
```

Нажатие клавиши:

```
vnc.key_down
```

Данные передаваемого видео в формате H.264:

```
vnc.h264_data
```

Вырезанный текст:

```
vnc.client_cut_text
```

Другие фильтры VNC: https://www.wireshark.org/docs/dfref/v/vnc.html

#### Remote Desktop Protocol (RDP)

Чтобы показать только трафик RDP сессий:

```
rdp
```

Другие фильтры Remote Desktop Protocol (RDP): https://www.wireshark.org/docs/dfref/r/rdp.html

#### Фильтры Wireshark для HTTP Basic и Digest аутентификации

Wireshark может фильтровать сессии аутентификации. Для этого имеются следующие фильтры:

Все сессии аутентификации (BASIC/DIGEST/NTLM):


```
http.authorization
```

Только HTTP Basic аутентификация:

```
http.authbasic
```

Только HTTP Basic аутентификация с определёнными учётными данными:

```
http.authbasic == "ЛОГИН:ПАРОЛЬ"
```

#### Фильтры Wireshark для анализа трафика через веб прокси-сервер

Этот фильтр покажет запросы от прокси на HTTP Digest аутентификацию:

```
http.proxy_authenticate
```

Этот фильтр покажет учётные данные, отправляемые клиентом на прокси-сервер для авторизации:

```
http.proxy_authorization
```

Показ запросов, сделанных через прокси-сервер (HTTP метод CONNECT):

```
http.request.method == "CONNECT"
```

Поскольку для аутентификации пользователей веб-прокси используют HTTP Basic и Digest аутентификации, то можно использовать соответствующие фильтры Wireshark. Все сессии аутентификации (BASIC/DIGEST/NTLM):

```
http.authorization
```

Только HTTP Basic аутентификация:

```
http.authbasic
```

Только HTTP Basic аутентификация с определёнными учётными данными:

```
http.authbasic == "ЛОГИН:ПАРОЛЬ"
```

Запрос Digest аутентификации от прокси-сервера:

```
http.proxy_authenticate contains "Digest"
```

Ответ пользователя передаваемый на прокси-сервер с информацией для Digest авторизации:

```
http.proxy_authorization contains "Digest"
```

#### Фильтры для Wi-Fi фреймов

Показать элементы четырёхэтапных рукопожатий (то есть фреймы протокола EAPOL):

```
eapol
```

Показать фреймы Beacon (маяки):

```
wlan.fc.type_subtype == 0x08
```

Показать фреймы Probe Response:

```
wlan.fc.type_subtype == 0x05
```

Показать всё сразу: EAPOL, маяки, Probe Response:

```
wlan.fc.type_subtype == 0x08 || wlan.fc.type_subtype == 0x05 || eapol
```

Показать беспроводные фреймы для определённого устройства с MAC-адресом BSSID:

```
wlan.addr==BSSID
```

Показать EAPOL, маяки, Probe Response для определённого устройства с MAC-адресом 28:28:5D:6C:16:24:

```
(wlan.fc.type_subtype == 0x08 || wlan.fc.type_subtype == 0x05 || eapol) && wlan.addr==28:28:5D:6C:16:24
```

Показ всех PMKID:

```
eapol && wlan.rsn.ie.pmkid
```

Либо просто:

```
wlan.rsn.ie.pmkid
```

Показать PMKID с определённым значением:

```
wlan.rsn.ie.pmkid == 21:89:fa:52:75:df:e9:f5:56:f3:2e:e5:4b:86:b7:8f
```

Показать PMKID, маяки, Probe Response:

```
(wlan.fc.type_subtype == 0x08 || wlan.fc.type_subtype == 0x05 || (eapol && wlan.rsn.ie.pmkid))
```

Показать PMKID, маяки, Probe Response для точки доступа с MAC-адресом 40:3D:EC:C2:72:B8:

```
(wlan.fc.type_subtype == 0x08 || wlan.fc.type_subtype == 0x05 || (eapol && wlan.rsn.ie.pmkid)) && wlan.addr==40:3D:EC:C2:72:B8
```

Показать только первое сообщение рукопожатия:

```
wlan_rsna_eapol.keydes.msgnr == 1
```

Показать только второе сообщение рукопожатия (можно использовать для сообщения рукопожатия с любым номером):

```
wlan_rsna_eapol.keydes.msgnr == 2
```

Показать фреймы для точек доступа со скоростью (Data Rate) 1 Мb/s:

```
wlan_radio.data_rate == 1
```

Показать фреймы для точек доступа со скоростью более 10 Мb/s:

```
wlan_radio.data_rate > 10
```

Показать данные относящиеся к частотам диапазона 2 GHz:

```
radiotap.channel.flags.2ghz == 1
```

Показать данные относящиеся к частотам диапазона 5 GHz:

```
radiotap.channel.flags.5ghz == 1
```

Показать захваченные данные на определённом канале:

```
wlan_radio.channel == 44
```

Показывать точки доступа на определённой частоте:

```
radiotap.channel.freq == 2412
```

Показывать точки доступа с определённым уровнем сигнала:

```
wlan_radio.signal_dbm > -50
```

Фильтры, связанные с наличием у устройства антены:

```
radiotap.present.antenna == 1
```

и

```
radiotap.antenna == 1
```

Полный перечень фильтров заголовков IEEE 802.11 Radiotap Capture: https://www.wireshark.org/docs/dfref/r/radiotap.html


# Транспортные протоколы TCP и UDP

## Сходства и различия TCP и UDP  

В первой части «[Как работают компьютерные сети](https://hackware.ru/?p=6290)» мы узнали, что для передачи информации используются транспортные протоколы TCP и UDP. В физическом смысле эти протоколы представляют собой сетевые пакеты. Каждый сетевой пакет передаёт небольшой фрагмент информации, поэтому данные разбиваются на много пакетов.

Каждый сетевой пакет обоих протоколов TCP и UDP состоит из двух частей:

- заголовок
- непосредственно данные

В заголовке содержится «служебная информация» (можно сказать, что это метаданные) — порты пункта назначения и исходного узла, номер пакета в потоке, тип пакета и так далее.

Различие между протоколами TCP и UDP в том, что протокол TCP имеет механизм контроля полноты переданных данных — если какой-либо пакет был потерян или повреждён, то предусмотрен механизм для проверки этого факта и повторной отправки пакета. В протоколе UDP такого механизма нет — то есть если потерян пакет протокола UDP, то узел, который его отправил, никогда об этом не узнает, а принимающая сторона никогда не узнает, что ей был отправлен потерянный пакет UDP.

Может возникнуть вопрос, зачем вообще нужен такой ненадёжный протокол UDP, если есть надёжный протокол TCP? Платой за надёжность протокола TCP является то, что в бухгалтерии называется «накладные расходы» (overheads) — суть в том, что для обеспечения механизма контроля доставки пакетов в протоколе TCP отправляется много данных, которые не содержат полезной информации, а служат только для установки и контроля соединения. К примеру, чтобы отправить хотя бы одни пакет с полезными данными в TCP нужно завершить трёхступенчатое рукопожатие, которое заключается в отправке 1 особого пакета от источника к пункту назначения, получения 1 пакета о возможности установить соединения и отправки ещё 1 специального пакета от источника с подтверждением, что всё готово к отправке — за это время с помощью протокола UDP можно было бы отправить уже несколько пакетов с полезными данными.

По этой причине, оба протокола TCP и UDP являются «хорошими» - важно правильно их использовать. Например, при потоковом вещании видео неважно, какой пакет был потерян секунду или две назад. Но при открытии веб-страницы, когда из-за неполных данных могут возникнуть проблемы с обработкой запроса от HTTP протокола, напротив, нужно следить за доставкой и целостностью каждого пакета с данными.

Детальное понимание TCP и UDP имеет значение при:

- анализе сетевого трафика
- настройке сетевого файервола **iptables**
- понимания и защиты от DoS атак некоторого вида.

К примеру, понимая механизм TCP подключения, можно настроить файлервол (**iptables**) так, что будут запрещены все новые подключения с сохранением существующих, либо запретить любые входящие подключения с полным разрешением исходящих, понимать и предотвращать ряд DoS атак, понимать SYN и другие виды сканирований — почему они возможны и каков их механизм и т.д..

## Протокол TCP  

Transmission Control Protocol (TCP, протокол управления передачей) — один из основных протоколов передачи данных интернета, предназначен для управления передачей данных.

---

Из-за перегрузки сети, балансировки нагрузки трафика или непредсказуемого поведения сети, IP-пакеты могут быть потеряны, дублированы или доставлены не в неправильном порядке. TCP обнаруживает эти проблемы, запрашивает повторную передачу потерянных данных, переупорядочивает неупорядоченные данные и даже помогает минимизировать перегрузку сети, чтобы уменьшить возникновение других проблем. Если данные все ещё остаются недоставленными, источник уведомляется об этом сбое. После того, как получатель TCP собрал последовательность первоначально переданных октетов, он передаёт их принимающему приложению. Таким образом, TCP абстрагирует связь приложения от базовых сетевых деталей.

TCP широко используется во многих интернет-приложениях, включая World Wide Web (WWW), электронную почту, протокол передачи файлов, Secure Shell, одноранговый обмен файлами и потоковое мультимедиа.

Протокол TCP оптимизирован для точной доставки, а не для своевременной доставки, и может вызывать относительно длительные задержки (порядка секунд) при ожидании сообщений, вышедших из строя или повторных передач потерянных сообщений. Поэтому он не особенно подходит для приложений реального времени, таких как передача голоса по IP.

Итак, механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета, гарантируя тем самым, в отличие от UDP, целостность передаваемых данных и уведомление отправителя о результатах передачи.

Алгоритм работы TCP следующий:

1. Устанавливается трёхэтапное рукопожатие между двумя узлами. На этом этапе узлы согласуют два числа — начальные номера первого пакета для каждого из узлов.
2. При отправке пакетов узлы последовательно номеруют их, то есть каждому сетевому пакету присвоен один из последовательных номеров.
3. В дополнении к номеру, для каждого пакета рассчитывается контрольная сумма. Получив пакет, вновь рассчитывается контрольная сумма для полученных данных — если она не совпадает, значит пакет был повреждён при передаче.
4. Итак, поскольку все пакеты имеют последовательные номера, то становится видно если какие-то из них отсутствуют. В этом случае отправляется запрос на повторную отправку пакета.
5. Если для какого-то пакета не совпала контрольная сумма, то отправляется запрос на повторную отправку пакета.

В общем, используя два простых механизма — контрольную сумму и последовательную нумерацию каждого пакета — удаётся достичь надёжности передачи данных и возможности организовать их в правильную последовательность независимо от того, в каком порядке они доставлены.

Всё это возможно с помощью заголовков TCP пакета.

### Что такое 1 соединение TCP  

Прежде чем изучить структуру заголовка TCP пакета, разберёмся, что такое 1 TCP соединение — это поможет яснее понимать, что именно мы анализируем в [Wireshark](https://kali.tools/?p=1407) и сколько TCP соединений нам нужно искать. К примеру, сколько TCP соединений задействуется при открытии 1 страницы веб-сайта? Типичный веб-сайт состоит из 1 страницы HTML кода, нескольких страниц каскадных таблиц стилей CSS и JavaScript файлов, а также пары десятков файлов изображений. Так вот, для получения каждого из этих файлов создаётся новое TCP соединеие. Для каждого из этих соединений выполняется трёхэтапное рукопожатие — это к вопросу о том, какие издержки, «накладные расходы» несёт в себе TCP.

То есть при открытии страницы веб-сайта браузер делает первое TCP подключение и получает исходный код веб страницы. В данном коде браузер находит ссылки на файлы стилей, скриптов, картинок — для каждого из этого файлов запускается новое TCP соединение.

Поэтому при анализе трафика в **Wireshark** при открытии даже одной веб страницы вы увидите множество начатых и завершённых TCP соединений.

### Заголовок TCP

![[image_2024-03-13_00-34-33.png]]

- **Порт источника** — биты 0-15. Это порт источника пакета. Исходный порт изначально был связан напрямую с процессом в отправляющей системе. Сегодня мы используем хеш между IP-адресами и портами назначения и порта источника для достижения этой уникальности, которую мы можем привязать к одному приложению или программе.
- **Порт назначения** — биты 16-31. Это порт назначения пакета TCP. Как и в случае с портом-источником, он изначально был напрямую связан с процессом в принимающей системе. Сегодня вместо этого используется хеш, который позволяет нам иметь больше открытых соединений одновременно. Когда пакет получен, порты назначения и исходные порты возвращаются в ответе обратно к первоначально отправляющему хосту, так что порт назначения теперь является портом источника, а порт источника является портом назначения.

Порт источника и порт назначения не обязаны быть одинаковыми: к примеру, если делается запрос к 80-му порту сервера, то этот запрос может прийти, например, с порта 34054.

Номера портов на сервере могут использоваться как стандартные, так и произвольные.

- **Порядковый номер (Sequence number)** — биты 32-63. Поле порядкового номера используется для установки номера в каждом TCP-пакете, чтобы можно было правильно упорядочить поток TCP (например, пакеты приводятся к правильному порядку). Затем в поле ACK возвращается порядковый номер, чтобы подтвердить, что пакет был принят правильно.

Указывает на количество переданных байт, и каждый переданный байт полезных данных (payload) увеличивает это значение на 1.

Если установлен флаг SYN (идёт установление сессии), то поле содержит изначальный порядковый номер — ISN (Initial Sequence Number). В целях безопасности это значение генерируется случайным образом и может быть равно от 0 до 232-1 (4294967295). Первый байт полезных данных в устанавливающейся сессии будет иметь номер ISN+1.

В противном случае, если SYN не установлен, первый байт данных, передаваемый в данном пакете, имеет этот порядковый номер.

- **Номер подтверждения** (Acknowledgment Number (ACK SN)) — биты 64-95. Это поле используется, когда мы подтверждаем определённый пакет, полученный хостом. Например, мы получаем пакет с одним установленным порядковым номером, и если с пакетом все в порядке, мы отвечаем пакетом ACK с номером подтверждения, равным оригинальному порядковому номеру.

Если установлен флаг ACK, то это поле содержит порядковый номер октета, который отправитель данного сегмента желает получить. Это означает, что все предыдущие октеты (с номерами от ISN+1 до ACK-1 включительно) были успешно получены.

Каждая сторона подсчитывает свой Sequence number для переданных данных и отдельно Acknowledgement number для полученных данных. Соответственно Sequence number каждой из сторон соответствует Acknowledgement number другой стороны.

- **Длина заголовка** (смещение данных) — биты 96-99. В этом поле указывается длина заголовка TCP пакета и где начинаются фактические данные (полезная нагрузка). Поле имеет размер в 4 бита и указывает заголовок TCP в 32-битных словах. Заголовок должен всегда заканчиваться чётной 32-битной границей, даже с различными установленными опциями (опции могут отсутствовать вовсе, либо их количество может различаться). Это возможно благодаря полю **Padding** в самом конце заголовка TCP.

Минимальный размер заголовка составляет 5 слов, а максимальный — 15 слов, что даёт минимальный размер 20 байтов и максимум 60 байтов, что позволяет использовать до 40 байтов опций в заголовке. Это поле получило такое имя (смещение данных) из-за того, что оно также показывает расположение фактических данных от начала сегмента TCP.

Итак, длина заголовка определяет смещение полезных данных относительно начала сегмента. Например, Data offset равное 1111 говорит о том, что заголовок занимает пятнадцать 32-битных слова (15 строк*32 бита в каждой строке/8 бит = 60 байт).

- **Зарезервировано** — биты 100-102. Эти биты зарезервированы для будущего использования.
- **Флаги** (управляющие биты)
- **NS** — бит 103. ECN-nonce - concealment protection
- **CWR** (Congestion Window Reduced) — бит 104. Поле «Окно перегрузки уменьшено» — флаг установлен отправителем, чтобы указать, что получен пакет с установленным флагом ECE
- **ECE** — бит 105. ECE (ECN-Echo) — Поле «Эхо ECN» — указывает, что данный узел способен на ECN (явное уведомление перегрузки) и для указания отправителю о перегрузках в сети (RFC 3168)
- **URG** — бит 106. Поле «Указатель важности» задействовано. Если установлено значение 0, не используется Urgent Pointer, если установлено значение 1, то используется Urgent Pointer.
- **ACK** — бит 107. Этот бит устанавливается для пакета, чтобы указать, что это ответ на другой полученный нами пакет, содержащий данные. Пакет подтверждения всегда отправляется, чтобы указать, что мы фактически получили пакет, и что он не содержит ошибок. Если этот бит установлен, исходный отправитель данных проверит номер подтверждения, чтобы увидеть, какой пакет фактически подтверждён, а затем выгрузит его из буферов.
- **PSH** — бит 108. Флаг PUSH используется для указания протоколу TCP на любых промежуточных хостах отправлять данные фактическому пользователю, включая реализацию TCP на принимающем хосте. Это протолкнёт все данные, независимо от того, где и сколько из окна TCP было уже передано.
- **RST** — бит 109. Флаг RESET установлен, чтобы сообщить другому концу разорвать TCP-соединение. Это делается в нескольких различных сценариях, основными причинами которых является то, что соединение по какой-то причине разорвалось, если соединение не существует или если пакет каким-то образом неправильный.
- **SYN** — бит 110. SYN (или синхронизация номеров последовательности) используется во время первоначального установления соединения. Он устанавливается в двух экземплярах соединения: начальный пакет, который открывает соединение, и ответный пакет SYN/ACK. Он никогда не должен использоваться за пределами этих случаев.
- **FIN** — бит 111. Бит FIN указывает, что у хоста, который отправил бит FIN, больше нет данных для отправки. Когда другой конец увидит бит FIN, он ответит FIN/ACK. Как только это будет сделано, хост, который первоначально отправил бит FIN, больше не сможет отправлять какие-либо данные. Однако другой конец может продолжать отправлять данные до тех пор, пока они не будет завершаться, и затем отправит пакет FIN обратно и дождётся окончательного FIN/ACK, после чего соединение отправляется в состояние CLOSED.
- **Размер окна** (Window Size) — биты 112-127. Window Size определяет количество байт данных (payload), после передачи которых отправитель ожидает подтверждения от получателя, что данные получены. Иначе говоря, получатель пакета располагает для приёма данных буфером длиной "размер окна" байт.

По умолчанию размер окна измеряется в байтах, поэтому ограничен 216 (65535) байтами. Однако благодаря TCP опции **Window scale option** этот размер может быть увеличен до 1 Гбайта. Чтобы задействовать эту опцию, обе стороны должны согласовать это в своих SYN сегментах.

- **Контрольная сумма** — биты 128-143. Поле контрольной суммы — это 16-битное дополнение к сумме всех 16-битных слов заголовка (включая псевдозаголовок) и данных. Если сегмент, по которому вычисляется контрольная сумма, имеет длину не кратную 16-битам, то длина сегмента увеличивается до кратной 16-ти, за счёт дополнения к нему справа нулевых битов заполнения. Биты заполнения (0) не передаются в сообщении и служат только для расчёта контрольной суммы. При расчёте контрольной суммы значение самого поля контрольной суммы принимается равным 0.
- **Указатель важности** (Urgent pointer) — биты 144-159. 16-битовое значение положительного смещения от порядкового номера в данном сегменте. Это поле указывает порядковый номер октета, которым заканчиваются важные (urgent) данные. Поле принимается во внимание только для пакетов с установленным флагом URG. Используется для внеполосных данных.
- **Опции** — биты 160-**. Могут применяться в некоторых случаях для расширения протокола. Иногда используются для тестирования. На данный момент в опции практически всегда включают 2 байта NOP (в данном случае 0x01) и 10 байт, задающих timestamps. Вычислить длину поля опции можно через значение поля смещения.

Поле Options является полем переменной длины и содержит необязательные заголовки, которые мы можем захотеть использовать. По сути, это поле всегда содержит 3 подполя. В начальном поле указывается длина поля «Параметры», во втором поле указывается, какие параметры используются, а затем у нас есть фактические параметры. Полный список всех опций TCP можно найти в [опциях TCP](https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TCPOPTIONS).

- **Заполнение (Padding)** — биты**. Поле Заполнение дополняет заголовок TCP, пока весь заголовок не закончится на 32-разрядной границе. Это гарантирует, что часть данных пакета начинается с 32-разрядной границы, и данные в пакете не теряются. Заполнение всегда состоит только из нулей.

### Сессия TCP  

**Рукопожатие TCP (установление подключения TCP)**

Для установления соединения TCP использует трёхэтапное рукопожатие.

Подключение можно выполнить только если вторая сторона прослушивает порт, к которому будет выполняться подключение: к примеру, веб-сервер прослушивает порты 80 и 443. То есть это не охватывается рукопожатием, но прежде чем клиент попытается соединиться с сервером, сервер должен сначала подключиться к порту и начать прослушивать его, чтобы открыть его для соединений: это называется пассивным открытием. Как только пассивное открытие установлено, клиент может инициировать активное открытие. Для установления соединения происходит трёхэтапное (или трёхступенчатое) рукопожатие:

Первый этап, отправка пакета с включённым флагом **SYN**: активное открытие выполняется клиентом, отправляющим SYN на сервер. Клиент устанавливает порядковый номер сегмента на случайное значение A.

Обратите внимание, что по умолчанию **Wireshark** показывает относительное значение порядкового номера (Sequence number), чуть ниже вы также можете видеть реальное значение (показано как **raw**).

![[Pasted image 20240313003601.png]]

Второй этап, отправка пакета с включённым флагом SYN-ACK: В ответ сервер отвечает SYN-ACK. Номер подтверждения установлен на единицу больше принятого Порядкового номера (Sequence number), то есть A+1. Поскольку сервер также будет отправлять данные, то для себя он тоже выбирает Порядковый номер (Sequence number) первого пакета с данными, который будет другим случайным числом B.

![[Pasted image 20240313003613.png]]

Третий этап, отправка пакета с включённым флагом ACK: наконец, клиент отправляет ACK обратно на сервер. Порядковый номер устанавливается равным полученному значению подтверждения, то есть A+1, а номер подтверждения устанавливается на единицу больше, чем принятый порядковый номер, то есть B+1.

![[Pasted image 20240313003654.png]]

На этом этапе и клиент, и сервер получили подтверждение соединения. Шаги 1, 2 устанавливают параметр соединения (порядковый номер) для одного направления, и оно подтверждается. Шаги 2, 3 устанавливают параметр соединения (порядковый номер) для другого направления, и он подтверждается. Таким образом устанавливается полнодуплексная (двухсторонняя) связь.

**Передача данных в TCP**

**PSH-ACK**: Клиент отправляет запрос к серверу по HTTP протоколу, поскольку данные поместились в один сетевой пакет TCP, то он имеет флаг PSH, чтобы сервер не ждал продолжение получения данных, а отправил их веб-серверу для выполнения.

![[Pasted image 20240313003731.png]]

**ACK:** В ответ на принятую информацию сервер отправляет пакет ACK с номером успешно полученных данных.

![[Pasted image 20240313003743.png]]

**PSH-ACK:** Сервер обработал запрос и отправляет данные — веб страницу

![[Pasted image 20240313003813.png]]

**ACK**: клиент подтверждает, что данные получены

---

На последнем скриншоте:

1 - установка соединения
2 - передача данных
3 - завершение соединения

**Завершение соединения**

Фаза завершения соединения использует четырёхэтапное рукопожатие, причём каждая сторона соединения завершается независимо. Когда конечная точка хочет остановить свою половину соединения, она передаёт пакет FIN, который другой конец подтверждает пакетом с флагом ACK. Поэтому для типичного разрыва требуется пара сегментов FIN и ACK от каждой конечной точки TCP. После того, как сторона, отправившая первый FIN, ответила с последним ACK, она ожидает тайм-аута, прежде чем окончательно закрывает соединение, в течение которого локальный порт недоступен для новых соединений; это предотвращает путаницу из-за задержанных пакетов, доставляемых во время последующих соединений.

Соединение может быть «полуоткрытым», и в этом случае одна сторона завершила свою часть, а другая — нет. Завершившая сторона больше не может отправлять какие-либо данные в соединение, но другая сторона может. Завершающая сторона должна продолжить чтение данных, пока другая сторона также не завершит свою работу.

Также возможно разорвать соединение трёхэтапным рукопожатием, когда хост A отправляет FIN, а хост B отвечает FIN&ACK (просто объединяет 2 шага в один), а хост A отвечает ACK.

Некоторые операционные системы, такие как Linux и H-UX, реализуют полудуплексную последовательность закрытия в стеке TCP. Если хост активно закрывает соединение, но при этом остаются непрочитанными входящие данные, хост отправляет сигнал RST (потеря всех полученных данных) вместо FIN. Это гарантирует приложению TCP, что удалённый процесс прочитал все переданные данные, ожидая сигнала FIN, прежде чем он активно закроет соединение. Удалённый процесс не может различить сигнал RST для прерывания соединения и потери данных. Оба вызывают удалённый стек, чтобы потерять все полученные данные.

Как можно увидеть на скриншоте, завершение TCP соединения также происходит как (Linux с последним ядром):

Клиент: **FIN-ACK**

Сервер: **FIN-ACK**

Клиент: **ACK**

### Состояния клиента и сервера

| Состояния сеанса TCP |                                                                                                                                                                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **CLOSED**           | Начальное состояние узла. Фактически фиктивное                                                                                                                                                                                      |
| **LISTEN**           | Сервер ожидает запросов установления соединения от клиента                                                                                                                                                                          |
| **SYN-SENT**         | Клиент отправил запрос серверу на установление соединения и ожидает ответа                                                                                                                                                          |
| **SYN-RECEIVED**     | Сервер получил запрос на соединение, отправил ответный запрос и ожидает подтверждения                                                                                                                                               |
| **ESTABLISHED**      | Соединение установлено, идёт передача данных                                                                                                                                                                                        |
| **FIN-WAIT-1**       | Одна из сторон (назовём её узел-1) завершает соединение, отправив сегмент с флагом FIN                                                                                                                                              |
| **CLOSE-WAIT**       | Другая сторона (узел-2) переходит в это состояние, отправив, в свою очередь сегмент ACK и продолжает одностороннюю передачу                                                                                                         |
| **FIN-WAIT-2**       | Узел-1 получает ACK, продолжает чтение и ждёт получения сегмента с флагом FIN                                                                                                                                                       |
| **LAST-ACK**         | Узел-2 заканчивает передачу и отправляет сегмент с флагом FIN                                                                                                                                                                       |
| **TIME-WAIT**        | Узел-1 получил сегмент с флагом FIN, отправил сегмент с флагом ACK и ждёт 2*MSL секунд, перед окончательным закрытием соединения                                                                                                    |
| **CLOSING**          | Обе стороны инициировали закрытие соединения одновременно: после отправки сегмента с флагом FIN узел-1 также получает сегмент FIN, отправляет ACK и находится в ожидании сегмента ACK (подтверждения на свой запрос о разъединении) |
Описание данных состояний позволяет лучше понимать информацию, которую показывают программы о состоянии сети, такие как **netstat** и **ss** (смотрите также «[Как проверить открытые порты на своём компьютере. Что означают 0.0.0.0, :*, [::], 127.0.0.1. Как понять вывод NETSTAT](https://hackware.ru/?p=7309)»).

### Фильтры Wireshark для TCP  

Чтобы увидеть только трафик TCP:

```
tcp
```

Показать трафик, источником или портом назначения которого является определённый порт, например 8080:

```
tcp.port==8080
```

Показать трафик, источником которого является порт 80:

```
tcp.srcport == 80
```

Показать трафик, который отправляется службе, прослушивающей порт 80:

```
tcp.dstport == 80
```

Показать TCP пакеты с включённым флагом SYN:

```
tcp.flags.syn==1
```

Показать TCP пакеты с включённым флагом SYN и отключённым флагом ACK:

```
tcp.flags.syn==1 && tcp.flags.ack==0
```

Аналогично и для других флагов:

SYN

```
tcp.flags.syn==1
```

ACK

```
tcp.flags.ack==1
```

RST

```
tcp.flags.reset==1
```

FIN

```
tcp.flags.fin==1
```

CWR

```
tcp.flags.cwr==1
```

ECE

```
tcp.flags.ecn==1
```

URG

```
tcp.flags.urg==1
```

PSH

```
tcp.flags.push==1
```

NS

```
tcp.flags.ns==1
```

Также можно использовать синтаксис вида tcp.flags == 0x0XX, например:


- FIN это tcp.flags == 0x001
- SYN это tcp.flags == 0x002
- RST это tcp.flags == 0x004
- ACK это tcp.flags == 0x010


- Установленные одновременно ACK и FIN это tcp.flags == 0x011
- Установленные одновременно ACK и SYN это tcp.flags == 0x012
- Установленные одновременно ACK и RST это tcp.flags == 0x014
- Длина заголовка (смещение данных):

```
tcp.hdr_len == 32
tcp.hdr_len == 52
tcp.hdr_len > 32
```

Пакеты с установленными зарезервированными битами:

```
tcp.flags.res == 1
```

Размер окна:

```
tcp.window_size_value == 11
tcp.window_size_value == 4468
tcp.window_size_value > 65000
tcp.window_size_value < 100
```

Вычесленный размер окна:

```
tcp.window_size == 45056
tcp.window_size == 11
```

Фактор масштабирования размера окна:

```
tcp.window_size_scalefactor == 4096
```

tcp.window_size_value — это необработанное значение размера окна, считываемое непосредственно из заголовка TCP, тогда как tcp.window_size — это вычисленный размер окна, который основан на том, применимо ли масштабирование окна или нет. 

Если масштабирование окна не используется или коэффициент масштабирования равен 1 или неизвестно, применимо ли масштабирование окна или нет, потому что трёхэтапное рукопожатие TCP не было захвачено, тогда эти два значения будут одинаковыми. 

С помощью tcp.window_size_scalefactor вы можете определить, какое из этих условий применимо — если его значение равно -1, то оно неизвестно, если его значение равно -2, тогда масштабирование окна не используется, а все остальные значения представляют фактический размер фактора масштабирования окна.

Чтобы показать пакеты, содержащие какую либо строку, например, строку hackware:

```
tcp contains hackware
```

![[Pasted image 20240313004402.png]]

Следовать потоку TCP с номером X:

```
tcp.stream eq X
```

Фильтровать по номеру потока:

```
tcp.seq == x
```

Показать повторные отправки пакетов. Помогает прослеживать замедление производительности приложений и потери пакетов:

```
tcp.analysis.retransmission
```

Этот фильтр выведен проблемные пакеты (потерянные сегменты, повторную отправку и другие. Этот фильтр проходят пакеты TCP Keep-Alive, но они не являются показателем проблем.

```
tcp.analysis.flags
```

Фильтры для оценки качества сетевого подключения.

Следующие характеристики относятся к TCP фреймам. Причём они не основываются на заголовках фрейма — рассматриваемые характеристики (пропуск данных, дубли) присвоены программой Wireshark исходя из анализа.

Фильтр выводит информацию о фреймах с флагом ACK, которые являются дублями. Большое количество таких фреймов может говорить о проблемах связи:

```
tcp.analysis.duplicate_ack_num == 1
```

Фильтр показа фреймов для которых не захвачен предыдущий сегмент:

```
tcp.analysis.ack_lost_segment
```

Это нормально в начале захвата данных — поскольку информация перехватывается не с самого начала сессии.

Для показа фреймов, которые являются ретрансмиссией (отправляются повторно):

```
tcp.analysis.retransmission
```

Вывод фреймов, которые получены не в правильном порядке:

```
tcp.analysis.out_of_order
```

Смотрите также «Фильтры Wireshark».

### Виды сканирований Nmap

Мы рассмотрели механизм рукопожатия TCP, напомним его структуру:

- Клиент: SYN
- Сервер: SYN-ACK
- Клиент: ACK

Знаменитый сканер портов Nmap по умолчанию выполняет сканирования с использованием полуотрытых соединений, или его ещё называют SYN сканированием. На самом деле, это не что иное, как отправленный пакет с включённым флагом SYN — то есть Nmap инициирует рукопожатие TCP. Если в ответ приходит пакет с флагами SYN-ACK (то есть удалённый хост отправляет свою часть рукопожатия), то это означает, что порт открыт. Если удалённый хост отвечает пакетом с флагом RST-ACK, то это означает, что порт закрыт.

Такой метод, с одной стороны, является универсальным — любой открытый порт обязательно должен ответить пакетом с флагами SYN-ACK, поскольку это стандарт транспортного протокола TCP. Но при этом Nmap не завершает рукопожатие, то есть не создаётся полноценное соединение и приложение, которое прослушивает просканированный порт, никогда не узнает об этом неудачном TCP рукопожатии, и этот факт не отобразиться в журналах этого приложения.

Пример сканирования портов:

```
sudo nmap -p 70-90 185.117.153.79
```

На следующем скриншоте мы можем видеть отправленные и полученные пакеты:

![[Pasted image 20240313004642.png]]

Первая группа пакетов (выделена прямоугольником) — пинг хоста, чтобы определить, доступен ли он. Также на этапе доступности хоста делается запрос к портам 80 и 443 (хотя порт 443 не указан для сканирования), видимо, также для подтверждения того, что хост онлайн.

Если от порта получен пакет SYN-ACK (сервер готов к установке соединения), то Nmap отвечает пакетом с флагом RST для обрыва начатого рукопожатия.

Вторая группа — они отмечены серым и зелёным — это непосредственно сканирование портов — это пакеты с флагом SYN. Серым отмечены те, которые прислали ответ RST-ACK (порт закрыт), а зелёным т е, которые прислали ответ SYN-ACK (порт открыт).

Пакеты RST-ACK, а также пакеты RST (от Nmap) помечены красным.

Как можно увидеть, техника очень простая и использует самые базовые возможности трансопртного протокола TCP.

Кроме этого метода, Nmap поддерживает ещё несколько типов сканирования:

```
-sS/sT/sA/sW/sM: TCP SYN/с использованием системного вызова Connect()/ACK/Window/Maimon сканирования
-sU: UDP сканирование
-sN/sF/sX: TCP Null, FIN и Xmas сканирования
--scanflags <флаги>: Задать собственные TCP флаги
```

Если вы хотите узнать об этих опциях и типах сканирвоания подробнее, то рекомендуется изучить их на справочной странице Nmap: https://kali.tools/?p=1317

Теперь, когда понятна суть сканирований портов, можно предложить меры по защите сервера от сканирований. Если ваш сервер предназначен принимать входящие соединения (например, это веб сервер с SSH), то на 100% защититься от сканирований портов нельзя, поскольку для полуоткрытых соединений используются «легальные» TCP пакеты с флагом SYN, которые являются первой частью рукопожатий. Тем не менее в iptables или fail2ban можно настроить примерно такое правило: «если от одного удалённого хоста поступило более 10 SYN пакетов за указанный промежуток времени, то отклонять его последующие попытки подключения». Это затруднит или даже сделает невозможным массовое сканирование портов на вашем сервере.

Если у вас настроен контроль доступа по IP, то можно запретить SYN пакеты от любого хоста, кроме разрешённых IP, — в этом случае посторонние не только не смогут подключаться, но и не смогут узнать, что порт на самом деле открыт.

## Протокол UDP  

Если вы смогли разобраться с TCP и его заголовками, то с UDP вам будет совсем просто.

Протокол пользовательских дейтаграмм (UDP) — это очень простой протокол. Он был разработан для обеспечения очень простой передачи данных без какого-либо обнаружения ошибок. Это так называемый stateless (то есть «без состояния») протокол, это отличает его от протокола TCP, в котором есть понятие соединения (stateful), включающее в себя создания подключения (трёхэтапное рукопожатие) и в котором передача данных выполняется только в рамках данного подключения. Соответственно, для протокола UDP не предусмотрены различные состояния клиента и сервера.

Однако он очень хорошо подходит для приложений типа запрос/ответ, таких как, например, DNS и т. д., поскольку мы знаем, что если мы не получим ответ от DNS-сервера, запрос где-то был потерян. Иногда также стоить использовать протокол UDP вместо TCP, например, когда мы хотим только обнаружение ошибок/потерь, но не заботимся о последовательности пакетов. Это устраняет некоторые издержки, связанные с протоколом TCP.

Природа UDP как протокола без сохранения состояния также полезна для серверов, отвечающих на небольшие запросы от огромного числа клиентов, например DNS и потоковые мультимедийные приложения вроде IPTV, Voice over IP, протоколы туннелирования IP и многие онлайн-игры.

### Что такое 1 соединение UDP  

Для UDP пакетов понятие «соединение» неправильное, поскольку отправляется один пакет без установки соединения. Если требуется передать поток данных, то отправляется множество UDP пакетов, которые хотя и могут иметь одну общую задачу, с точки зрения транспортного протокола каждый из них является независимым.

В ответ также может прийти один или несколько пакетов UDP. Они приходят на тот же порт, с которого был отправлен исходный UDP пакет — это позволяет определить, что данная датаграмма является ответной на отправленную ранее.

Тем не менее при открытом UDP порте состояние сервера становится **LISTEN** (сервер ожидает запросов установления соединения от клиента). Также UDP соединение может иметь статус **UCONN** или **ESTAB**.

Как можно увидеть, UDP пакет отправлен с порта 42044:

![[Pasted image 20240313004800.png]]

Ответный UDP пакет также пришёл на порт 42044:

![[Pasted image 20240313004811.png]]

Если сравнить с TCP, то минимальное количество пакетов для отправки запроса и получения информации — 10, а для UDP минимальное количество пакетов для отправки запроса и получения информации — 2. 
### Заголовок UDP

Можно сказать, что заголовок UDP представляет собой очень упрощённый заголовок TCP. Он содержит порты назначения, порты источника, длину заголовка и контрольную сумму, как показано на рисунке ниже.

![[image_2024-03-13_00-49-24.png]]

- **Исходный порт** — биты 0-15. Это порт источника пакета, описывающий, куда должен быть отправлен ответный пакет. Он может фактически быть установлено на ноль, если значение порта не применимо. Например, иногда нам не требуется ответный пакет, то тогда пакет может быть установлен на нулевой порт источника. В большинстве реализаций он установлен на некоторый номер порта.
- **Порт назначения** — биты 16-31. Порт назначения пакета. Это требуется для всех пакетов, в отличие от порта источника пакета.

Как и с протоколом TCP — для сервера обычно используется один из стандартных портов (например, порт 53 для DNS серверов), а порт источника выбирается произвольно для каждого соединения, обычно это номера портов с большим номером (десятки тысяч).

- **Длина** — биты 32-47. Поле длины указывает длину всего пакета в октетах, включая заголовок и части данных. Самый короткий возможный пакет может быть длиной 8 октетов.

Поле, задающее длину всей датаграммы (заголовка и данных) в байтах. Минимальная длина равна длине заголовка — 8 байт. Теоретически, максимальный размер поля — 65535 байт для UDP-датаграммы (8 байт на заголовок и 65527 на данные). Фактический предел для длины данных при использовании IPv4 — 65507 (помимо 8 байт на UDP-заголовок требуется ещё 20 на IP-заголовок).

- **Контрольная сумма** — биты 48-63. Контрольная сумма — это та же контрольная сумма, что и в заголовке TCP, за исключением того, что она содержит другой набор данных. Другими словами, это дополнение к сумме дополнительных частей заголовка IP, всего заголовка UDP, данных UDP и дополнения нулями в конце, когда это необходимо.

Поле контрольной суммы используется для проверки заголовка и данных на ошибки. Если сумма не сгенерирована передатчиком, то поле заполняется нулями. Поле не является обязательным для IPv4.

### Фильтры Wireshark для UDP  

Чтобы увидеть только трафик UDP:

```
udp
```

Для UDP не используются флаги. Для этого протокола можно только указать порт.

Показать трафик, источником которого является порт 53:

```
udp.srcport == 53
```

Показать трафик, который отправляется службе, прослушивающей порт 53:

```
udp.dstport == 53
```

UDP пакет, в котором встречается определённая строка, например, строка hackware:

```
udp contains hackware
```

Порт назначения ИЛИ исходный порт:

```
udp.port == 53
udp.port > 40000
udp.port < 30
```

Длина пакета:

```
udp.length == 60
udp.length > 50000
```

Время между пакетами (для выявления проблем сети):

```
udp.time_delta > 1.5
```

Номер потока (запрос-ответ):

```
udp.stream == 5
```

Пакеты трассировки:

```
udp.possible_traceroute
```

## Сравнение UDP и TCP  

TCP — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки соединения между двумя хостами. Как только соединение установлено, пользователи могут отправлять данные в обоих направлениях.

- Надёжность — TCP управляет подтверждением, повторной передачей и тайм-аутом сообщений. Производятся многочисленные попытки доставить сообщение. Если оно потеряется на пути, сервер вновь запросит потерянную часть. В TCP нет ни пропавших данных, ни (в случае многочисленных тайм-аутов) разорванных соединений.
- Упорядоченность — если два сообщения последовательно отправлены, первое сообщение достигнет приложения-получателя первым. Если участки данных прибывают в неверном порядке, TCP отправляет неупорядоченные данные в буфер до тех пор, пока все данные не могут быть упорядочены и переданы приложению.
- Тяжеловесность — TCP необходимо три пакета для установки сокет-соединения перед тем, как отправить данные. TCP следит за надёжностью и перегрузками.
- Потоковость — данные читаются как поток байтов, не передается никаких особых обозначений для границ сообщения или сегментов.

UDP — более простой, основанный на сообщениях протокол без установления соединения. Протоколы такого типа не устанавливают выделенного соединения между двумя хостами. Связь достигается путём передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя. В приложениях для голосовой связи через интернет-протокол (Voice over IP, TCP/IP) UDP имеет преимущество над TCP, в котором любое «рукопожатие» помешало бы хорошей голосовой связи. В VoIP считается, что конечные пользователи в реальном времени предоставят любое необходимое подтверждение о получении сообщения.

- Ненадёжный — когда сообщение посылается, неизвестно, достигнет ли оно своего назначения — оно может потеряться по пути. Нет таких понятий, как подтверждение, повторная передача, тайм-аут.
- Неупорядоченность — если два сообщения отправлены одному получателю, то порядок их достижения цели не может быть предугадан.
- Легковесность — никакого упорядочивания сообщений, никакого отслеживания соединений и т. д. Это небольшой транспортный уровень, разработанный на IP.
- Датаграммы — пакеты посылаются по отдельности и проверяются на целостность только если они прибыли. Пакеты имеют определенные границы, которые соблюдаются после получения, то есть операция чтения на сокете-получателе выдаст сообщение таким, каким оно было изначально послано.
- Нет контроля перегрузок — UDP сам по себе не избегает перегрузок. Для приложений с большой пропускной способностью возможно вызвать коллапс перегрузок, если только они не реализуют меры контроля на прикладном уровне.
- Широковещательные рассылки (Broadcasts) — при отсутствии соединения, UDP может делать широковещательные рассылки — отправленные пакеты могут быть адресованы для приёма всеми устройствами в подсети.
- Многоадресная рассылка (Multicast) — поддерживается многоадресный режим работы, при котором один пакет дейтаграмм может быть автоматически направлен без дублирования группе подписчиков.