# CPU Registers

---

Регистры являются важными компонентами процессора. Почти все регистры имеют небольшой объем памяти, где данные могут временно храниться. Однако некоторые из них имеют особую функцию.

Эти регистры будут разделены на общие регистры, регистры управления и регистры сегментов. Наиболее важные регистры, которые нам нужны, — это общие регистры. В них есть дополнительные подразделения на регистры данных, регистры указателей и регистры индексов.

#### Data registers

|**32-битный регистр**|**64-битный регистр**|**Описание**|
|---|---|---|
|`EAX`|`RAX`|Аккумулятор используется при вводе/выводе и для арифметических операций.|
|`EBX`|`RBX`|База используется в индексированной адресации.|
|`ECX`|`RCX`|Счетчик используется для ротации инструкций и подсчета циклов.|
|`EDX`|`RDX`|Данные используются для ввода-вывода и в арифметических операциях для операций умножения и деления, включающих большие значения.|

---

#### Pointer registers

|**32-битный регистр**|**64-битный регистр**|**Описание**|
|---|---|---|
|`EIP`|`RIP`|Указатель инструкций хранит адрес смещения следующей инструкции, которая будет выполнена.|
|`ESP`|`RSP`|Указатель стека указывает на вершину стека.|
|`EBP`|`RBP`|Базовый указатель также известен как `Stack Base Pointer` или `Frame Pointer` это указывает на основание стека|

---

## Stack Frames

Поскольку стек начинается с старшего адреса и по мере добавления значений увеличивается до младших адресов памяти, `Base Pointer` указывает на начало (базу) стека в отличие от `Stack Pointer`, который указывает на вершину стека.

По мере роста стека он логически делится на области, называемые `Stack Frames`, которые выделяют необходимую память в стеке для соответствующей функции. Кадр стека определяет кадр данных с началом ( `EBP`) и конец ( `ESP`), который помещается в стек при вызове функции.

Поскольку стековая память построена на `Last-In-First-Out` ( `LIFO`) структуры данных, первым шагом является сохранение `previous EBP`позиция в стеке, которую можно восстановить после завершения функции. Если мы теперь посмотрим на `bowfunc` функция, в GDB она выглядит следующим образом:

```shell-session
(gdb) disas bowfunc 

Dump of assembler code for function bowfunc:
   0x0000054d <+0>:	    push   ebp       # <---- 1. Stores previous EBP
   0x0000054e <+1>:	    mov    ebp,esp
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404
   <...SNIP...>
   0x00000580 <+51>:	leave  
   0x00000581 <+52>:	ret    
```

The `EBP` в кадре стека устанавливается первым при вызове функции и содержит `EBP`предыдущего кадра стека. Далее, значение `ESP` копируется в `EBP`, создавая новый кадр стека.

```shell-session
(gdb) disas bowfunc 

Dump of assembler code for function bowfunc:
   0x0000054d <+0>:	    push   ebp       # <---- 1. Stores previous EBP
   0x0000054e <+1>:	    mov    ebp,esp   # <---- 2. Creates new Stack Frame
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404 
   <...SNIP...>
   0x00000580 <+51>:	leave  
   0x00000581 <+52>:	ret    
```

Затем в стеке создается некоторое пространство, перемещая `ESP` вверху для необходимых и обработанных операций и переменных.

#### Prologue

```shell-session
(gdb) disas bowfunc 

Dump of assembler code for function bowfunc:
   0x0000054d <+0>:	    push   ebp       # <---- 1. Stores previous EBP
   0x0000054e <+1>:	    mov    ebp,esp   # <---- 2. Creates new Stack Frame
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404 # <---- 3. Moves ESP to the top
   <...SNIP...>
   0x00000580 <+51>:	leave  
   0x00000581 <+52>:	ret    
```

Эти три инструкции представляют собой так называемую `Prologue`.

Для выхода из кадра стека делается обратное: `Epilogue`. Во время эпилога `ESP` заменяется текущим `EBP`, и его значение сбрасывается до значения, которое оно имело ранее в прологе. Эпилог относительно короткий, и помимо других возможностей его выполнения, в нашем примере он выполняется двумя инструкциями:

#### Epilogue

```shell-session
(gdb) disas bowfunc 

Dump of assembler code for function bowfunc:
   0x0000054d <+0>:	    push   ebp       
   0x0000054e <+1>:	    mov    ebp,esp   
   0x00000550 <+3>:	    push   ebx
   0x00000551 <+4>:	    sub    esp,0x404 
   <...SNIP...>
   0x00000580 <+51>:	leave  # <----------------------
   0x00000581 <+52>:	ret    # <--- Leave stack frame
```

---

#### Index registers

|**Зарегистрировать 32-битную версию**|**Зарегистрировать 64-битную версию**|**Описание**|
|---|---|---|
|`ESI`|`RSI`|Индекс источника используется как указатель на источник для строковых операций.|
|`EDI`|`RDI`|Назначение используется как указатель на место назначения для строковых операций.|

---

Еще один важный момент, касающийся представления ассемблера, — это именование регистров. Это зависит от формата, в котором был скомпилирован двоичный файл. Мы использовали GCC для компиляции `bow.c`код в 32-битном формате. Теперь давайте скомпилируем тот же код в `64-bit` формат.

#### Compile in 64-bit Format

```shell-session
student@nix-bow:~$ gcc bow.c -o bow64 -fno-stack-protector -z execstack -m64
student@nix-bow:~$ file bow64 | tr "," "\n"

bow64: ELF 64-bit LSB shared object
 x86-64
 version 1 (SYSV)
 dynamically linked
 interpreter /lib64/ld-linux-x86-64.so.2
 for GNU/Linux 3.2.0
 BuildID[sha1]=9503477016e8604e808215b4babb250ed25a7b99
 not stripped
```

Итак, если мы теперь посмотрим на ассемблерный код, то увидим, что адреса в два раза больше, и у нас почти половина инструкций, как в 32-битном скомпилированном двоичном файле.

```shell-session
student@nix-bow:~$ gdb -q bow64

Reading symbols from bow64...(no debugging symbols found)...done.
(gdb) disas main

Dump of assembler code for function main:
   0x00000000000006bc <+0>: 	push   rbp
   0x00000000000006bd <+1>: 	mov    rbp,rsp
   0x00000000000006c0 <+4>: 	sub    rsp,0x10
   0x00000000000006c4 <+8>:  	mov    DWORD PTR [rbp-0x4],edi
   0x00000000000006c7 <+11>:	mov    QWORD PTR [rbp-0x10],rsi
   0x00000000000006cb <+15>:	mov    rax,QWORD PTR [rbp-0x10]
   0x00000000000006cf <+19>:	add    rax,0x8
   0x00000000000006d3 <+23>:	mov    rax,QWORD PTR [rax]
   0x00000000000006d6 <+26>:	mov    rdi,rax
   0x00000000000006d9 <+29>:	call   0x68a <bowfunc>
   0x00000000000006de <+34>:	lea    rdi,[rip+0x9f]
   0x00000000000006e5 <+41>:	call   0x560 <puts@plt>
   0x00000000000006ea <+46>:	mov    eax,0x1
   0x00000000000006ef <+51>:	leave  
   0x00000000000006f0 <+52>:	ret    
End of assembler dump.

```

Однако сначала мы рассмотрим 32-битную версию уязвимого двоичного файла. Самая важная инструкция для нас сейчас – это `call`инструкция. `call` Инструкция используется для вызова функции и выполняет две операции:

1. он помещает обратный адрес в `stack` чтобы выполнение программы можно было продолжить после того, как функция успешно выполнила свою задачу,
2. это меняет `instruction pointer` ( `EIP`) к месту назначения вызова и начать выполнение там.

#### GDB - Intel Syntax

```shell-session
student@nix-bow:~$ gdb ./bow32 -q

Reading symbols from bow...(no debugging symbols found)...done.
(gdb) disassemble main

Dump of assembler code for function main:
   0x00000582 <+0>: 	lea    ecx,[esp+0x4]
   0x00000586 <+4>: 	and    esp,0xfffffff0
   0x00000589 <+7>: 	push   DWORD PTR [ecx-0x4]
   0x0000058c <+10>:	push   ebp
   0x0000058d <+11>:	mov    ebp,esp
   0x0000058f <+13>:	push   ebx
   0x00000590 <+14>:	push   ecx
   0x00000591 <+15>:	call   0x450 <__x86.get_pc_thunk.bx>
   0x00000596 <+20>:	add    ebx,0x1a3e
   0x0000059c <+26>:	mov    eax,ecx
   0x0000059e <+28>:	mov    eax,DWORD PTR [eax+0x4]
   0x000005a1 <+31>:	add    eax,0x4
   0x000005a4 <+34>:	mov    eax,DWORD PTR [eax]
   0x000005a6 <+36>:	sub    esp,0xc
   0x000005a9 <+39>:	push   eax
   0x000005aa <+40>:	call   0x54d <bowfunc>		# <--- CALL function
<SNIP>
```

---

## Порядок байтов

Во время операций загрузки и сохранения в регистрах и памяти байты читаются в другом порядке. Этот порядок байтов называется `endianness`. Эндианность различают между `little-endian` формат и `big-endian` формат.

`Big-endian` и `little-endian`имеют порядок валентности. В `big-endian`, изначально цифры с наивысшей валентностью. В `little-endian`, цифры с наименьшей валентностью находятся в начале. Процессоры мейнфреймов используют `big-endian` формате, некоторых RISC-архитектурах, мини-компьютерах и в сетях TCP/IP порядок байтов также находится в `big-endian` формат.

Теперь давайте посмотрим на пример со следующими значениями:

- Адрес: `0xffff0000`
- Слово: `\xAA\xBB\xCC\xDD`

| **Адрес памяти** | **0xffff0000** | **0xffff0001** | **0xffff0002** | **0xffff0003** |
| ---------------- | -------------- | -------------- | -------------- | -------------- |
| Big-Endian       | AA             | BB             | CC             | DD             |
| Little-Endian    | DD             | CC             | BB             | AA             |

Это очень важно для того, чтобы мы могли ввести наш код в правильном порядке позже, когда нам придется сообщить процессору, на какой адрес он должен указывать.