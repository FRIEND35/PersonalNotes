
# Stack-Based Buffer Overflow

---

Исключения памяти — это реакция операционной системы на ошибку в существующем программном обеспечении или во время его выполнения. Это является причиной большинства уязвимостей безопасности в программных потоках за последнее десятилетие. Часто возникают ошибки программирования, приводящие к переполнению буфера из-за невнимательности при программировании на низкоабстрактных языках, таких как `C` или `C++`.

Эти языки компилируются практически непосредственно в машинный код и, в отличие от высоко абстрактных языков, таких как Java или Python, практически не используют структуру управления операционной системы. Переполнение буфера — это ошибки, которые позволяют данным, слишком большим, поместиться в буфер памяти операционной системы, который недостаточно велик, тем самым переполняя этот буфер. В результате такого неправильного обращения память других функций исполняемой программы перезаписывается, что потенциально создает уязвимость безопасности.

Такая программа (двоичный файл) представляет собой обычный исполняемый файл, хранящийся на носителе данных. Существует несколько различных форматов таких исполняемых двоичных файлов. Например, `Portable Executable Format` ( `PE`) используется на платформах Microsoft.

Другой формат исполняемых файлов — это `Executable and Linking Format` ( `ELF`), поддерживаемый практически всеми современными `UNIX`варианты. Если компоновщик загрузит такой исполняемый двоичный файл и программа будет выполнена, соответствующий программный код будет загружен в основную память и затем выполнен ЦП.

Программы хранят данные и инструкции в памяти во время инициализации и выполнения. Это данные, которые отображаются в исполняемом программном обеспечении или вводятся пользователем. Специально для ожидаемого пользовательского ввода необходимо заранее создать буфер путем сохранения ввода.

Инструкции используются для моделирования потока программы. Помимо прочего, в памяти хранятся адреса возврата, которые относятся к другим адресам памяти и, таким образом, определяют поток управления программой. Если такой адрес возврата намеренно перезаписан с помощью переполнения буфера, злоумышленник может манипулировать ходом программы, заставив адрес возврата ссылаться на другую функцию или подпрограмму. Кроме того, можно было бы вернуться к коду, ранее введенному пользователем.

Чтобы понять, как это работает на техническом уровне, нам необходимо ознакомиться с тем, как:

- память разделена и используется
- отладчик отображает и называет отдельные инструкции
- отладчик может использоваться для обнаружения таких уязвимостей
- мы можем манипулировать памятью

Еще одним важным моментом является то, что эксплойты обычно работают только для определенной версии программного обеспечения и операционной системы. Поэтому нам приходится пересобирать и перенастраивать целевую систему, чтобы привести ее в то же состояние. После этого исследуемая нами программа устанавливается и анализируется. В большинстве случаев у нас будет только одна попытка использовать программу, если мы упустим возможность перезапустить ее с повышенными привилегиями.

---

## The Memory

При вызове программы разделы сопоставляются с сегментами процесса, и сегменты загружаются в память, как описано в `ELF` файл.

#### Buffer

![[Pasted image 20240806025336.png]]

#### .text

The `.text`Раздел содержит актуальные ассемблерные инструкции программы. Эта область может быть доступна только для чтения, чтобы предотвратить случайное изменение своих инструкций процессом. Любая попытка записи в эту область неизбежно приведет к ошибке сегментации.

---

#### .data

The `.data` Раздел содержит глобальные и статические переменные, которые явно инициализируются программой.

---

#### .bss

Некоторые компиляторы и компоновщики используют `.bss` раздел как часть сегмента данных, который содержит статически выделенные переменные, представленные исключительно нулевыми битами.

---

#### The Heap

`Heap memory`выделяется из этой области. Эта область начинается в конце сегмента «.bss» и увеличивается до старших адресов памяти.

---

#### The Stack

`Stack memory` это `Last-In-First-Out` структура данных, в которой хранятся адреса возврата, параметры и, в зависимости от опций компилятора, указатели кадров. `C/C++`Здесь хранятся локальные переменные, и вы даже можете скопировать код в стек. `Stack` представляет собой определенную территорию в `RAM`. Компоновщик резервирует эту область и обычно помещает стек в нижнюю область ОЗУ над глобальными и статическими переменными. Доступ к содержимому осуществляется через `stack pointer`, устанавливается в верхний конец стека во время инициализации. Во время выполнения выделенная часть стека увеличивается до нижних адресов памяти.

Современные средства защиты памяти ( `DEP`/ `ASLR`) предотвратит повреждения, вызванные переполнением буфера. DEP (предотвращение выполнения данных) помечает области памяти «только для чтения». Области памяти, доступные только для чтения, — это места, где хранится некоторый пользовательский ввод (пример: стек), поэтому идея DEP заключалась в том, чтобы запретить пользователям загружать шеллкод в память, а затем устанавливать указатель инструкции на шеллкод. Чтобы обойти эту проблему, хакеры начали использовать ROP (возвратно-ориентированное программирование), поскольку оно позволяло им загружать шеллкод в исполняемое пространство и использовать существующие вызовы для его выполнения. При использовании ROP злоумышленнику необходимо знать адреса памяти, в которых хранятся данные, поэтому защита от него заключалась в реализации ASLR (рандомизации макета адресного пространства), которая рандомизирует место хранения данных, что усложняет ROP.

Пользователи могут обойти ASLR путем утечки адресов памяти, но это делает эксплойты менее надежными, а иногда и невозможными. Например [, «FTP-сервер Freefloat»](https://www.exploit-db.com/exploits/46763) легко использовать в Windows XP (до DEP/ASLR). Однако, если приложение запускается в современной операционной системе Windows, переполнение буфера существует, но в настоящее время его не так просто использовать из-за DEP/ASLR (поскольку не существует известного способа утечки адресов памяти).

---

## Vulnerable Program

Сейчас мы пишем простую программу на языке C под названием `bow.c` с уязвимой функцией под названием `strcpy()`.

#### Bow.c

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int bowfunc(char *string) {

	char buffer[1024];
	strcpy(buffer, string);
	return 1;
}

int main(int argc, char *argv[]) {

	bowfunc(argv[1]);
	printf("Done.\n");
	return 1;
}
```

Современные операционные системы имеют встроенные средства защиты от таких уязвимостей, такие как рандомизация адресного пространства (ASLR). Чтобы изучить основы эксплуатации переполнения буфера, мы собираемся отключить следующие функции защиты памяти:

#### Disable ASLR

Переполнение буфера на основе стека

```shell-session
student@nix-bow:~$ sudo su
root@nix-bow:/home/student# echo 0 > /proc/sys/kernel/randomize_va_space
root@nix-bow:/home/student# cat /proc/sys/kernel/randomize_va_space

0
```

Затем мы компилируем код C в 32-битный двоичный файл ELF.

#### Compilation

Переполнение буфера на основе стека

```shell-session
student@nix-bow:~$ sudo apt install gcc-multilib
student@nix-bow:~$ gcc bow.c -o bow32 -fno-stack-protector -z execstack -m32
student@nix-bow:~$ file bow32 | tr "," "\n"

bow: ELF 32-bit LSB shared object
 Intel 80386
 version 1 (SYSV)
 dynamically linked
 interpreter /lib/ld-linux.so.2
 for GNU/Linux 3.2.0
 BuildID[sha1]=93dda6b77131deecaadf9d207fdd2e70f47e1071
 not stripped
```

---

## Vulnerable C Functions

В языке программирования C есть несколько уязвимых функций, которые не защищают память самостоятельно. Вот некоторые из функций:

- `strcpy`
- `gets`
- `sprintf`
- `scanf`
- `strcat`
- ...

---

## GDB Introductions

GDB, или отладчик GNU, — это стандартный отладчик систем Linux, разработанный проектом GNU. Он был портирован на многие системы и поддерживает языки программирования C, C++, Objective-C, FORTRAN, Java и многие другие.

GDB предоставляет нам обычные функции трассировки, такие как точки останова или вывод трассировки стека, и позволяет нам вмешиваться в выполнение программ. Это также позволяет нам, например, манипулировать переменными приложения или вызывать функции независимо от обычного выполнения программы.

Мы используем `GNU Debugger` ( `GDB`) для просмотра созданного двоичного файла на уровне ассемблера. Как только мы выполнили двоичный файл с помощью `GDB`, мы можем дизассемблировать основную функцию программы.

#### GDB - AT&T Syntax

Переполнение буфера на основе стека

```shell-session
student@nix-bow:~$ gdb -q bow32

Reading symbols from bow...(no debugging symbols found)...done.
(gdb) disassemble main

Dump of assembler code for function main:
   0x00000582 <+0>: 	lea    0x4(%esp),%ecx
   0x00000586 <+4>: 	and    $0xfffffff0,%esp
   0x00000589 <+7>: 	pushl  -0x4(%ecx)
   0x0000058c <+10>:	push   %ebp
   0x0000058d <+11>:	mov    %esp,%ebp
   0x0000058f <+13>:	push   %ebx
   0x00000590 <+14>:	push   %ecx
   0x00000591 <+15>:	call   0x450 <__x86.get_pc_thunk.bx>
   0x00000596 <+20>:	add    $0x1a3e,%ebx
   0x0000059c <+26>:	mov    %ecx,%eax
   0x0000059e <+28>:	mov    0x4(%eax),%eax
   0x000005a1 <+31>:	add    $0x4,%eax
   0x000005a4 <+34>:	mov    (%eax),%eax
   0x000005a6 <+36>:	sub    $0xc,%esp
   0x000005a9 <+39>:	push   %eax
   0x000005aa <+40>:	call   0x54d <bowfunc>
   0x000005af <+45>:	add    $0x10,%esp
   0x000005b2 <+48>:	sub    $0xc,%esp
   0x000005b5 <+51>:	lea    -0x1974(%ebx),%eax
   0x000005bb <+57>:	push   %eax
   0x000005bc <+58>:	call   0x3e0 <puts@plt>
   0x000005c1 <+63>:	add    $0x10,%esp
   0x000005c4 <+66>:	mov    $0x1,%eax
   0x000005c9 <+71>:	lea    -0x8(%ebp),%esp
   0x000005cc <+74>:	pop    %ecx
   0x000005cd <+75>:	pop    %ebx
   0x000005ce <+76>:	pop    %ebp
   0x000005cf <+77>:	lea    -0x4(%ecx),%esp
   0x000005d2 <+80>:	ret    
End of assembler dump.

```

В первом столбце шестнадцатеричные числа обозначают `memory addresses`. Числа со знаком плюс ( `+`) показать `address jumps`в памяти в байтах, используемых для соответствующей инструкции. Далее мы можем увидеть `assembler instructions` ( `mnemonics`) с регистрами и их `operation suffixes`. Текущий синтаксис `AT&T`, что мы можем узнать по `%` и `$` персонажи.

| **Адрес памяти** | **Адресные переходы** | **Инструкция ассемблера** | **Суффиксы операций** |
| ---------------- | --------------------- | ------------------------- | --------------------- |
| 0x00000582       | <+0>:                 | lea                       | 0x4(%esp),%ecx        |
| 0x00000586       | <+4>:                 | and                       | $0xffffff0,%esp       |
| ...              | ...                   | ...                       | ...                   |

Синтаксис `Intel` облегчает чтение дизассемблированного представления, и мы можем изменить синтаксис, введя в GDB следующие команды:

#### GDB - Change the Syntax to Intel

Переполнение буфера на основе стека

```shell-session
(gdb) set disassembly-flavor intel
(gdb) disassemble main

Dump of assembler code for function main:
   0x00000582 <+0>:	    lea    ecx,[esp+0x4]
   0x00000586 <+4>:	    and    esp,0xfffffff0
   0x00000589 <+7>:	    push   DWORD PTR [ecx-0x4]
   0x0000058c <+10>:	push   ebp
   0x0000058d <+11>:	mov    ebp,esp
   0x0000058f <+13>:	push   ebx
   0x00000590 <+14>:	push   ecx
   0x00000591 <+15>:	call   0x450 <__x86.get_pc_thunk.bx>
   0x00000596 <+20>:	add    ebx,0x1a3e
   0x0000059c <+26>:	mov    eax,ecx
   0x0000059e <+28>:	mov    eax,DWORD PTR [eax+0x4]
<SNIP>
```

Нам не нужно постоянно менять режим отображения вручную. Мы также можем установить это как синтаксис по умолчанию с помощью следующей команды.

#### Change GDB Syntax

Переполнение буфера на основе стека

```shell-session
student@nix-bow:~$ echo 'set disassembly-flavor intel' > ~/.gdbinit
```

Если теперь мы перезапустим GDB и дизассемблируем основную функцию, мы увидим синтаксис Intel.

#### GDB - Intel Syntax

Переполнение буфера на основе стека

```shell-session
student@nix-bow:~$ gdb ./bow32 -q

Reading symbols from bow...(no debugging symbols found)...done.
(gdb) disassemble main

Dump of assembler code for function main:
   0x00000582 <+0>: 	lea    ecx,[esp+0x4]
   0x00000586 <+4>: 	and    esp,0xfffffff0
   0x00000589 <+7>: 	push   DWORD PTR [ecx-0x4]
   0x0000058c <+10>:	push   ebp
   0x0000058d <+11>:	mov    ebp,esp
   0x0000058f <+13>:	push   ebx
   0x00000590 <+14>:	push   ecx
   0x00000591 <+15>:	call   0x450 <__x86.get_pc_thunk.bx>
   0x00000596 <+20>:	add    ebx,0x1a3e
   0x0000059c <+26>:	mov    eax,ecx
   0x0000059e <+28>:	mov    eax,DWORD PTR [eax+0x4]
   0x000005a1 <+31>:	add    eax,0x4
   0x000005a4 <+34>:	mov    eax,DWORD PTR [eax]
   0x000005a6 <+36>:	sub    esp,0xc
   0x000005a9 <+39>:	push   eax
   0x000005aa <+40>:	call   0x54d <bowfunc>
   0x000005af <+45>:	add    esp,0x10
   0x000005b2 <+48>:	sub    esp,0xc
   0x000005b5 <+51>:	lea    eax,[ebx-0x1974]
   0x000005bb <+57>:	push   eax
   0x000005bc <+58>:	call   0x3e0 <puts@plt>
   0x000005c1 <+63>:	add    esp,0x10
   0x000005c4 <+66>:	mov    eax,0x1
   0x000005c9 <+71>:	lea    esp,[ebp-0x8]
   0x000005cc <+74>:	pop    ecx
   0x000005cd <+75>:	pop    ebx
   0x000005ce <+76>:	pop    ebp
   0x000005cf <+77>:	lea    esp,[ecx-0x4]
   0x000005d2 <+80>:	ret    
End of assembler dump.
```

Разница между `AT&T` и `Intel` Синтаксис заключается не только в представлении инструкций с их символами, но также в порядке и направлении, в котором инструкции выполняются и читаются.

В качестве примера возьмем следующую инструкцию:

Переполнение буфера на основе стека

```shell-session
   0x0000058d <+11>:	mov    ebp,esp
```

Используя синтаксис Intel, мы имеем следующий порядок инструкций из примера:

## Intel Syntax

| **Инструкция** | **`Destination`** | **Источник** |
| -------------- | ----------------- | ------------ |
| mov            | `ebp`             | esp          |

## AT&T Syntax

| **Инструкция** | **Источник** | **`Destination`** |
| -------------- | ------------ | ----------------- |
| mov            | %esp         | `%ebp`            |

---
# Questions

>По какому адресу в «main» функции вызывается функция «bowfunc»?


Запускаем машину, и после того как она будет готова подключимся к ней по SSH:

```
ssh htb-student@10.129.42.190
```

Посмотрим что у нас есть тут:

```
htb-student@nixbof32:~$ ls  
bow
```

Открываем программу в отладчике:

```
htb-student@nixbof32:~$ gdb ./bow
```

Посмотрим список функции:

```
(gdb) info functions  
All defined functions:  
  
Non-debugging symbols:  
0x00000398  _init  
0x000003d0  strcpy@plt  
0x000003e0  puts@plt  
0x000003f0  __libc_start_main@plt  
0x00000400  __cxa_finalize@plt  
0x00000408  __gmon_start__@plt  
0x00000410  _start  
0x00000450  __x86.get_pc_thunk.bx  
0x00000460  deregister_tm_clones  
0x000004a0  register_tm_clones  
0x000004f0  __do_global_dtors_aux  
0x00000540  frame_dummy  
0x00000549  __x86.get_pc_thunk.dx  
0x0000054d  bowfunc  
0x00000582  main  
0x000005d3  __x86.get_pc_thunk.ax  
0x000005e0  __libc_csu_init  
0x00000640  __libc_csu_fini  
0x00000644  _fini
```

И так, в `main` вызывается функция `bowfunc`, нам нужно найти адрес инструкцию которая вызывает эту функция. Как мы знаем, функции вызываются с п.м. инструкции `call`. Это значит, что нам нужно найти адрес функции `call` который вызываем `bowfunc` в `main`.

По умолчанию GDB использует AT&T-синтаксис, который отличается от Intel-синтаксиса в синтаксисе команд и порядка операндов. Команда `set disassembly-flavor intel` используется в отладчиках, таких как GDB, для того чтобы изменить формат вывода дизассемблированного кода на Intel-синтаксис.

```
(gdb) set disassembly-flavor intel
```

Команда `disassemble main` в GDB используется для дизассемблирования кода функции main, показывая ее машинный код в читаемом виде.  

Посмотрим что там в `main`:

```
(gdb) disassemble main  
Dump of assembler code for function main:  
  0x00000582 <+0>:     lea    ecx,[esp+0x4]  
  0x00000586 <+4>:     and    esp,0xfffffff0  
  0x00000589 <+7>:     push   DWORD PTR [ecx-0x4]  
  0x0000058c <+10>:    push   ebp  
  0x0000058d <+11>:    mov    ebp,esp  
  0x0000058f <+13>:    push   ebx  
  0x00000590 <+14>:    push   ecx  
  0x00000591 <+15>:    call   0x450 <__x86.get_pc_thunk.bx>  
  0x00000596 <+20>:    add    ebx,0x1a3e  
  0x0000059c <+26>:    mov    eax,ecx  
  0x0000059e <+28>:    mov    eax,DWORD PTR [eax+0x4]  
  0x000005a1 <+31>:    add    eax,0x4  
  0x000005a4 <+34>:    mov    eax,DWORD PTR [eax]  
  0x000005a6 <+36>:    sub    esp,0xc  
  0x000005a9 <+39>:    push   eax  
  0x000005aa <+40>:    call   0x54d <bowfunc>  
  0x000005af <+45>:    add    esp,0x10  
  0x000005b2 <+48>:    sub    esp,0xc  
  0x000005b5 <+51>:    lea    eax,[ebx-0x1974]  
  0x000005bb <+57>:    push   eax  
  0x000005bc <+58>:    call   0x3e0 <puts@plt>  
  0x000005c1 <+63>:    add    esp,0x10  
  0x000005c4 <+66>:    mov    eax,0x1  
  0x000005c9 <+71>:    lea    esp,[ebp-0x8]  
  0x000005cc <+74>:    pop    ecx  
  0x000005cd <+75>:    pop    ebx  
  0x000005ce <+76>:    pop    ebp  
  0x000005cf <+77>:    lea    esp,[ecx-0x4]  
  0x000005d2 <+80>:    ret       
End of assembler dump.
```

Находим что  инструкции `call` который вызывает `bowfunc` в `main` -   **0x000005aa** 

