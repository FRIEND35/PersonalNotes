 
# Вступление

Кибербезопасность — одна из самых быстро развивающихся областей технологий, и ставки высоки. Ошибки могут быть порядка миллионов долларов. Компьютеры вторглись во все аспекты нашей повседневной жизни. Хотя это означает, что я могу получить доступ к миллионам изображений кошек одним нажатием кнопки, опасно предполагать, что каждый, кто пользуется компьютером, любит пушистых кошачьих. Кредитные карты, пароли и номера социального страхования распространяются по Интернету так же быстро, как и изображения кошек, но с прибыльным черным рынком. Успешный взлом может принести много пользы, и хакеры сделают все возможное,
чтобы взломать системы, на которые мы полагаемся и которые мы используем ежедневно. От высокотехнологичных эксплойтов, таких как Spectre и Meltdown 2018 года, до низкотехнологичных эксплойтов, таких как фишинг и социальная инженерия, нам, разработчикам, важно знать, как злоумышленники могут получить доступ к нашим системам.

Наша ежедневная работа по развитию выполняется в мире абстракций. Программное обеспечение, которое мы создаем сегодня, опирается на существующее программное обеспечение и технологии. Мы не начинаем с нуля каждый раз, когда начинаем создавать приложение. Нам не часто приходится беспокоиться о тонкостях управления памятью или об отдельных пакетах, которые мы отправляем с каждым HTTP-запросом, но поскольку это основа современных вычислений, уязвимость на одном уровне делает уязвимыми все, что выше этого уровня. В этом посте мы покинем наш уютный мир IDE и автоматической сборки мусора и погрузимся в мир переполнения буфера. 

Впервые задокументированные в 1972 году, переполнения буфера использовались как часть нескольких громких инцидентов компьютерной безопасности, таких как червь Морриса (1988) и Code Red (2001). Червь Морриса — один из первых компьютерных вирусов, который привлек внимание средств массовой информации во всем мире и использовал переполнение буфера, обнаруженное в обычной программе Linux, для заражения других компьютеров. В отчетах говорится, что было заражено около 6000 компьютеров (что в 1988 году составляло примерно 10% всего Интернета). Code Red также распространялся, используя уязвимость переполнения буфера,
однако этот червь был нацелен на неисправленные версии IIS, веб-сервера Microsoft. На пике было заражено 359
000 компьютеров. Оба этих вируса серьезно нарушили работу Интернета в то время, и потребовались тысячи
часов, чтобы изолировать и устранить ущерб.

# Обзор

Переполнение буфера происходит, когда программа пытается поместить слишком много данных в зарезервированную область памяти. Эти зарезервированные области называются буферами. Так же, как когда вы переполняете чашку кофе, все, что не может вместиться, должно куда-то идти. Кофе «переливается» на прилавок, закрывая все, что находится рядом. Та же идея применима и к памяти компьютера – память рядом с буфером будет перезаписана тем, что не поместилось! Но каковы последствия этого? Как мы можем перейти от грязной столешницы к компьютерному червю? Как я уже упоминал, все, что мы не можем поместить в этот буфер, перезапишет память рядом с ним. Что, если что-то рядом с буфером было важным? Что, если бы мы могли заменить некоторые данные, которые уже существуют в программе, нашими собственными данными? Мы можем изменить переменные на все, что захотим! Вот где скрывается опасность (и веселье). Злоумышленник может изменить то, что делает наша программа. Чтобы понять, как этого можно достичь, мы должны надеть наши шляпы по информатике 101 и просмотреть то, что мы узнали о памяти.

# Память

Память компьютера — это место, где любые запущенные в данный момент процессы хранят информацию, такую как переменные, а также место, где находится наш код, разбитый на мельчайшие отдельные шаги, понятные компьютеру (называемые инструкциями). Представьте себе память в виде башни из блоков Дженга. Внизу у вас есть блок номер 0, блок выше, который является блоком номер 1, и так далее. Каждое из этих чисел называется адресом этого блока памяти. С адресом памяти мы можем быстро перейти к этому месту в памяти и посмотреть, что там хранится в любое время (при условии, что память, к которой мы обращаемся, не принадлежит другой программе).
Возможность легко получить доступ к заданной ячейке памяти дает возможность организовать память, не беспокоясь о том, где физически хранится информация. Почти так же, как при записи маршрута к дому вашего друга, нам нужно только запомнить адрес, который мы хотим посетить в будущем.

Память организована в разные разделы, каждый из которых предназначен для определенной цели. В этой серии мы поговорим о текстовом разделе и стеке. В текстовом разделе компьютер будет хранить любые исполняемые инструкции (наш код). Счетчик программ (PC на диаграмме 1) — это адрес памяти следующей инструкции, которая должна быть выполнена. Каждый раз, когда процесс выполняет инструкцию, программный счетчик увеличивается или модифицируется, чтобы указать на следующую инструкцию. Наш код не  обязательно выполняется сверху вниз — у нас есть циклы, условные операторы и функции, к которым нам нужно перейти. Счетчик программ делает это возможным, отслеживая, где мы находимся и что делаем в данный момент.

Стек фактически является «рабочей памятью» компьютера. Здесь компьютер отслеживает значения и функции, которые выполняются в данный момент. Стек начинается с самого высокого адреса памяти и растет вниз к более низким адресам памяти. Каждый раз, когда мы входим в функцию, мы помещаем данные на вершину стека, и каждый раз, когда мы возвращаемся из функции, мы удаляем эти данные с вершины стека. Указатель стека (SP на диаграмме 1) всегда указывает на вершину стека и будет корректироваться каждый раз, когда мы добавляем или удаляем данные. 

Указатель стека всегда будет указывать на самые последние добавленные данные. Данные, добавленные в стек, на самом деле представляют собой группу данных, связанных с функцией, которая выполняется в данный момент. Здесь будут храниться любые локальные переменные, аргументы функции и т. д. на время работы функции. Эта группа данных называется кадром стека. Как минимум, в каждом кадре будет храниться адрес возврата или адрес инструкции, которая должна быть выполнена после завершения текущей функции. Когда наш код переходит к другой функции, нам нужно каким-то образом удерживать свое место. Это работа адреса возврата в кадре стека, чтобы временно отметить нашу исходную позицию. Когда мы завершаем выполнение функции и удаляем соответствующий кадр стека, программный счетчик становится равным адресу возврата, хранящемуся в только что удаленном кадре. Таким образом, последующая инструкция в нашем коде выполняется независимо от того, где она физически хранится в памяти.

![[Pasted image 20230612064931.png]]


Диаграмма 1: Схема памяти

**Это прекрасно и денди, но как это позволяет мне взломать компьютер?

Итак, мы знаем, что можем переполнить буфер и перезаписать соседние данные, знаем, где в памяти хранятся буферы, и знаем, как выглядит эта память. Но в чем подвиг? Поскольку буфер, который мы собираемся переполнить, хранится в стеке во фрейме стека своей функции, объем того, чем мы можем манипулировать, несколько ограничен. Наш кофе прольется только на прилавок возле кружки. То, что находится рядом с нашей кружкой, первым будет покрыто кофе. Рядом с нашим буфером хранится адрес возврата — место, откуда компьютер будет считывать следующие инструкции. Мы сможем переполнить буфер и изменить то, что программа пытается сделать!

Ранее я упоминал, что мы не можем получить доступ к памяти, которая не принадлежит нашей программе. Между программами и физической памятью существует уровень безопасности, который не позволяет нам следить за тем, что делают другие программы. Мы также не можем изменить текстовый раздел — обычно он доступен только для чтения, чтобы предотвратить изменение текущего кода. На первый взгляд кажется, что наши возможности того, что мы можем сделать с обратным адресом, довольно ограничены. Тем не менее, любая память, принадлежащая текущей запущенной программе, по-прежнему является честной игрой. Если бы мы только могли вставить в нашу программу собственные инструкции! Если бы мы знали, что где-то в памяти есть инструкции, которые мы хотим выполнить следующими, мы могли бы заменить адрес возврата адресом нужных инструкций. 

Оказывается, это то, чем мы собираемся заполнить буфер! Мы можем заполнить этот буфер инструкциями для компьютера, чтобы открыть новую оболочку (или терминал, или командную строку). Демонстрация во второй части будет посвящена Linux, поэтому мы сосредоточимся на оболочке). У нас был бы почти полный контроль над компьютером, если бы мы могли открывать оболочку, когда захотим. Все программы запускаются с набором разрешений, и любая новая программа, созданная существующей программой, будет иметь те же разрешения. Если программа, которую мы атакуем, запущена с правами root или администратора, наша новая оболочка также будет иметь эти права. Наличие прав администратора на целевом компьютере позволит нам создавать учетные записи, устанавливать новое программное обеспечение (например, вирус) или просто удалять все! Когда программа запрашивает у пользователя какие-либо входные данные, не устанавливая ограничения на объем принимаемых данных, мы можем переполнить буфер и использовать эту уязвимость с нашими тщательно обработанными входными данными. Нам нужно, чтобы содержимое нашего буфера выглядело так же, как это был текстовый раздел памяти. Нам нужно будет хранить инструкции любого кода, который мы хотим запустить. Однако нам не нужно
беспокоиться об этом до второй части. Просто знайте, что введенный код будет инструкциями, понятными компьютеру, чтобы открыть оболочку. Если мы изменим адрес возврата на адрес памяти нашего буфера, где хранится введенный нами код, тогда компьютер будет считать, что внедренный нами код должен быть выполнен следующим (см. Диаграмму 2). Мы обманываем компьютер, заставляя его думать, что он выполняет следующую часть программы, но вместо этого мы даем свои собственные инструкции!

![[Pasted image 20230612065122.png]]

Диаграмма 2: Переполнение буфера внедренным кодом и замена RA (адреса возврата) адресом внедренного кода.

Как только хакер получает доступ к оболочке с корневым доступом, он получает полную свободу действий, пока не будет обнаружен. Согласно Black Report от Nuix за 2018 год , опросу известных хакеров, большинству хакеров требуется всего 15 часов, чтобы взломать, идентифицировать ценные данные и украсть их. Это невероятно малое время для обнаружения атаки, не говоря уже об изоляции и решении проблемы. Переполнение буфера требует некоторых технических знаний, но, по сравнению с другими эксплойтами, не очень сложно и сравнительно легко реализуется. Но надежда не потеряна! Их легко предотвратить с помощью сочетания безопасности на уровне операционной системы и методов безопасного кодирования. Разработчики должны знать, как работают эти уязвимости и что мы можем сделать, чтобы их предотвратить. Во второй части я расскажу о некоторых способах, которыми операционная система предотвращает атаки с переполнением буфера, о том, как разработчики могут защитить свой собственный код, и, самое главное, мы расскажем, как на самом деле использовать эту уязвимость! 

---
# Прежде, чем мы начнем

Прежде чем мы начнем, мы должны выбрать цель. Существует несколько методов обнаружения потенциальных  переполнений буфера, от ручного чтения кода до автоматического тестирования. Предполагая, что у вас есть исходный код программы, поиск небезопасных функций в стандартной библиотеке C является базовой, но отличной отправной точкой. Такие функции, как strcat () и strcpy () не проверяют длину входных строк относительно размера целевого буфера - это именно то условие, которое мы хотим использовать. Безопасное использование этих функций полностью зависит от реализации программиста. 

Получение исходного кода для нескольких программ и поиск уязвимостей может быть утомительным занятием.
Ради экономии времени, здравомыслия и защиты авторских прав мы атакуем базовую программу, созданную для
этой демонстрации. Ознакомьтесь с исходным кодом overfow.c ниже:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerableFunc(char* input) {
   char buffer[80];
   strcpy(buffer, input);
}

int main(int argc, char** argv) {
   if (argc != 2) {
   printf("Arguments: <buffer input>\n");
   exit(1);
}
vulnerableFunc(argv[1]);
   printf("Exiting...\n");
   exit(0);
}
```

Программа принимает один аргумент и передает его в weakFunc(), которая создает буфер и копирует в него аргумент. Затем программа напечатает «Exiting…» и завершит работу. Это не увлекательная (или полезная) программа, но она определенно небезопасна! Вызов strcpy () в строке 7 - это то, что мы собираемся использовать - обратите внимание, как разработчик не проверил длину того, что копируется в буфер. 

Я упоминал ранее, что этот пример будет сильно упрощен по сравнению с реальным примером. В большинстве операционных систем и компиляторов по умолчанию включены определенные функции для предотвращения переполнения буфера. Отключение функций безопасности на вашем обычном компьютере обычно является довольно плохой идеей, поэтому я буду делать эту демонстрацию в контейнере Docker с 64-битным образом Ubuntu. Ближе к концу поста я более подробно расскажу о настройке среды и некоторых функциях, предназначенных для предотвращения этих эксплойтов.

# Что мы будем делать сегодня вечером, Брэйн?

Прежде чем мы начнем слепо заниматься проблемой, давайте составим план игры. Если вы помните из части первой: мы хотим заполнить буфер каким-то вредоносным кодом, переполнить буфер за пределами конца и перезаписать адрес возврата для текущей функции, чтобы он указывал обратно на буфер (и, следовательно, на наш код). Мы можем разбить это на несколько шагов:

1. Найдите размер буфера
2. Найдите адрес буфера
3. Найдите обратный адрес
4. Замените адрес возврата адресом буфера
5. Заполните буфер вредоносным кодом
6. Эксплуатация!

Хорошая новость в том, что мы уже добились прогресса - мы знаем размер буфера, глядя на исходный код! буфер определяется как массив символов размером 80. Первый шаг был довольно простым, насколько сложным может быть все остальное?



# Ткните его палкой

Мы должны с чего-то начать. Посмотрим, что произойдет, когда вы запустите программу в обычном режиме. Я собираюсь использовать в качестве аргумента последовательность «А». На этом этапе аргумент на самом деле не имеет значения, но использование повторяющегося символа будет полезно. Вы скоро поймете почему. Мы запустим программу дважды, один раз с менее чем 80 А, а другой с большим. 

![[Pasted image 20230612070026.png]]

Первое выполнение прошло, как и ожидалось, мы видим сообщение «Exiting…», напечатанное на консоли. Но второе выполнение завершилось сбоем и напечатало «Ошибка сегментации». Обычно это не лучший знак при кодировании, но для нас это хорошая новость! Ошибка сегментации - это ошибка, возникающая, когда программа пытается получить доступ к ограниченной памяти. Единственное, что изменилось между первым и вторым вызовом переполнения, - это наш ввод - очевидно, что во второй раз произошло что-то, что заставило нашу программу попытаться получить доступ к запрещенной памяти. Чтобы понять, что происходит, нам нужно вкратце взглянуть на отладку кода C с помощью GNU Debugger (GDB).


# Территория GNU

Если вы не знакомы с GDB, оставшаяся часть этой статьи, вероятно, покажется довольно пугающей. Я обещаю, что это не так страшно и чуждо, как кажется - GDB такой же отладчик, как и любой другой. Мы будем устанавливать точки останова, просматривать содержимое переменных и проходить код построчно, как мы привыкли, только без красивого пользовательского интерфейса. Начнем с отображения weakFunc () и установки нескольких точек останова.

![[Pasted image 20230612070123.png]]

Мы собираемся остановиться на строке 7 и строке 8, непосредственно перед и сразу после того, как мы скопируем наш ввод в буфер. Давайте запустим нашу программу в GDB с «AAAA» в качестве входных данных. Мы остановимся непосредственно перед копированием чего-либо в буфер, чтобы можно было посмотреть содержимое. 

![[Pasted image 20230612070144.png]]

Хорошо, давайте рассмотрим это по крупицам. Мы запустили нашу программу в GDB с запуском AAAA, который затем достиг нашей первой точки останова в строке 7. Вторая команда x / 128bx buﬀer отображает 128 байтов в виде шестнадцатеричных символов, начиная с того места, где буфер хранится в памяти. В крайнем левом столбце отображается адрес памяти, в котором находится первый столбец. Итак, в нашем примере буфер начинается с адреса памяти 0x7ﬀﬀﬀfe600, а первые восемь байтов равны 0x00. Посмотрим, что произойдет после вызова strcpy () . Команда continue возобновит выполнение программы, чтобы мы могли перейти к следующей точке
останова. 

![[Pasted image 20230612070212.png]]

У нас есть данные! Первые четыре значения буфера теперь равны 0x41. Это может показаться ничем, но 0x41 - это то, как ASCII-символ A представлен как шестнадцатеричное значение. Наш буфер начинает заполняться. Из исходного кода мы знаем, что буфер представляет собой массив из 80 символов. Каждый символ - это байт, поэтому мы должны без проблем заполнить 80 байтов. Давайте снова запустим программу, на этот раз с 80 А, и посмотрим, как будет выглядеть наша память после strcpy() возврата.

![[Pasted image 20230612070245.png]]

Надеюсь, это имеет некоторый смысл, почему единственный ввод, который мы даем, - это последовательность А. Это делает это довольно очевидным в памяти! Похоже, что буфер начинается с адреса 0x7ﬀﬀﬀfe5c0 и заканчивается по адресу 0x7ﬀﬀﬀfe610 , который находится на расстоянии 80 байт. Эти адреса могут измениться, когда мы запустим программу, но это не будет проблемой. На данный момент нас не интересует, где хранятся определенные значения, мы хотим знать расстояние между этими значениями. Независимо от того, где хранится наш буфер, он всегда заканчивается на 80 байт позже.

Если все, что находится выше фиолетовой линии, является нашим буфером, что хранится под линией? Мы знаем, что хотим, чтобы наш буфер был переполнен, чтобы мы могли перезаписать там данные, но что именно? Здесь важна концепция стековых фреймов. Если вы помните из прошлого раза, кадр стека содержит некоторые данные о том, откуда была вызвана наша функция, аргументы и адрес возврата. Цель состоит в том, чтобы перезаписать адрес возврата, чтобы мы могли контролировать дальнейшие действия программы. GDB упрощает это с помощью команды информационного фрейма . Давайте снова запустим программу (используя наши 80 A) и посмотрим, какую информацию мы сможем собрать. Контейнер [[Database/00. SECTIONS/20. Linux (OS)/23. DevOps/23-00. DET (DevOps engineer tools)/Docker/README|Docker]] работает под управлением 64-разрядной версии Ubuntu,
в которой указатель инструкции хранится в регистре, называемом rip.

![[Pasted image 20230612070706.png]]

Посмотри на это! GDB не только сообщает нам значение rip ( 0x55555555472a ), но также сообщает нам, где оно хранится в памяти ( 0x7ﬀﬀﬀfe618 ). Но где это относительно буфера?

![[Pasted image 20230612070724.png]]

Мы видим буфер по адресу 0x7ﬀﬀﬀfe5c0 и видим адрес возврата по адресу 0x7ﬀﬀﬀfe618 , как и обещал GDB. Обратите внимание, как адрес в памяти меняется на противоположный по сравнению с тем, как он отображается GDB. Компьютер, который я использую, использует порядок байтов с прямым порядком байтов, что очень упрощенно означает, что он хранит данные в обратном порядке. Не зацикливайтесь на том, что это на самом деле означает, просто помните, что адрес в памяти будет перевернут, когда он будет использоваться. Похоже, адрес буфера изменился с момента последнего запуска программы! Хорошая новость заключается в том, что адрес возврата всегда будет на одинаковом расстоянии от конца буфера. Выполнение шестнадцатеричной математики:
   
   0xe618 - 0xe5c0 = 0x58 -> 88(10)
   
Нахождение разницы между адресами и преобразование ее в десятичное показывает, что адрес возврата сохраняется через 88 байт после начала буфера . Поскольку для буфера выделено 80 байтов, оставшиеся 8 байтов переполнятся и окажутся рядом с адресом возврата. В 64-битных операционных системах все адреса памяти используют 64 бита (8 байтов). Если бы мы предоставили 96 символов, мы бы заполнили буфер, переполнились, так что мы приблизились к адресу возврата, а затем перезапишем весь адрес возврата. Посмотрим на буфер при копировании 96 А.

![[Pasted image 20230612070814.png]]

информационный фрейм показывает нам, что адрес возврата хранится по адресу 0x7ﬀﬀﬀfe608 , но посмотрите, что находится в памяти! Мы успешно перезаписали обратный адрес. Когда наша функция завершится, программа обратится к 0x7ﬀﬀﬀfe608, определить, чтобы какую инструкцию выполнить следующей. Но вместо исходного местоположения он попытается перейти по адресу 0x4141414141414141 . Шансы на то, что в этом месте есть что-нибудь полезное, довольно малы. Мы изменим адрес возврата, чтобы он был равен адресу буфера, чтобы мы могли предоставить наш собственный код для запуска.

# Вернуть отправителю

У нас есть последовательность из 96 А, где последние 8 заменяют адрес возврата, хранящийся в стеке. Нам нужно изменить эти 8 байтов на адрес буфера . Если адрес буфера является 0x7ﬀﬀﬀfe5b0 , мы должны расколу что в отдельных байтах, обратить его (прямой порядок байтов порядок байтов!), И поместить его в аргументе. Следует отметить одну сложную вещь: GDB удаляет ведущие нули для адресов памяти. Наш адрес состоит всего из двенадцати шестнадцатеричных значений, что составляет всего шесть байт. Поскольку адреса памяти на этом компьютере действительно имеют длину 8 байтов, мы добавим недостающие нули, чтобы убедиться, что наш адрес
работает.

```hex
   0x00007ﬀﬀﬀfe5b0
   0x00 0x00 0x7f 0xﬀ 0xﬀ 0xﬀ 0xe5 0xb0
   0xb0 0xe5 0xﬀ 0xﬀ 0xﬀ 0x7f 0x00 0x00
   \xb0\xe5\xﬀ\xﬀ\xﬀ\x7f\x00\x00
   ```

Компьютер будет интерпретировать символы, которым предшествует «\ x», как шестнадцатеричные вместо
обычных символов ASCII. В этом разница между восприятием «А» как значения в памяти и «41». Наша входная
строка теперь выглядит так:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7\x7\x7\x7\x7\x7\x7
```

Давайте проверим, успешно ли это заменило обратный адрес:

![[Pasted image 20230612071239.png]]

Адрес памяти, где хранился указатель инструкции, теперь содержит обратный адрес буфера , отлично! Когда наша функция завершится, программа перейдет в наш буфер, чтобы попытаться найти следующие инструкции для выполнения, но «AAAAAAAA» вряд ли является полезной инструкцией. Далее мы создадим наш вредоносный код. 


# Шеллкод

Вредоносный код, который мы вставляем в буфер, имеет одну цель - открыть для нас оболочку. Так родилось креативное название «шеллкод». Стандартная библиотека C имеет несколько функций, которые могут создавать новые процессы, но мы сосредоточимся на execve () . Он принимает три аргумента: путь к программе, массив аргументов для передачи этой программе и массив настроек среды. Используя эту информацию, он заменит текущий запущенный процесс любой программой, которую вы ему прикажете запустить. Это означает, что всего после вызова execve () не происходит! Полностью заменен в памяти. Посмотрите на пример кода ниже.

```c
#include
#include
#include

main()
{
char* argv[] = {"/bin/sh", NULL};
char* env[] = {"FLAG=1", NULL};
execve(argv[0], argv, env);
printf("execve failed");
}
```

Теперь давайте создадим этот код и посмотрим, что он делает:

![[Pasted image 20230612071415.png]]

Сразу после запуска программы появляется пустая строка с подсказкой «#». Это новая оболочка! Он ничем не отличается от оболочки, которую мы только что использовали для запуска нашей программы. Когда мы выходим из этой оболочки, мы возвращаемся туда, где мы были при первоначальном запуске нашего шелл-кода. Обратите внимание, что мы нигде не видим «execve failed» на консоли - эта строка была заменена успешным вызовом execve() . Это функция, которую мы собираемся использовать для перехвата уязвимой программы.


# Требуется некоторая сборка

К сожалению, это не так просто, как скопировать и вставить наш код во входные данные программы - нам нужно получить инструкции, понятные процессору. При компиляции кода существует промежуточный этап между читаемым человеком текстом и исполняемой программой, на котором мы можем просмотреть фактический машинный код. 

Однако здесь есть две проблемы. Первое: шаги по поиску этих инструкций различны для каждого компилятора. Это затрудняет написание хорошего пошагового руководства! Вторая проблема: наш код не оптимизирован, чтобы занимать как можно меньше места. Инструкции для примера шелл-кода занимали несколько сотен байтов памяти, намного больше, чем наш буфер мог вместить. Мы решим обе эти проблемы так, как могли бы только программисты - смотря онлайн! веб сайта Шелл-шторм - шелл- управляется исследователем безопасности, который скомпилировал несколько версий кодов, оптимизированных для переполнения буфера. Я буду использовать
найденную 27-байтовую версию[[ http://shell-storm.org/shellcode/files/shellcode-806.html| здесь]] . Инструкции, преобразованные в шестнадцатеричные символы, выглядят так:


```
\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xﬀ\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05
```

Теперь нам нужно обновить нашу строку атаки, чтобы программа могла найти наши инструкции, когда она пытается прочитать наш буфер! Наша строка атаки в настоящее время выглядит так:

```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x7\x7\x7\x7\x7\x7\x7
```

Нам нужно убедиться, что общий размер нашей строки остается неизменным, чтобы адрес возврата был
перезаписан. Если мы собираемся добавить 27 байтов, нам нужно удалить 27 A. Последняя строка атаки выглядит
так:

```
\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xﬀ\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xb0\xe5\xﬀ\xﬀ\xﬀ\x7f\x00\x00
```

Запускаем программу еще раз:

![[Pasted image 20230612075608.png]]

Мы видим, что код был вставлен прямо там, где буфер, начинается и наш адрес возврата указывает на буфер. Осталось только посмотреть, работает ли это! 



# То же самое, что мы делаем каждую ночь, Пинки - попытайся захватить мир!

Выполнение команды whoami распечатает ваше имя пользователя. На этой машине используемая учетная запись тонко называется «хакер». Давайте запустим программу еще раз и посмотрим, что будет.  

![[Pasted image 20230612075725.png]]

Я начинал как «хакер», запустил программу, и теперь у меня открыта оболочка как пользователь root! Может показаться, что это не так уж много, но для подготовленного хакера открывает множество возможностей. Ни один из известных эксплойтов переполнения буфера, упомянутых в прошлой статье, не был просто переполнением буфера - это было как раз подходящим вариантом. Отсюда мы могли установить кейлоггер, украсть данные на сервере или начать рассылать действительно надоедливые спам-письма!

# Не обращайте внимания на этого человека за занавеской.

Теперь, если вы сидите и думаете: «Ого, вы можете научить кого-нибудь взламывать после одного сообщения в блоге, нет ничего безопасного», позвольте мне ответить на некоторые из ваших проблем и показать вам, что я скрывал за кулисами. Короче говоря, на обычном компьютере это не сработает. При подготовке этой демонстрации я отключил множество функций безопасности.

Когда я запускал образ Docker, мне нужно было предоставить два флага: –privileged , чтобы предоставить контейнеру полный доступ к устройствам и памяти хост-машины, и –security-opt seccomp = undeﬁned , чтобы снять любые ограничения безопасности, наложенные на контейнер. После запуска контейнера мне пришлось отключить функцию операционной системы под названием Address Space Layout Randomization, или ASLR. ASLR позволяет операционной системе рандомизировать, где программы загружаются в память. Помните, как в какой-то момент адрес буфера немного изменился ? Это происходило бы каждый раз, когда мы запускали программу, что значительно затрудняло бы успешное изменение обратного адреса. 

Мне также пришлось предоставить компилятору параметры для отключения некоторых функций, которые он предоставляет по умолчанию. Первым был флаг –z execstack . Это позволяет программе выполнять любые инструкции, которые находятся в стеке. Если бы мы оставили это включенным, наша программа вылетела бы, даже если бы мы использовали правильную строку атаки - она не смогла бы выполнить шелл-код. Другая функция была отключена с помощью –fno-stack-protector . Эта функция определяет, были ли какие-либо переполнения в стеке, добавляя скрытое рандомизированное значение в каждый кадр стека и проверяя значение в начале и в конце каждой функции. Если это значение изменяется после запуска функции, но до ее возврата, программа знает, что произошло переполнение, и уже небезопасно предполагать, что следующая инструкция должна быть выполнена.


# Конец линии

Мы перешли от чистой теории к простому рабочему эксплойту в двух сообщениях в блоге. Возможно, переполнение буфера не является самой серьезной проблемой безопасности в 2019 году, но оно действительно случается, и его несложно использовать. Программисты придумали решения на уровне операционной системы и компилятора, но единственный верный способ защиты от переполнения буфера (и большинства уязвимостей) сводится к безопасным методам программирования. Единственный оператор if, чтобы убедиться, что буфер
достаточно велик, сделает эту атаку невозможной.