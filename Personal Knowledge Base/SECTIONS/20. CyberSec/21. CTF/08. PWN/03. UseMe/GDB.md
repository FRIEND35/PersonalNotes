Отладчиком называется программа, которая выполняет внутри себя другую программу. Основное назначение отладчика - дать возможность пользователю в определенной степени осуществлять контроль за выполняемой программой, т.е. определять, что происходит в процессе ее выполнения. Наиболее известным отладчиком для Linux является программа GNU GDB, которая содержит множество полезных возможностей, но для простой отладки достаточно использовать лишь некоторые из них.

Программа gdb - это популярный отладчик для программ, написанных на языке программирования Си и С++. Отладчик позволяет выполнить программу пошагово, посмотреть значения всех переменных на каждом из этапов выполнения, а если это необходимо, то и дизассемблировать код и посмотреть состояние регистров процессора.

Когда вы запускаете программу, содержащую ошибки, обнаруживаемые лишь на стадии выполнения, возникают несколько вопросов, на которые вам нужно найти ответ:

- Какое выражение или оператор в программе вызывает ошибку?
- Если ошибка возникает в результате вызова функции, в каком месте программы происходит этот вызов?
- Какие значения содержат переменные и параметры программы в определенной точке ее выполнения?
- Что является результатом вычисления выражения в определенном месте программы?
- Каков действительный порядок выполнения операторов программы?

Эти действия требуют, чтобы пользователь отладчика был в состоянии:

1. проанализировать данные программы;
2. получить трассу - список вызовов функций, которые были выполнены, с сортировкой, указывающей, кто кого вызывал;
3. установить точки останова, в которых выполнение программы приостанавливается, чтобы можно было проанализировать данные;
4. выполнять программу по шагам, чтобы увидеть, что в действительности происходит.

Программа GDB предоставляет все перечисленные возможности. Она называется отладчиком на уровне исходного текста, создавая иллюзию, что вы выполняете операторы C++ из вашей программы, а не машинный код, в который они действительно транслируются.

Всякий раз, когда ваша программа работает неверно (выдает неверный ответ, или ошибку во время исполнения программы), на помощь вам прийдет отладчик GDB (Gnu debugger). Он позволяет подробно изучить ход выполнения программы, исполняя ее пошагово и просматривая значения переменных.


# Основные команды

## Запуск

Общий синтаксис выбора исполняемого файла для анализа

```
gdb program_name
```


Запустить выполнение программы

```
run | r
```


Присоединиться к gdbserver

```
target remote host:port
```
  

Присоединиться к процессу, отключиться от него

```
attach PID / detach
```
  

Выйти из gdb  

```
quit | q
CTRL + D
```


Показать исзодный код

```
list | l
```



## Статический анализ

Выбрать синтаксис ассемблера

```
set disassembly-flavor intel/att
```



### Извлечение информации

Команда **info** даст нам информацию об исполняемой программе.

Получение списка функций

```
info functions | i func
```


Посмотреть список точек останова

```
info break | b
```

Информация об аргументах функции, локальных переменных (для файлов, содержащих отладочную информацию) и фрейме текущей функции

```
info args
info locals
info frame
```

  
Просмотреть список процессов и выбрать интересующий

```
info threads
thread number
```


Просмотреть информацию об архитектуре, секциях

```
info file 
```

  
Получение asm-листинга функции

```
disas func_name
disas address 
```

  
Если у вас есть исходники (можем собрать с опцией -g3 для gcc) или исследуемая программа содержит отладочную информацию, можем посмотреть листинг ее исходного кода

```
list func_name
```



### Динамический анализ

Установить аргументы для каждого запуска программы и посмотреть их

```
set args
show args
```

  
Распределение виртуальной памяти

```
info proc mappings
```

  
Просмотр регистров

```
info registers
```

Или же:

```
registers
```



## Отладка

  
Шаг с заходом в функцию

```
step | s
```

  
Шаг с прыжком через вызываемую подпрограмму

```
next | n
```

  
Выполнить до нужной строки, адреса

```
until | u number_of_list_string
until | u *func_name+offset
until | u *address
```


### Точка останова/контрольная точка

Команда **break** позволяет нам установить breakpoint на указанном месте.
 
Способы расстановки breakpoints

```
b func_name
b *func_name+offset
b *address
```

Включить или отключить, удалить breakpoint

```

disable/enable breakpoint_number
delete breakpoint_number
ignore breakpoint_number n  //  остановится на этой точке пройдя ее n раз
```


Если программа завершилась с ошибкой, вы можете вывести стек вызовов функций для того чтобы узнать в какой именно функции возникла ошибка:

```
(gdb) backtrace
```

Программа сообщает на какой строчке исходного кода возникла проблема. Чтобы посмотреть весь исходник выполните команду list:

  
Продолжить выполнение до следующего breakpoint-а

```
continue | c
```

  
Просмотр стека

```
telescope
telescope $rsp+64
```


### Просмотр памяти
  
Для отображения значения по указанному адресу используется команда x, где через "/" указывается формат вывода

```
x/i - инструкция
x/x - hex
x/s - строка
x/a - адрес
х/с - символ
x/d - десятичный
x/f - число с плавающей запятой
x/o - восьмиричный
```

  
а также размер вывода

```
x/b - 8-bit
x/h - 16-bit
x/w - 32-bit
x/g - 64-bit
```

  
Пример

```
x/64bx
x/i $pc
```

  
Передача аргумента командной строки

```
run $(python -c "print('A'*32 + '\xde\xad')")
run $(echo "asdf\\xde\xad")
```

  
Для передачи значений функциям ввода

```
run <<< $(python -c "print('A1'*3)")
run <<< $(echo "asdf\xde\xad")
```

  
## Gdb Сервер

Запустить сервер gdb для отладки

```
gdbserver host:port program
```

  
## Reverse Debug

Все мы проходили через этот неловкий момент когда во время отладки мы проскочили интересующую нас функцию, и теперь снова надо перезапускать отладчик, проходить тот же путь на CFG и т.п. Чтобы избежать этого, в gdb есть такая фишка как Reverse Debug, позволяющая сохранить состояние программы и обратно отладить до него.

  
Для этого, после запуска отладчика укажем gdb, что хотим начать использовать reverse debug и стоит сохранять состояния программы

```
record
```

  
После этого станут доступны следующие команды

```
reverse-step
reverse-next
```

  
## Создание дампа

Сдампить участок памяти ( часто необходимо при работе с распаковщиками )

```
dump memory output_file start_addr end_addr
```

  
## Настройка для работы

Для того чтобы закрепить вывод команды, скажем просмотр инструкций во время отладки и отображения регистров можно воспользоваться командой display

```
display/5i $pc
display/g $rax
display/g $rbx
display/g $rcx
```

  
## Делаем жизнь проще с GEF

Для эффективного использования gdb лучше воспользоваться плагином [gef](https://github.com/hugsy/gef), он уже включает в себя удобный закрепленный вывод, используемый при динамическом анализе, а также набор собственных команд расширяющий возможности нашего универсального отладчика. Рассмотрим некоторые наиболее полезные.

Посмотреть состояние aslr, включить/отключить

```
aslr
aslr on/off
```

Для проверки исполняемого файла на наличие ASLR, Canary, PIE и т.д.

```
checksec
```

  
Посмотреть чанки

```
heap chunks
```


Находясь в функции можем получить значение канарейки и адрес, где она расположена

```
canary
```

  
Чуть более удобный вывод, чем info proc mappings

```
vmmap
```

  
Просмотр регистра флагов и изменение их

```
flags
flags -Flag_name +Flag_name
```


Помощь для поиска уязвимостей форматной строки (установка на них точек останова, информация по найденным функциям)

```
format-string-helper
```

  
Создание паттерна и его поиск

```
pattern create 128
pattern search 0x61616167
pattern search $rbp
```



Поиск строк по шаблону

```
search-pattern pattern
```

  
## Патчинг

```
patch byte/word/dword/qword address value
```


Печать массива в формате удобном для копирования в python код. Параметр b должен быть 8/16/32/64, l контролирует длину массива

  
Пример

```
print-format -b 64 -l 1  $rsp
```

  
Для поиска шеллкода по шаблону

```
shellcode search pattern
shellcode get shellcode_number
```

  
Ксорим значения в памяти и регистрах

```
xor display address/register size xor_key
xor patch address/register size xor_key
```



```
run or r –> executes the program from start to end.  
break or b –> sets breakpoint on a particular line.  
disable -> disable a breakpoint.  
enable –> enable a disabled breakpoint.  
next or n -> executes next line of code, but don’t dive into functions.  
step –> go to next instruction, diving into the function.  
list or l –> displays the code.  
print or p –> used to display the stored value.  
quit or q –> exits out of gdb.  
clear –> to clear all breakpoints.  
continue –> continue normal execution.
```


Самая распространенная ошибка, которую я вижу, это то, что люди воспринимают GDB как автономный инструмент отладчика. Я предлагаю вам думать о GDB как о структуре отладчика, которая позволяет вам создавать свои собственные инструменты. Или вы можете использовать готовые инструменты. Мой любимый инструмент на основе GDB — Peda. Его довольно легко установить, просто следуйте инструкциям по установке из репозитория Peda: [https://github.com/longld/peda.](https://github.com/longld/peda)


## Пример программы

Я буду использовать эту простую программу в качестве цели отладки:

```c
#include <stdio.h>

int main() {
   int x = 5;
   printf("x = %d\n", x);
   x = x + 5;
   printf("x = %d", x);
   return 0;
}
```


Этот код создает локальную переменную X в стеке, выводит ее значение на консоль, затем добавляет к X 5 и снова выводит ее значение. Довольно просто, как раз то, что нам нужно для нашего обучающего примера.

### Первые шаги по отладке программы

Чтобы открыть файл в GDB, введите в консоли «gdb [имя файла]». GDB откроет и загрузит ваш файл. Обратите внимание, что выполнение кода не началось. Это потому, что есть отдельная команда для запуска выполнения, она называется «выполнить» или «r» для краткости.

![[Pasted image 20230624180108.png]]

И если мы его запустим, наша программа успешно завершит выполнение. Это потому, что мы еще не установили точки останова. Мы можем установить точку останова, используя имя символа, например, `break main`, или адрес: `break *0x555555555149`. Вы можете распечатать список всех ваших точек останова с помощью «информационных точек останова» и удалить их с помощью «удалить <номер точки останова>».

![[Pasted image 20230624180148.png]]

Теперь, если я выдаю команду запуска, выполнение удобно останавливается в начале «основной» функции. И просто чтобы сэкономить время, мы можем использовать команду start, которая исходит от Peda, вместо того, чтобы делать все это. Эта команда сделает всю эту работу за нас.Конечно, как и в любом другом отладчике, мы можем использовать пошаговое выполнение с помощью команды `step` или `stepi`.

И если вам нравится много делать пошагово, обратите внимание, что нажатие «Return» на пустой строке заставит GDB выполнить предыдущую команду, которую вы ввели еще раз. Кроме того, вы можете использовать команду `next` для одного шага без ввода вызовов функций. Чтобы выполнить сразу несколько инструкций, вы можете использовать команду `next <количество инструкций>`.

Если вы хотите продолжить выполнение до определенного места в программе (например, чтобы выйти из цикла), вы можете использовать команду `xuntil <адрес или функция>`.

### Изменение регистров

Чтобы изменить регистры, используйте следующую конструкцию `set $<имя регистра> = 1234`. Например, если я хочу пропустить увеличение X, я могу изменить значение регистра RIP на 0x555555555176 с помощью команды `set $RIP = 0x555555555176`.

![[Pasted image 20230624180240.png]]

Как вы могли заметить, регистры можно рассматривать как переменные в GDB. Таким образом, я могу назначить значение RIP для EAX с помощью команды `set $rip = $eax`. Теперь я могу выполнить команду `context`, чтобы заставить Peda перепечатать свое красивое контекстное «окно», чтобы убедиться, что RIP указывает на какую-то чепуху.

![[Pasted image 20230624180255.png]]

И я хочу начать выполнение с начала основной функции, я могу просто написать `set $rip = main`.

Кстати, с Peda у вас есть более быстрый способ пропустить инструкции, не выполняя их с помощью команды `skipi`.

### Изменение памяти

Модификация памяти аналогична модификации регистров в том смысле, что любая ячейка памяти может быть переменной в GDB. Итак, в моем примере я хочу изменить содержимое строки формата «x = %d». Эта строка находится по адресу 0x555555556004 в моем двоичном файле. Я могу использовать этот адрес как переменную и ввести ту же команду, что и для регистров: `set 0x555555556004 = “AAAA%d”`. Но в этом случае мы увидим сообщение об ошибке. Это потому, что вы всегда должны указывать тип переменной при изменении памяти в GDB. Итак, позвольте мне исправить мою команду на `set {char[7]}0x555555556004 = “AAAA%d”`.

![[Pasted image 20230624180324.png]]

### Печать xprint hexdump hexprint

Вы можете использовать команду x для проверки памяти. Например, если я хочу вывести 20 8-байтовых слов из указателя стека, я буду использовать команду `x/20xg $rsp`: 20 — количество слов, x — шестнадцатеричный формат, g — гигантский (8-байтовый слова).

![[Pasted image 20230624180349.png]]

Изменив второй `x` на `i`, вы можете распечатать память как инструкции.

![[Pasted image 20230624180404.png]]

Кроме того, Peda предоставляет вам удобную команду `hexdump address /count` (дамп «количества» строк, по 16 байт каждая), которую вы можете использовать… ну, для отображения шестнадцатеричного дампа.

![[Pasted image 20230624180539.png]]

И если вы хотите снова распечатать все, что показывает вам Peda (инструкции, регистры, стек и т. д.), вы командуете `context`.

### Последние мысли

Итак, сегодня мы увидели проблеск функциональности GDB. Подводя итог, я хочу, чтобы вы взяли домой 3 вещи:

- используйте Peda или другой плагин GDB, который вам подходит
- используйте команды «break» и «delete» для управления точками останова
- используйте команду «x» для печати содержимого памяти

Если у вас есть дополнительные вопросы по GDB, пожалуйста, оставьте комментарий ниже. Поставьте лайк статье, если хотите больше подобного контента. И удачного взлома, ребята.