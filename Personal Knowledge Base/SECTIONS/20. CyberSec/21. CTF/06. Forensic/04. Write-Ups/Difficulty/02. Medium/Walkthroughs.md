# Remote Password Manager

**Платформа:**  justCTF 2020

За­дачи на форен­зику (кри­мина­лис­тику) в сорев­новани­ях Capture The Flag делят­ся на нес­коль­ко боль­ших типов: ана­лиз опе­ратив­ной памяти, жес­тко­го дис­ка и иссле­дова­ние дам­пов тра­фика. В этой статье мы раз­берем задачу **Remote Password Manager** на тему ана­лиза памяти из сорев­нования JustCTF 2021, а заод­но рас­смот­рим мало­извес­тную, но очень полез­ную фиш­ку GIMP.

## Что нужно делать

Ана­лиз опе­ратив­ной памяти час­то исполь­зует­ся, ког­да у нас был физичес­кий дос­туп к машине и получи­лось снять сле­пок опе­ратив­ной памяти. По нему мож­но опре­делить, какие при­ложе­ния запус­кались во вре­мя это­го сеан­са, потому что, пока человек не вык­лючил или не перезаг­рузил компь­ютер, в опе­ратив­ной памяти хра­нит­ся инте­ресу­ющая нас информа­ция (нап­ример, дан­ные про­цес­сов).

Для ана­лиза дам­пов памяти сущес­тву­ет нес­коль­ко при­ложе­ний, которые на слу­ху у всех, кто хоть раз имел дело с задача­ми на форен­зику: это [Volatility](https://github.com/volatilityfoundation/volatility), [Memoryze](https://www.fireeye.com/services/freeware/memoryze.html) и [Autopsy](https://www.autopsy.com/) (в связ­ке с Volatility). Есть, конеч­но, и дру­гие, но под­робно мы на них оста­нав­ливать­ся не будем.

Круп­ные решения вро­де Autopsy хороши тем, что поз­воля­ют про­извести ком­плексный ана­лиз все­го слеп­ка одной кноп­кой, одна­ко цена за это — боль­шое вре­мя работы прог­раммы. На сорев­новани­ях обыч­но необ­ходимо делать задачу мак­сималь­но быс­тро, поэто­му исполь­зовать мы будем Volatility. В «Хакере» уже [бы­ли](https://xakep.ru/2018/04/03/forensics-guide-1/) статьи, свя­зан­ные с этим чудес­ным инс­тру­мен­том, так что, если ты новичок в теме, сто­ит сна­чала озна­комить­ся с ними.

## Начало

Вот как выг­лядело усло­вие задачи. Нам дан непос­редс­твен­но сле­пок опе­ратив­ной памяти и его хеш MD5 для про­вер­ки.

![[Pasted image 20240303185514.png]]

Приб­лизитель­ный перевод:

> У меня есть самый безопас­ный менед­жер паролей. Даже если ты укра­дешь мой ноут­бук, ты не смо­жешь узнать мои сек­реты.
> 
> Под­сказ­ка: Уда­лен­ный не зна­чит обя­затель­но бра­узер

За­кача­ем наш образ на машину, где будем про­водить ана­лиз (у меня это Kali):

```
wget https://ams3.digitaloceanspaces.com/justctf/69f7647d-2f7a-4604-b9f6-553c6bb447ee/challenge.tar.gz     
```

Рас­паку­ем:

```
tar -xzvf challenge.tar.gz     
```

И сра­зу же про­верим, что с ним все в поряд­ке:

```
md5sum pub/challenge.vmem     
```

Ес­ли хеш не сошел­ся с исходным хешем — при­дет­ся еще раз ска­чать архив.
## О важности актуальных версий

Ни для кого не сек­рет, что с каж­дым обновле­нием любого инс­тру­мен­та раз­работ­чики ста­рают­ся добавить новые воз­можнос­ти и убрать ~~ста­рые недоку­мен­тирован­ные воз­можнос­ти~~ баги. В опе­раци­онных сис­темах семей­ства Linux есть встро­енные менед­жеры пакетов, которые сущес­твен­но упро­щают уста­нов­ку и обновле­ние прог­рамм. Из‑за это­го боль­шинс­тво людей пер­вым делом лезет в свой пакет­ный менед­жер, что­бы уста­новить отту­да прог­рамму.

Од­нако здесь есть неболь­шие шерохо­ватос­ти: раз­работ­чик может забыть (или забить?) обно­вить пакет в репози­тории. В таких слу­чаях при­ходит­ся искать исходни­ки и собирать акту­аль­ную вер­сию самос­тоятель­но.

Те, кто зна­ком с Volatility, зна­ют о его осо­бен­ностях. Нап­ример, что он исполь­зует так называ­емые про­фили, которые поз­воля­ют пра­виль­но рас­парсить весь сле­пок опе­ратив­ной памяти, и энту­зиас­ты пос­тоян­но обновля­ют их спи­сок. Разуме­ется, про­филь мож­но сде­лать и [са­мос­тоятель­но](https://www.andreafortuna.org/2019/08/22/how-to-generate-a-volatility-profile-for-a-linux-system/), но явно про­ще вос­поль­зовать­ся готовы­ми. Во вре­мя сорев­нования я стол­кнул­ся с тем, что дав­но не обновлял свой Volatility и нуж­ных про­филей для решения задачи у меня не ока­залось.

Что­бы с тобой не слу­чилось подоб­ного, перед началом решения задачи я нас­тоятель­но рекомен­дую обно­вить (или уста­новить) Volatility с [гит­хаба](https://github.com/volatilityfoundation/volatility/wiki/Installation) про­екта.

## Определение профиля

Отправной точкой задачи является файл vmem. Это файл виртуальной памяти, используемый различными гипервизорами для хранения оперативной памяти при приостановке работы виртуальной машины. Известный инструмент для анализа памяти [Volatility](https://github.com/volatilityfoundation/volatility) способен справиться с файлами такого типа, поэтому давайте попробуем. Во-первых, нам необходимо идентифицировать систему и ее версию.

Пер­вым делом нам необ­ходимо опре­делить вер­сию опе­раци­онной сис­темы, с которой сни­мали сле­пок. Это мож­но сде­лать коман­дой `imageinfo`:

```
vol.py -f challenge.vmem imageinfo     
```

![[Pasted image 20240303185819.png]]

Через пару минут он вернул предложенный профиль Windows. Многие люди не смогли его найти из-за устаревшей версии Volatility. Всегда пытайтесь обновить свои инструменты, если что-то, что должно работать, не работает. Имея правильный профиль, теперь мы можем попробовать использовать различные модули, чтобы увидеть, с чем мы имеем дело. Первое, что я обычно проверяю, — это список запущенных процессов. Это может многое рассказать о назначении системы и указать на другие интересные места, на которые стоит обратить внимание. На этот раз ничего особенного не происходило, работали только стандартные системные процессы. Однако мы знаем, что нам нужно искать «удаленный» объект, поэтому еще один взгляд на список процессов должен переключить наше внимание на два процесса: MS Edge и RDP-клиент ( `mstsc.exe`). Глядя на подсказку, мы можем смело игнорировать браузер и сосредоточиться на RDP-клиенте.

Нам нуж­но обра­тить вни­мание на строч­ку с Suggested Profile(s). Имен­но здесь нам говорят, что пред­полага­емый про­филь слеп­ка опе­ратив­ной памяти — `Win10x64_18362`. Теперь мы дол­жны ука­зывать аргу­мент `--profile Win10x64_18362` для пос­леду­ющих команд.

## Собираем информацию о машине 

Ка­кую информа­цию име­ет смысл добыть вна­чале? Обыч­но это:

- про­цес­сы;
- ис­тория бра­узе­ра;
- ис­тория запущен­ных команд в кон­соли.

Этих трех пун­ктов хва­тает для опре­деле­ния век­тора даль­нейшей раз­ведки.
## Процессы

Что­бы най­ти про­цес­сы, нам дос­таточ­но исполь­зовать коман­ду `pstree`. Есть еще `pslist`, но пер­вая коман­да удоб­нее, потому что показы­вает про­цес­сы в виде дерева — так нам­ного про­ще понять, на какие из них сто­ит обра­тить вни­мание.

```
vol.py -f challenge.vmem --profile Win10x64_18362 pstree     
```

![[Pasted image 20240303185933.png]]

Или:

```sh
➜  ~ vol.py -f pub/challenge.vmem --profile Win10x64_18362 pslist
Volatility Foundation Volatility Framework 2.6.1
Offset(V)          Name                    PID   PPID (...)
------------------ -------------------- ------ ------ (...)
0xffffe00d93088040 System                    4      0 (...)
0xffffe00d930d6080 Registry                136      4 (...)
(...)
0xffffe00d9af0f480 svchost.exe            4044    692 (...)
0xffffe00d9af57080 mstsc.exe              6484   3904 (...)
0xffffe00d9afd2080 svchost.exe            6832    692 (...)
0xffffe00d9b0693c0 WmiApSrv.exe           6928    692 (...)
0xffffe00d9ae87080 audiodg.exe            7792   1944 (...)
0xffffe00d9a24a4c0 MicrosoftEdgeC         8104    904 (...)
0xffffe00d9b6454c0 MicrosoftEdgeC         7636    904 (...)
0xffffe00d9b1c14c0 MicrosoftEdgeC         7532    904 (...)
0xffffe00d9340f080 cmd.exe                7420   2448 (...)
0xffffe00d930d0080 conhost.exe            8024   7420 (...)
➜  ~ 
```

Обычно соединения RDP зашифрованы, верно? Но в какой-то момент передаваемые данные должны быть расшифрованы и отображены в окне клиента. Некоторые из отображаемых изображений могут все еще присутствовать в памяти процесса, несмотря на получение новых обновлений экрана или закрытие соединения. Однако такие инструменты, как binwalk или, прежде всего, не найдут эти изображения, поскольку они представляют собой обычные растровые изображения. Самый простой и эффективный способ поиска растровых изображений внутри дампов памяти — использовать Gimp. Gimp позволяет загружать произвольные объекты данных в виде растрового изображения и отображать их. Однако было бы сложно найти растровое изображение неизвестной ширины в дампе памяти объемом 1 ГБ. Итак, чтобы сделать это хотя бы немного проще, давайте сбросим память процесса, который нас особенно интересует, `mstsc.exe`.

![[Pasted image 20240303195029.png]]

Теперь, когда у нас есть дамп меньшего размера, давайте загрузим его в Gimp и найдем некоторые регионы, которые не выглядят совершенно случайными. Сначала нам нужно переименовать `6484.dmp`его в `6468.data`, чтобы Gimp смог его увидеть. Затем выберите в меню `File`-> `Open`-> `Select File Type`-> `Raw image data`и откройте `6468.data`. Начнем с изменения ширины на 1080 и высоты на максимально видимое значение, в моем случае 545.

![[Pasted image 20240303195048.png]]

Первое, что не похоже на какой-то гараж, это какая-то иконка (наверное?). Но это не то, что мы ищем.

![[Pasted image 20240303195111.png]]
## Бинго

Пройдя дальше и отрегулировав ширину, мы получим флаг, который отображался в блокноте на удаленном сервере.

![[Pasted image 20240303195135.png]]

Думаю, это не лучший способ хранить пароли, не так ли?

