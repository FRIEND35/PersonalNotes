[ Больше подробности](https://www.opennet.ru/base/sys/initrd_intro.txt.html)


Initrd (сокращение от англ. Initial RAM Disk, диск в оперативной памяти для начальной инициализации) — временная файловая система, используемая ядром Linux при начальной загрузке. Initrd обычно используется для начальной инициализации перед монтированием «настоящих» файловых систем. В Linux Kernel HOWTO (руководстве о сборке ядра) пишут, что initrd призван решить проблему курицы и яйца для модульного ядра: для монтирования файловой системы необходим модуль для работы с диском и файловой системой, а для чтения модуля необходима файловая система, с которой этот модуль читается. 

Исходный _RAM-диск (initrd)_ — это начальная корневая файловая система, которая монтируется до того, как настоящая корневая файловая система станет доступной. initrd привязан к ядру и загружается как часть процедуры загрузки ядра. Затем ядро ​​монтирует этот initrd как часть двухэтапного процесса загрузки, чтобы загрузить модули, чтобы сделать реальные файловые системы доступными и добраться до настоящей корневой файловой системы.

Для этого initrd содержит минимальный набор каталогов и исполняемых файлов, таких как `insmod` инструмент для установки модулей ядра в ядро.

В случае настольных или серверных систем Linux initrd является временной файловой системой. Его срок службы короток, он служит только мостом к настоящей корневой файловой системе. Во встроенных системах без изменяемого хранилища initrd является постоянной корневой файловой системой. В этой статье рассматриваются оба этих контекста.

## Анатомия initrd

Образ initrd содержит необходимые исполняемые и системные файлы для поддержки второго этапа загрузки системы Linux.

В зависимости от того, какую версию Linux вы используете, способ создания начального RAM-диска может различаться. До Fedora Core 3 initrd создавался с использованием _устройства цикла_ . Устройство _петли_ — это драйвер устройства, который позволяет вам монтировать файл как блочное устройство, а затем интерпретировать представляемую им файловую систему. Устройство цикла может отсутствовать в вашем ядре, но вы можете включить его с помощью инструмента конфигурации ядра ( `make menuconfig`), выбрав « **Драйверы устройств» > «Блочные устройства» > «Поддержка устройства обратной связи»** . Вы можете проверить петлевое устройство следующим образом (имя файла initrd может отличаться):

##### Листинг 1. Проверка initrd (до FC3)

```
                
#mkdir temp ; cd temp
#cp /boot/initrd.img.gz .
#gunzip initrd.img.gz
#mount ‑t ext ‑o loop initrd.img /mnt/initrd
#ls ‑la /mnt/initrd
#
```

Теперь вы можете проверить подкаталог /mnt/initrd на наличие содержимого файла initrd. Обратите внимание, что даже если ваш файл образа initrd не заканчивается суффиксом .gz, это сжатый файл, и вы можете добавить суффикс .gz, чтобы заархивировать его.

Начиная с Fedora Core 3 образ initrd по умолчанию представляет собой сжатый файл архива cpio. Вместо того, чтобы монтировать файл как сжатый образ с помощью устройства loop, вы можете использовать архив cpio. Чтобы проверить содержимое архива cpio, используйте следующие команды:

##### Листинг 2. Проверка initrd (FC3 и более поздние версии)

```
                
#mkdir temp ; cd temp
#cp /boot/initrd‑2.6.14.2.img initrd‑2.6.14.2.img.gz
#gunzip initrd‑2.6.14.2.img.gz
#cpio ‑i ‑‑make‑directories < initrd‑2.6.14.2.img
#
```

В результате получается небольшая корневая файловая система, как показано в листинге 3. Небольшой, но необходимый набор приложений находится в каталоге ./bin, включая `nash`(не оболочка, интерпретатор скриптов), `insmod`для загрузки модулей ядра и `lvm`(инструменты управления логическими томами).

##### Листинг 3. Структура каталогов Linux initrd по умолчанию

```
                
#ls ‑la
#
drwxr‑xr‑x  10 root root    4096 May 7 02:48 .
drwxr‑x‑‑‑  15 root root    4096 May 7 00:54 ..
drwxr‑xr‑x  2  root root    4096 May 7 02:48 bin
drwxr‑xr‑x  2  root root    4096 May 7 02:48 dev
drwxr‑xr‑x  4  root root    4096 May 7 02:48 etc
‑rwxr‑xr‑x  1  root root     812 May 7 02:48 init
‑rw‑r‑‑r‑‑  1  root root 1723392 May 7 02:45 initrd‑2.6.14.2.img
drwxr‑xr‑x  2  root root    4096 May 7 02:48 lib
drwxr‑xr‑x  2  root root    4096 May 7 02:48 loopfs
drwxr‑xr‑x  2  root root    4096 May 7 02:48 proc
lrwxrwxrwx  1  root root       3 May 7 02:48 sbin ‑> bin
drwxr‑xr‑x  2  root root    4096 May 7 02:48 sys
drwxr‑xr‑x  2  root root    4096 May 7 02:48 sysroot
#
```

В листинге 3 интерес представляет файл инициализации в корне. Этот файл, как и традиционный процесс загрузки Linux, вызывается, когда образ initrd распаковывается на RAM-диск. Мы рассмотрим это позже в статье.

## Инструменты для создания initrd

**Команда cpio**

С использованием `cpio`команда, вы можете манипулировать `cpio`файлы. Cpio также является файловым форматом, представляющим собой просто объединение файлов с заголовками. `cpio`Формат файла позволяет использовать как ASCII, так и двоичные файлы. Для переносимости используйте ASCII. Для уменьшения размера файла используйте двоичную версию.

Давайте теперь вернемся к началу, чтобы формально понять, как создается образ initrd. Для традиционной системы Linux образ initrd создается в процессе сборки Linux. Многочисленные инструменты, такие как `mkinitrd`, можно использовать для автоматической сборки initrd с необходимыми библиотеками и модулями для подключения к реальной корневой файловой системе. `mkinitrd`Утилита на самом деле является сценарием оболочки, поэтому вы можете видеть, как именно она достигает своего результата. Есть также `YAIRD`Утилита (Yet Another Mkinitrd), которая позволяет настраивать каждый аспект конструкции initrd.

## Создание пользовательского начального RAM-диска вручную

Поскольку во многих встроенных системах на основе Linux нет жесткого диска, initrd также служит постоянной корневой файловой системой. В листинге 4 показано, как создать образ initrd. Я использую стандартный рабочий стол Linux, чтобы вы могли работать без встроенной цели. За исключением кросс-компиляции, концепции (поскольку они применяются к конструкции initrd) одинаковы для встроенной цели.

##### Листинг 4. Утилита (mkird) для создания собственного initrd

```
                
#!/bin/bash

# Housekeeping...
rm ‑f /tmp/ramdisk.img
rm ‑f /tmp/ramdisk.img.gz

# Ramdisk Constants
RDSIZE=4000
BLKSIZE=1024

# Create an empty ramdisk image
dd if=/dev/zero of=/tmp/ramdisk.img bs=$BLKSIZE count=$RDSIZE

# Make it an ext2 mountable file system
/sbin/mke2fs ‑F ‑m 0 ‑b $BLKSIZE /tmp/ramdisk.img $RDSIZE

# Mount it so that we can populate
mount /tmp/ramdisk.img /mnt/initrd ‑t ext2 ‑o loop=/dev/loop0

# Populate the filesystem (subdirectories)
mkdir /mnt/initrd/bin
mkdir /mnt/initrd/sys
mkdir /mnt/initrd/dev
mkdir /mnt/initrd/proc

# Grab busybox and create the symbolic links
pushd /mnt/initrd/bin
cp /usr/local/src/busybox‑1.1.1/busybox .
ln ‑s busybox ash
ln ‑s busybox mount
ln ‑s busybox echo
ln ‑s busybox ls
ln ‑s busybox cat
ln ‑s busybox ps
ln ‑s busybox dmesg
ln ‑s busybox sysctl
popd

# Grab the necessary dev files
cp ‑a /dev/console /mnt/initrd/dev
cp ‑a /dev/ramdisk /mnt/initrd/dev
cp ‑a /dev/ram0 /mnt/initrd/dev
cp ‑a /dev/null /mnt/initrd/dev
cp ‑a /dev/tty1 /mnt/initrd/dev
cp ‑a /dev/tty2 /mnt/initrd/dev

# Equate sbin with bin
pushd /mnt/initrd
ln ‑s bin sbin
popd

# Create the init file
cat >> /mnt/initrd/linuxrc << EOF
#!/bin/ash
echo
echo "Simple initrd is active"
echo
mount ‑t proc /proc /proc
mount ‑t sysfs none /sys
/bin/ash ‑‑login
EOF

chmod +x /mnt/initrd/linuxrc

# Finish up...
umount /mnt/initrd
gzip ‑9 /tmp/ramdisk.img
cp /tmp/ramdisk.img.gz /boot/ramdisk.img.gz
```

**дистрибутив initrd Linux**

Интересным проектом с открытым исходным кодом, который был разработан как дистрибутив Linux, вписывающийся в initrd, является Minimax. Он имеет размер 32 МБ и использует BusyBox и uClibc из-за своего сверхмалого размера. Несмотря на небольшой размер, это ядро ​​Linux версии 2.6 с большим набором полезных инструментов.

Чтобы создать initrd, начните с создания пустого файла, используя `/dev/zero`(поток нулей) в качестве входной записи в файл ramdisk.img. Результирующий файл имеет размер 4 МБ (4000 блоков по 1 КБ). Затем используйте `mke2fs`Команда для создания файловой системы ext2 (вторая расширенная) с использованием пустого файла. Теперь, когда этот файл является файловой системой ext2, смонтируйте файл в /mnt/initrd, используя устройство цикла. В точке монтирования у вас теперь есть каталог, представляющий файловую систему ext2, которую вы можете заполнить для вашего initrd. Большая часть остальной части скрипта обеспечивает эту функциональность.

Следующим шагом является создание необходимых подкаталогов, составляющих вашу корневую файловую систему: /bin, /sys, /dev и /proc. Нужны лишь некоторые из них (например, нет библиотек), но они содержат довольно много функциональности.

**Альтернатива файловой системе ext2**

Хотя ext2 является распространенным форматом файловой системы Linux, существуют альтернативы, которые могут уменьшить размер образа initrd и результирующие смонтированные файловые системы. Примеры включают romfs (файловая система ROM), cramfs (сжатая файловая система ROM) и squashfs (сильно сжатая файловая система только для чтения). Если вам нужно временно записать данные в файловую систему, ext2 отлично подойдет. Наконец, e2compr — это расширение драйвера файловой системы ext2, поддерживающее онлайн-сжатие.

Чтобы сделать вашу корневую файловую систему полезной, используйте BusyBox. Эта утилита представляет собой единый образ, содержащий множество отдельных утилит, обычно встречающихся в системах Linux (например, ash, awk, sed, insmod и т. д.). Преимущество BusyBox в том, что он упаковывает множество утилит в одну, разделяя при этом их общие элементы, в результате чего изображение становится намного меньше. Это идеально подходит для встраиваемых систем. Скопируйте образ BusyBox из его исходного каталога в корневой каталог /bin. Затем создается ряд символических ссылок, которые указывают на утилиту BusyBox. BusyBox определяет, какая утилита была вызвана, и выполняет эту функцию. В этом каталоге создается небольшой набор ссылок для поддержки вашего сценария инициализации (каждая ссылка на команду указывает на BusyBox).

Следующим шагом является создание небольшого количества специальных файлов устройств. Я копирую их прямо из моего текущего подкаталога /dev, используя команду `-a`вариант (архив) для сохранения их атрибутов.

Предпоследним шагом является создание файла linuxrc. После монтирования RAM-диска ядро ​​ищет `init`файл для выполнения. Если `init`файл не найден, ядро ​​вызывает файл linuxrc в качестве сценария запуска. В этом файле вы выполняете базовую настройку среды, например монтируете файловую систему /proc. В дополнение к /proc я также монтирую файловую систему /sys и вывожу сообщение на консоль. Наконец, я призываю `ash`(клон Bourne Shell), чтобы я мог взаимодействовать с корневой файловой системой. Затем файл linuxrc становится исполняемым с помощью `chmod`.

Наконец, ваша корневая файловая система готова. Он размонтируется, а затем сжимается с помощью `gzip`. Полученный файл (ramdisk.img.gz) копируется в подкаталог /boot, чтобы его можно было загрузить через GNU GRUB.

Чтобы создать начальный RAM-диск, вы просто вызываете `mkird`, и образ автоматически создается и копируется в /boot.

**Поддержка Initrd в ядре Linux**

Чтобы ядро ​​Linux поддерживало исходный RAM-диск, оно должно быть скомпилировано с `CONFIG_BLK_DEV_RAM`а также `CONFIG_BLK_DEV_INITRD`опции.

## Тестирование пользовательского начального RAM-диска

Ваш новый образ initrd находится в /boot, поэтому следующим шагом будет его тестирование с ядром по умолчанию. Теперь вы можете перезагрузить систему Linux. Когда появится GRUB, нажмите клавишу C, чтобы включить утилиту командной строки в GRUB. Теперь вы можете взаимодействовать с GRUB, чтобы определить конкретное ядро ​​и образ initrd для загрузки. `kernel`команда позволяет определить файл ядра и `initrd`Команда позволяет указать конкретный файл образа initrd. Когда они определены, используйте `boot`команду для загрузки ядра, как показано в листинге 5.

**Листинг 5. Загрузка ядра и initrd вручную с помощью GRUB**

```
GNU GRUB  version 0.95  (638K lower / 97216K upper memory)

[ Minimal BASH-like line editing is supported. For the first word, TAB
  lists possible command completions. Anywhere else TAB lists the possible
  completions of a device/filename. ESC at any time exits.]

grub> kernel /bzImage-2.6.1
   [Linux-bzImage, setup=0x1400, size=0x29672e]

grub> initrd /ramdisk.img.gz
   [Linux-initrd @ 0x5f2a000, 0xb5108 bytes]

grub> boot

Uncompressing Linux... OK, booting the kernel.
```

После запуска ядро ​​проверяет, доступен ли образ initrd (подробнее об этом позже), а затем загружает и монтирует его как корневую файловую систему. Вы можете увидеть конец этого конкретного запуска Linux в листинге 6. При запуске оболочка ash доступна для ввода команд. В этом примере я исследую корневую файловую систему и опрашиваю запись файловой системы виртуального proc. Я также демонстрирую, что вы можете писать в файловую систему, прикасаясь к файлу (тем самым создавая его). Обратите внимание, что первым созданным процессом является `linuxrc`(обычно `init`).

##### Листинг 6. Загрузка ядра Linux с помощью простого initrd

```
                
...
md: Autodetecting RAID arrays
md: autorun
md: ... autorun DONE.
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 file system).
Freeing unused kernel memory: 208k freed
/ $ ls
bin         etc       linuxrc       proc        sys
dev         lib       lost+found    sbin
/ $ cat /proc/1/cmdline
/bin/ash/linuxrc
/ $ cd bin
/bin $ ls
ash      cat      echo     mount    sysctl
busybox  dmesg    ls       ps
/bin $ touch zfile
/bin $ ls
ash      cat      echo     mount    sysctl
busybox  dmesg    ls       ps       zfile
```

## Загрузка с начальным RAM-диском

Теперь, когда вы увидели, как создать и использовать собственный начальный RAM-диск, в этом разделе исследуется, как ядро ​​идентифицирует и монтирует initrd в качестве своей корневой файловой системы. Я пройдусь по некоторым основным функциям в цепочке загрузки и объясню, что происходит.

Загрузчик, такой как GRUB, идентифицирует ядро, которое должно быть загружено, и копирует этот образ ядра и любой связанный initrd в память. Вы можете найти большую часть этой функциональности в подкаталоге ./init в исходном каталоге ядра Linux.

После того как ядро ​​и образы initrd распакованы и скопированы в память, запускается ядро. Выполняется различная инициализация и, в конце концов, вы оказываетесь в `init/main.c:init()`(подкаталог/файл:функция). Эта функция выполняет большую часть инициализации подсистемы. Здесь звонят `init/do_mounts.c:prepare_namespace()`, который используется для подготовки пространства имен (монтирования файловой системы dev, RAID или md, устройств и, наконец, initrd). Загрузка initrd выполняется через вызов `init/do_mounts_initrd.c:initrd_load()`.

The `initrd_load()`вызовы функций `init/do_mounts_rd.c:rd_load_image()`, который определяет образ RAM-диска для загрузки через вызов `init/do_mounts_rd.c:identify_ramdisk_image()`. Эта функция проверяет магический номер образа, чтобы определить, является ли он форматом minux, etc2, romfs, cramfs или gzip. По возвращении в `initrd_load_image`, осуществляется вызов `init/do_mounts_rd:crd_load()`. Эта функция выделяет место для RAM-диска, вычисляет контроль циклическим избыточным кодом (CRC), а затем распаковывает и загружает образ RAM-диска в память. На данный момент у вас есть образ initrd в блочном устройстве, подходящем для монтирования.

Монтирование блочного устройства теперь как root начинается с вызова `init/do_mounts.c:mount_root()`. Создается корневое устройство, а затем выполняется вызов `init/do_mounts.c:mount_block_root()`. Отсюда, `init/do_mounts.c:do_mount_root()`называется, который вызывает `fs/namespace.c:sys_mount()`фактически смонтировать корневую файловую систему, а затем `chdir`к этому. Здесь вы видите знакомое сообщение, показанное в листинге 6: `VFS: Mounted root (ext2 file system).`

Наконец, вы возвращаетесь к `init`функция и вызов `init/main.c:run_init_process`. Это приводит к вызову `execve`для запуска процесса инициализации (в данном случае `/linuxrc`). linuxrc может быть исполняемым файлом или сценарием (если для него доступен интерпретатор сценариев).

Иерархия вызываемых функций показана в листинге 7. Здесь показаны не все функции, участвующие в копировании и монтировании исходного RAM-диска, но это дает вам общее представление об общем потоке.

##### Листинг 7. Иерархия основных функций загрузки и монтирования initrd

```
                
init/main.c:init
  init/do_mounts.c:prepare_namespace
    init/do_mounts_initrd.c:initrd_load
      init/do_mounts_rd.c:rd_load_image
        init/do_mounts_rd.c:identify_ramdisk_image
        init/do_mounts_rd.c:crd_load
          lib/inflate.c:gunzip
    init/do_mounts.c:mount_root
      init/do_mounts.c:mount_block_root
         init/do_mounts.c:do_mount_root
           fs/namespace.c:sys_mount
  init/main.c:run_init_process
    execve
```

## Бездисковая загрузка

Как и во встроенных сценариях загрузки, локальный диск (дискета или компакт-диск) не требуется для загрузки ядра и корневой файловой системы виртуального диска. Протокол динамической конфигурации хоста (или DHCP) можно использовать для определения сетевых параметров, таких как IP-адрес и маска подсети. Затем можно использовать простой протокол передачи файлов (или TFTP) для передачи образа ядра и начального образа виртуального диска на локальное устройство. После переноса ядро ​​Linux можно загрузить и смонтировать initrd, как это делается при загрузке с локального образа.

## Уменьшение вашего initrd

Если вы создаете встраиваемую систему и вам нужен самый маленький из возможных образов initrd, обратите внимание на несколько советов. Первый — использовать BusyBox (показано в этой статье). BusyBox занимает несколько мегабайт утилит и сжимает их до нескольких сотен килобайт.

В этом примере образ BusyBox статически связан, поэтому библиотеки не требуются. Однако, если вам нужна стандартная библиотека C (для ваших пользовательских двоичных файлов), помимо массивного glibc есть и другие варианты. Первой небольшой библиотекой является uClibc, которая представляет собой уменьшенную версию стандартной библиотеки C для систем с ограниченным пространством. Еще одна библиотека, идеально подходящая для сред с ограниченным пространством, — диетическая библиотека. Имейте в виду, что вам нужно будет перекомпилировать двоичные файлы, которые вы хотите во встроенной системе, используя эти библиотеки, поэтому требуется дополнительная работа (но она того стоит).

## Резюме

Исходный RAM-диск изначально был создан для поддержки соединения ядра с конечной корневой файловой системой через временную корневую файловую систему. Initrd также полезен как непостоянная корневая файловая система, смонтированная на RAM-диске для встраиваемых систем Linux.