Ядро Linux — ядро операционной системы, соответствующее стандартам [[OO. POSIX | POSIX]], составляющее основу операционных систем семейства Linux, а также ряда операционных систем для мобильных устройств, в том числе Android, Tizen, KaiOS. Разработка кода ядра была начата финским студентом Линусом Торвальдсом в 1991 году, на его имя зарегистрирована торговая марка «Linux».

Код написан в основном на Си с некоторыми расширениями gcc и на ассемблере (с использованием AT&T-синтаксиса GNU Assembler).

Распространяется как свободное программное обеспечение на условиях GNU General Public License, кроме несвободных элементов, особенно драйверов, которые используют прошивки, распространяемые под различными лицензиями.

Операционные системы на базе ядра Linux являются лидерами на рынках суперкомпьютеров, микрокомпьютеров, серверов и смартфонов. 




# Ядро Linux

**Ядро** — это своего рода главная программа, являющаяся основной частью операционной системы. Оно выступает в роли посредника между устройствами компьютера (процессором, видеокартой, оперативной памятью и т.д.) и его программным обеспечением, абстрагируя от обычных программ и пользователей сложную, низкоуровневую работу с «железом» компьютера, предоставляя взамен простой, понятный и удобный в использовании интерфейс. Для этого в код ядра были включены [[LL. Что такое драйвер | драйверы]] устройств, которые могут как загружаться в память вместе с ядром ОС, так и подключаться по мере возникновения потребности в ресурсах необходимого устройства.

**Ядро́** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") kernel) — центральная часть [операционной системы](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Операционная система") (ОС), обеспечивающая [приложениям](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Прикладное программное обеспечение") координированный доступ к ресурсам [компьютера](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80 "Компьютер"), таким как [процессорное время](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%BD%D0%BE%D0%B5_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F "Процессорное время"), [память](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B5%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE_%D1%81_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%BC_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC "Запоминающее устройство с произвольным доступом"), внешнее [аппаратное обеспечение](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BB%D0%B5%D0%BA%D1%82%D1%83%D1%8E%D1%89%D0%B8%D0%B5 "Компьютерные комплектующие"), внешнее устройство ввода и вывода информации. Также обычно ядро предоставляет сервисы [файловой системы](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Файловая система") и [сетевых протоколов](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Протокол передачи данных").

Как основополагающий элемент ОС ядро представляет собой наиболее низкий уровень [абстракции](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Абстракция данных") для доступа [приложений](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5 "Прикладное программное обеспечение") к ресурсам системы, необходимым для своей работы. Как правило, ядро предоставляет такой доступ исполняемым процессам соответствующих приложений за счёт использования механизмов [межпроцессного взаимодействия](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5 "Межпроцессное взаимодействие") и обращения приложений к системным вызовам ОС.

Ядро - это центральный компонент операционной системы. Ядро также считается сердцем операционной системы. Он отвечает за управление всеми процессами, памятью, файлами и т. д. Ядро функционирует на самом низком уровне операционной системы. Он действует как интерфейс (мост) между пользовательским приложением (программным обеспечением) и аппаратным обеспечением. Поэтому связь между программным обеспечением и аппаратным обеспечением осуществляется через ядро.

![[Pasted image 20221014050155.png]]


### Архитектура ядра

Уровень доступа к ресурсам компьютера зависит от того, какое ядро использует операционная система. Привилегии ядра выше остальных приложений, а работает оно в едином адресном пространстве. В зависимости от того, сколько задач выполняется на уровне ядра, различают несколько типов ядер. Самые популярные – это монолитное (Linux), микроядро (macOS) и гибридное (Windows).

Ядро Linux монолитное, большая его часть хранится в одном файле. Однако, это не признак монолитного ядра, модули вполне могут храниться отдельно. Основная его особенность заключается в том, что оно обрабатывает все процессы, кроме пользовательских приложений. То есть управление процессами и памятью, [[LL. Что такое драйвер | драйверы]], виртуальная файловая система, сетевой стек и многое другое – это всё заботы ядра, которые к тому же имеют самый высокий уровень доступа к аппаратной части компьютера.

Однако, это не означает то, что пользовательские приложения не могут выполнять схожие функции. Например, система инициализации Systemd помимо прочего выстраивает иерархию процессов поверх групп ядра cgroups, а [демоны](https://losst.pro/chto-takoe-demony-v-linux), вроде PulseAudio, контролируют работу устройств, расширяя функциональность драйверов.

Также стоит понимать, что ядро хоть и монолитное, но состоит из внутренних модулей, которые загружаются только по необходимости, а не все сразу. Некоторые модули хранятся отдельно от ядра, в основном это дополнительные драйверы устройств.

Интерфейсы, имена переменных и структура каталогов системы определяются стандартами  [[OO. POSIX | POSIX]], что делает Linux UNIX-подобной системой. Линус Торвальдс, создатель ядра, выбрал UNIX по той причине, что имелась база приложений, необходимых для функционирования операционной системы, утилиты GNU. Однако, он не разделяет идеи философии UNIX, одна программа – одно действие, текстовый вывод информации как универсальный интерфейс. По его мнению они не отражают запросы современных пользователей.


Основные функции, которые выполняет ядро:

 -   управление процессами
 -   управление памятью
 -   управление устройством
 -   обработка прерываний
 -   операции ввода/вывода

>**_Примечание:_** Ядро Linux было разработано в 1991 году программистом Линусом Торвальдсом. Об этом снят **_документальный_ _фильм «Revolution OS»_** (2001 г.).

Можно сказать что ядро очень низкий программное обеспечение, которое взаимодействует с апаратными частями компьютера. Допустимчто вы открыли программу, в это время ядро выделяет для него память, управляет потоками ввода-вывода и многое другое.

Именно ядро проверяет пользователя на наличии доступа к файлам и папкам. Ядро указывает ОС какие ресуры компьютера нужны данной программе.

Теперь давайте разберемся подробнее в этих функциях ядра...

---

### Функции ядра в операционной системе

#### Управление процессами

Создание, выполнение и завершение процессов выполняются внутри системы всякий раз, когда система находится во включенном состоянии (режиме ON). Процесс содержит всю информацию о задаче, которую необходимо выполнить. Таким образом, для выполнения любой задачи внутри системы создается процесс. В то же время существует множество процессов, которые находятся в активном состоянии внутри системы. Управление всеми этими процессами очень важно для предупреждения тупиковых ситуаций и для правильного функционирования системы, и оно осуществляется ядром.

---

#### Управление памятью

Всякий раз, когда процесс создается и выполняется, он занимает память, и когда он завершается, память должна быть освобождена и может быть использована снова. Но память должна быть обработана кем-то, чтобы освобожденная память могла быть снова назначена новым процессам. Эта задача также выполняется ядром. Ядро отслеживает, какая часть памяти в данный момент выделена и какая часть доступна для выделения другим процессам.

---

#### Управление устройствами

Ядро также управляет всеми различными устройствами, подключенными к системе, такими как устройства ввода и вывода и т. д.

---

#### Обработка прерываний

При выполнении процессов возникают условия, при которых сначала необходимо решить задачи с большим приоритетом. В этих случаях ядро должно прерывать выполнение текущего процесса и обрабатывать задачи с большим приоритетом, которые были получены в промежутке.

---

#### Операции ввода/вывода

Поскольку ядро управляет всеми подключенными к нему устройствами, оно также отвечает за обработку всех видов входных и выходных данных, которыми обмениваются эти устройства. Таким образом, вся информация, которую система получает от пользователя, и все выходные данные, которые пользователь получает через различные приложения, обрабатываются ядром.

### Так что делает ядро

Как было сказано ранее, у монолитного ядра самый широкий спектр задач. На верхнем уровне ядро обрабатывает поступающие системные вызовы, которые являются интерфейсом между ядром и пользовательскими приложениями. На нижнем уровне ядро обрабатывает аппаратные прерывания, сигналы, поступающие от периферии, процессора, памяти и так далее.

На обработке прерываний задачи ядра не заканчиваются, оно содержит в себе [[LL. Что такое драйвер | драйверы]] устройств. Драйверы нужны для того, чтобы обработать поступающие с устройств сигналы, а команды приложений перевести в машинный код.

Драйверы занимают большую часть ядра. Некоторые из них представлены сразу в виде бинарных файлов, что противоречит идеям фонда СПО. Версия ядра без закрытых драйверов называется Linux-libre, на практике его использование крайне затруднительно, так как собрать компьютер на основе комплектующих только с открытыми драйверами у вас едва ли получится.

Остальные задачи ядра – это работа с абстракциями. Например, планировщик создаёт виртуальные потоки, менеджер памяти выделяет и изолирует часть оперативной памяти под процесс, виртуальная файловая система создаёт единое пространство для хранения файлов, а сетевой модуль создаёт сокеты. Это одно из условий обеспечения высокого уровня безопасности, иначе одна программа могла бы беспрепятственно взять конфиденциальные данные из другой, например, ключи шифрования.

Система межпроцессного взаимодействия следит за тем, чтобы не возникало конфликтов при обращении к одним и тем же ресурсам компьютера, а также обеспечивает обмен данными между процессами.

Со стороны пользовательских приложений всё это выглядит как настоящее оборудование, с той лишь разницей, что общение с процессором и памятью происходит не напрямую, а с помощью системных вызовов. Для периферийных устройств имеются символьные и блочные ссылки в каталоге /dev, последние отличает то, что ни работают с блоками фиксированного размера.

Несмотря на то, что ядро контролирует все процессы, само по себе оно ничего не делает, ему нужны пользовательские программы и их процессы. Среди базовых приложений стоит отметить утилиты проекта GNU, без них не обходится ни один дистрибутив Linux. Например, командная оболочка Bash позволит вам вводить команды в консоли.



## Типы ядер в операционной системе 

Как вы наверняка знаете, на компьютере может быть запущено сразу несколько программ: какие-то из них работают в фоновом режиме, другие могут ожидать определенных действий от пользователя, а третьим необходимо получать информацию из другой запущенной программы. В такой ситуации именно ядро берет на себя функцию оптимального распределения ресурсов компьютера между запущенными программами и организацию параллельной работы множества различных процессов. Оно первым загружается в оперативную память компьютера и всегда находится в запущенном состоянии, постоянно взаимодействуя с его аппаратным обеспечением и установленными программами.

Как правило, большинство ядер делятся на три типа:

   - микроядра;

   - монолитные;

   - гибридные.

**Микроядро** — это ядро, состоящее из нескольких подгружаемых в память по мере надобности независимых модулей, выполняющихся в отдельных адресных пространствах. По сути, в таком варианте исполнения оно не сильно отличается от обычных прикладных программ. К достоинствам данного ядра можно отнести теоретически большую надежность в сравнении с другими архитектурами (в действительности же не всё так радужно и гладко) и его модульность (легкость в подключении дополнительных частей ядра). К минусам микроядерной архитектуры относится то, что ядро, построенное по такой схеме, получается очень медленным (ведь ему нужно постоянно переключаться между отдельными частями). В этом типе архитектуры ядра основные пользовательские службы, такие как управление драйверами устройств, управление стеком протоколов, управление файловой системой и управление графикой, присутствуют в пространстве пользователя, а остальные функции управление памятью, управление процессами присутствует внутри пространства ядра. Таким образом, всякий раз, когда система имеет потребность в услугах, присутствующих в пространстве ядра, ОС переключается в режим ядра, а для служб пользовательского уровня она переключается в режим пользователя. Этот тип архитектуры ядра уменьшает размер ядра, но скорость выполнения процессов и предоставления других услуг значительно ниже, чем у монолитных ядер.

**Монолитное ядро** — это полная противоположность микроядра, т.к. в памяти компьютера всегда находится весь (или почти весь) код ядра, вследствие чего скорость его работы выше в сравнении с микроядром. В этом типе архитектуры ядра все функции, такие как управление процессами, управление памятью, обработка прерываний и т. д. выполняются в пространстве ядра. Монолитные ядра сначала состояли только из одного модуля, и этот модуль отвечал за все функции, которые выполнялись ядром. Это увеличило производительность ОС, так как все функции присутствовали внутри одного модуля, но это также привело к серьезным недостаткам, таким как большой размер ядра, очень низкая надежность, потому что даже если одна функция ядра отказала, это привело к отказу всей программы ядра и плохому обслуживанию, по той же причине. Таким образом, для повышения производительности системы был применен модульный подход в монолитных ядрах, в которых каждая функция присутствовала в отдельном модуле внутри пространства ядра. Таким образом, для исправления любых ошибок или в случае сбоя, только этот конкретный модуль был выгружен и загружен после исправления. Монолитные ядра, как правило, лучше справляются с операциями доступа к оборудованию и многозадачностью, потому что, если программе нужно получить информацию из памяти или другого запущенного процесса, у нее есть прямая линия для доступа к ней, и программе не нужно ждать в очереди, чтобы сделать что-то. Однако такой подход может вызвать серьезные проблемы, потому что, чем больше процессов выполняется на уровне ядра, тем больше вероятность, что в случае непредвиденного поведения они создадут общий сбой вашей системы.

**Гибридное ядро** — это ядро, сочетающее в себе элементы как монолитной, так и микроядерной архитектур. Для наилучшей производительности системы нам требуется как высокая скорость, так и малый размер ядра, чтобы наша система могла иметь максимальную эффективность. Поэтому для решения этой задачи был разработан новый тип ядра, который представлял собой комбинацию монолитного ядра и микроядра. Этот тип ядра известен как гибридное ядро. Такой тип архитектуры используется практически во всех системах, которые производятся в настоящее время. У таких ядер есть возможность выбирать, какие части будут работать в пользовательском пространстве (например, драйверы устройств и система ввода-вывода файловой системы), а какие — в пространстве ядра (вызовы межпроцессного (IPC) и серверного взаимодействий). Но этот подход имеет и некоторые проблемы, унаследованные от микроядерной архитектуры (особенно, по части быстродействия).

**Ядро Linux хоть и относится к монолитным ядрам, но оно также заимствует и некоторые идеи из микроядерной архитектуры**, что означает, что вся операционная система работает в пространстве ядра, а драйвера устройств (в виде модулей) могут быть легко загружены (или выгружены) прямо во время работы операционной системы.


## Где хранятся файлы ядра

Файл initrd.img – это первичная файловая система, которая монтируется перед тем, как подключить реальные накопители к виртуальной файловой системе VFS. Там же содержатся дополнительные модули ядра, поэтому этот файл может быть больше самого ядра. В файле system.map можно найти адреса функций и процедур ядра, что будет полезно при отладке.

Файлы ядра хранятся в каталоге /boot. Непосредственно само ядро находится в запакованном виде в файле vmlinuz, где z как раз и указывает на то, что ядро сжато для экономии места. В этом файле основные функции такие как:  работа с памятью, управление процессами и многое другое. В папке _/boot_ вы также найдете и другие очень важные файлы:

   - _img-[версия_ядра]_ — используется в качестве RAM-диска, в который распаковывается и с которого загружается ядро;

   - _map-[версия_ядра]_ — используется для управления памятью до полной загрузки ядра;

   - _config-[версия_ядра]_ — сообщает ядру, какие параметры и модули следует загрузить в образ ядра при его компиляции.

>**_Примечание_**: Также для сжатия ядра часто применяются алгоритмы LZMA или bzip2, а сами ядра именуются _zImage_.

Когда Линус Торвальдс только начинал разрабатывать свое ядро, оно носило простое название — **_linux_**. С появлением технологии **[виртуальной памяти](https://ravesli.com/memory-management-in-linux/#toc-1)** к ядру добавилась приставка _**vm**_ (сокр. от _«**v**irtual **m**emory»_). Со временем ядро настолько разрослось, что к нему стали применять сжатие, об этом нам говорит буква **_z_** (от _«**z**lib compression»_) в слове _vmlinu**z**._ Но когда ядро нужен допольнительные функции например - работа сетевым оборудованием, то ядро обращается к специальным файлам, а именно - к модулям.

## Что такое модули ядра (LKM)

Что, если б в [**Windows**](https://ravesli.com/sravnenie-linux-i-windows-v-chem-raznitsa-i-chto-luchshe/ "Сравнение Linux и Windows") уже содержались все доступные [[LL. Что такое драйвер | драйверы ]] устройств, и вам просто нужно было задействовать некоторые из них? В этом, по сути, и заключен принцип _загружаемых модулей ядра Linux_ (сокр. _**«****LKM»**_ от англ. _«**L**oadable **K**ernel **M**odule»_). Они должны обеспечивать взаимодействие ядра со всем вашим оборудованием, и при этом не занимать всю доступную память.

**Модули** обычно расширяют базовые возможности ядра, связанные с различной работой устройств, файловых систем и системных вызовов. Они, как правило, имеют расширение _.ko_ и обычно хранятся в каталоге _/lib/modules_:

![[Pasted image 20221019094249.png]]

Благодаря модульной структуре, вы можете легко настроить ядро под себя, установив необходимые модули с помощью `menuconfig` или отредактировав файл _/boot/config_, или вы можете загружать и выгружать модули «на лету» с помощью команды `modprobe`.

В некоторых дистрибутивах, таких как [**Ubuntu**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/#toc-9), доступны модули сторонних производителей или с закрытым исходным кодом. Разработчики программного обеспечения (например, NVIDIA, AMD и др.) не предоставляют исходный код, а скорее создают свои собственные модули в виде предварительно скомпилированных _.ko_-файлов. Некоторые разработчики Linux считают, что такие закрытые модули «портят» своим присутствием ядро, предоставляя [**несвободное программное обеспечение**](https://ravesli.com/copyright-i-copyleft-litsenziya-gnu-gpl/ "Copyright и Copyleft. Лицензия GNU GPL"), и не включают их в свои дистрибутивы.

## Для особо одаренных 

Модули ядра — это фрагменты кода, которые могут быть загружены и выгружены в ядро по требованию. Они расширяют функциональность ядра без необходимости перезагрузки системы. Модуль может быть настроен как встроенный в ядро или загружаемый во время работы операционной системы.

Примеры модулей ядра — это [[LL. Что такое драйвер | драйверы ]] различных устройств.

**Wiki:** Модуль ядра, загружаемый модуль ядра** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") loadable kernel module, LKM) — [объектный файл](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB "Объектный файл"), содержащий код, расширяющий функциональность запущенного или так называемого базового [ядра ОС](https://ru.wikipedia.org/wiki/%D0%AF%D0%B4%D1%80%D0%BE_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B "Ядро операционной системы"). Модули ядра используются, чтобы добавить поддержку нового [оборудования](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%BE%D1%80%D1%83%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Компьютерное оборудование") или [файловых систем](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Файловая система") или для добавления новых [системных вызовов](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2 "Системный вызов"). Когда функциональность, предоставляемая модулем, больше не требуется, он может быть выгружен, чтобы освободить память и другие ресурсы.

Как мы уже знаем, в модулях храниться код необходимой для работы с оборудованием или программный функционал. Все обычно происходить не заметно для пользователя, например вы вставили флешку, а ядро загрузла модуль для работы с usb-флэшками, также модуль для работы с файловой системой на этой флэшке. На других ОС это может работать по другому. 

В мире Linux модули загружаются и выгружаются утилитой modprobe. Модули хранятся в /lib/modules в файлах с расширением .ko («kernel object»), начиная с версии Linux 2.6. В предыдущих версиях использовалось расширение ".ko" . Команда lsmod показывает список загруженных модулей ядра и зависимости между ними. Если в Windows вы сначало грузите систему, а потом драйвера, то в Linux всё предосмотрено в виде модулей.

В файле **/lib/modules/(version)/modules.alias** перечислено для каких устройств какие модули грузить в ядро. В отличии от Windows где вы устанавливаете систему, потом устанавливаете [[LL. Что такое драйвер | драйвера ]], в Linux большинство драйверов уже предустанвлены в виде модулей. Это благодаря тому что производители оборудование сотрудничают с разработчиками ядра и предоставляют открытый исходный код драйверов на оборудование. Но не все производители предастваляют исходный код своих драйверов, из за чего он может не работать из коробки.  А еще бывает так что с п.м. ревёрс инжинеринга создают свободные дравйвера. То есть берут драйвера с закрытым исходным кодом, изучают его с п.м. специальных программ программ и методик и стараются воссоздать этот драйвер. Для видеокарт Nvidia таким образом был создан драйвер nouveau. Это работает, но естественно без гарантии. 

Возварщаемся к файлу. Там очень много список устройств, но для примера мы подберём только одну:

>`alias pci:v00001002d00004242sv*sd*bc*sc*i* radeonfb

Во втором столбике у нас перечислены идентификаторы оборудование (Hardware ID). Если ядро видет что к PCI шине подключено устройства у которого:

  - Vendor ID - 1002;
  - Device ID - 4242;

То ядро знает что, для этого устройства нужен модуль с названием radeon:

### Device Details

### R200 [All-In-Wonder Radeon 8500 DV]

| Type | Information |
| ---- | ----------- |
| ID   | 4242        |

### Vendor Details

### Advanced Micro Devices, Inc. [AMD/ATI]

| Type | Information |
| ---- | ----------- |
|      |             |

У нас может быть версии какого-то оборудование, классы и подклассы. Но нам это сейчас не особо важно. В интернете польно информации о них. Есть много разных сайтов для поиска оборудование по его ID. Например - https://devicehunt.com

У каждой информации своя задача. И всё это нужен ради того чтобы установть нужный драйвер. И ядро смотрить в файл **/lib/modules/(version)/modules.alias** и устанавливает нужный драйвер. Например, если оборудование такой, производитель такой, версия такая, а это такой - то установи вот это!.

## Получение информации о модулях  

Модули храняться в директории **/usr/lib/modules/ВЫПУСК_ЯДРА**. Текущую папку с модулями можно узнать командой:

>`echo` `/lib/modules/``` ` ```uname` `` -r` ``

Пример вывода:

>/lib/modules/5.6.14-arch1-1`


Имена модулей часто содержат символы подчёркивания (**_**) или дефисы (**-**); при этом данные символы являются взаимозаменяемыми в командах **modprobe** и в конфигурационных файлах в директории **/etc/modprobe.d/**.

Команда **lsmod** показывает драйверы и другие модули, которые загружены в данный момент. Чтобы увидеть, какие модули загружены в данный момент, выполните:

>`lsmod`
  
или команду

>`kmod list`

На самом деле, это одно и то же. Информация считывается из **/proc/modules** и данные команды только выводят её в более понятном для восприятия виде.

Для показа информации о модуле используется команда **modinfo**:

>`modinfo ИМЯ_МОДУЛЯ`

Если вы получили ошибку:

>`bash``: modinfo: команда не найдена`

То запустите **modinfo** с [sudo](https://hackware.ru/?p=11183).

К примеру, чтобы узнать информацию о модуле **iwlwifi**:

>`modinfo iwlwifi`

Как понять вывод modinfo

Вывод **modinfo** обширен и содержит много информации.

Строка «**filename**» показывает полный путь до файла модуля.

В строке «**author**» содержится информация о создателе модуля, например, «Copyright(c) 2003- 2015 Intel Corporation <linuxwifi@intel.com>»

В строке «**description**» описание модуля, например, «Intel(R) Wireless WiFi driver for Linux».

---

Рассмотрим, как интерпретировать строки

-   **firmware**
-   **alias**
-   **intree**
-   **vermagic**

на примере модуля **i915**
 
>`modinfo i915`

Фрагмент вывода:


```

`filename:       /lib/modules/4.2.0-1-amd64/kernel/drivers/gpu/drm/i915/i915.ko`
`license:        GPL and additional rights`
`description:    Intel Graphics`
`author:         Intel Corporation`
`[...]`
`firmware:       i915/skl_dmc_ver1.bin`
`alias:          pci:v00008086d00005A84sv*sd*bc03sc*i*`
`[...]`
`depends:        drm_kms_helper,drm,video,button,i2c-algo-bit`
`intree:         Y`
`vermagic:       4.2.0-1-amd64 SMP mod_unload modversions`
`parm:           modeset:Use kernel modesetting [KMS] (0=DRM_I915_KMS from .config, 1=on, -1=force vga console preference [default]) (int)`

`[...]`


```

**firmware:**


>`firmware:       i915/skl_dmc_ver1.bin`

Многим устройствам для правильной работы нужны две вещи: драйвер и прошивка. Драйвер запрашивает прошивку из файловой системы в **/lib/firmware**. Это специальный файл, необходимый для аппаратного обеспечения, это не бинарный файл. Затем дайвер делает всё, что нужно для загрузки прошивки в устройство. Прошивка выполняет программирование оборудования внутри устройства.

**alias:**

>`alias:          pci:v00008086d00005A84sv*sd*bc03sc*i*`

Эту запись можно разделить на части символами двоеточия (**:**)

-   **pci**: тип устройства, pci или usb

-   **v00008086**: **v** обозначает идентификатор поставщика, он идентифицирует производителя оборудования. Этот список поддерживается Специальной группой интересов PCI ([PCI Special Interest Group](https://pcisig.com/)). Номер 0x8086 означает «Корпорация Intel».

-   **d00005A84**: **d** обозначает идентификатор устройства, выбранный производителем. Этот идентификатор обычно соединяется с идентификатором поставщика, чтобы создать уникальный 32-битный идентификатор для аппаратного устройства. Официального списка нет.

-   **sv***, **sd***: версия поставщика подсистемы и версия устройства подсистемы для дальнейшей идентификации устройства (***** указывает, что оно будет соответствовать чему угодно)

-   **bc03**: базовый класс. Это определяет, что это за устройство; Интерфейс IDE, контроллер Ethernet, контроллер USB, … **bc03** означает контроллер дисплея. Вы можете заметить их из вывода **lspci**, потому что **lspci** сопоставляет число и класс устройства.

-   **sc***: подкласс базового класса.

-   **i***: интерфейс

**intree:**



>`intree:         Y`

Все модули ядра начинают свои разработки как вне дерева. Как только модуль принимается для включения, он становится модулем внутри дерева. Модули без этого флага (установленного в **N**) могут испортить ядро.

**vermagic:**

>`vermagic:       4.2.0-1-amd64 SMP mod_unload modversions`

При загрузке модуля строка **vermagic** проверяются на совпадение с текущей версией ядра. Если они не совпадают, вы получите ошибку, и ядро откажется загружать модуль. Вы можете преодолеть это, используя в modprobe флаг **--force**. Естественно, эти проверки существуют для вашей защиты, поэтому использование этой опции опасно.

Для вывода списка опций, установленных для загруженного модуля:

>`systool -``v` `-m ИМЯ_МОДУЛЯ`

Если вы получили ошибку:

>`bash``: systool: команда не найдена`

То установите пакет **sysfsutils**.

Пример вывода для модуля iwlwifi:

>`systool -``v` `-m iwlwifi`

Для отображения полной конфигурации всех модулей:

>`modprobe -c |` `less`

Чтобы отобразить конфигурацию определённого модуля:

>`modprobe -c |` `grep` `ИМЯ_МОДУЛЯ`

Чтобы перечислить зависимости модуля (или псевдонима), включая сам модуль:

>`modprobe --show-depends ИМЯ_МОДУЛЯ`


## Версии ядра дистрибутивов Linux

  

### Stable

**Stable** — это последняя доступная стабильная версия ядра Linux, предназначенная для широкого круга использования. По умолчанию, в большинстве дистрибутивов Linux применяется именно stable-версия ядра. Она регулярно обновляется, и к ней довольно часто выпускаются новые патчи.  

### LTS

**LTS** (сокр. от _«**L**ong-**T**erm **S**upport»_) — это версия ядра с длительным сроком поддержки, которая считается более стабильной в сравнении с обычной версией ядра, т.к. при её разработке программисты стараются не экспериментировать с различными нововведениями. Однако из-за этого, LTS-версии ядра могут не иметь некоторых функций ядер более свежих релизов, а также содержать старые версии драйверов, несовместимых с более новым оборудованием. Жизненный цикл LTS-ядра, обычно, составляет 5 лет для настольных компьютеров и серверов (раньше для настольных компьютеров поддержка осуществлялась на протяжении 3 лет). Для сравнения, обычные релизы ядра имеют поддержку всего 9 месяцев с момента выпуска.

Несмотря на то, что исправления безопасности внедряются в LTS-версию так же часто, как и в обычную, она, тем не менее, не дает 100% гарантии отсутствия каких-либо ошибок. Правда, шанс того, что с LTS-версией ядра Linux возникнут какие-то проблемы, немного меньше по сравнению с обычной версией ядра Linux, и поэтому многие предприятия отдают предпочтение именно LTS-релизам.

**_Примечание_**: По данным компании Canonical, примерно 95% всех установок Ubuntu являются LTS-релизами.

### Hardened

**Hardened** — это усиленная различными обновлениями безопасности stable-версия ядра Linux. Она умеет блокировать потенциально опасные операции, обеспечивая тем самым эффективную защиту от [**эксплойтов**](https://ravesli.com/slovar-programmista-sleng-kotoryj-dolzhen-znat-kazhdyj-koder/ "Словарь программиста. Сленг, который должен знать каждый кодер"), нацеленных на использование уязвимостей ядра. Данная версия ядра не так популярна, как другие, из-за того, что несколько медленнее их. Hardened-ядро убивает любой процесс, который покажется ему потенциально опасным. Кроме этого, он не отображает [**PID процессов**](https://ravesli.com/processes-v-linux/#toc-1), и, следовательно, вы не сможете напрямую обратиться к запущенному исполняемому файлу. Также некоторые программы и функции могут не работать с hardened-ядром.  

### Zen

**Zen** — версия ядра Linux, ориентированная на повышение производительности и отзывчивости системы. Также говорят, что это лучшее ядро Linux для игр. Zen имеет низкую задержку и высокочастотный планировщик.

## Установка/Обновление ядра Linux

В Linux есть _исходное_ ядро, которое разработал Линус Торвальдс, а затем уже дополняли и дополняют другие разработчики и организации вместе с Линусом Торвальдсом. Расположено _исходное_ ядро на сайте [**kernel.org**](https://www.kernel.org/).

Все дистрибутивы Linux (Debian, Ubuntu, Manjaro, CentOS и др.), которые начали появляться после публикации _исходного_ ядра, стали вносить свои изменения и дополнения, формируя, таким образом, свой вариант _исходного_ ядра Linux. Все Linux-дистрибутивы имеют в своей основе _исходное_ ядро из kernel.org, но уже с внесенными в него соответствующими правками.

**_Примечание_**: Ядра разных дистрибутивов не являются взаимозаменяемыми. Теоретически, можно _«подкинуть»_, например, ядро из Debian в Ubuntu. И система даже заработает (ведь Ubuntu произошла от Debian), но в 99% случаев начнут появляться разные глюки и баги.

Соответственно, из этого можно сделать следующие выводы:

   - Если вы хотите установить «чистое», оригинальное ядро Linux, то вам нужно скачать его с kernel.org, затем сконфигурировать на свое усмотрение и наслаждаться.

   - Если вам нужно ядро Linux с правками под какой-то конкретный дистрибутив (например, Debian или Manjaro), то вам нужно скачать ядро из репозитория конкретного дистрибутива с помощью менеджера пакетов.

Зачем тогда нужен kernel.org? Дело в том, что сначала свежая версия _исходного_ ядра появляется на kernel.org, а затем уже «расходится» по репозиториям остальных дистрибутивов.

Есть 2 способа установки/обновления ядра Linux:

   - [**Самостоятельная установка и конфигурирование ядра Linux**](https://ravesli.com/build-linux-kernel-from-scratch/ "Как собрать ядро Linux с нуля").

   - Обновление ядра Linux через менеджер пакетов.

На этом уроке мы рассмотрим обновление ядра Linux через менеджер пакетов, а на следующем — самостоятельную установку и конфигурирование ядра Linux.


## Заключение

Linux поддерживает целый ряд аппаратных устройств от телефонов и до суперкомпьютеров. Каждая операционная система на базе ядра Linux имеет ядро Linux и набор ПО для управления аппаратными ресурсами компьютера.

На следующих уроках мы детально рассмотрим тему лицензии GNU GPL, **[сравним Linux и Windows](https://ravesli.com/sravnenie-linux-i-windows-v-chem-raznitsa-i-chto-luchshe/ "Сравнение Linux и Windows")**, выполним [**обзор дистрибутивов Linux**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Обзор дистрибутивов Linux. Какой выбрать?") и продолжим наше погружение в изучение Linux.




# Если вам интересно как пишут модули ядра, то вот вам несколько ссылок

[Программирование модуля ядра Linux — простейший пример](https://dzone.com/articles/linux-kernel-module-programming-simplest-example)
[Стиль кодирования ядра Linux](https://www.kernel.org/doc/html/v4.10/process/coding-style.html)
[MODULE_LICENSE("GPL")](https://www.google.com/search?client=firefox-b-d&q=ODULE_LICENSE%28%22GPL%22%29)
[Hello World (часть 4): Лицензирование и документация по модулю](https://tldp.org/LDP/lkmpg/2.6/html/x279.html)
[Hello World (часть 1): самый простой модуль](https://tldp.org/LDP/lkmpg/2.6/html/x121.html)
[printk](https://en.wikipedia.org/wiki/Printk)
[Стиль кодирования ядра Linux "Google"](https://www.google.com/search?client=firefox-b-d&q=%D0%A1%D1%82%D0%B8%D0%BB%D1%8C+%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F+%D1%8F%D0%B4%D1%80%D0%B0+Linux+)
[Стиль кода ядра Linux](https://russianblogs.com/article/44151818408/)

**Зацепка

```
Стиль кодирования ядра Linux

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Sachith Muhandiram");
MODULE_DESCRIPTION("Simple first Linux module");
MODULE_VERSION("1.0.0");

printk(KERN_INFO "Hello, this is my first kernel module \n");
module_init(initHelloWorld);
```
