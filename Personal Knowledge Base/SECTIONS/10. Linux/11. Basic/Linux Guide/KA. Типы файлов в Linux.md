Философия операционных систем Unix гласит, что все есть файл. Это значит, что вся работа с этой операционной системой сводится к файлам. Поскольку Linux можно считать тоже потомком Unix, то эта концепция применима и здесь. Файлы это объекты, в которые мы записываем информацию и наши данные, исполняемые файлы, но кроме этих привычных нам понятий здесь есть файлы специального назначения - файлы устройств, файлы туннелей, сокетов и многое другое. Эта тема очень слабо освещена в интернете, поэтому в нашей сегодняшней статье мы рассмотрим типы файлов linux.

Пространство нашего жесткого диска занято файлами разных типов. Например, взять даже наш корневой раздел (/), при создании файла, файловая система записывает его в определенном формате на нужное физическое место жесткого диска. Всегда, для работы с файлами используется файловая система, но не всегда она записывает файлы на диск, файловая система может работать на лету, генерируя файлы, например, как procfs, с помощью которой может быть выполнена настройка ядра linux или записывать файлы в оперативную память, как tmpfs расположенная в папке /tmp. Но все это не имеет значения, ведь в любом случае мы имеем дело именно с файлами.

В системе Linux нет различий между каталогами и файлами. Но каталоги могут объединять другие файлы в группы, чтобы их было легче найти и использовать. Все аппаратные устройства представлены в виде файлов и находятся в каталоге dev, только через эти файлы программы могут работать с ними.

Преимущество использования файлов как для обычной информации, так и для устройств, в том, что не нужно реализовать отдельный набор [[NN. Что такое API | API]] интерфейсов для каждого устройства, с ним могут работать все стандартные утилиты Linux и [[NN. Что такое API | API]] интерфейсы.

При навигации по файловой системе в [**Linux**](https://ravesli.com/chto-takoe-linux-ego-struktura-i-preimushhestva/ "Что такое Linux? Его преимущества"), вы обязательно столкнетесь с различными типами файлов. Наиболее часто используемые и очевидные типы — это обычные файлы и каталоги. Однако помимо их в Linux также существуют еще 5 специальных типов.

# Типы файлов в Linux

Файлы в операционной системе Linux можно поделить на три основных типа:

-   Обычные файлы, для хранения информации
-   Специальные файлы - для устройств и туннелей
-   Директории


Ниже представлено краткое описание **7 различных типов файлов в Linux**:

   `-` — обычный файл;

   `d` — каталог;

   `c` — символьное устройство;

   `b` — блочное устройство;

   `s` — (локальный) сокет;

   `p` — именованный канал;

   `l` — символьная ссылка.

Дальше рассмотрим более подробно эти типы файлов linux.



# Обычные файлы


_Обозначается как_ `-`

**Обычный файл** — это наиболее распространенный тип файлов в Linux. Текстовые файлы, изображения, двоичные файлы, общие библиотеки и т.д. — все они относятся к _обычному типу файлов_. Вы можете создать _обычный файл_ с помощью команды `touch`:

`diego@debian:~$ touch ravesli.txt  
`diego@debian:~$ ls -ld ravesli.txt 
`-rw-r--r-- 1 diego diego 0 фев 20 11:14 ravesli.txt`

Первый символ вывода команды `ls`, в данном случае `-`, обозначает, что перед нами _обычный файл_. Для удаления _обычного файла_ используется команда `rm` (сокр. от _«_**_r_**_e**m**ove»_):

`diego@debian:~$ rm ravesli.txt   
`diego@debian:~$ ls -ld ravesli.txt  
`ls: невозможно получить доступ к 'ravesli.txt': Нет такого файла или каталога`

---
то есть это файлы, с которыми мы привыкли работать каждый день, они могут содержать текст, исполняемые инструкции для программ, изображения или другую информацию. Это самый распространенный тип файлов, которые вы можете найти в системе Linux. Рассмотрим небольшой список относящихся сюда файлов:

-   Текстовые файлы
-   Исполняемые файлы
-   Файлы изображений
-   Файлы архивов
-   Файлы библиотек программ
-   И другие подобные типы

### Идентификация типов файлов в Linux

Для определения типа файла достаточно воспользоваться всего одной командой:

`$ ls -ld <имя_файла>`

Например:

`$ ls -ld /etc/services   -rw-r--r-- 1 root root 19281 Feb 14  2012 /etc/services`

Команда `ls` отобразит тип файла в виде первого символа из списка. В данном случае этим символом будет `-`, обозначающий _«обычный файл»_. Важно отметить, что в Linux не следует путать типы файлов с расширениями файлов.


Утилита ls может определять тип файла в режиме списка, обычные файлы обозначаются черточкой, например:

`ls -l /bin/ | grep "^-"`

![[Pasted image 20221024044157.png]]

Эта статья была бы неполной, если бы мы рассматривали типы файлов, но не упомянули о форматах. Дело в том, что все обычные файлы сохранены в определенном формате, это нужно, чтобы система знала какой программой нужно открывать файл.

Посмотреть форматы файлов linux можно с помощью утилиты file. Например:

 `file /bin/tar`

![[Pasted image 20221024044224.png]]

Система сообщила что это исполняемый файл, а теперь посмотрим обычный, текстовый:

`file /etc/passwd`

![[Pasted image 20221024044255.png]]

Утилита умеет распознавать все известные форматы файлов. Чтобы узнать вывести все доступные форматы файлов linux наберите:

`file -l`



# Специальные файлы

Специальные файлы намного интереснее, они предназначены для обмена информации с ядром, работы с устройствами или общения между программами. Такие файлы могут тоже быть нескольких типов, в зависимости от назначения.

## Блочные файлы 

_Обозначается как_ `b`

**Блочные устройства** похожи на символьные. Чаще всего они управляют аппаратными устройствами, такими как: жесткие диски, память и т.д. Большинство из них располагаются в каталоге _`/dev`_:

`diego@debian:~$ ls -ld /dev/sda  
`brw-rw---- 1 root disk 8, 0 фев 20 12:49 /dev/sda`

то есть эти файлы устройств, которые обеспечивают буферизованный доступ к аппаратным компонентам. При записи данных на жесткий диск или на флешку нет смысла записывать данные сразу же после их поступления. Так мы будем только понапрасну расходовать ресурс устройства и энергию. Можно подождать пока наберется достаточное количество данных а потом записать их за один раз. Эти данные и собираются в буфере. С помощью таких файлов, файловая система и другие утилиты могут обращаться к драйверам аппаратных устройств. Такие файлы могут передать большой блок данных за небольшой один раз.

Утилита ls обозначает блочные файлы буквой b, например, выберем все блочные файлы из каталога /dev:

`ls -l /dev/ | grep "^b"`

![[Pasted image 20221024044935.png]]

Утилита file, которую мы рассматривали в предыдущем разделе тоже умеет определять типы файлов:

`file /dev/sda`

![[Pasted image 20221024044959.png]]


## Символьные файлы

_Обозначается как_ `c`

**Символьные и блочные файлы устройств** позволяют пользователям и программам взаимодействовать с аппаратными периферийными устройствами. При этом символьные устройства обеспечивают последовательный поток ввода или вывода:

`diego@debian:~$ sudo ls -ld /dev/urandom  
`crw-rw-rw- 1 root root 1, 9 фев 20 12:49 /dev/urandom`

В этом примере символьным устройством является генератор псевдослучайных чисел.

то есть символьные файлы обеспечивают не буферизованный доступ к аппаратным компонентам и ядру. Поскольку у них нет буфера, они позволяют передавать только по одному символу за один раз. А в остальном, это такие же файлы устройств, как и блочные файлы.

Вы также можете отфильтровать их с помощью ls. Символьные файлы обозначаются буквой c (character):

`ls -l /dev/ | grep "^c"`

![[Pasted image 20221024045454.png]]

## Символические ссылки

### Символьные ссылки

_Обозначаются как_ `l`

С помощью **символьных ссылок** администратор назначает файлу или каталогу несколько идентификаторов. Символьную ссылку можно рассматривать как [**указатель**](https://ravesli.com/urok-80-ukazateli-vvedenie/ "Урок №80. Указатели") на исходный файл.

Существует **два типа символьных ссылок в Linux**:

   - **Мягкая ссылка** является указателем на некоторый файл или каталог (сродни ярлыкам в Windows). Если вы переместите файл, связь с символьной ссылкой разорвётся (но сама ссылка все еще будет существовать, указывая на файл, которого нет). Если вы замените файл другим, сохранив имя, символьная ссылка будет указывать на новый файл. Символьные ссылки могут охватывать различные разделы файловой системы.

   - **Жесткая ссылка** привязывается только к файлам, охватывает только один раздел файловой системы и, по сути, является тем же файлом, на который ссылается.

Для создания символьной мягкой ссылки используется команда `ln -s`:

`diego@debian:~$ echo file1 > file1  
`diego@debian:~$ ln -s file1 file2 
`diego@debian:~$ cat file2  
`file1 
`diego@debian:~$ ls -ld file2   
``lrwxrwxrwx 1 diego diego 5 фев 20 14:11 file2 -> file1`

Чтобы удалить символьную ссылку, мы можем использовать команду `unlink` или `rm`.

то есть эти файлы, которые указывают на другие файлы в системе по их имени. Они могут указывать как на обычные файлы, таки на каталоги или другие типы файлов в linux. По сути, это те же ярлыки Windows. В Linux еще есть жесткие ссылки, но они не имеют отношения к типу файлов, потому что реализованы на уровне файловой системы и считаются обычными файлами. Поскольку они указывают на одно и то же место на диске, это два разных файла, с одинаковым содержимым.

Но вернемся к символическим ссылкам. Утилита ls обозначает их буквой l (link):

`ls -l /dev/ | grep "^l"`

![[Pasted image 20221024045544.png]]

Создавать символические ссылки можно с помощью утилиты ln. Например:

`ln -s file1.txt file2.txt`

Можете использовать ls чтобы убедиться в том, что это ссылка. Проверьте таким же образом жесткие ссылки, чтобы убедиться, что то что я сказал о них - правда.

**Туннели и именованные туннели** - это файлы, позволяющие настроить связь между двумя процессами перенаправив вывод одного процесса на вход другого. Именованные туннели используются для связи между двумя процессами и работают так же как и обычные туннели.

Обозначаются такие типы файлов linux буквой p (pipe):

`ls -l /dev/ | grep "^p"`

![[Pasted image 20221024045605.png]]

Чтобы создать именованный тоннель вы можете использовать утилиту mkfifo:

`mkfifo pipe1`

`echo "test test test" > pipe1`

После создания туннеля мы передали в него данные, и оболочка стала не интерактивной. Она будет ожидать пока данные будут прочитаны на другом конце туннеля. Открываем другую оболочку и читаем данные:

`while read line ;do echo "Data: '$line' "; done<pipe1`

## Файлы сокетов 

_Обозначаются как_ `s`

Как правило, **локальные сокеты** используются для связи между такими службами, как: X Window, syslog и т.д.

`$ ls -ld /dev/log  
`srw-rw-rw- 1 root root 0 Jan  4 10:13 /dev/log`
 
То есть эти файлы, обеспечивающие прямую связь между процессами, они могут передавать информацию между процессами, запущенными в разных средах или даже разных машинах. Это значит, что с помощью сокетов программы могут обмениваться данными даже по сети. По сути, сокет работает так же как туннели, но только в обе стороны.

Файлы сокетов обозначаются буквой s:

`ls -l /dev/ | grep "^s"`

![[Pasted image 20221024045628.png]]

Создать сокет можно с помощью функции socket() на языке программирования Си, чтение и запись выполняется системными вызовами read() и write(). Но нам сейчас не нужно писать реальную программу, будет достаточно немного поиграться. Поэтому воспользуемся утилитой nc. Создаем Unix сокет:

`nc -lU socket.sock`

![[Pasted image 20221024045732.png]]

Подключаемся к нему из другой консоли:

`nc -U socket.sock`

Все данные, которые вы будете набирать в одной из консолей будут отправляться на другую после нажатия Enter, связь работает в обоих направлениях.

## Каталоги

_Обозначается как_ `d`

**Каталог** — это второй по распространенности тип файлов в Linux. Каталог можно создать с помощью команды `mkdir` (сокр. от _«_**_m_**_a**k**e_ **_dir_**_ectory»_):

`diego@debian:~$ mkdir ravesli  
`diego@debian:~$ ls -ld ravesli 
`drwxr-xr-x 2 diego diego 4096 фев 20 12:14 ravesli`

Как объяснялось ранее, каталогу соответствует символ `d` (от _«_**_d_**_irectory»_) выходных данных команды `ls`. Для удаления пустого каталога используется команда `rmdir` (сокр. от _«_**_r_**_e**m**ove_ **_dir_**_ectory»_):

`diego@debian:~$ rmdir ravesli 
`diego@debian:~$ ls -ld ravesli 
`ls: невозможно получить доступ к 'ravesli': Нет такого файла или каталога`

При попытке удалить каталог, содержащий внутри себя файлы, вы получите сообщение об ошибке:

`diego@debian:~$ mkdir ravesli 
`diego@debian:~$ touch /home/diego/ravesli/ravesli.txt 
`diego@debian:~$ rmdir ravesli  
`rmdir: не удалось удалить 'ravesli': Каталог не пуст`

В этом случае вам нужно использовать команду `rm -r`:

`diego@debian:~$ rm -r ravesli/ 
`diego@debian:~$ ls -ld ravesli 
`ls: невозможно получить доступ к 'ravesli': Нет такого файла или каталога   diego@debian:~$`

то есть это специальные файлы, которые позволяют объединять другие и каталоги в группы для более простой навигации и поиска. Естественно, они могут содержать как обычные, так и специальные файлы, одним словом любые типы файлов ос linux. В системе Linux, файлы организуются в папки начиная от корня (/)

Обозначаются каталоги буквой **d** (directory):

![[Pasted image 20221024045857.png]]


Создать каталог в linux можно с помощью команды mkdir:

`mkdir каталог1`

## Именованные каналы

_Обозначаются как_ `p`

Подобно локальным сокетам, **именованные каналы** позволяют осуществлять связь между двумя локальными процессами. Основное отличие от сокетов в том, что через каналы данные могут проходить одновременно только в одном направлении. Они могут быть созданы с помощью команды `mknod` и удалены с помощью команды `rm`.

# Заключение

Как системный администратор вы, в основном, будете иметь дело с _обычными файлами_, _каталогами_ и _символьными устройствами_. Как разработчик программного обеспечения вы будете сталкиваться с _сокетами_ и _именованными каналами_.