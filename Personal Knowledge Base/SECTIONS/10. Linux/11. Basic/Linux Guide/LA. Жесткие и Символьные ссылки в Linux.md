**Ссылка** в Unix-подобных системах — это своего рода указатель, напоминающий [**указатели в языках программирования**](https://ravesli.com/urok-80-ukazateli-vvedenie/ "Урок №80. Указатели"), с той лишь разницей, что он указывает на файл или каталог. Ссылки позволяют нескольким именам файлов ссылаться на один и тот же файл, расположенный где-то в другом месте. В [**Linux-системах**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Обзор дистрибутивов Linux. Какой выбрать?") существуют два разных типа ссылок: **символьная** (или **_«мягкая»_**, **_«символическая»_**) **ссылка** и **жесткая ссылка**. На этом уроке мы разберем, чем символьная ссылка отличается от жесткой, и как с ними работать.

**losst:** Символические и жесткие ссылки - это особенность файловой системы Linux, которая позволяет размещать один и тот же файл в нескольких директориях. Это очень похоже на ярлыки в Windows, так как файл на самом деле остается там же где и был, но вы можете на него сослаться из любого другого места.

В Linux существует два типа ссылок на файлы. Это символические и жесткие ссылки Linux. Они очень сильно отличаются и каждый тип имеет очень важное значение. В этой небольшой статье мы рассмотрим чем же отличаются эти ссылки, зачем они нужны, а также как создавать ссылки на файлы в Linux.

# Жесткая ссылка (Hard link)

Предположим, вы захотели скопировать файл. В процессе копирования будет создан новый файл. Его непосредственные данные запишутся в свободное место на диске, а самому файлу система назначит уникальный идентификатор — **_индексный номер_** (сокр. **_«inode»_** от англ. _«**i**ndex **node**«)._

Создавая **жесткую ссылку** (англ. _«hard link»_) на файл, мы привязываемся к его индексному номеру, получая тот же самый файл (с новым именем), на который указывает ссылка, но без физического создании копии.

![[Pasted image 20221026043638.png]]


**losst:** Этот тип ссылок реализован на более низком уровне файловой системы. Файл размещен только в определенном месте жесткого диска. Но на это место могут ссылаться несколько ссылок из файловой системы. Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. Рассмотрим особенности:

-   Работают только в пределах одной файловой системы;
-   Нельзя ссылаться на каталоги;
-   Имеют ту же информацию inode и набор разрешений что и у исходного файла;
-   Разрешения на ссылку изменяться при изменении разрешений файла;
-   Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

## Создаение жесткой ссылки

Для создания жесткой ссылки используется **команда ln** (от англ. _«**l**i**n**k»_), имеющая довольно простой синтаксис:

>**ln опции файл_источник файл_ссылки**

Рассмотрим опции утилиты:

-   **-d** - разрешить создавать жесткие ссылки для директорий суперпользователю;
-   **-f** - удалять существующие ссылки;
-   **-i** - спрашивать нужно ли удалять существующие ссылки;
-   **-P** - создать жесткую ссылку;
-   **-r** - создать символическую ссылку с относительным путем к файлу;
-   **-s** - создать символическую ссылку.

Для примера создадим ссылку с именем _hardlink1_, указывающую на уже существующий файл _file1_:

`$ ln file1 hardlink1`

Чтобы убедиться, что файл _file1_ и ссылка _hardlink1_, по сути, являются одним и тем же объектом файловой системы — сравним их индексные номера, выполнив команду `ls` вместе с опциями `-l` (отображать расширенную информацию), `-i` (выводить _inode_) и `-h` (использовать буквы для обозначения размера):

`$ ls –lih`

Результат:

![[Pasted image 20221026044159.png]]

Как можно заметить, _file1_ и _hardlink1_ имеют общий индексный номер — `131094`. Теперь давайте создадим еще одну ссылку и посмотрим, как поведет себя счетчик ссылок (число, следующее за группой установленных [**разрешений файла**](https://ravesli.com/tipy-polzovatelej-i-prava-dostupa-k-fajlam-katalogam-v-linux/#toc-1)):

`$ ln file1 hardlink2
``$ ls –lih`

Результат:

![[Pasted image 20221026044220.png]]

Обратите внимание, теперь счетчик ссылок показывает цифру 3 вместо 2.

### Пример 2

`echo "текст текст текст текст" > source  
``$ cat source`

![[Pasted image 20221026044402.png]]

Теперь создадим жесткую ссылку Linux. Для этого достаточно вызвать утилиту без параметров:

`ln source hardlink`

![[Pasted image 20221026044420.png]]

Посмотрите содержимое файла:

`cat hardlink`

![[Pasted image 20221026044434.png]]

Данные те же самые, а если мы посмотрим вывод утилиты ls, то увидим что inode и права доступа тоже совпадают:

`ls -li`

![[Pasted image 20221026044452.png]]

Если для одного из файлов поменять разрешения, то они изменяться и у другого. Теперь удалите исходный файл:

`rm source`

Затем посмотрите содержимое:

`cat hardlink`

![[Pasted image 20221026044509.png]]

Как видите, ничего не произошло и ссылка по-прежнему указывает на нужный участок диска, это главное отличие жесткой ссылки от символической. Мы можем сделать вывод, что жесткая ссылка linux это обычный файл. Каждый файл имеет как минимум одну ссылку, но для некоторых мы можем создать несколько ссылок.


## Символьная ссылка (Symbolic link)

**Символьная ссылка** (сокр. **_«symlink»_** от англ _«**sym**bolic **link**«_), в отличие от жесткой ссылки, указывает не на индексный номер файла, а на его имя (путь). В каком-то роде символьная ссылка является аналогом ярлыка в [**Windows-системах**](https://ravesli.com/istoriya-vseh-versij-os-windows/ "История всех версий ОС Windows").

![[Pasted image 20221026044715.png]]

### Создание символических ссылок

Символьную ссылку можно создать с помощью той же команды `ln`, добавив к ней опцию `-s`:

` ln -s file1 symlink1`

При этом будет создан новый (!) объект файловой системы с именем _symlink1_, указывающий на существующий файл _file1_:

![[Pasted image 20221026044814.png]]

Буква `l` в группе прав доступа к файлу сигнализирует нам о том, что этот файл является символьной ссылкой на другой файл, что также отражено в имени файла — `symlink1 -> file1`.

Сравним индексные номера _file1_, _hardlink1_, _hardlink2_ и _symlink1_:

![[Pasted image 20221026045044.png]]

Видно, что индексный номер _symlink1_ отличается от других номеров, так как для файловой системы это уже два независимых объекта. Также заметно и различие в наборе прав.

#### Пример 2

Сначала создайте папку test и перейдите в нее:

`mkdir test && cd test`

![[Pasted image 20221026045142.png]]

Затем создайте файл с именем source с каким-либо текстом:

`echo "текст текст текст текст" > source  
``$ cat source`

![[Pasted image 20221026045201.png]]

Файл готов, дальше создадим символическую ссылку Linux, для этого используется команда ln с опцией -s:

`ln -s source softlink`

![[Pasted image 20221026045214.png]]

Попробуем посмотреть содержимое файла по ссылке:

`cat softlink`

![[Pasted image 20221026045226.png]]

Как видите, нет никакой разницы между ней и исходным файлом. Но утилита ls покажет что это действительно ссылка:

`ls -li`

![[Pasted image 20221026045239.png]]

Несмотря на то, что содержимое одинаковое, здесь мы видим, что адрес иноды и права доступа к файлам отличаются, кроме того, явно показано что это символическая ссылка Linux.

Теперь удалите исходный файл и посмотрите что будет:

`cat softlink`

![[Pasted image 20221026045257.png]]

Вы получите ошибку, что такого файла не существует, потому что мы действительно удалили исходный файл. Если вы удалите ссылку, то исходный файл останется на месте.

