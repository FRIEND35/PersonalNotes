**Процесс** — это экземпляр запущенной программы. Всякий раз, когда в терминале выполняется какая-нибудь команда (например, команда `pwd`), система создает/запускает новый процесс.


# Типы процессов

В [**Linux**](https://ravesli.com/chto-takoe-linux-ego-struktura-i-preimushhestva/ "Что такое Linux? История создания Linux") существует три основных типа процессов:

   - **Процессы переднего плана** (или **_«интерактивны_****_е процес_****_сы»_**) — инициализируются и управляются с помощью терминального сеанса. Другими словами, необходимым условием для запуска таких процессов является наличие пользователя, подключенного к системе; они не запускаются автоматически как часть системных функций/служб. Когда команда/процесс выполняется на переднем плане, то они полностью занимают запустивший их терминал. Вы не сможете использовать другие команды, т.к. **[приглашение оболочки](https://ravesli.com/kak-izmenit-priglashenie-komandnoj-obolochki-bash-v-linux/ "Как изменить приглашение командной оболочки bash в Linux?")** будет недоступно, пока данный процесс выполняется на переднем плане.

   - **Фоновые процессы** (или **_«_****_автоматически_****_е процессы»_**) — это процессы, не подключенные к терминалу; они не ожидают пользовательского ввода данных. Таким образом, другие процессы могут выполняться параллельно с процессом, запущенным в фоновом режиме, поскольку им не нужно ждать его завершения.

   - [[DD. Демоны | Демоны]] (англ. **_«_****_daemons»_**) — это особый тип фоновых процессов, которые запускаются при старте системы и продолжают работать в виде службы; они не _умирают_. Такие процессы запускаются как системные задачи (службы). Однако при этом они могут управляться пользователем через _**init**_-процесс (о котором мы поговорим чуть позже). Например, к демонам относится служба электронных сообщений _sendmail_ и _sshd_ (служба, принимающая от клиентов запросы на соединения по протоколу ssh). За исключением процесса _init_ и некоторых других, процессы демонов обычно имеют окончание `d` в своем имени.


# Как Linux идентифицирует процессы?

Каждый процесс в операционной системе имеет свой уникальный идентификатор, по которому можно получить информацию об этом процессе, а также отправить ему управляющий сигнал или завершить. В Linux такой идентификатор называется PID.

PID — это аббревиатура от идентификационного номера процесса в Linux или Unix-подобной операционной системе. PID автоматически назначается каждому процессу при его создании. Процесс — это не что иное, как запущенный экземпляр программы, и каждый процесс имеет уникальный PID в Unix-подобной системе. Самый простой способ узнать, запущен ли процесс, — запустить команду ps aux и имя процесса grep. Если вы получили вывод вместе с именем процесса/pid, ваш процесс запущен.


Поскольку Linux является многопользовательской системой, разные пользователи могут запускать различные программы, при этом каждый запущенный экземпляр программы должен быть однозначно идентифицирован [[AA. Ядро linux | ядром]].

Процессы запущенной программы имеют уникальный пятизначный номер — **PID** (сокр. от _«**P**rocess **ID**entificator»_ — _«идентификатор процесса»_), а также **PPID** (сокр. от _«**P**arent **P**rocess **ID**entificator»_ — _«идентификатор родительского процесса»_). В связи с этим процессы дополнительно разделяют на две группы:

   - **Родительские процессы** — это процессы, которые во время своего выполнения создают другие процессы.

   - **Дочерние процессы** — эти процессы, создаваемые другими процессами во время своего выполнения.

Прародителем всех процессов в системе является **процесс init** (от англ. _«**init**ialization»_) — первая программа, которая выполняется при загрузке Linux и управляет всеми другими процессами в системе. init запускается самим ядром и всегда имеет _PID = 1_, поэтому у него в принципе нет родительского процесса.

**_Примечание:_** В любой момент времени в системе не существует двух процессов с одинаковым PID. Вновь создаваемому процессу может быть назначен ранее использованный свободный PID.

У каждого процесса также есть PPID, в котором хранится PID родительского процесса, которым был создан этот процесс. Также есть процесс TTY, в котором хранится идентификатор терминала, который вы использовали для запуска процесса, и UID, в котором хранится идентификатор создавшего его пользователя. Любой процесс, в котором отсутствует TTY, обычно называется _демоном_ . Этот термин используется для обозначения системных процессов, работающих в фоновом режиме и не имеющих управляющего терминала.

Всякий раз, когда процесс закрывается, этот PID становится доступным для использования другим процессом. Каждый процесс также закрывается с кодом выхода, обычно используемым для обозначения того, произошла ли ошибка. Код выхода 0 — это чистый выход, все, что больше, — это конкретная ошибка.

# Состояния процесса в Linux

Когда процесс передает ядру запрос, который не может быть исполнен сразу же, то процесс «погружается в сон/ожидание» и «пробуждается», когда запрос может быть удовлетворен. В связи с этим, в зависимости от текущей ситуации, процесс, во время своего выполнения, может переходить из одного состояния в другое:

![[Pasted image 20221018095607.png]]

Рассмотрим основные состояния процесса:

   - **Выполнение** — процесс либо запущен (текущий процесс в системе), либо готов к запуску (ожидает передачи на выполнение процессору).

   - **Ожидание** — процесс ожидает наступления некоторого события (пользовательского ввода, сигнала от другого процесса и т.п.) или выделения системных ресурсов. Кроме того, [[AA. Ядро linux | ядро]] также различает два типа ожидающих процессов:

       - _прерываемые ожидающие процессы_ — могут быть прерваны сигналами;

       - _непрерываемые ожидающие процессы_ — процессы ожидают непосредственно на аппаратном уровне и не могут быть прерваны каким-либо событием/сигналом.

   - **Завершен** — процесс был остановлен, как правило, путем получения сигнала штатного завершения работы _exit()_.

   - **Зомби** — иногда, когда родительский процесс убивается до завершения дочернего процесса, дочерние процессы становятся «осиротевшими», при этом в качестве нового родителя (с соответствующим изменением PPID) им назначается процесс init. Убитые процессы, но при этом все еще отображающиеся в таблице процессов, называются процессами **_зомби_** (они мертвы и не используются).


# Как получить идентификатор (PID) процесса

Для отображения идентификатора нужного вам процесса можно использовать **команду pidof**, например:

`$ pidof init 
``$ pidof bash
``$ pidof systemd`

![[Pasted image 20221018095736.png]]

**_Примечание_**: На вышеприведенном скриншоте вы можете видеть, что процессу init назначен `PID=1`, а процессу systemd — `PID=881`, хотя системой инициализации в Debian является именно systemd. Детально о том, почему возникла такая путаница, читайте [**здесь**](https://ravesli.com/linux-init-systems/#toc-11).

Чтобы вывести PID и PPID текущей оболочки, выполните:

`$ echo $$   
``$ echo $PPID`

![[Pasted image 20221018095801.png]]

# Запуск интерактивного процесса в Linux

Как только вы выполните какую-нибудь команду или программу (например, `firefox`), она создаст в системе соответствующий процесс. Вы можете запустить процесс переднего плана (он будет подключен к терминалу, ожидая пользовательского ввода) следующим образом:

`$ firefox`

![[Pasted image 20221018100224.png]]


# Запуск фонового процесса в Linux

Запуск процесса в фоновом режиме полезен только для программ, которые не нуждаются в пользовательском вводе (через [**оболочку**](https://ravesli.com/shell-v-linux/ "Что такое shell? Типы shell в Linux и Unix")). Перевод задания в фоновый режим обычно выполняется, когда ожидается, что выполнение задания займет много времени.

Кроме этого, в оболочку встроена **утилита управления заданиями jobs**, которая позволяет легко управлять несколькими процессами, переключая их между передним планом и фоновым исполнением. Также, с помощью `jobs` процессы могут быть сразу запущены в фоновом режиме.

Чтобы запустить процесс в фоновом режиме, используйте символ `&` после имени запускаемой программы. В этом случае процесс не будет принимать пользовательский ввод, пока не переместится на передний план:

`$ firefox &   
``$ jobs`

![[Pasted image 20221018100315.png]]

Вы также можете отправить процесс в фоновый режим, приостановив его с помощью сочетания клавиш _Ctrl+Z_. Данное сочетание клавиш отправит процессу сигнал `SIGSTOP`, тем самым переведя его в режим ожидания:

`$ firefox _#После Enter нажмите Ctrl+Z_   
``$ jobs`

Чтобы продолжить выполнение вышеупомянутой приостановленной команды в фоновом режиме, используйте **команду bg** (от англ. _«**b**e**g**in»_):

`$ bg`

Чтобы отправить фоновый процесс на передний план, используйте **команду fg** (от англ. _«**f**ore**g**round»_) вместе с идентификатором задания следующим образом:

`$ jobs 
``$ fg %1`

![[Pasted image 20221018100356.png]]


# Отслеживание активных процессов

Существует несколько различных инструментов для просмотра/перечисления запущенных в системе процессов. Двумя традиционными и хорошо известными из них являются **команды ps** и **top**.  

### Команда ps

Отображает информацию об активных процессах в системе, как показано на следующем скриншоте:

`$ ps  
``$ ps -e | head _#(head – фильтр, отображающий только первые 10 строк вывода команды "ps -e")_`

![[Pasted image 20221018100726.png]]

Для получения дополнительной информации о процессах, запущенных текущим пользователем, применяется опция `-f`:

`$ ps -f`

![[Pasted image 20221018100745.png]]

Столбцы, присутствующие в выводе команды `ps`, имеют следующие значения:

   - **UID** — идентификатор пользователя, которому принадлежит процесс (тот, от чьего имени происходит выполнение).

   - **PID** — идентификатор процесса.

   - **PPID** — идентификатор родительского процесса.

   - **C** — загрузка CPU процессом.

   - **STIME** — время начала выполнения процесса.

   - **TTY** — тип терминала, связанного с процессом.

   - **TIME** — количество процессорного времени, потраченного на выполнение процесса.

   - **CMD** — команда, запустившая этот процесс.

Также можно отобразить информацию по конкретному процессу, используя команду `ps -f [PID]`, например:

`$ ps -f 1208`

![[Pasted image 20221018100825.png]]

Есть и другие опции, которые можно использовать вместе с командой `ps`:

  -  `-a` — показывает информацию о процессах по всем пользователям;

  - `-x` — показывает информацию о процессах без терминалов;

 -  `-u` — показывает дополнительную информацию о процессе по заданному UID или имени пользователя;

 - `-e` — отображение расширенной информации.

Если вы хотите вывести вообще всю информацию по всем процессам системы, то используйте команду `ps –aux`:

![[Pasted image 20221018100914.png]]

Обратите внимание на выделенный заголовок. Команда `ps` поддерживает функцию сортировки процессов по соответствующим столбцам. Например, чтобы отсортировать список процессов _по потреблению ресурсов процессора (в порядке возрастания)_, введите команду:

`$ ps -aux --sort=**%cpu**`

Результат:

![[Pasted image 20221018101005.png]]


Если вы хотите выполнить сортировку по _потреблению памяти (в порядке убывания),_ то добавьте к имени интересующего столбца знак минуса:

`$ ps -aux --sort=**-%mem**`

Результат:

![[Pasted image 20221018101024.png]]

Еще один очень популярный пример использования команды `ps` — это объединение её и [**команды grep**](https://ravesli.com/top-komand-v-linux-dlya-sisadminov/#toc-15) для поиска заданного процесса по его имени:

`$ ps -aux | grep bash`

Результат:

![[Pasted image 20221018101044.png]]

## Управление процессами в Linux

Также в Linux присутствуют некоторые **команды для управления процессами**:

   - **kill** — посылает процессу сигнал завершения работы;

   - **pkill** — завершает процесс по его имени;

   - **pgrep** — ищет процесс по его имени (и, опционально, по имени запустившего его пользователя);

   - **killall** — завершает все активные процессы.

Ниже приведены несколько основных примеров их использования:

```
$ pgrep -u diego firefox  
$ kill 6516
$ pgrep -u diego firefox
$ pgrep -u diego glances
$ pkill glances   
$ pgrep -u diego glances`

```

![[Pasted image 20221018101237.png]]

### Отправка сигналов процессам

Основополагающим способом управления процессами в Linux является отправка им соответствующих сигналов. Для перечисления списка всех доступных сигналов, введите команду:

`$ kill -l`

![[Pasted image 20221018101301.png]]

Чтобы отправить процессу нужный сигнал, используйте команды `kill`, `pkill` или `pgrep`, о которых мы упоминали ранее. Но программы могут реагировать на сигналы только в том случае, если они запрограммированы на распознавание этих сигналов.

Большинство сигналов предназначены для внутреннего использования системой или для программистов, когда они пишут код. Ниже приведены наиболее полезные сигналы:

   - **SIGHUP (1)** — отправляется процессу, когда его управляющий терминал закрыт.

   - **SIGINT (2)** — отправляется процессу управляющим терминалом, когда пользователь прерывает процесс нажатием клавиш _Ctrl+C_.

   - **SIGQUIT (3)** — отправляется процессу, если пользователь посылает сигнал выхода _Ctrl+D_.

   - **SIGKILL (9)** — этот сигнал немедленно завершает (убивает) процесс, и процесс не будет выполнять никаких операций очистки за собой.

   - **SIGTERM (15)** — сигнал завершения программы (отправляется командой `kill` по умолчанию).

   - **SIGTSTP (20)** — отправляется процессу управляющим терминалом с запросом на остановку; инициируется пользователем нажатием клавиш _Ctrl+Z_.

Ниже приведены примеры команды `kill` для уничтожения приложения `firefox` с помощью PID, после его зависания:

`$ pgrep -u diego firefox
`2275 _#ответ терминала_ 
``$ kill 9 2275`

или

`$ kill -KILL 2275`

или

`$ kill -SIGKILL 2275`

Чтобы убить приложение, используя его имя, применяются команды `pkill` или `killall`, например:

`$ pkill firefox`

или

`$ killall firefox`

### Изменение приоритета процесса

В системе Linux все активные процессы имеют определенный приоритет выполнения, задаваемый так называемым _**nice**_-значением. Процессы с более высоким приоритетом обычно получают больше процессорного времени, чем процессы с более низким приоритетом. Однако пользователь с root-правами может повлиять на это с помощью **команд nice** и **renice**.

Узнать значение приоритета команды можно по выводу команды `top` (столбец _NI_):

`$ top`

![[Pasted image 20221018101642.png]]

Используйте команду `nice`, чтобы задать _NI_-значение для запускаемого процесса. Имейте в виду, что обычные пользователи могут задавать данный параметр в диапазоне от `0` до `20` тем процессам, которыми они владеют. Только пользователь _root_ может использовать отрицательные значения приоритета.

Чем больше _nice_-значение, тем меньшим приоритетом будет обладать процесс. Например, вы можете задать приоритет для запускаемого процесса следующим образом:

`$ nice -n 10 firefox`

Чтобы изменить приоритет уже запущенного процесса, используйте команду `renice` следующим образом:

`$ renice +8 5547   
``$ renice +8 1151`

**Кто не знает:

**Процессорное время** ([англ.](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA "Английский язык") process time или CPU time) — время, затраченное [процессором](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80 "Центральный процессор") [компьютера](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80 "Компьютер") на обработку [задачи](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) "Процесс (информатика)") ([программы](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0 "Компьютерная программа")). Распределяется между потоками, которые могут принадлежать одному или разным [процессам](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81 "Вычислительный процесс") в соответствии с используемым режимом [операционной системы](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Операционная система").

Процессорное время измеряется в [тиках](https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%8B_%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8 "Часы реального времени") или [секундах](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BA%D1%83%D0%BD%D0%B4%D0%B0 "Секунда"). Часто бывает полезно измерение процессорного времени в процентах от мощности процессора, который называется загрузкой процессора.

Процессорное время и загрузка процессора имеет две основных сферы применения.

Первое заключается в количественном измерении общей занятости системы. Когда загрузка процессора выше 70%, пользователь может почувствовать задержку. Такая высокая загрузка ЦП указывает на недостаточную вычислительную мощность. Либо вычислительная мощность процессора (процессоров) должна быть повышена или объём пользовательских задач должен быть уменьшен, например, путём перехода на более низкое графическое разрешение и отключение анимации.

Второе применение, возникшее с появлением многозадачности, заключается в количестве того как процессор разделяется между компьютерными программами.