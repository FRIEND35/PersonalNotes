**Источники:** 

- https://www.redhat.com/sysadmin/bash-navigation
- https://habr.com/ru/companies/ruvds/articles/323330/


Каждый, кто пользуется командной строкой Linux, встречался со списками полезных советов. Каждый знает, что повседневные дела вполне можно выполнять эффективнее, да только вот одно лишь это знание, не подкреплённое практикой, никому не приносит пользы.  
  
Как выглядят типичные трудовые будни системного администратора, который сидит на Linux? Если абстрагироваться от всего, кроме набираемых на клавиатуре команд, то окажется, что [команды](https://likegeeks.com/main-linux-commands-easy-guide/) эти постоянно повторяются. Всё выходит на уровень автоматизма. И, если даже в работе есть что улучшать, привычка противится новому. Как результат, немало времени уходит на то, чтобы делать так, как привычнее, а не так, как быстрее, и, после небольшого периода привыкания – удобнее. Помнить об этом, сознательно вводить в собственную практику новые полезные мелочи – значит профессионально расти и развиваться, значит – экономить время, которое можно много на что потратить.

## Поймите подсказку

```shell
[tux@rhel8 ~]$
```

Начну с самой подсказки. По умолчанию командная строка может выглядеть странно или искаженно, но на самом деле она содержит довольно полезную информацию. Я разложу приведенную выше подсказку, которая содержит четыре очень важных значения:

- `tux` текущее имя пользователя.
- `@rhel8` это имя хоста системы.
- `~` указывает текущий каталог. `~` это сокращение вашего домашнего каталога. Если бы вы были в `/etc`, оно бы сказало `etc`; если бы ты был в `/usr/src/`, оно бы сказало `src`.
- `$` указывает, имеете ли вы привилегии. `$` указывает на обычного пользователя, и `#` указывает привилегированного суперпользователя (также называемого _root_ ).

Поскольку это приглашение легко настраивается, в оставшейся части этой статьи я буду использовать самое простое общее приглашение: одно `$` характер. Не вводите `$` подсказывать при вводе команд. Его цель, как в вашем терминале, так и в этой статье, — помочь вам отслеживать вводимые вами команды и выходные данные, которые ваш компьютер возвращает вам.

## Сменить каталоги

Если вы росли вместе со мной, у вас была коллекция компакт-дисков. Если нет, то вы, вероятно, хотя бы знаете, что такое компакт-диски. В Linux `cd` Команда не имеет ничего общего с музыкой. Вместо, `cd` означает _изменение каталога_ в Bash. Вы переходите в новый каталог, введя `cd /path/to/new/directory`. Но есть и несколько ярлыков, которые следует знать.

- `.` текущий каталог (вы редко будете `cd` к `.` но это очень полезно для других вещей).
- `..` — это каталог над текущим рабочим каталогом.
- `-` это последний каталог, в котором вы были.
- `~` это ваш домашний каталог.
- `/` — это корень файловой системы или разделитель между каталогами в полном пути.

- `ls .` - Показать содержимое текущего каталога;
- `ls ..` - Показать содержимое каталога на текущем катологом;
- `ls ...` - Показать содержимое верхнего каталога, который находится над текущем каталога.

Но удобнее использовать такой синтаксис команды: 

```
ls ../../../
ls ../../../../
```

- `cd -` Вернуться в предыдущий каталог;
- `cd ~` - Перейти в домашний каталог;
- `cd $HOME` - Перейти в домашний каталог используя переменную окружения;

Команда `pwd` (что означает «текущий рабочий каталог») сообщает вам абсолютный путь к текущему рабочему каталогу. Попробуйте и попрактикуйтесь в использовании `cd` чтобы перейти к каталогам, перечисленным выше, используя приведенные ниже примеры.

```shell
$ pwd
/home/tux
```

Мое имя пользователя `tux`, поэтому `pwd` вывод сообщает мне, что я нахожусь в своем домашнем каталоге. В вашем терминале вы увидите свое имя пользователя.

Вот пример сеанса с некоторыми `cd` и `pwd` команды (для демонстрации я создал несколько тестовых каталогов и подкаталогов, поэтому этих папок не существует на вашем компьютере):

```shell
$ cd test1/
$ cd testsub1/
$ pwd
/home/tux/test1/testsub1
$ cd ..
$ cd /etc/
$ cd ~/test2/
$ pwd
/home/tux/test2
$ cd -
/etc
$ pwd
/etc
$ cd ~
$ pwd
/home/tux
$
```

## Запуск другой команды вместе с текущей

Чтобы запустить другую команду вместе с текущею, можно использовать синтаксис `$('command')`:

- `grep -i -r main $('pwd')` -  Найти строку **main** во всех файлах текущего каталога;
- `grep -i -r main $('pwd')/*` - Найти строку **main** во всех файлах текущего каталога (динамический синтаксис);
- `grep -i -r main $('pwd')/*.c` - Найти строку **main** во всех файлах текущего каталога с расширением **.c**;

## Использовать автозаполнение команд

Автозаполнение — это инструмент, которым я злоупотребляю. Это сэкономит вам массу времени, если вы знаете первые несколько букв команды. Вы используете его, вводя несколько символов и затем нажимая **клавишу Tab** . Затем Bash вводит за вас остальную часть команды. Однократное нажатие **Tab** завершает команду, если есть только одна команда, соответствующая введенным вами буквам. При двойном нажатии **Tab** отображаются все подходящие варианты. Вот пример:

```shell
$ rsyn<tab>
$ rsync
$ rsy<tab><tab>
rsync   rsyslogd     rsyslog-recover-qi.pl
```

**_[Загрузите [шпаргалку по Bash](https://opensource.com/downloads/bash-cheat-sheet?intcmp=701f20000012ngPAAQ) , чтобы повысить эффективность работы в командной строке. ]_**

Некоторые команды даже имеют встроенное автозаполнение параметров командной строки.

Автозаполнение также предупредит вас, если результатов будет много.

```shell
$ l<tab><tab>
Display all 128 possibilities? (y or n)n
```


## Сортировка 

```bash
cat file.txt
```

![[Pasted image 20240908221314.png]]

```bash
sort file.txt
```

![[Pasted image 20240908221330.png]]

Или можно перенаправить входные данные в `sort`:

```bash
cat file.txt | sort
```

Если мы хотим отсортировать строки в обратном порядке в файле Linux, мы можем использовать команду сортировки с опцией -r. 
Представьте, что у вас есть файл с именем «employee_data.txt», который содержит информацию о сотрудниках в формате, разделенном табуляцией. Каждая строка представляет собой запись с такими сведениями, как идентификатор сотрудника, имя, отдел и зарплата, разделенными вкладками. Вы хотите упорядочить эти данные по отделам и отобразить результаты в алфавитном порядке.

**Например** : если имя нашего файла — «employee_data.txt», а содержимое внутри него следующее.

```bash
cat employee_data.txt
```

![[Pasted image 20240908221556.png]]

Для этого вы можете использовать команду «сортировка».

```bash
cat employee_data.txt | sort -k3
```

**-k3** : этот параметр указывает, что сортировка должна выполняться на основе третьего столбца (Отдел).

![[Pasted image 20240908221700.png]]

В этом примере записи о сотрудниках теперь отсортированы в алфавитном порядке на основе столбца «Отдел». Команда «сортировка» с настраиваемым разделителем позволяет эффективно организовывать и анализировать данные, разделенные табуляцией, что делает ее ценным инструментом для управления структурированной информацией в различных сценариях.

**Сортировка процессов по используемой памяти:**

```bash
ps aux | sort -nk 4
```

![[Pasted image 20240908221759.png]]

**Сортировка процессов по использованию ресурсов CPU:**

```bash
ps aux | sort -nk 3
```

Для того, чтобы вывести сведения об архитектуре, используйте команду `getconf LONG_BIT`.

## Мониторинг с регулярными интервалами

Использование утилиты `watch` (например, `watch df –h`) поможет организовать наблюдение за выводом любой команды. Например, можно наблюдать за объёмом свободного пространства, и за тем, как он меняется.

- `watch ls -l` - Просмотр список файлов в реальном времени
- `watch ifconfig` - Просмотр список сетевых интерфесвов в реальном времени 

Пожалуй, вы сами сможете найти подходящие сценарии для использования этой команды.

## Продолжение выполнения программы после окончания сессии

  
Когда вы запускаете любую программу в фоне и закрываете консоль, программа тоже завершит работу. А что, если надо, чтобы программа работала и после закрытия оболочки?  
  
Для того, чтобы этого добиться, можно воспользоваться командой `nohup`, название которой расшифровывается как «no hang-up». Выглядит это так:  
  

```bash
nohup wget site.com/file.zip
```

  
Пожалуй, эта команда – одна из тех, о которой забывают чаще всего, открывая по несколько окон терминала только ради исполняющихся в них команд.

![[Pasted image 20240908223244.png]]

В примере, показанном на рисунке выше, в текущей директории будет создан файл `nohup.out`, содержащий вывод команды:

![[Pasted image 20240908223255.png]]

Полезная штука, согласны?
## Автоматический ответ yes или no

Предположим, вы хотите автоматизировать процесс, который требует от пользователя постоянно отвечать `yes`. Сделать это можно, используя команду `yes`:  
  

```bash
yes | apt-get update
```

Возможно, вместо этого вы решите автоматизировать отрицательные ответы. Тут поможет такая конструкция:  
  
```bash
yes no | command
```

## Создание файла заданного размера
  
Создавать файлы заданного размера можно, используя команду `dd`:  
  
```bash
dd if=/dev/zero of=out.txt bs=1M count=10
```

Вышеприведённая команда создаст файл размером 10 Мб, заполненный нулями.

![[Pasted image 20240908223457.png]]

## Выполнение последней команды с root-привилегиями

Иногда можно забыть ввести `sudo` перед командой, которой нужны root-привилегии. Вводить всё заново нет нужды – достаточно воспользоваться такой командой:  
  

```bash
sudo !!
```

![[Pasted image 20240908223518.png]]

## Создание протокола терминальной сессии

- Для того, чтобы записать в файл всё, что было выведено в окне терминала, можно воспользоваться командой **`script`**.    
- После выхода из сессии протокол будет записан в файл **`typescript`**.

## Замена символов в файле

Вот команда, которая позволяет заменить пробелы на знаки табуляции:    

```
cat geeks.txt | tr ':[space]:' '\t' > out.txt
```

На самом деле, она универсальна и умеет работать с любыми символами.   

**Замена строчных букв на прописные:**

А вот – пример вышеописанной команды для замены строчных букв в файле с текстом на прописные:  
  
```
cat myfile | tr a-z A-Z > output.txt
```

## Автоматическое формирование списка аргументов для команд: xargs  
 
Утилита `xargs`, пожалуй, достойна звания одной из самых полезных возможностей командной строки Linux. Её можно использовать для передачи вывода некоей команды в качестве аргумента для другой. Например, вот как можно выполнить поиск .png-файлов и сжать их, или сделать с ними что-нибудь ещё:  
  
```bash
find. -name *.png -type f -print | xargs tar -cvzf images.tar.gz
```
 
Или, возможно, у вас имеется файл со списком URL, и вы хотите загрузить ресурсы по этим адресам, или ещё как-то их обработать:  
  
```bash
cat urls.txt | xargs wget
```
 
Тут надо учитывать, что вывод первой команды передаётся в качестве аргумента в конце команды `xargs`. Если при конструировании второй команды надо явно указать место, куда должны попасть выходные данные первой, достаточно воспользоваться парой фигурных скобок, `{}` и параметром `–i` для замены аргумента в нужном месте:  
  
```bash
ls /etc/*.conf | xargs -i cp {} /home/likegeeks/Desktop/out
```

![[Pasted image 20240908225150.png]]
## Итоги
  
Полезности для командной строки Linux – тема невероятно обширная. Поэтому любой список, подобный нашему, можно пополнять очень и очень долго. Например, много неожиданного скрыто в командах `awk` и `sed`. Пожалуй, главное – чтобы такие вот списки шли в дело.