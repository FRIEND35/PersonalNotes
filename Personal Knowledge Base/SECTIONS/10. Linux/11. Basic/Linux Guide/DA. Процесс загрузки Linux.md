Вы когда-нибудь интересовались различными этапами загрузки операционной системы? Что происходит, когда вы включаете свой компьютер?

Этапы процесса загрузки Linux условно можно разделить на:

   - Загрузка [[II. BIOS и UEFI | BIOS]] (POST).

   - Первый этап загрузки ([[JJ. MBR и GPT | MBR]] или [[JJ. MBR и GPT | GPT]]).

   - Второй этап загрузки (GRUB2).

   - Инициализация ядра.

   - Инициализация главного процесса (init или systemd).

   - Уровни выполнения (runlevels).

Сейчас мы их и рассмотрим.




# Процесс загрузки Linux

## Ravesli 

### Загрузка BIOS (POST)

[[II. BIOS и UEFI| BIOS]] (сокр. от _«**B**asic **I**nput/**O**utput **S**ystem»_) — это низкоуровневое программное обеспечение (_прошивка_), хранящееся на небольшом чипе памяти материнской платы вашего компьютера. Оно облегчает процесс запуска компьютера, а также управляет потоком данных между ним и другими подключенными к компьютеру устройствами, такими как: мышь, принтер, монитор и пр. Когда вы нажимаете кнопку питания, первым инициализируется BIOS, который начинает поиск загрузочного устройства для запуска операционной системы.

Если процесс инициализации BIOS и поиск загрузочного устройства завершаются успешно, то компьютер издает один звуковой сигнал, а затем еще один, когда система готова к загрузке операционной системы. Данный этап носит название **POST** (сокр. от _«**P**ower-**O**n **S**elf-**T**est»_ — самотестирование при включении). POST проверяет работоспособность системного оборудования и находит загрузочный сектор, который содержит программное обеспечение, необходимое для продолжения процесса загрузки. POST выполняется программами, входящими в BIOS.

Вы можете использовать функциональные клавиши (F1-F12) в режиме BIOS, чтобы задать приоритет загрузки устройств, настроить параметры аппаратного обеспечения компьютера или восстановить заданные по умолчанию значения параметров компьютера. В меню BIOS вы найдете номер версии BIOS, наименование поставщика BIOS, тип вашего процессора и другую подробную информацию о системе.

![[Pasted image 20221017045611.png]]

Меню загрузки в BIOS (_Boot_ _Manager_) представляет собой список, в котором вы можете выбрать загружаемую операционную систему. Если на вашем компьютере установлено несколько [**дистрибутивов Linux**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Лучшие дистрибутивы Linux. Обзор дистрибутивов Linux") или других операционных систем, вы можете добавить их в меню загрузки. Последняя установленная ОС будет показана в верхней части Boot Manager.

На следующем рисунке вы можете видеть, что на моем компьютере установлены Ubuntu и Windows. Я могу выбрать любую операционную систему (из доступных) для загрузки.

![[Pasted image 20221017045627.png]]

### Первый этап загрузки (MBR или GPT)

К загрузчикам первого этапа относятся [[JJ. MBR и GPT| MBR ]] (сокр. от _«**M**aster **B**oot **R**ecord»_) и  [[JJ. MBR и GPT | GPT ]] (сокр. от _«**G**uided **P**artition **T**able»_). MBR содержит таблицу разделов диска и находится в первом секторе загрузочного диска, обычно это _/dev/hda_ или _/dev/sda_, в зависимости от вашего оборудования. Основная задача  ([[JJ. MBR и GPT | MBR]]  — это «переход» в тот раздел диска, с которого необходимо выполнять дальнейший код загрузки операционной системы.

Как только  [[JJ. MBR и GPT | MBR]]  обнаруживает загрузчик второго этапа, то передает управление на него.

**_Примечание_**: Стоит отметить, что сейчас все чаще вместо MBR используется более современная технология — [[JJ. MBR и GPT | GPT]].


### Второй этап загрузки (GRUB2)

Задача загрузчика второго этапа состоит в том, чтобы найти [[AA. Ядро linux | ядро]] системы и загрузить его в память.

Большинство дистрибутивов Linux используют в качестве загрузчика [[CC. GRUB | GRUB ]](сокр. от _«**GR**and **U**nified **B**ootloader»_) или **GRUB2** (как более современный). Поскольку GRUB2 является более новой версией GRUB, то именно эту версию вы увидите в большинстве случаев при загрузке компьютера. В данном загрузчике есть простое меню, в котором вы можете выбрать опции загрузки. Если у вас установлено несколько различных ядер, вы можете использовать клавиатуру, чтобы выбрать именно то [[AA. Ядро linux | ядро]], с которым хотите загрузить свою систему:

![[Pasted image 20221017045650.png]]


Конфигурационными файлами загрузчика [[CC. GRUB | GRUB]]  обычно являются файлы [[II. BIOS и UEFI | BIOS]]ot/grub/grub.conf_ или _/etc/grub.conf_. Как только загрузчик находит[[AA. Ядро linux | ядро]], то загружает его в оперативную память и передает ему дальнейшее управление.

**_Примечание_**: Раньше в дистрибутивах Linux использовался преимущественно **загрузчик LILO** (сокр. от _«**LI**nux **LO**ader»_). Но на сегодняшний день его полностью вытеснил более современный [[CC. GRUB | GRUB]] .


### Инициализация ядра

Большинство новых пользователей Linux считают, что Linux — это операционная система. Но на самом деле Linux — это [[AA. Ядро linux | ядро]]. Ядро часто называют сердцем операционной системы. Оно играет очень важную роль в процессе загрузки Linux. [**Ядро Linux**](https://ravesli.com/linux-kernel/ "Ядро Linux") находится в [**каталоге**](https://ravesli.com/struktura-katalogov-v-linux/ "Структура каталогов в Linux") _/boot_ и отвечает за взаимодействие между основными компонентами компьютера и операционной системой.

Поскольку для экономии места на жестком диске ядро находится в сжатом виде, первое, что оно сделает, как только получит контроль, — это произведет свою «самораспаковку». Затем выполнит монтирование образа корневой файловой системы, указанной в файле _grub.cfg_, и запустит процесс инициализации системы.

![[Pasted image 20221017045711.png]]

### Инициализации главного процесса (init или systemd)

[[AA. Ядро linux | Ядро]] , сразу после своей загрузки, запускает **главный** **процесс инициализации**, который приводит к запуску всех необходимых служб и программ. Данные службы продолжат работать после инициализации и будут управлять основными системными процессами, такими как: регистрация различных системных сообщений, отслеживание устройств и обеспечение синхронизации файловой системы с системной памятью.

![[Pasted image 20221017045727.png]]

**_Примечание_**: В [**системе инициализации**](https://ravesli.com/linux-init-systems/ "Системы инициализации Linux. Сравнение SysV и systemd") SysV главным процессом является процесс _init_, а в системе инициализации systemd — (одноименный) процесс _systemd_.

### Уровни выполнения (runlevels)

  

**Уровень выполнения** (**runlevel**) — это непосредственное состояние операционной системы (например, когда Linux завершил процесс загрузки и готов к использованию), в котором можно управлять параметрами питания, пользовательским режимом и всем окружением. Когда система переходит на соответствующий уровень выполнения, на экран продолжат выводиться сообщения главного процесса инициализации. Стандартное  [[AA. Ядро linux | ядро]] Linux поддерживает семь различных уровней выполнения:

   **Runlevel 0** — завершает работу системы.

   **Runlevel 1** — однопользовательский режим работы. Чаще всего используется в целях обслуживания и выполнения других административных задач. Этот уровень также может называться **Runlevel S** (от англ. _«**S**ingle-user»_). Если вам когда-либо приходилось сбрасывать пароль на Linux, то вы вероятно уже пользовались этим режимом.

   **Runlevel 2** — многопользовательский режим работы (англ. _«multi-user»_) без поддержки сетевых служб.

   **Runlevel 3** — многопользовательский режим с поддержкой сети, но без графического интерфейса. Чаще всего серверные версии Linux работают именно на этом уровне выполнения.

   **Runlevel 4** — не используется. Пользователь может настраивать этот уровень исходя из его целей.

   **Runlevel 5** — схож с режимом 3, но здесь запускается графический интерфейс. В этом режиме работают десктопные версии Linux.

   **Runlevel 6** — перезагружает систему.

**_Примечание_****:** В системах семейства Debian уровни выполнения выстроены немного иначе. Например, Ubuntu в режиме командой строки запускается с уровнем выполнения 5.

В процессе загрузки Linux состояние уровня выполнения представлено буквенно-цифровым кодом. Если вы посмотрите на скриншот, приведенный ниже, вы увидите, что мой текущий уровень выполнения равен `N 5`; это означает, что мой компьютер уже завершил процесс загрузки, и работает в многопользовательском режиме с графическим интерфейсом.

Узнать текущий режим уровня выполнения можно с помощью следующей команды:

`sudo runlevel`

![[Pasted image 20221017045837.png]]

Если вам по какой-либо причине потребуется изменить уровень выполнения, то это можно сделать с помощью следующей команды:

`sudo telinit [номер_уровня]`  

### Заключение

Данный урок является лишь общим обзором процесса загрузки Linux, тем не менее для новичков он уже должен внести понимание о том, что происходит с системой Linux при нажатии кнопки включения на компьютере.

## Habr

![[Pasted image 20221102044403.png]]

#### 1. BIOS

  

-   [[II. BIOS и UEFI | BIOS]] отвечает за базовый ввод/вывод данных с устройств/на устройства.
-   Делает некоторые проверки целостности устройств. К тому же, за тестирование работоспособности электроники отвечает POST (Power-on self-test, он же «тест на адекватность себя самого», выполняющийся как этап пре-загрузки), который управляется [[II. BIOS и UEFI | BIOS]]
-   Ищет, загружает и выполняет программу-загрузчик ОС
-   Берет загрузчик из флопика, сидюка или жесткого диска. Во время загрузки [[II. BIOS и UEFI | BIOS]]'а вы можете нажать на кнопку (обычно это F12 или F2 или Del, зависит от платформы), если вам требуется внести некоторые изменения касательно настройки железа.
-   Как только загрузчик был обнаружен и загружен в память, BIOS передает управление ему.
-   Короче говоря, BIOS загружает и выполняет загрузочную запись  ([[JJ. MBR и GPT | MBR]] ).

  

#### 2. MBR

  

-    [[JJ. MBR и GPT | MBR]]  — это главная загрузочная запись, хранящаяся на жестком диске
-   Она размещена в 1-м секторе загрузочного диска, например /dev/hda или /dev/sda
-   MBR занимает меньше, чем 512 байтов. Она состоит из трех компонентов: 1) главная загрузочная информация, «живущая» в первых 446 байтах; 2) информация о таблице разделов — в следующих 64 байтах; 3) и последние 2 байта нужны для проверки корректности mbr.
-   Она содержит информацию о [[CC. GRUB | GRUB]]'е (или LILO).
-   Простыми словами — MBR загружает и выполняет загрузчик GRUB.

  

#### 3. GRUB

  

-   [[CC. GRUB | GRUB]]  — Grand Unified Bootloader.
-   Если в вашей системе установлено более, чем одно [[AA. Ядро linux | ядро]], у вас есть возможность выбирать, которое из них должен выполняться
-   GRUB отображает ~~красивую анимацию plymouth~~ заставку, и, подождав несколько секунд интерактивного воздействия пользователя, если он не нажал ни одной клавиши, он загружает[[AA. Ядро linux | ядро]], установленное по умолчанию в файле конфигурации grub.
-   GRUB понимает, что такое файловая система (древние загрузчики Linux'а, например, LILO этого не понимают).
-   Конфигурационный файл Grub обычно лежит по пути /boot/grub/grub.conf (так же /etc/grub.conf может быть символьной ссылкой на него). Вот пример файла конфигурации для CentOS:  
  
```  
#boot=/dev/sda<br>default=0<br>timeout=5<br>splashimage=(hd0,0)
/boot/grub/splash.xpm.gz<br>hiddenmenu<br>title CentOS 
(2.6.18-194.el5PAE)<br>      root (hd0,0)<br>     kernel /boot/vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/<br>   initrd /boot/initrd-2.6.18-194.el5PAE.img

```    
-   В качестве примечания к информации выше, конфигурационный файл содержит путь к ядру и образу initrd
-   Если быть кратким, [[CC. GRUB | GRUB]] просто напросто загружает и выполняет образы ядра и initrd.

  

#### 4. Ядро или Kernel

  

-    [[AA. Ядро linux | Ядро]] монтирует файловую систему в соответствии с настройкой «root=» в фале grub.conf
-   Выполняет программу /sbin/init
-   Поскольку init — это первый процесс, запущенный ядром Linux, поэтому она имеет идентификатор процесса (PID) №1. Можете выполнить «ps -ef | grep init» и убедиться в этом.
-   initrd — это Initial RAM Disk, он же временный диск в оперативной памяти
-   initrd используется самим ядром в качестве временной корневой файловой системы, пока kernel не загрузится в реальную примонтированную файловую систему. Этот временный диск также содержит необходимые для загрузки драйверы, позволяющие получить доступ к разделам дисков и другому оборудованию

  

#### 5. Init

  

-   Смотрит в файл /etc/inittab для того, чтобы определить уровень выполнения (run level).
-   Есть следующие уровни выполнения:  
    -   0 – прервать выполнение
    -   1 – Однопользовательский режим, так называемый «Single user mode», или иными словами, консоль восстановления
    -   2 – Многопользовательский режим без поддержки NFS
    -   3 – Полноценный многопользовательский режим
    -   4 – не используется
    -   5 – X11
    -   6 – перезагрузка
-   Init определяет уровень выполнения по умолчанию исходя из /etc/inittab и использует его для загрузки всех необходимых программ.
-   Выполните «grep initdefault /etc/inittab» на вашей системе, и вы узнаете, какой уровень по умолчанию у вас используется
-   Если у вас не получается жить спокойно, то можете установить стандартный уровень на 0 или 6. :)
-   В большинстве случаев вам будет достаточно уровня 3 или 5.

  

#### 6. Уровень выполнения программ (Runlevel)

  

-   Когда Линукс выполняет свою загрузку, вы можете наблюдать загрузку различных служб. К примеру, это могут быть сообщения типа «starting Postfix … OK» (запускается Postfix). Эти службы — и называются программами уровня выполнения, выполняемые из директории, которая соответствует нужному уровню выполнения.
-   Исходя из настроек по умолчанию, система будет выполнять файлы в соответствии с нижеприведенными директориями.  
    -   Выполнение уровня 0 – /etc/rc.d/rc0.d/
    -   Выполнение уровня 1 – /etc/rc.d/rc1.d/
    -   Выполнение уровня 2 – /etc/rc.d/rc2.d/
    -   Выполнение уровня 3 – /etc/rc.d/rc3.d/
    -   Выполнение уровня 4 – /etc/rc.d/rc4.d/
    -   Выполнение уровня 5 – /etc/rc.d/rc5.d/
    -   Выполнение уровня 6 – /etc/rc.d/rc6.d/
-   Но имейте ввиду, что еще в каталоге /etc могут быть символические ссылки. Например, /etc/rc0.d залинкован на /etc/rc.d/rc0.d.
-   В каталогах /etc/rc.d/rc*.d/ вы можете увидеть список программ, имя которых начинается из букв S и K.
-   Программы, начинающиеся на S используются для запуска. S, потому что **s**tartup.
-   Программы, которые начинаются с литеры K используются — правильно — для завершения работы. K, потому что **k**ill.
-   Еще есть номера рядом с буквами S и K в именах программ. Эти номера используются для определения порядка запуска этих программ.
-   К примеру, S12syslog предназначен для запуска демона syslog, его порядковый номер 12. S80sendmail — для запуска демона sendmail, имеющего порядковый номер 80. Таким образом, программа syslog будет запущена перед sendmail.

  
  
Вот и все. Возможно, некоторым из вас это не ново и особого интереса не было при чтении статью, поскольку она более ориентирована на начально-средний уровень знакомства з Линуксом.  
В таком случае могу лишь сказать, что «повторение — мать учения» (с).  
  

#### Дополнения, исправления, уточнения

  
В комментариях неоднократно было апеллировано к тексту статьи, поэтому, думаю, стоит учесть некоторые важные комментарии хабрасообщества. (спасибо [artemlight](http://artemlight.habrahabr.ru/), [3al](http://3al.habrahabr.ru/), [Tishka17](http://tishka17.habrahabr.ru/), [HhyperH](http://hhyperr.habrahabr.ru/), [Next_Alex](http://next_alex.habrahabr.ru/), [Ilya_Shmelykh](http://ilya_smelykh.habrahabr.ru/), [Aux](http://aux.habrahabr.ru/), [soomrack](http://soomrack.habrahabr.ru/), [Xpeh](http://xpeh.habrahabr.ru/) )  

-   [artemlight:](http://habrahabr.ru/blogs/linux/113350/#comment_3640280): «Ну скажем прямо — так грузятся далеко не все дистры». С ним согласилось большинство, отмечая и bsd-style init, u-boot, и хоть initrd в статье пропущен, стоить заметить, что он нужен ядру не во всех дистрибутивах. Также отмечено, что в slackware поддержка rc.d осуществляется только в качестве совместимости, а встраиваемые системы грузятся иначе. На декстопах иногда бывает EFI, а кроме того Linux популярен в мире embedded и там ещё куча разных платформ. Линукс в телефоне вообще иначе грузится.
-   [soomrack](http://habrahabr.ru/blogs/linux/113350/#comment_3640776), ссылая на википедию: Еще хочется сделать замечание по поводу  [[JJ. MBR и GPT | MBR]] , первого сектора и пр. Все несколько усложнилось за последние годы. Сейчас уместней говорить о EFI.  
      
    «GUID Partition Table (GPT) является стандартным форматом размещения таблиц разделов на физическом жестком диске. Он является частью Extensible Firmware Interface (EFI) (Расширяемый Микропрограммный Интерфейс) — стандарта, предложенного Intel на смену отжившего [[II. BIOS и UEFI | BIOS]], одного из последних реликтов первозданной IBM PC. EFI использует GPT там, где BIOS использует Главную загрузочную запись (MBR)....»
-   Так же [просили вспомнить](http://habrahabr.ru/blogs/linux/113350/#comment_3640356) о LILO. LILO, ми тебя помним! Привет!
-   Xpeh [доплняет](http://habrahabr.ru/blogs/linux/113350/#comment_3640405), что «[[II. BIOS и UEFI | BIOS]] (и не упомянутый тут (U)EFI) прежде всего занимается инициализацией устройств (в том числе загрузку собственных биосов PCI-устройств), про это ничего не написано. Хотя эта роль постепенно сокращается, так как всё больше железа инициализирует себя само и/или поддерживает горячее подключение и потому всё равно инициализируется ОС, но, например, инициализацию оперативной памяти он делает всегда. „
-   VolCh [уточняет](http://habrahabr.ru/blogs/linux/113350/#comment_3640644) загрузку для ОС Debian-Ubuntu:  
    Для Debian/Ubuntu:  
    — каталога /etc/rc.d/ нет;  
    — каталоги /etc/rc?.d/ настоящие каталоги, а не ссылки;  
    — в этих каталогах хранятся ссылки на скрипты в каталоге /etc/init.d/  
      
    Вручную лучше в /etc/rc?.d/ ничего не править, а использовать команду update-rc.d, которая позволяет создавать ссылки, удалять их, запрещать (фактически переименовывать c S* на K*) и разрешать (c K* на S*) запуск.


## losst 

Практически каждый этап загрузки может идти несколькими путями. Например, вы узнаете о том, чем отличается [[II. BIOS и UEFI | BIOS]] от UEFI, что делает [[CC. GRUB | GRUB]] и чем его можно заменить, почему одного лишь ядра Linux недостаточно для функционирования операционной системы.


Процесс загрузки операционной системы можно разбить на 5 этапов, причём первые три зависят от материнской платы. Ниже вы можете видеть схематичное изображение этапов загрузки Linux.

Как видите, до того, как загрузится ядро, процесс имеет существенные отличия. И всё же любая загрузка системы начинается с включения компьютера.

### Первый этап: включение компьютера

Запуск компьютера с [[II. BIOS и UEFI | BIOS]] и [[II. BIOS и UEFI | UEFI  ]]отличается. Первый BIOS появился в середине 70-х годов, а  [[JJ.  [[JJ. MBR и GPT | MBR]] стали использовать с 1983 года. Стоит ли говорить о том, что для современного компьютера предпочтительнее использовать UEFI и  [[JJ. MBR и GPT | GPT]] . А теперь перейдём непосредственно к рассмотрению первого этапа загрузки.

#### BIOS + MBR

[[II. BIOS и UEFI | BIOS]] – это базовая система ввода-вывода. Она представляет из себя набор программ для взаимодействия с устройствами компьютера. BIOS хранится на микросхеме EEPROM материнской платы. При каждом запуске компьютера плата автоматически отправляет код процессору на исполнение. Далее BIOS проводит проверку оборудования (тест POST) и обращается к жёсткому диску или твердотельному накопителю. От него ему нужны первые 512 байт, именно там находится главная загрузочная запись ( ([[JJ. MBR и GPT | MBR]] ). Ниже вы можете видеть структуру MBR.

Если подпись  ([[JJ. MBR и GPT | MBR]]  равна 55AAh, то система начинает выполнять код первичного загрузчика. В случае с Linux, MBR передаёт управление основному загрузчику [[CC. GRUB | GRUB]]. Он располагается сразу после MBR. До начала первого раздела на накопителе есть не менее 32 килобайт свободного места (современные системы оставляют 1 Мбайт), этого достаточно для того, чтобы разместить [[CC. GRUB | GRUB]].

Таблица разделов в MBR имеет крайне скромный размер, есть место всего на 4 позиции. В связи с этим нельзя разметить накопители объёмом более 2 терабайт. К тому же она использует устаревшую адресацию, с цилиндрами, головками и секторами жёсткого диска.

На компьютерах с [[II. BIOS и UEFI | UEFI]] поддержка MBR никуда не делась, но для этого вам придётся активировать [[II. BIOS и UEFI | BIOS]] или CSM mode, в зависимости от производителя материнской платы. Это нужно для совместимости со старыми операционными системами.

#### UEFI + GPT

Интерфейс расширяемой прошивки EFI (позднее унифицированный [[II. BIOS и UEFI | UEFI]]) – это разработка Intel. Он был создан потому, что [[II. BIOS и UEFI | BIOS]] имеет ряд недостатков. К ним можно причислить работу в 16-битном режиме, последовательную проверку устройств и загрузку только через MBR.

Физически поменялось не многое, разве что FLASH-накопитель для хранения прошивки стал больше. Зато программная часть претерпела значительные изменения. [[II. BIOS и UEFI | UEFI]] работает в 32- и 64-битном режиме, поддерживает таблицу разделов  [[JJ. MBR и GPT | GPT]] , может иметь красивый графический интерфейс, оболочку EFI Shell и управление с помощью мыши. К тому же опрос оборудования происходит гораздо быстрее.

Оглавление таблицы  [[JJ. MBR и GPT | GPT]]  располагается в первом логическом блоке (LBA 1). В  [[JJ. MBR и GPT | GPT]]  перешли к использованию логических блоков, к тому же их понимают современные жёсткие диски и SSD. Нулевой блок по-прежнему отдаётся под MBR, но в этот раз он выполняет защитную функцию, чтобы старые операционные системы не переписали  [[JJ. MBR и GPT | GPT]] .

Каждой записи таблицы даётся 128 байт, что позволяет разметить накопители практически неограниченного объёма. Да и самих записей может быть больше 100.

В конце таблицы находится контрольная сумма. Если будет обнаружено несоответствие, то система попробует обратиться к резервной копии таблицы, расположенной в последних блоках накопителя.

После проверки устройств, [[II. BIOS и UEFI | UEFI]] может самостоятельно обратиться к таблице разделов  [[JJ. MBR и GPT | GPT]]. В ней её интересует EFI раздел. Обычно под него выделяется 520-540 Мбайт. Такой размер связан с тем, что ранние версии EFI могли выдавать ошибку при работе с меньшим объёмом. Но Windows уже отходит от этой традиции и ограничивается 100 Мбайтами.

![[Pasted image 20221102045403.png]]



В разделе EFI обязательно должна быть папка EFI/BOOT, в ней находится загрузчик по умолчанию. Но никто не мешает добавить свой загрузчик, например, для Ubuntu и Windows.

К минусам [[II. BIOS и UEFI | UEFI]] можно отнести Secure Boot. Загрузчик без подписи просто не сможет быть использован. Эти меры направлены в первую очередь на компьютеры с Windows, чтобы не допустить использование старых систем на новых омпьютерах. Для Linux в этом случае приходится искать подписанный загрузчик или отключать Secure Boot, если имеется такая возможность.

#### PXE

Ещё одним способом загрузки является PXE – загрузка через сетевой интерфейс. Первичный загрузчик находится в ПЗУ сетевой карты. С его помощью карта через протокол TFTP получает основной загрузчик.

Этот способ загрузки будет работать как с [[II. BIOS и UEFI | BIOS]], так и с [[II. BIOS и UEFI | UEFI]]. Он полезен для работы с тонкими клиентами и для установки операционной системы по сети.

### Второй этап: загрузчик

Загрузчик подготавливает систему к загрузке ядра операционной системы. Например, для Linux он может передавать параметры запуска ядра. В зависимости от того, что используется, [[II. BIOS и UEFI | BIOS]] или [[II. BIOS и UEFI | UEFI]], выбор загрузчика отличается.

![[Pasted image 20221102045428.png]]

Как можете видеть, в Ubuntu есть как .efi загрузчик, так и [[CC. GRUB | GRUB]].

#### GRUB

![[Pasted image 20221102045512.png]]

[[CC. GRUB | GRUB]]  – это основной загрузчик для большинства дистрибутивов Linux. Он примечателен тем, что позволяет не только запустить ядро Linux или другой операционной системы, но ещё и сам по себе способен выполнять некоторые операции. Он имеет собственную командную строку и в теории позволяет устранить собственные ошибки. [[CC. GRUB | GRUB]]  существует в версиях как для BIOS, так и [[II. BIOS и UEFI | UEFI]]. Но последний не имеет цифровой подписи для Secure Boot.

#### Syslinux Project

Syslinux – это целое семейство, состоящее из трёх загрузчиков: syslinux, isolinux, pxelinux. Первый выполняет аналогичную [[CC. GRUB | GRUB]]  функцию, isolinux подходит для работы с файловой системой компакт-дисков (используется для загрузочных Flash-нкопителей), pxelinux загружается по сети. Версия [[II. BIOS и UEFI | UEFI]], как и в случае с [[CC. GRUB | GRUB]] , не имеет подписи.

#### rEFInd

Если же вы хотите иметь возможность выбора операционной системы при запуске компьютера с [[II. BIOS и UEFI | UEFI]], то вам стоит установить rEFInd. Этот загрузчик имеет цифровую подпись и может передать управление другим загрузчикам формата .efi.

Ещё одним загрузчиком такого плана будет Clover. Его выбирают зачастую для работы на компьютерах Apple.

#### EFI BOOT STUB

Начиная с версии 3.3 ядра Linux можно упаковать [[AA. Ядро linux | ядро]] в .efi файл. Иными словами, загрузчиком будет выступать само [[AA. Ядро linux | ядро]]Linux.

Несмотря на такое разнообразие загрузчиков, некоторые пользователи до сих пор продолжают использовать LILO – один из первых мультизагрузчиков Linux. Несколько лет назад имел место быть даже EFI-загрузчик ELILO.

### Третий этап: ядро

Дальше выполняется загрузка [[AA. Ядро linux | ядро]] Linux. Ядро лежит в папке boot под названием vmlinuz. «vm» в начале говорит о том, что  [[AA. Ядро linux | ядро]] будет размещено в виртуальной памяти. А «z» на конце означает то, что ядро запаковано в архив и требует распаковку. Это возможно благодаря тому, что в начале архива находится исполняемый код.

В процессе запуска ядра настраивается оборудование, запускается менеджер памяти, планировщик задач и многое другое, необходимое для функционирования операционной системы.

 [[AA. Ядро linux | Ядро]] Linux монолитное, драйверы устройств хранятся прямо в нём. Однако, это утверждение верно лишь отчасти. Большая часть периферийных устройств не имеет драйверов в ядре Linux. Вместо этого в оперативной памяти распаковывается ещё один файл во временной файловой системе – initrd.img.

После запуска всех необходимых служб временный раздел удаляется. Но это происходит не всегда. Например, он остаётся после запуска в режиме liveCD и при использовании тонкого клиента.

### Четвертый этап: запуск пользовательских служб

 [[AA. Ядро linux | Ядро]] загрузилось и работает. Но этого недостаточно для работы с операционной системой. Вы по-прежнему не можете взаимодействовать с ней на прикладном уровне. Для того, чтобы можно было что-то сделать в Linux, управление получает подсистема инициализации и управления службами. Обычно этот процесс имеет идентификационный номер PID-1.

#### Systemd

Systemd – это самая популярная система инициализации. Она хорошо распараллеливает задачи и практически вытеснила другие решения. Запускаются десятки служб. Например, такие, которые управляют звуковыми устройствами, мультимедийными клавишами, запускают графическую оболочку. Большая часть файлов подсистемы представлена конфигурационными файлами, ссылающимися на конкретные утилиты и сервисы, но есть и собственные службы.

Стоит пару слов уделить D-Bus. Эта служба позволяет процессам взаимодействовать друг с другом. Например, через неё служба управления звуковыми устройствами узнаёт о том, что была нажата клавиша увеличения громкости, распознанная другой службой. Такой подход позволяет создавать простые, но эффективные службы.

А ещё в комплект утилит Systemd входит супервизор. Он следит за тем, чтобы все критически важные службы работали. Если он заметит, что какой-то службы не хватает, то сразу же запустит её снова. Его также применяют для поддержания работы серверов.

#### Sysvinit, OpenRC и другие

Sysvinit считается устаревшей системой. Она следует принципам, заложенным ещё в 80-х годах для операционной системы Unix System V. Запуск служб происходит последовательно, а настройка производится с помощью скриптов, что несколько проще, чем у systemd.

Для дистрибутива Gentoo разрабатывается система инициализации OpenRC. Её можно назвать осовремененной sysvinit. Но важно понимать, что рядовому пользователю система инициализации безразлична, она интересует лишь тех, кто добавляет свои службы и утилиты в дистрибутив Linux.

О других системах, вроде Runit, Daemontools или S6, справедливо предыдущее утверждение, к тому же их доля совсем невелика. Хотя они тоже имеют свои особенности. После этого процесс загрузки Linux практически завершен.

### Пятый этап: экранный менеджер и окружение рабочего стола

Нельзя списывать со счетов и дисплейный менеджер. Это по сути первая программа с графическим интерфейсом. Она отвечает за вход в систему. Хотя и до её запуска проводились некоторые работы, был запущен сервер X11 для обращения к видеокарте и обработки команд управления c мыши и клавиатуры.

После ввода пароля запускается оконный менеджер с библиотеками отображения (обычно GTK3 или Qt) и непосредственно само окружение рабочего стола. Эти службы отвечают за то, чтобы вы могли перемещать окна, перетаскивать файлы, иметь несколько рабочих столов и тому подобное. Всё, загрузка Linux выполнена и операционная система полностью готова к использованию!