# Что такое /dev/null

Linux - это интересная операционная система, в которой размещены некоторые виртуальные устройства для различных целей. Для программ, работающих в системе, эти виртуальные устройства действуют так, как будто это реальные файлы. Инструменты могут запрашивать и получать данные из этих источников. Данные генерируются ОС вместо того, чтобы считывать их с диска.

Одним из таких примеров является `/dev/null`. С технической точки зрения _/dev/null_ в [**Linux**](https://ravesli.com/chto-takoe-linux-ego-struktura-i-preimushhestva/ "Что такое Linux? История создания Linux") — это файл виртуального устройства. Программы и утилиты могут взаимодействовать с ним как с настоящим файлом: запрашивать данные, а также отправлять в него любую информацию. Но всё, что вы пишете в _/dev/null_, отправляется в пустоту и забывается (другими словами, отправляется в _чёрную дыру_). 

Другими словами,  это специальный файл, который присутствует в каждой системе Linux. Однако, в отличие от большинства других виртуальных файлов, вместо чтения он используется для записи. Все, что вы запишете в `/dev/null`, будет отброшено, забыто в пустоте. В системе UNIX он известен как нулевое устройство.

Зачем вам выбрасывать что-то в пустоту? Давайте посмотрим, что такое `/dev/null` и как он используется.

Чтобы понять, почему это полезно, вы должны сначала иметь базовое представление о стандартном потоке вывода данных (stdout) и стандартном потоке вывода ошибок (stderr). 

## stdout и stderr

Всякий раз, когда запускается какая-либо утилита командной строки, она генерирует два типа вывода: стандартный вывод выполнения команды отправляется в **stdout**, а сообщения об ошибках (если таковые есть) — в **stderr**.

По умолчанию stdout и stderr связаны с окном [**терминала**](https://ravesli.com/bash-v-linux/#toc-0) (или консолью). Это означает, что всё, что отправляется в stdout и stderr, обычно отображается на нашем экране. Но с помощью перенаправления вывода мы можем изменить это поведение. Например, мы можем перенаправить вывод stdout в файл. Таким образом, вместо отображения информации о выполнении команды на экране терминала, она будет сохранена в файле, который мы позже сможем прочитать. Или же можно перенаправить stdout на физическое устройство, скажем, на цифровой ЖК-дисплей.

В Linux-системах stdout имеет файловый дескриптор `1`, а stderr — файловый дескриптор `2`. Используя данные дескрипторы, мы можем перенаправлять вывод из stdout и stderr в другие файлы:

   `1>` используется для перенаправления стандартного вывода данных (_stdout__)_;

   `2>` используется для перенаправления вывода сообщений об ошибках (_stderr__)_. Например, `2>/dev/null` отправляет сообщения об ошибках в «чёрную дыру», а `2>/home/user/error.log` — в файл _error.log_.

   `&>` используется для перенаправления как стандартного вывода данных (_stdout_), так и вывода сообщений об ошибках (_stderr_).

## /dev/null как средство избавления от ненужного вывода

Допустим, нам нужно найти файлы в каталоге _/sys_, которые относятся к настройкам питания:

`grep -r power /sys/`

![[Pasted image 20221027032721.png]]

В выводе команды будет много файлов, которые обычный пользователь (не _root_) не сможет прочитать (мы получим сообщение об ошибке _«Отказано в доступе»_). Эти сообщения загромождают терминал и затрудняют поиск. Поскольку ошибки _«Отказано в доступе»_ являются частью stderr, то мы можем перенаправить их в «чёрную дыру», используя _/dev/null_:

`grep -r power /sys/ 2>/dev/null`

![[Pasted image 20221027032733.png]]

Как вы можете видеть, теперь результат воспринимается гораздо проще.

В других случаях может быть полезно сделать обратное: отфильтровать стандартный вывод, чтобы мы могли видеть только ошибки, например:

`ping ravesli.com 1>/dev/null`

![[Pasted image 20221027032803.png]]

На вышеприведенном скриншоте показано, что без перенаправления команда `ping` отображает свой обычный вывод. Во второй команде ничего не отображается, пока сеть подключена, но как только она отключается, выводится (только) сообщение об ошибке.

Мы можем перенаправить как stdout, так и stderr в два разных места:

`ping google.com 1>/dev/null 2>error.log`

В этом случае стандартный вывод выполнения команды не будет отображаться вовсе, а сообщения об ошибках будут сохранены в файле _error.__log_.  

## Перенаправление всего вывода в /dev/null

Иногда полезно избавиться от всех выходных данных. Есть два способа сделать это:

`grep -r power /sys/ >/dev/null 2>&1`

Часть `>/dev/null` означает _«перенаправить данные из stdout в /dev/null»_, а часть `2>&1` означает _«перенаправить данные из stderr в stdout»_. Таким образом мы перенаправили весь вывод команды в пустоту.

**_Примечание_**: В этом случае мы должны ссылаться на стандартный вывод (stdout) при помощи знака амперсанда — `&1`, а не просто `1`. Запись `2>1` перенаправит данные из stdout в файл с именем `1`.

Стоит отметить, что здесь очень важен порядок: если вы измените параметры перенаправления следующим образом:

`grep -r power /sys/ 2>&1 >/dev/null`

…то это сработает не так, как задумывалось. Часть `2>&1` перенаправит stderr в stdout, отобразит вывод на экране, после чего перенаправит stdout в _/dev/null_. Конечным результатом станет то, что вместо искомой информации вы увидите сообщения об ошибках. Если вы не можете запомнить правильный порядок составляющих, есть более простое перенаправление:

`grep -r power /sys/ &>/dev/null`

В этом случае `&>/dev/null` эквивалентно выражению _«перенаправить как stdout, так и stderr в /dev/null»_.


## Заключение

_/dev/null_ — это файл виртуального устройства, который при записи в него всё отправляет в пустоту, а при чтении из него — считывает ноль. Истинный потенциал _/dev/null_ очень хорошо раскрывается в различных [**bash-сценариях**](https://ravesli.com/bash-v-linux/ "Что такое bash в Linux? Гайд по созданию bash-скриптов").