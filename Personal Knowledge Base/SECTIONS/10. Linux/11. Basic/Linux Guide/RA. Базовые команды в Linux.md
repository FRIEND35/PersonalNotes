# Навигация по файловой системе

При навигации по файловой системе в Linux можно использовать как _абсолютный_, так и _относительный_ пути к ресурсу.

_Абсолютный_ (или _полный__)_ _путь_ начинается с корневого каталога, обозначаемого символом `/`, а _относительный путь_ начинается с текущего каталога (в котором в данный момент работает пользователь).

---

## pwd

**Команда pwd** (от англ. _«**p**resent **w**orking **d**irectory»_) позволяет узнать, в каком каталоге вы находитесь в данный момент:

```
$ pwd
```

Результатом будет путь к текущему рабочему каталогу:

```
/home/diego
```

Чтобы узнать текущую папку в скрипте не обязательно использовать эту команду. Достаточно обратится к переменной окружения PWD:

```
echo $PWD
```

---

## cd

**Команда cd** (от англ. _«**c**hange **d**irectory»_) используется для смены текущего рабочего каталога. При использовании без каких-либо параметров, команда `cd` перенесет вас в ваш домашний каталог:

```
$ cd
```

Чтобы перейти в другой каталог, вы можете использовать абсолютный или относительный путь. Например, перейти в папку _Downloads_, расположенную в текущем каталоге, можно как через относительный путь:

```
$ cd Downloads
```

Так и через абсолютный путь:

```
$ cd /home/diego/Downloads
```

Две точки `..` обозначают родительский каталог или каталог уровнем выше текущего. Предположим, что в данный момент вы находитесь в каталоге _/__usr/__local/__bin_. Чтобы перейти в каталог _/__usr/__local_ (на один уровень выше текущего каталога), необходимо ввести:

```
$ cd ../
```

Чтобы подняться на два уровня вверх:

```
$ cd ../../
```

Чтобы вернуться к предыдущему рабочему каталогу, используйте символ тире `–` в качестве опции:

```
$ cd ~
```

Если каталог, который вы хотите изменить, имеет пробелы в своем имени, то вы должны либо взять путь в кавычки, либо использовать символ обратной косой черты `\`:

```
$ cd имя\ каталога\ с\ пробелами
```

---

# Работа с файлами и каталогами

  
## ls

**Команда** **ls** (от англ. _«_**_l_**_i**s**t»_) выводит информацию о файлах и каталогах внутри заданного каталога. При использовании без параметров, данная команда отобразит в алфавитном порядке список имен всех файлов в текущем рабочем каталоге:

```
$ ls
````

Чтобы вывести содержимое конкретного каталога, достаточно указать путь к этому каталогу в качестве параметра:

```
$ ls /usr
```

Теперь посмотрим содержимое каталога снова, только на этот раз в виде списка с максимальным количеством информации. По умолчанию, команда `ls`  отображает только имена файлов и каталогов. Для более подробного вывода применяется опция `-l`:

```
$ ls -l /etc/hosts
```

Выходные данные будут содержать информацию о типе файла, разрешениях, количестве ссылок на него, владельце, группе, размере, дату и имя файла:

```
-rw-r--r-- 1 root root 337 Oct  4 11:31 /etc/hosts
```

По умолчанию, команда `ls` не показывает скрытые файлы (файлы, имена которых начинаются с точки `.`). Чтобы отобразить все файлы, включая скрытые, используйте опцию `-a`:

```
$ ls -a ~/
```

Для вывода списка всех файлов в подкаталогах используйте опцию `-R`:

```
$ ls -R /usr
```


Если вы хотите рекурсивно вывести содержимое всех папок, используйте опцию -R:

```
$ ls -lR /usr
```

---
## file

[**Файлы в Linux**](https://ravesli.com/tipy-fajlov-v-linux/ "Типы файлов в Linux") не обязаны всегда иметь расширения для того, чтобы с ними можно было работать. Поэтому пользователю иногда трудно определить, что за файл перед ним. **Команда file** помогает решить данную проблему, отображая информацию о типе файла на основе его содержания:

```
$ file /etc/fstab
```

Результат:

```
/etc/fstab: ASCII text
```

Команда `file` может работать и с директориями, например:

```
$ file /tmp/
```

Результат:

```
/tmp/: sticky, directory
```

---

## touch

Команда **touch** позволяет создать новый пустой файл через командную строку Linux. В качестве примера введите **touch /home/username/Documents/Web.html**, чтобы создать файл HTML с названием **Web** в каталоге **Documents**.

**Команда** **touch** используется для создания новых пустых файлов, а также для обновления временных меток в уже существующих файлов и каталогов.

Чтобы создать новый файл, используйте команду `touch` с именем (создаваемого) файла в качестве параметра:

```
$ touch file.txt
```

Если файл уже существует, команда `touch` изменит отметку о времени последнего доступа (или изменения) к нему.

---

## mkdir

**Команда mkdir** (от англ. _«**m**a**k**e **dir**ectory»_) позволяет создавать новые каталоги. Для этого укажите имя каталога в качестве параметра:

```
$ mkdir /tmp/newdir
```

В качестве параметров команда `mkdir` может принимать одно или несколько имен каталогов. Если параметром является имя каталога без полного пути, то новый каталог создастся в текущем рабочем каталоге.

Для создания родительских каталогов используется опция `-p`:

```
$ mkdir -p Projects/ravesli.com/src/assets/images
```

Вышеприведенная команда создаст полную структуру каталогов.

При использовании команды `mkdir` с опцией `-p`, она создает каталог только в том случае, если он изначально отсутствует.

Например, нам нужно создать несколько папок, тогда можно сделать все одной командой:

```
mkdir {папка1,папка2,папка3}
```

Если нужно создать папку Ubuntu, а в ней еще несколько папок, можно воспользоваться командой:

```
mkdir -p ~/Загрузки/папка/папка/папка/папка
```

Или, например, сложная структура:

```
mkdir -p ~/Загрузки/папка/{папка1,папка2,папка3}
```

---

## rmdir

**Команда** **rmdir** (от англ. _«**r**e**m**ove **dir**ectory»_) используется для удаления (только) пустых каталогов:

```
$ rmdir /tmp/mydir
```

---

## ln

Создает [жёсткие или символические ссылки](https://losst.pro/simvolicheskie-i-zhestkie-ssylki-linux) на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определённому файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жёсткие ссылки, в отличие от символических, указывают на физический адрес области диска, где хранятся данные файла.

**Команда ln** (от англ. _«**l**i**n**k»_) используется для создания символьных ссылок. Символьная ссылка — это особый тип файла, который указывает на другой файл или каталог. Чтобы создать символьную ссылку, используйте команду `ln -s`, указывая имя файла в качестве первого параметра и имя символьной ссылки в качестве второго параметра:

```
$ ln -s имя_файла имя_ссылки
```

Если в качестве параметра указан только файл, команда `ln` создаст в текущем рабочем каталоге ссылку на этот файл с тем же именем, что у файла.

---

## rm

**Команда** **rm** (от англ. _«**r**e**m**ove»_) используется для удаления файлов и каталогов. При указании без параметров данная команда удаляет только файлы. Стоит отметить, что при этом команда не запрашивает у пользователя подтверждения на продолжение удаления файлов.

Чтобы удалить файл или символьную ссылку, используйте команду `rm` и имя файла в качестве параметра:

```
$ rm file.txt
```

Также в качестве параметров допускается указывать одно или несколько имен файлов или каталогов.

Опция `-i` указывает команде `rm` запрашивать у пользователя подтверждение перед удалением файла:

```
$ rm -i file.txt
```

Результат:

`rm: удалить пустой обычный файл 'file.txt'?`

Опция `-d` используется для удаления одного или нескольких пустых каталогов:

`$ rm -d mydir`

Чтобы рекурсивно удалить непустые каталоги и все файлы в них, используйте опцию `-r` (от англ. _«_**_r_**_ecursive»_):

`$ rm -rf mydir`

Опция `-f` указывает команде `rm` никогда не запрашивать подтверждения у пользователя и игнорировать несуществующие файлы.

**_Примечание_****:** Будьте очень осторожны с командой `rm -rf` и дважды проверьте, в каком каталоге вы находитесь, т.к. вызов `rm -rf` безвозвратно (и без дополнительного подтверждения) удалит все файлы и папки из него.

Чтобы удалить все файлы, начинающиеся на слово file можно использовать специальный символ *, означает любой символ в любом количестве:

`rm /home/user/file*`

Эта команда удаления файла в linux должна использоваться очень осторожно, чтобы не удалить ничего лишнего. В утилите есть опция -i, которая заставляет программу спрашивать пользователя перед тем, как удалить файл linux:

`rm /home/user/file*`

---

## cp

**Команда** **cp** (от англ. _«**c**o**p**y»_) позволяет копировать файлы и каталоги. Чтобы скопировать файл в текущий рабочий каталог, используйте исходный файл в качестве первого параметра, а новый файл — в качестве второго:

`$ cp file file_backup`

Чтобы скопировать файл в другой каталог, укажите абсолютный или относительный путь к целевому каталогу. Если в качестве места назначения указано только имя каталога, то скопированный файл будет иметь то же имя, что и исходный файл.

`$ cp file.txt /backup`

По умолчанию, если файл назначения существует, он будет перезаписан.

Чтобы скопировать каталог, вместе с его файлами и подкаталогами, используйте опцию `-R` или `-r`:

`$ cp -R Pictures /opt/backup`

По умолчанию команда **cp** Linux перезаписывает существующие файлы или папки, но можно заставить утилиту спрашивать, нужно ли перезаписывать каждый файл, если вы не уверены в правильности составления команды:

`cp -i ~/test ~/Documents/test`

Опция **-u** полезна в следующем случае: вы знаете или предполагаете, что в директории, куда копируется файл, есть старая его версия, тогда оператор -u выполнит замену на новую версию:

`cp -u ~/test ~/Documents/test`

---

## mv

**Команда** **mv** (от англ. _«_**_m_**_o**v**e»_) используется для перемещения файлов и каталогов из одного места в другое, а также для переименования файлов. Например, чтобы переместить файл _file.txt_ в каталог _/tmp_, вы должны выполнить:

`$ mv file.txt /tmp`

Чтобы переименовать файл, необходимо указать имя целевого файла, а затем его новое имя:

`$ mv file.txt file1.txt`

Синтаксис перемещения каталогов такой же, как и при перемещении файлов. Чтобы одновременно переместить несколько файлов и каталогов, укажите конечный каталог в качестве последнего параметра:

`$ mv file.tx1 file1.txt /tmp`

---

## du

Показывает размер файла или каталога. Самые полезные опций: -h (**H**uman), которая преобразует размеры файлов в легко читаемый формат, -s (**S**ummarize), которая выводит минимум данных, и -d (**D**epth), устанавливающая глубину рекурсии по каталогам.

Для получения информации об объеме директории, а также всех ее поддиректорий может использоваться команда **du** без каких-либо параметров — главное передать путь к интересующей директории:

`$ du /home/alexfc/bakfile/`

В результате будет получен аналогичный вывод:

`8348    /home/alexfc/nolf228/other`  
`9184    /home/alexfc/nolf228/`

Очевидно, что объемы поддиректорий даны в количестве блоков диска. Для того, чтобы получить объемы директорий в килобайтах и мегабайтах следует использовать параметр **-h**:

`$ du -h /home/alexfc/bakfile/`

Теперь будет получен более читаемый вывод:

`8,2M    /home/alexfc/nolf228/other`  
`9,0M    /home/alexfc/nolf228/`

Для получения лишь общего объема директории следует добавить параметр **-s**:

`$ du -hs /home/alexfc/bakfile/`

Вывод будет содержать единственную строку:

`9,0M    /home/alexfc/nolf228/`

Если же требуется получить информацию обо всех хранящихся в директориях файлах, нужно использовать параметр **-a**:

`$ du -ha /home/alexfc/bakfile/`

Вывод будет выглядеть аналогичным образом:

`380K    /home/alexfc/nolf228/splash1280.jpg`  
`188K    /home/alexfc/nolf228/nolf228.jpg`  
`264K    /home/alexfc/nolf228/splash1024.jpg`  
`8,2M    /home/alexfc/nolf228/other/Better_Red_Than_Dead.rar`  
`8,2M    /home/alexfc/nolf228/other`  
`9,0M    /home/alexfc/nolf228/`

Для вывода общего объема следует использовать параметр **-c**:

`$ du -hс /home/alexfc/bakfile/`

Теперь в выводе появится дополнительная строка «итого»:

`8,2M    /home/alexfc/nolf228/other`  
`9,0M    /home/alexfc/nolf228/`  
`9,0M    итого`

В том случае, если нужно скрыть информацию о файлах с определенными именами, может использоваться параметр **--exclude=<шаблон>**. Например, данная команда позволяет скрыть информацию обо всех графических файлах с расширением **.jpg**:

`$ du -ha --exclude="*.jpg" /home/alexfc/nolf228/`

Вывод не будет содержать информации о файлах с упомянутым расширением, но будет содержать информацию о файлах со всеми другими расширениями, а также обо всех директориях. При этом объем директорий будет приведен в соответствие со списком отображаемых файлов :

`8,2M    /home/alexfc/nolf228/other/Better_Red_Than_Dead.rar`  
`8,2M    /home/alexfc/nolf228/other`  
`8,2M    /home/alexfc/nolf228/`

---

## tar

Изначально **tar** использовалась для архивации данных на ленточных устройствах. Но также она позволяет записывать вывод в файл, и этот способ стал широко применяться в Linux по своему назначению. Здесь будут рассмотрены самые распространенные варианты работы с  этой утилитой.

**Команда** **tar** является наиболее часто используемой командой для объединения нескольких файлов в один **_*.__tar_**-архив — распространенный формат файлов Linux (похожий на формат ._zip__)_, причем процедура сжатия для него не является обязательной.

**Команда справики:

`tar -h

Предположим, что нам нужно создать ._tar_-архив каталога _/__etc_, для этого необходимо использовать следующую команду:

`tar -cvf myarchive.tar /etc`

Опция `-c` указывает команде `tar` на то, что мы создаем _.tar_-файл, опция `-v` отображает список обрабатываемых файлов, а опция `-f` применяется для указания имени архивного файла.

Если вы хотите добавить файл к уже существующему ._tar_-архиву, то вместо опции `-c` используется опция `-r`. Например, давайте добавим к нашему архиву _myarchive.__tar_ файл _/__etc/__fstab_:

`tar -rvf myarchive.tar /etc/fstab`

**_Примечание_:** К уже сжатому ._tar_-файлу добавить новый файл или каталог не получится.

Извлечение в текущую папку файлов и каталогов из архивного файла выполняется с помощью опции `-x`:

`tar -xvf myarchive.tar`

Опция `-C` дает пользователю возможность самостоятельно указывать путь для извлекаемых файлов:

`tar -xvf myarchive.tar -C /tmp/`

С помощью следующей команды создается архив archive.tar с подробным выводом информации, включающий файлы **file1**, **file2** и **file3**:

`tar --totals --create --verbose --file archive.tar file1 file2 file3`

Но длинные опции и параметры можно заменить (при возможности) однобуквенными значениями:

`tar --totals -cvf archive.tar file1 file2 file3`

Следующая команда выводит содержимое архива, не распаковывая его:

`tar -tf archive.tar`

Распаковывает архив **test.tar** с выводом файлов на экран:

`tar -xvf archive.tar`

Чтобы сделать это в другой каталог, можно воспользоваться параметром **-C**:

`tar -C "Test" -xvf archive.tar`

Следует помнить, что **tar** только создаёт архив, но не сжимает. Для этого используются упомянутые компрессорные утилиты **bzip2** и **gzip**. Файлы, сжатые с их помощью, имеют соответствующие расширения **.tar.bz2** и **.tar.gz**. Чтобы создать сжатый архив с помощью **bzip2,** введите:

`tar -cjvf archive.tar.bz2 file1 file2 file3`

Синтаксис для **gzip** отличается одной буквой в параметрах, и меняется окончание расширения архива:

`tar -czvf archive.tar.gz file1 file2 file3`

При распаковке tar-архивов с таким расширением следует указывать соответствующую опцию:

`tar -C "Test" -xjvf arhive.tar.bz2`

или:

`tar -xzvf archive.tar.gz`

---

## zip/unzip

**Команда** **zip** применяется для сжатия файлов в ._zip_-архив, а **команда** **unzip** — для извлечения заархивированных файлов из ._zip_-архива.

Чтобы создать архив из нескольких файлов, просто укажите имя создаваемого архива и перечислите список помещаемых в него файлов:

`$ zip newarchive.zip file1 file2 file3`

Если вы хотите сжать каталог вместе с вложенными в него файлами, то необходимо использовать опцию `-r`:

`$ zip –r newarchive.zip /home/diego/mydocs/`

Также, цифрами от **0** (без сжатия, быстро) до **9** (максимальное сжатие, медленно) вы можете указывать степень сжатия будущего архива. По умолчанию, используется 6-й уровень сжатия:

`$ zip -9 –r newarchive.zip /home/diego/mytxtfiles/`

Для извлечения содержимого архива в текущий каталог используется команда `unzip`:

`$ unzip myarchive.zip`

Опция `-d` позволяет распаковать содержимое архива в указанную папку, например:

`$ unzip myarchive.zip –d /tmp/`

---

## gzip

Команда **gzip** предназначена для сжатия данных без потерь с помощью одноименной утилиты, использующей алгоритм Лемпела-Зива (LZ77) с кодированием Хаффмана. Целью использования данной утилиты является экономия дискового пространства. Упомянутый алгоритм позволяет достичь худшей степени сжатия данных, чем те, которые реализованы в рамках утилит **bzip2** и **xz**. При этом данный алгоритм является стандартным алгоритмом утилиты **zip** и используется по умолчанию в архивах формата ZIP. Кроме того, он является менее ресурсоемким, чем алгоритмы, которые реализованы в рамках утилит **bzip2** и **xz**. Последнее обстоятельство обуславливает актуальность данной утилиты для низкопроизводительных систем.

Базовый синтаксис команды выглядит следующим образом:

`$ gzip [параметры] <имена файлов>`

Чаще всего **gzip** используется вообще без каких-либо параметров, причем в качестве аргументов может передаваться неограниченное количество имен файлов, которые следует сжать. По умолчанию оригинальные версии файлов заменяются на их сжатые версии с соответствующими метаданными (то есть, меткой времени модификации, правами доступа, именами владельца и группы владельцев и так далее). Если вас не устраивает такое положение дел, вы можете воспользоваться параметром **-k** для сохранения оригинальных версий файлов. Параметры из диапазона от **-1** до **-9** позволяют задать степень сжатия (от самой низкой до самой высокой соответственно), при этом чем выше степень сжатия, тем больше системных ресурсов требуется утилите. Параметр **-t** предназначен для тестирования целостности сжатого файла и не оказывает какого-либо влияния на него (следует комбинировать его с параметром **-v** для подробного вывода). Параметр **-l** также не оказывает никакого влияния на сжатый файл и предназначен для получения информации об архиве (размеров сжатого и не сжатого файлов, степени сжатия и имени оригинального файла). Параметр **-d** позволяет восстановить оригинальные версии файлов с переданными именами на основе их сжатых версий.

Если же вам нужно создать архив с несколькими файлами внутри, одной утилиты **gzip** будет явно мало. Для этой цели также понадобится утилита **tar**, с помощью которой можно создать архив с файлами, после чего сжать этот архив с помощью утилиты **gzip**. Например, вы можете использовать следующую последовательность команд для создания архива с именем _archive.tar.gz_:

```
$ tar -cf archive.tar <имена файлов>
$ gzip archive.tar
```

Параметры **-c** и **-f** утилиты tar предназначены для указания на необходимость добавления всех файлов в один архив (**-c**) и чтения имени файла архива из следующего аргумента (**-f**). Альтернативным вариантом является замена последней команды на параметр **-z** утилиты **tar**, позволяющий автоматически сжать полученный архив с помощью **gzip**:

```
$ tar -cfz archive.tar.bz2 <имена файлов>
```

**Сжатие одного файла

```
$ gzip text.txt
```

В результате оригинальный файл _text.txt_ будет заменен на свою сжатую версию _text.txt.gz_.

**Одновременное сжатие нескольких файлов

```
$ gzip text1.txt text2.txt text3.txt
```

В этом случае также все оригинальные версии файлов (_text1.txt_, _text2.txt_, _text3.txt_) будут заменены на сжатые версии (_text1.txt.gz_, _text2.txt.gz_, _text3.txt.gz_). Добавление нескольких файлов в единый файл архива будет рассмотрено ниже.

**Сжатие одного файла с сохранением оригинала

Если вы хотите сохранить исходный (исходный) файл, используйте -k опцию:

```
$ gzip -k text.txt
```

Теперь оригинальный файл _text.txt_ будет оставлен в директории вместе со сжатой версией _text.txt.gz_.

Другой вариант сохранить исходный файл - использовать `-c` опцию, которая говорит, что `gzip` нужно писать в стандартный вывод и перенаправлять вывод в файл:  
  

```
gzip -c filename > filename.gz

```

**Подробный вывод

Используйте эту `-v` опцию, если вы хотите увидеть процентное сокращение и имена файлов, которые обрабатываются:

```
gzip -v filename   
```

```output
filename:	  7.5% -- replaced with filename.gz

```

**Восстановление оригинальной версии файла из сжатой версии

```
$ gzip -d text.txt.gz
```

В результате сжатая версия файла _text.txt.gz_ будет заменена на его оригинальную версию _text.txt_. Если вам нужно сохранить сжатую версию, следует воспользоваться параметром **-k** таким же образом, как было показано выше.

**Сжатие файла с указанием степени сжатия

Степень сжатия файла может регулироваться с помощью параметров из диапазона от **-1** (минимальная) до **-9** (максимальная). Уровень сжатия по умолчанию - `-6`.  Команда для сжатия файла с минимальной степенью сжатия:

```
$ gzip -1 text.txt
```

С максимальной степенью сжатия:

```
$ gzip -9 text.txt
```

При этом параметр **-1** может заменяться на параметр **--fast**, а параметр **-9** — на параметр **--best**.

**Создание сжатого архива со всеми файлами из директории

```
$ tar -cfz etc.tar.bz2 /etc/
```

В результате будет создан архив _etc.tar.gz_ с файлами из директории _/etc/_.

**Проверка целостности сжатой версии файла

```
$ gzip -tv text.txt.gz  
text.txt.gz: OK
```

Для проверки целостности сжатых версий файлов используются контрольные суммы (CRC). В случае повреждения сжатой версии файла выводится сообщение об ошибке, в противном случае — слово **«OK»**.

**Получение информации о сжатом файле

```
$ gzip -l enums.c.gz  
compressed uncompressed ratio uncompressed_name  
       253          371 38.8% enums.c
```

Очевидно, что в столбце **compressed** выводится размер сжатого файла в байтах, в столбце **uncompressed** — размер несжатого файла в байтах, в столбце **ratio** — степень сжатия файла, а в столбце **uncompressed_name** — имя оригинального файла. Вся эта информация хранится в заголовке сжатого файла.

**Сжать все файлы в каталоге

Чтобы сжать все файлы в данном каталоге, используйте `-r` параметр:

```
gzip -r directory
```

`gzip` будет рекурсивно проходить через всю структуру каталогов и сжимать все файлы в каталоге и его подкаталогах.

**Распаковка файлов с gzip

Чтобы распаковать `.gz` файл, используйте `-d` параметр:  
  

```
gzip -d filename.gz
```

  
Еще одна команда, которую вы можете использовать для распаковки GZIP-файла [`gunzip`](https://baks.dev/search.php?tags=gunzip). Эта команда в основном псевдоним для `gzip -d`:  
  

```
gunzip filename.gz
```

  
Возможно, вам будет легче запомнить, `gunzip` чем `gzip -d`.

---

## mount/umount

Точка подключения-это физическое расположение в разделе, используемой в качестве корневой файловой системы. Существует много различных типов хранения, в том числе магнитных, магнитооптических, оптических и полупроводниковых (твердотельных) накопителей. В настоящее время, магнитные носители по-прежнему являются одними из самых распространенными и выпускаются как жесткие диски и, реже, дискеты. Прежде чем любой из них будет использоваться для хранения, средства, с помощью которых информация считывается и записывается должны быть распознаны и информация об этом должна быть доступна для операционной системы. Каждый тип файловой системы характеризуется метаданными, так что операционная система знает как читать и записывать данные. Когда носитель установлен, эти метаданные считываются операционной системой таким образом, чтобы его можно использовать для хранения. [UNIX](https://ru.bmstu.wiki/UNIX "UNIX")-подобные операционные системы часто включают в себя программное обеспечение и инструменты, которые помогают в процессе монтажа и предоставляют новые функциональные возможности. Некоторые из этих возможностей предоставляют "авто-монтирование".

Во многих ситуациях, файловые системы, кроме корневого каталог должны быть доступны, как только операционная система загрузится. Поэтому все [UNIX](https://ru.bmstu.wiki/UNIX "UNIX")-подобных системы предоставляют возможность для монтирования файловых систем во время загрузки. Системные администраторы определяют эти файловые системы в конфигурационном файле fstab (vfstab в Solaris), что также указывает на варианты и точки монтирования. В некоторых ситуациях нет необходимости монтировать определенные файловые системы во время загрузки системы, хотя их применение может потребоваться в дальнейшем. Существует несколько утилит для [UNIX](https://ru.bmstu.wiki/UNIX "UNIX")-подобных систем, которые позволяют монтировать стандартных файловых систем по запросу.


**Что такое монтирование

**Монтирование файловой системы** — системный процесс, подготавливающий [раздел диска](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB_%D0%B4%D0%B8%D1%81%D0%BA%D0%B0 "Раздел диска") к использованию [операционной системой](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Операционная система").

Операция монтирования состоит из нескольких этапов:

1.  определение типа монтируемой системы;
2.  проверка целостности монтируемой системы;
3.  считывание системных структур данных и инициализация соответствующего модуля файлового менеджера (драйвера [файловой системы](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0 "Файловая система"));
4.  установка [флага](https://ru.wikipedia.org/wiki/%D0%A4%D0%BB%D0%B0%D0%B3_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F_%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0) "Флаг (компьютерная техника)"), сообщающего об окончании монтирования. При корректном размонтировании этот флаг сбрасывается. Если при загрузке система определяет, что флаг не сброшен, значит работа была завершена некорректно, и возможно ФС нуждается в починке;
5.  включение новой файловой системы в общее [пространство имен](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%B8%D0%BC%D0%B5%D0%BD "Пространство имен").


Файловая система — это способ, с помощью которого операционная система организует файлы на диске. Эти файловые системы бывают разных видов в зависимости от ваших конкретных потребностей. Для Windows у вас есть файловые системы NTFS, FAT, FAT16 или FAT32. Для Macintosh у вас есть файловая система HFS, а для Linux у вас больше файловых систем, чем мы можем перечислить в этом руководстве. Одна из замечательных особенностей Linux заключается в том, что у вас есть возможность доступа к данным, хранящимся во многих различных файловых системах, даже если эти файловые системы принадлежат другим операционным системам.

Как я уже сказал Linux имеет единую корневую файловую систему, куда подключаются все запоминающие устройства и другие ресурсы. На самом деле, в Windows происходит что-то подобное, только все это скрыто от пользователя.

Фактически смонтированный раздел становится частью корневой файловой системы и система старается сделать работу со всеми разделами, независимо от их файловых систем, прозрачной. Это значит, что если вы примонтируете участок оперативной памяти или удаленную сетевую папку, то сможете работать с ней в файловом менеджере точно так же, как и с локальным диском.

Например, вы хотите примонтировать флешку. Вы даете системе команду подключить ее в папку /run/media/имя_пользователя/UUID_флешки/. Система определяет файловую систему устройства, а затем, используя драйвера ядра подключает ее к указанной папке. Дальше вам остается работать с той папкой, как с любой другой. Больше ни о чем думать не нужно. Когда надумаете извлечь флешку, ее нужно отмонтировать.

Монтирование в Linux позволяет получить доступ к содержимому диска и организовать структуру файловой системы. С помощью монтирования также можно открыть для работы образ диска (например, созданного с помощью программы **dd**), а также открыть для доступа и редактирования самые разные файловые системы и образы дисков (например, образы дисков виртуальных машин); даже удалённые сетевые директории могут быть смонтированы, в результате чего они станут доступны как будто бы файлы на любом другом локальном хранилище.

Кроме того, что с помощью монтирования можно работать с образами дисков, правильные настройки монтирования необходимы для компьютера к которому подключается диск для криминалистического анализа — например, этот диск не должен автоматически монтироваться с правами записи (чтобы не быть испорченным).

В Linux есть такое понятие как «монтирование» диска. Чтобы получить доступ к файлам на этом диске, его нужно сначала смонтировать. Может возникнуть вопрос, зачем такие сложности? Монтирование это мощнейшая вещь, которая позволяет поразительно гибко настроить файловую систему!

Суть монтирования в том, что в файловой системе создаётся новая директория (обычная папка), допустим, это папка **/mnt/disk_d**. А затем командой **mount** указывается, что теперь, например, диск **/dev/sda** смонтирован в директорию **/mnt/disk_d**. После этого можно получить доступ (то есть можно уже с ним работать - создать, удалять, изменить и так далее) к файлам диска **/dev/sda** открыв папку **/mnt/disk_d** в любом менеджере файлов:

![[Pasted image 20221030153241.png]]

С помощью такого подхода — когда любой диск может быть любой папкой в системе, можно делать очень гибкую настройку. Самый частый пример, встречающийся на практике: файлы пользователя хранятся в папке **/home/имя_пользователя/**, например, у меня это папка **/home/mial/**. При установке операционной системы я могу сделать так, что мой второй или третий диск (а не системный) будет смонтирован в точку **/home/mial/**. То есть вся операционная система будет располагаться на одном диске, а все мои пользовательские файлы — на другом. Что это даёт? В случае переустановки системы, я вновь настрою монтирование диска с моими файлами в папку **/home/mial/** и в результате в новой, только что установленной системе, уже будут на месте все мои документы, фотографии и прочее!

Поскольку часто узким местом в мощных компьютерах является скорость чтения с диска, то на на серверах с высокой нагрузкой практикуется перенос файлов баз данных (например, **/var/lib/mysql/** на другой диск), возможен перенос файлов сервера (**/srv/http/**) на третий диск, файлов логов (**/var/log/httpd/**) на ещё один диск и т. д. Это позволяет добиться того, что данные из баз данных считываются независимо от записи журналов, то есть пока выполняются операции чтения-записи для одного процесса, другому процессу не нужно ждать своей очереди — всё выполняется одновременно.

Ещё монтирование позволяет выбрать различные режимы, например, диск можно смонтировать в режиме «только чтение» - в результате с него можно будет просматривать файлы, но испортить этот диск невозможно.

В общем, несмотря на то, что монтирование является чем-то непривычным для пользователей Windows, это потрясающая функция! Причём ничего сложного в этом нет, если понять суть.

**Монтирование дисков в Linux

Обычно, монтированием занимаются специальные сервисы оболочки, но не всегда они доступны. А иногда нужно сделать все вручную, чтобы задать дополнительные опции монтирования или другие параметры. Для монтирования в Linux используется команда mount. Рассмотрим ее параметры:

```
mount файл_устройства папка_назначения
```

Или расширенный вариант:

```
$ mount опции -t файловая_система -o опции_монтирования файл_устройства папка_назначения
```

Опции задают различные дополнительные особенности работы утилиты. Опция -t необязательна, но она позволяет задать файловую систему, которая будет использована и иногда это очень полезно. С помощью опции -o вы можете задать различные параметры монтирования, например, монтировать только для чтения и т д. Последних два параметра - это файл устройства, например, /dev/sda1 и папка назначения, например, /mnt. 

Перед тем как перейти к рассмотрению примеров работы утилитой, давайте рассмотрим ее основные опции:

-   **-V** - вывести версию утилиты;
-   **-h** - вывести справку;
-   **-v** - подробный режим;
-   **-a, --all** - примонтировать все устройства, описанные в fstab;
-   **-F, --fork** - создавать отдельный экземпляр mount для каждого отдельного раздела;
-   **-f, --fake** - не выполнять никаких действий, а только посмотреть что собирается делать утилита;
-   **-n, --no-mtab** - не записывать данные о монтировании в /etc/mtab;
-   **-l, --show-labels** - добавить метку диска к точке монтирования;
-   **-c** - использовать только абсолютные пути;
-   **-r, --read-only** - монтировать раздел только для чтения;
-   **-w, --rw** - монтировать для чтения и записи;
-   **-L, --label** - монтировать раздел по метке;
-   **-U, --uuid** - монтировать раздел по UUID;
-   **-T, --fstab** - использовать альтернативный fstab;
-   **-B, --bind** - монтировать локальную папку;
-   **-R, --rbind** - перемонтировать локальную папку.

Это не все, но основные опции, которые вам понадобятся во время работы с утилитой. Также, возможно, вы захотите знать список опций монтирования, которые могут быть полезными. Они все перечислены в статье автоматическое монтирование в fstab и писать их еще и здесь нет смысла. А теперь перейдем к примерам и рассмотрим как монтировать диск в linux.

**Монтирование разделов с помощью mount

Монтирование разделов с помощью mount выполняется очень просто. Фактически в большинстве случаев будет достаточно упрощенной версии команды. Например, смонтируем раздел /dev/sdb6 в папку /mnt:

`sudo mount /dev/sdb6 /mnt/

В большинстве случаев вы будете вынуждены выполнять команду mount с правами суперпользователя, если обратное не указано в fstab (опция монтирования users). Вы можете посмотреть информацию о процессе монтирования добавив опцию -v:

```
sudo mount -v /dev/sdb6 /mnt/
```

Если нужно, вы можете указать файловую систему с помощью опции -t:

```
sudo mount -v -t ext4 /dev/sdb6 /mnt
```

Если необходимо примонтировать файловую систему только для чтения, то вы можете использовать опцию -r или опцию монтирования -o тo, результат будет одинаковым:

```
sudo mount -t ext4 -r /dev/sdb6 /mnt   $ sudo mount -t ext4 -o ro /dev/sdb6 /mnt
```

Вы можете использовать и другие опции чтобы выполнить монтирование разделов linux, например, указать, что на этом разделе нельзя выполнять программы:

```
sudo mount -t ext4 -o noexec /dev/sdb6 /mnt
```

Обратите внимание, что вы не можете использовать опции uid, gid, fmask для файловых систем ext. Они поддерживаются только в FAT, vFAT, exFAT.

Вы можете использовать не только имена устройств чтобы выполнить монтирование диска в linux. Для этого можно применять UUID или метки, например, монтирование с помощью UUID:

```
sudo mount --uuid="b386d309-05c1-42c8-8364-8d37270b69e0" /mnt
```

Посмотреть uuid для ваших разделов можно с помощью команды:

```
sudo blkid
```

Точно так же вы можете использовать метки. Команда монтирования диска linux будет выглядеть так:

```
sudo mount --label="home" /mnt/
```

Вы можете примонтировать одну папку в другую, для этого используйте опцию --bind

```
sudo mount --bind /mnt/ /media/
```

Возможно, не только монтирование разделов linux, но и монтирование файлов, если они содержат файловую систему, например, образов дисков. Монтирование образа диска linux работает точно так же:

```
sudo mount ~/file.iso /mnt
```

Посмотреть список всех примонтированных устройств можно просто выполнив mount без параметров:

```
mount
```

**Размонтирование устройств в Linux

Когда вы хотите завершить работу с устройством, особенно с флешкой, его нужно размонтировать. Для этого существует утилита umount. В качестве параметров она принимает точку монтирования или устройство. Например:

```
sudo umount /mnt
```

Проблему можно решить закрыв все программы, которые могут использовать любой файл в этой папке. Какие именно это программы вы можете узнать с помощью команды lsof:

```
 lsof -w /mnt 
 lsof -w /dev/sdb6
```

Здесь вы видите всю необходимую информацию, чтобы понять что происходит и что с этим делать. Утилита вывела название программы, ее PID, и даже файл, с которым она работает. Вы можете завершить все программы, а потом снова повторить попытку или используйте опцию -l, файловая система будет отключена немедленно, несмотря на то, что она занята:

```
sudo umount -l /mnt 
```

Теперь ваше устройство не смонтировано. Но иногда может возникнуть ошибка размонтирования. Система сообщит, что устройство занято: **umount: /mnt: target is busy.**

**Как увидеть точки монтирования  

Для просмотра устройств и точек их монтирования, выполните команду:

```
findmnt --real
```

Эта команда отображает целевую точку монтирования (TARGET), исходное устройство (SOURCE), тип файловой системы (FSTYPE) и соответствующие параметры монтирования (OPTIONS) для каждой файловой системы, как показано на скриншоте. Подробности смотрите в статье «[Команда findmnt для просмотра смонтированных файловых систем в Linux](https://zalinux.ru/?p=4793)».

Команда **findmnt** без опций покажет больше данных:

```
findmnt
```

Но среди вывода будут различные виртуальные файловые системы, которые нужны не всегда.

Команда **mount** также может показывать список точек монтирования, но эта функция в ней поддерживается только для обратной совместимости. Тем не менее, для вывода смонтированных реальных файловых систем вы можете использовать команду:

```
mount | grep "^/dev"
```

А для показа всех точек монтирования, запустите команду следующим образом:

```
mount
```

Вы можете наблюдать процесс монтирования и размонтирования в реальном времени. К примеру, для отслеживания любых действий по монтированию и размонтированию в файловой системе используйте команду:

```
findmnt -p
```

**Заключение

Монтирование файловой системы - это системный процесс (подготовка), который подготавливает раздел диска (носителя) к использовании ОС.

Например у вас может быть так:

```
/dev/sda -  / 
/dev/sdb -  /boot 
```

Или же по другому: 

```
/dev/sda  - /home 
```

---

## locate

Команда locate Linux используется для поиска файлов, расположенных на машине пользователя или на сервере. Фактически она выполняет ту же работу, что и [команда find](https://losst.pro/komanda-find-v-linux), однако, ведёт поиск в собственной базе данных. Find же шаг за шагом проходит через всю иерархию директорий.

Обновление базы данных locate происходит автоматически, как правило, раз в сутки. Настроить желаемый интервал между сканированиями системы можно с помощью планировщика задач Cron.

В отличие от find, команда locate ведёт поиск в базе данных updatedb для шаблонов имён файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадёжен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.

**Как использовать команду locate

Синтаксис команды `locate` следующий:

```sh
locate [OPTION] PATTERN...
```

В самой простой форме, при использовании без каких-либо параметров, команда `locate` выводит на печать абсолютный путь ко всем файлам и каталогам, которые соответствуют шаблону поиска и для которых пользователь имеет разрешение на чтение.

Например, чтобы найти файл с именем `.bashrc` , введите:

```
locate .bashrc
```

Вывод будет включать имена всех файлов, содержащих в своих именах строку `.bashrc` :

```output
/etc/bash.bashrc
/etc/skel/.bashrc
/home/linuxize/.bashrc
/usr/share/base-files/dot.bashrc
/usr/share/doc/adduser/examples/adduser.local.conf.examples/bash.bashrc
/usr/share/doc/adduser/examples/adduser.local.conf.examples/skel/dot.bashrc
```

Файл `/root/.bashrc` не будет показан, потому что мы `/root/.bashrc` команду как обычный пользователь, у которого нет прав доступа к каталогу `/root` .

Если список результатов длинный, для лучшей читаемости вы можете направить вывод в команду [`less`](https://routerus.com/less-command-in-linux/) :

```
locate .bashrc | less
```

Команда `locate` также принимает шаблоны, содержащие символы подстановки, такие как подстановочный знак `*` . Если в шаблоне нет дополнительных символов, команда ищет `*PATTERN*` . Поэтому в предыдущем примере отображались все файлы, содержащие в своем имени шаблон поиска.

Подстановочный знак — это символ, используемый для обозначения нуля, одного или нескольких символов. Например, чтобы найти все файлы `.md` в системе, вы должны ввести:

```
locate *.md
```

Чтобы ограничить результаты поиска, используйте параметр `-n` после которого укажите количество результатов, которые вы хотите отобразить. Следующая команда `.py` поиск всех файлов `.py` и отобразит только 10 результатов:

```
locate -n 10 *.py
```

По умолчанию `locate` выполняет поиск с учетом регистра. Параметр `-i` ( `--ignore-case` ) указывает `locate` игнорировать регистр и запускать поиск без `--ignore-case` регистра.

```
locate -i readme.md
```

```output
/home/linuxize/p1/readme.md
/home/linuxize/p2/README.md
/home/linuxize/p3/ReadMe.md
```

Чтобы отобразить количество всех совпадающих записей, используйте параметр `-c` ( `--count` ). Следующая команда вернет количество всех файлов, содержащих `.bashrc` в своих именах:

```
locate -c .bashrc
```

```output
6
```

По умолчанию `locate` не проверяет, существуют ли еще найденные файлы в файловой системе. Если вы удалили файл после последнего обновления базы данных, и если файл соответствует шаблону поиска, он будет включен в результаты поиска.

Чтобы отображать только имена файлов, которые существуют на момент запуска `locate` , используйте параметр `-e` ( `--existing` ). Например, следующее будет возвращать только существующие файлы `.json` :

```
locate -e *.json
```

Если вам нужно выполнить более сложный поиск, используйте параметр `-r` ( `--regexp` ), который позволяет вам искать, используя базовое регулярное выражение вместо шаблонов. Этот параметр можно указывать несколько раз.  
Например, чтобы найти все файлы `.mp4` и `.avi` в вашей системе и игнорировать регистр, вы должны запустить:

```
locate --regex -i "(.mp4|.avi)"
```

**Обновления базу данных

Базу данных можно обновить вручную, запустив `updatedb` от имени пользователя root или пользователя с привилегиями sudo:

```
sudo updatedb
```

Процесс обновления займет некоторое время, в зависимости от количества файлов и каталогов, а также скорости вашей системы.

Файлы, созданные после обновления базы данных, не будут отображаться в результатах поиска.

По сравнению с более мощной командой [`find`](https://routerus.com/how-to-find-files-in-linux-using-the-command-line/) которая выполняет поиск в файловой системе, команда `locate` работает намного быстрее, но не имеет многих функций и может выполнять поиск только по имени файла.

---

## find

Очень важно уметь вовремя найти нужную информацию в системе. Конечно, все современные файловые менеджеры предлагают отличные функции поиска, но им не сравнится с поиском в терминале Linux. Он намного эффективнее и гибче обычного поиска, вы можете искать файлы не только по имени, но и по дате добавления, содержимому, а также использовать для поиска регулярные выражения.

Команда find - это одна из наиболее важных и часто используемых утилит системы Linux. Это команда для поиска файлов и каталогов на основе специальных условий. Ее можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.

Утилита find предустановлена по умолчанию во всех Linux дистрибутивах, поэтому вам не нужно будет устанавливать никаких дополнительных пакетов. Это очень важная находка для тех, кто хочет использовать командную строку наиболее эффективно.

Команда find имеет такой синтаксис:

**find [папка] [параметры] критерий шаблон [действие]**

- **Папка** - каталог в котором будем искать

- **Параметры** - дополнительные параметры, например, глубина поиска, и т д

- **Критерий** - по какому критерию будем искать: имя, дата создания, права, владелец и т д.

- **Шаблон** - непосредственно значение по которому будем отбирать файлы.



**Основные параметры команды find

Я не буду перечислять здесь все параметры, рассмотрим только самые полезные.

-   **-P** - никогда не открывать символические ссылки.
-   **-L** - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
-   **-maxdepth** - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
-   **-depth** - искать сначала в текущем каталоге, а потом в подкаталогах.
-   **-mount** искать файлы только в этой файловой системе.
-   **-version** - показать версию утилиты find.
-   **-print** - выводить полные имена файлов.
-   **-type f** - искать только файлы.
-   **-type d** - поиск папки в Linux.

**Критерии:

Критериев у команды find в Linux очень много, и мы опять же рассмотрим только основные.

-   **-name** - поиск файлов по имени.
-   **-perm** - поиск файлов в Linux по режиму доступа.
-   **-user** - поиск файлов по владельцу.
-   **-group** - поиск по группе.
-   **-mtime** - поиск по времени модификации файла.
-   **-atime** - поиск файлов по дате последнего чтения.
-   **-nogroup** - поиск файлов, не принадлежащих ни одной группе.
-   **-nouser** - поиск файлов без владельцев.
-   **-newer** - найти файлы новее чем указанный.
-   **-size** - поиск файлов в Linux по их размеру.

**Примеры использования

А теперь давайте рассмотрим примеры find, чтобы вы лучше поняли, как использовать эту утилиту.

**1. Поиск всех файлов

Показать все файлы в текущей директории:

```
find
```

```
find .
```

```
find . -print
```

Все три команды покажут одинаковый результат. Точка здесь означает текущую папку. В место неё можно указать любую другую.

**Команда** **find** выполняет поиск файлов и каталогов в заданном каталоге. Например, следующая команда будет искать файл с именем _notes.txt_ в каталоге _/home_ и его подкаталогах:

```
$ find /home/ -name notes.txt
```

**2. Поиск файлов в определенной папке

Показать все файлы в указанной директории:

```
find ./Изображения
```

Искать файлы по имени в текущей папке:

```
find . -name "*.png
```

Поиск по имени в текущей папке:

```
find . -name "testfile*"
```

Не учитывать регистр при поиске по имени:

```
find . -iname "TeStFile*"
```


**3. Ограничение глубины поиска

Поиска файлов по имени в Linux только в этой папке:

```
find . -maxdepth 1 -name "*.php"
```

**4. Инвертирование шаблона

Найти файлы, которые не соответствуют шаблону:

```
find . -not -name "test*"
```

**5. Несколько критериев

Поиск командой find в Linux по нескольким критериям, с оператором исключения:

```
find . -name "test" -not -name "*.php"
```

Найдет все файлы, начинающиеся на test, но без расширения php. А теперь рассмотрим оператор ИЛИ:

```
find -name "*.html" -o -name "*.php"
```

Эта команда найдёт как php, так и html файлы.


По умолчанию find ищет как каталоги, так и файлы. Если вам необходимо найти только каталоги используйте критерий **type** с параметром **d**. Например:

```
find . -type d -name "Загрузки"
```

Для поиска только файлов необходимо использовать параметр **f**:

```
find . -type f -name "Загрузки"
```

**6. Несколько каталогов

Искать в двух каталогах одновременно:

```
find ./test ./test2 -type f -name "*.c"
```

**7. Поиск скрытых файлов

Найти скрытые файлы только в текущей папке. Имена скрытых файлов в Linux начинаются с точки:

```
find . -maxdepth 1 -type f -name ".*"
```

**8. Поиск по разрешениям

Параметр perm в команде find используется для поиска файлов с определенными разрешениями в соответствии с маской прав доступа. Например, если вы хотите найти все файлы с определенным разрешением, вы можете использовать команду:

```
find /путь_к_каталогу -type f -perm 644
```

где:
- /путь_к_каталогу - путь к каталогу, в котором нужно выполнить поиск
- -type f - ищем только файлы, а не каталоги
- -perm 644 - ищем файлы с разрешением 644

Когда вы используете параметр perm с командой find, вы указываете числовое значение разрешения, которое вы ищете. Например:

- -perm 644 найдет файлы, у которых разрешения доступа установлены как 644.
- -perm -644 найдет файлы, у которых не установлены разрешения доступа 644.
- -perm /222 найдет файлы, у которых любой из битов разрешения доступа равен 222.

Также можно комбинировать несколько разрешений с помощью логических операторов. Например:
- -perm 644 -o -perm 600 найдет файлы с разрешениями 644 или 600.

Это позволяет настраивать поиск файлов и каталогов на основе их разрешений доступа.

Вы можете также использовать более сложные маски разрешений, используя символы, такие как + для совпадения всех битов в заданных разрешениях и / для совпадения хотя бы одного из битов.

Найти файлы с определенной маской прав, например, 0664:

```
find . -type f -perm 0664
```

Права также можно задавать буквами для u (user) g (group) и o (other). Например, для того чтобы найти все файлы с установленным флагом Suid в каталоге /usr выполните:

```
sudo find /usr -type f -perm /u=s
```

Поиск файлов доступных владельцу только для чтения только в каталоге **/etc**:

```
find /etc -maxdepth 1 -perm /u=r
```

Найти только исполняемые файлы:

```
find /bin -maxdepth 2 -perm /a=x
```

**9. Поиск файлов в группах и пользователях

Для поиска файлов и каталогов, принадлежащих определенному пользователю, можно использовать параметры user и group в команде find.

Например, чтобы найти все файлы и каталоги, принадлежащие пользователю "username", вы можете использовать следующие команды:

Для поиска файлов, принадлежащих пользователю:

```
find /путь_к_каталогу -user username
```

Для поиска файлов, принадлежащих группе:

```
find /путь_к_каталогу -group groupname
```

Где:
- /путь_к_каталогу - путь к каталогу, в котором нужно выполнить поиск
- username - имя пользователя, файлы которого вы хотите найти
- groupname - имя группы, файлы которой вы хотите найти

Эти команды позволят вам найти файлы и каталоги, принадлежащие определенному пользователю или группе, что может быть полезным при администрировании системы и выполнении поиска по различным критериям.

Найти все файлы, принадлежащие пользователю:

```
find . -user sergiy
```

Поиск файлов в Linux принадлежащих группе:

```
find /var/www -group www-data
```

**10. Поиск по дате модификации

Поиск файлов по дате в Linux осуществляется с помощью параметра mtime. Найти все файлы модифицированные 50 дней назад:

```
find / -mtime 50
```

Поиск файлов в Linux открытых N дней назад:

```
find / -atime 50
```

Найти все файлы, модифицированные между 50 и 100 дней назад:

```
find / -mtime +50 -mtime -100
```

Найти файлы измененные в течении часа:

```
find . -cmin 60
```

**11. Поиск файлов по размеру

Найти все файлы размером 50 мегабайт:

```
find / -size 50M
```

От пятидесяти до ста мегабайт:

```
find / -size +50M -size -100M
```

Найти самые маленькие файлы:

```
find . -type f -exec ls -s {} \; | sort -n -r | head -5
```

Самые большие:

```
find . -type f -exec ls -s {} \; | sort -n | head -5
```

**12. Поиск пустых файлов и папок

```
find /tmp -type f -empty

find ~/ -type d -empty
```

**13. Действия с найденными файлами

Для выполнения произвольных команд для найденных файлов используется опция **-exec**. Например, для того чтобы найти все пустые папки и файлы, а затем выполнить ls для получения подробной информации о каждом файле используйте:

```
find . -empty -exec ls -ld {} \;
```

Удалить все текстовые файлы в tmp

```
find /tmp -type f -name "*.txt" -exec rm -f {} \;
```

Удалить все файлы больше 100 мегабайт:

```
find /home/bob/dir -type f -name *.log -size +100M -exec rm -f {} \;
```

---

## df

Когда доходит дело до проверки свободного места через терминал, нам не обойтись без такой стандартной утилиты, как df.

**Команда** **df** (от англ. _«**d**isk **f**ree»_) используется для получения отчета об использовании дискового пространства системы, отображаемого в процентах и килобайтах. Если вы хотите просмотреть отчет в мегабайтах, введите `df -m`:

```
$ df -m
```

Чтобы посмотреть доступное пространство на всех примонтированных разделах и информацию о них достаточно набрать:

```
df
```

Утилита отображает стандартный набор колонок, но понять в ее выводе что-то с первого раза сложно. Все данные выводятся в килобайтах. Теперь давайте попросим утилиту выводить данные в более читаемом формате:

```
df -h
```

Это самое популярное сочетание опций, потому что оно дает максимально понятную информацию и уже можно судить о том, что происходит на диске. Например, мы видим, что в домашней папке уже занято 87% места и, возможно, пора что-то удалить. Если задать опцию -a, вы можете получить информацию обо всех файловых системах известных ядру, которые были смонтированы:

```
df -a
```

Здесь отображается огромное количество виртуальных файловых систем ядра. Если вы хотите вывести только информацию про реальные файловые системы на жестком диске можно использовать опцию **-x** чтобы отфильтровать все tmpfs:

```
df -x tmpfs
```

Также можно отфильтровать две файловые системы:

```
df -x devtmpfs -x tmpfs
```

Или же указать файловую систему, которую нужно отображать:

```
df -t ext4
```

Также можно указать интересующий вас раздел, как вы видели в синтаксисе команды:

```
df -h /dev/sdb6
```

С помощью опции **-i** вы можете посмотреть информацию про состояние inode в вашей файловой системе:

```
df -hi /dev/sdb6
```

---

## du

**Команда du** (от англ. _«_**_d_**_isk **u**sage»_) используется для проверки того, сколько места занимает указанный файл или каталог. Чтобы увидеть занимаемое дисковое пространство в байтах, килобайтах или мегабайтах, добавьте опцию `-h`:

```
$ du -h 
```

---

## rsync

**Rsync** ( **Remote Sync** ) — наиболее часто используемая команда для [копирования и синхронизации файлов и каталогов как удаленно](https://www.tecmint.com/sync-new-changed-modified-files-rsync-linux/ "Как использовать Rsync для синхронизации новых или измененных/модифицированных файлов в Linux") , так и **локально** в **системах Linux** / **Unix** .

С помощью команды **rsync** вы можете удаленно и локально копировать и синхронизировать данные между каталогами, дисками и сетями, выполнять резервное копирование данных и [зеркалировать между двумя машинами Linux](https://www.tecmint.com/clone-centos-server/ "Как клонировать Сервер CentOS с Rsync") .

_Rsync_ , что означает _удаленная синхронизация_ , представляет собой инструмент удаленной и локальной синхронизации файлов. Он использует алгоритм для минимизации объема копируемых данных, перемещая только те части файлов, которые были изменены.


rsync — это утилита для эффективной передачи и синхронизации файлов между компьютером и накопителем, а также между сетевыми компьютерами путем сравнения времени изменения и размера файлов. Он обычно встречается в Unix-подобных операционных системах и находится под лицензией GPL-3.0 или более поздней версии.

Потребность передачи файлов между серверами и компьютерами возникает довольно часто, особенно при администрировании нескольких устройств. Обычно для этих целей удобно использовать ssh и scp, но если файл очень большой, а изменена была только небольшая его часть, или вы хотите настроить постоянную автоматическую синхронизацию, то scp уже явно неидеальный вариант.

Карочи, rsync — очень гибкий инструмент синхронизации с поддержкой сети. Из-за его повсеместного распространения в Linux и Unix-подобных системах, а также его популярности в качестве инструмента для системных сценариев, он включен в большинство дистрибутивов Linux по умолчанию.

**Некоторые общие параметры, используемые с командами rsync.

Теперь давайте кратко рассмотрим параметры rsync. Здесь перечислены не все опции. Для более подробной информации смотрите man rsync:

-   **-v** - Выводить подробную информацию о процессе копирования;
-   **-q** - Минимум информации;
-   **-c** - Проверка контрольных сумм для файлов;
-   **-a** - Режим архивирования, когда сохраняются все атрибуты оригинальных файлов;
-   **-R** - Относительные пути;
-   **-b** - Создание резервной копии;
-   **-u** - Не перезаписывать более новые файлы;
-   **-l** - Копировать символьные ссылки;
-   **-L** - Копировать содержимое ссылок;
-   **-H** - Копировать жесткие ссылки;
-   **-p** - Сохранять права для файлов;
-   **-g** - Сохранять группу;
-   **-t** - Сохранять время модификации;
-   **-x** - Работать только в этой файловой системе;
-   **-e** - Использовать другой транспорт, например, ssh;
-   **-z** - Сжимать файлы перед передачей;
-   **--delete** - Удалять файлы которых нет в источнике;
-   **--exclude** - Исключить файлы по шаблону;
-   **--recursive** - Перебирать директории рекурсивно;
-   **--no-recursive** - Отключить рекурсию;
-   **--progress** - Выводить прогресс передачи файла;
-   **--stat** - Показать статистику передачи;
-   **--version** - Версия утилиты.

Синтаксис для `rsync` работает аналогично другим инструментам, таким как `ssh`, `scp`, а также `cp`.

Сначала перейдите в свой домашний каталог, выполнив следующую команду:

```
cd ~

```

Затем создайте тестовый каталог:

```
mkdir dir1

```

Создайте еще один тестовый каталог:

```
mkdir dir2

```

Теперь добавьте несколько тестовых файлов:

```
touch dir1/file{1..100}

```

Теперь есть каталог с именем `dir1` со 100 пустыми файлами в нем. Подтвердите, перечислив файлы:

```
ls dir1

```

```
Outputfile1    file18  file27  file36  file45  file54  file63  file72  file81  file90
file10   file19  file28  file37  file46  file55  file64  file73  file82  file91
file100  file2   file29  file38  file47  file56  file65  file74  file83  file92
file11   file20  file3   file39  file48  file57  file66  file75  file84  file93
file12   file21  file30  file4   file49  file58  file67  file76  file85  file94
file13   file22  file31  file40  file5   file59  file68  file77  file86  file95
file14   file23  file32  file41  file50  file6   file69  file78  file87  file96
file15   file24  file33  file42  file51  file60  file7   file79  file88  file97
file16   file25  file34  file43  file52  file61  file70  file8   file89  file98
file17   file26  file35  file44  file53  file62  file71  file80  file9   file99
```

У вас также есть пустой каталог с именем `dir2`. Чтобы синхронизировать содержимое `dir1`к `dir2`в той же системе вы будете запускать `rsync` и использовать `-r` флаг, который означает «рекурсивный» и необходим для синхронизации каталогов:

```
rsync -r dir1/ dir2

```

Другим вариантом является использование `-a` флаг, который является комбинированным флагом и означает «архив». Этот флаг рекурсивно синхронизируется и сохраняет символические ссылки, специальные файлы и файлы устройств, время модификации, группы, владельцев и разрешения. Он чаще используется, чем `-r`и является рекомендуемым флагом для использования. Запустите ту же команду, что и в предыдущем примере, на этот раз используя `-a`флаг:

```
rsync -a dir1/ dir2

```

Обратите внимание, что в конце стоит косая черта ( `/`) в конце первого аргумента в синтаксисе двух предыдущих команд и выделено здесь:

```
rsync -a dir1/ dir2

```

Эта завершающая косая черта означает содержимое `dir1`. Без завершающей косой черты, `dir1`, включая каталог, будет помещен в `dir2`. В результате будет создана следующая иерархия:

```
~/dir2/dir1/[files]
```

Еще один совет: перепроверьте свои аргументы перед выполнением `rsync` команда. Rsync предоставляет способ сделать это, передав `-n`или же `--dry-run` опции. `-v` флаг, что означает «подробный», также необходим для получения соответствующего вывода. Вы будете сочетать `a`, `n`, а также `v`флаги в следующей команде:

```
rsync -anv dir1/ dir2

```

```
Outputsending incremental file list
./
file1
file10
file100
file11
file12
file13
file14
file15
file16
file17
file18
. . .
```

Теперь сравните этот вывод с тем, который вы получаете при удалении завершающей косой черты, как показано ниже:

```
rsync -anv dir1 dir2

```

```
Outputsending incremental file list
dir1/
dir1/file1
dir1/file10
dir1/file100
dir1/file11
dir1/file12
dir1/file13
dir1/file14
dir1/file15
dir1/file16
dir1/file17
dir1/file18
. . .
```

Этот вывод теперь демонстрирует, что был передан сам каталог, а не только файлы в каталоге.

**Использование Rsync для синхронизации с удаленной системой

Использовать `rsync` для синхронизации с удаленной системой вам нужен только доступ SSH, настроенный между вашей локальной и удаленной машинами, а также `rsync` установлен в обеих системах. Как только вы подтвердите доступ SSH между двумя машинами, вы можете синхронизировать `dir1` папку из предыдущего раздела на удаленный компьютер, используя следующий синтаксис. В этом случае обратите внимание, что вы хотите передать фактический каталог, поэтому косая черта в конце пропущена:

```
rsync -a ~/dir1 username@remote_host:destination_directory

```

Этот процесс называется _операцией выталкивания_ , потому что он «выталкивает» каталог из локальной системы в удаленную систему. Противоположной операцией является _pull_ , и она используется для синхронизации удаленного каталога с локальной системой. Если `dir1`каталог был в удаленной системе, а не в вашей локальной системе, синтаксис будет следующим:

```
rsync -a username@remote_host:/home/username/dir1 place_to_sync_on_local_machine

```

Нравиться `cp` и подобных инструментов, источник всегда является первым аргументом, а место назначения всегда вторым.

**Использование других параметров Rsync

Rsync предоставляет множество параметров для изменения поведения утилиты по умолчанию, например параметры флага, о которых вы узнали в предыдущем разделе.

Если вы передаете файлы, которые еще не были сжаты, например текстовые файлы, вы можете уменьшить передачу по сети, добавив сжатие с `-z`вариант:

```
rsync -az source destination

```

The `-P`флаг также полезен. Он объединяет флаги `--progress` а также `--partial`. Этот первый флаг обеспечивает индикатор выполнения передачи, а второй флаг позволяет возобновить прерванную передачу:

```
rsync -azP source destination

```

```
Outputsending incremental file list
created directory destination
source/
source/file1
              0 100%    0.00kB/s    0:00:00 (xfr#1, to-chk=99/101)
sourcefile10
              0 100%    0.00kB/s    0:00:00 (xfr#2, to-chk=98/101)
source/file100
              0 100%    0.00kB/s    0:00:00 (xfr#3, to-chk=97/101)
source/file11
              0 100%    0.00kB/s    0:00:00 (xfr#4, to-chk=96/101)
source/file12
              0 100%    0.00kB/s    0:00:00 (xfr#5, to-chk=95/101)
. . .
```

Если вы снова запустите команду, вы получите сокращенный вывод, так как никаких изменений не было сделано. Это иллюстрирует способность Rsync использовать время модификации, чтобы определить, были ли внесены изменения:

```
rsync -azP source destination

```

```
Outputsending incremental file list
sent 818 bytes received 12 bytes 1660.00 bytes/sec
total size is 0 speedup is 0.00
```

Допустим, вы должны были обновить время модификации некоторых файлов с помощью следующей команды:

```
touch dir1/file{1..10}

```

Тогда, если бы вы бежали `rsync`с `-azP`опять же, вы заметите в выводе, как Rsync интеллектуально повторно копирует только измененные файлы:

```
rsync -azP source destination

```

```
Outputsending incremental file list
file1
            0 100%    0.00kB/s    0:00:00 (xfer#1, to-check=99/101)
file10
            0 100%    0.00kB/s    0:00:00 (xfer#2, to-check=98/101)
file2
            0 100%    0.00kB/s    0:00:00 (xfer#3, to-check=87/101)
file3
            0 100%    0.00kB/s    0:00:00 (xfer#4, to-check=76/101)
. . .
```

Чтобы два каталога были действительно синхронизированы, необходимо удалить файлы из целевого каталога, если они удалены из источника. По умолчанию, `rsync`ничего не удаляет из каталога назначения.

Вы можете изменить это поведение с помощью `--delete` вариант.  Использовать `--delete` возможность синхронизировать источник и цель.

Этот параметр указывает rsync удалить любой файл или каталог в месте назначения, если их нет в источнике. Прежде чем использовать эту опцию, вы можете использовать `-n`, `--dry-run` вариант, чтобы выполнить тест для предотвращения нежелательной потери данных:

```
rsync -an --delete source destination

```

Если вы предпочитаете исключить определенные файлы или каталоги, расположенные внутри каталога, который вы синхронизируете, вы можете сделать это, указав их в списке, разделенном запятыми, после `--exclude=`вариант:

```
rsync -a --exclude=pattern_to_exclude source destination

```

Если у вас есть указанный шаблон для исключения, вы можете переопределить это исключение для файлов, соответствующих другому шаблону, с помощью `--include=`вариант:

```
rsync -a --exclude=pattern_to_exclude --include=pattern_to_include source destination

```

Наконец, Rsync `--backup` Опция может использоваться для хранения резервных копий важных файлов. Используется совместно с `--backup-dir`опция, указывающая каталог, в котором должны храниться файлы резервных копий:

```
rsync -a --delete --backup --backup-dir=/path/to/backups /path/to/source destination

```

**Заключение

Rsync может упростить передачу файлов по сетевым соединениям и повысить надежность синхронизации локальных каталогов. Гибкость Rsync делает его хорошим вариантом для множества различных операций на уровне файлов.

Мастерство Rsync позволяет вам разрабатывать сложные операции резервного копирования и получать детальный контроль над тем, как и что передается.

---

# Владение файлами и права доступа

---

## chmod

**Команда** **chmod** (от англ. _«**ch**ange **mod**e»_) позволяет изменить [**права доступа**](https://ravesli.com/tipy-polzovatelej-i-prava-dostupa-k-fajlam-katalogam-v-linux/) к файлам. Она работает в двух режимах: _символьном_ и _числовом_.

При использовании числового режима вы можете установить разрешения для владельца, группы и всех остальных при помощи заданного набора чисел. Разрешения (права доступа)  на запись, чтение и выполнение имеют следующие числовые значения:

   `r` (чтение) = `4`

   `w` (запись) = `2`

   `x` (выполнение) = `1`

   нет разрешений = `0`

Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:

-   **u** - владелец файла;
-   **g** - группа файла;
-   **o** - все остальные пользователи;

Синтаксис настройки прав такой:

**группа_пользователейдействиевид_прав**

В качестве действий могут использоваться знаки **"+"** - включить или **"-"** - отключить. Рассмотрим несколько примеров:

-   **u+x** - разрешить выполнение для владельца;
-   **ugo+x** - разрешить выполнение для всех;
-   **ug+w** - разрешить запись для владельца и группы;
-   **o-x** - запретить выполнение для остальных пользователей;
-   **ugo+rwx** - разрешить все для всех;

Но права можно записывать не только таким способом. Есть еще восьмеричный формат записи, он более сложен для понимания, но пишется короче и проще. Я не буду рассказывать как считать эти цифры, просто запомните какая цифра за что отвечает, так проще:

-   **0** - никаких прав;
-   **1** - только выполнение;
-   **2** - только запись;
-   **3** - выполнение и запись;
-   **4** -  только чтение;
-   **5** - чтение и выполнение;
-   **6** - чтение и запись;
-   **7** - чтение запись и выполнение.

Права на папку linux такие же, как и для файла. Во время установки прав сначала укажите цифру прав для владельца, затем для группы, а потом для остальных. Например, :

-   **744** - разрешить все для владельца, а остальным только чтение;
-   **755** - все для владельца, остальным только чтение и выполнение;
-   **764** - все для владельца, чтение и запись для группы, и только чтение для остальных;
-   **777** - всем разрешено все.

Совокупность разрешений для определенного класса пользователей описывается суммой соответствующих значений разрешений. Например, чтобы дать владельцу файла права на чтение и запись, а также только права на чтение членам группы и всем другим пользователям, необходимо выполнить:

`$ chmod 644 имя_файла`

Только пользователь _root_, владелец файла или пользователь с правами _sudo_ могут изменять права доступа к файлу.

Самый частый случай - разрешить выполнения скрипта владельцу:

`chmod u+x file`

Или можно воспользоваться цифровой записью:

`chmod 766 file`

Теперь отключим выполнение владельцем:

`chmod u-x file`

Дальше разрешим только чтение всем, кроме владельца:

`chmod 744 file`

Или отберем все права:

`chmod ugo-rwx file`

Файлы с правами 000 недоступны никаким пользователям, кроме суперпользователя и владельца. Вернем права обратно:

`chmod 755 file`

Для рекурсивного изменения прав всех файлов и папок в заданном каталоге, используйте команду `chmod` с опцией `-R`:

`$ chmod -R 755 имя_каталога`

Система полномочий в Linux имеет очень важное значение, поскольку благодаря ей можно разделять привилегии между пользователями, ограничить доступ к нежелательным файлам или возможностям, контролировать доступные действия для сервисов и многое другое. В Linux существует всего три вида прав - право на чтение, запись и выполнение, а также три категории пользователей, к которым они могут применяться - владелец файла, группа файла и все остальные.

Эти права применяются для каждого файла, а поскольку все в системе Linux, даже устройства, считаются файлами, то, получается что эти права применимы ко всему. Мы более подробно рассматривали как работают [права доступа к файлам Linux](https://losst.pro/prava-dostupa-k-fajlam-v-linux) в отдельной статье, а этой, я хочу остановиться на команде chmod, которая используется для установки прав.



---

## chown

**Команда** **chown** (от англ. _«**ch**ange **own**er»_) позволяет изменить владельца и группу заданного файла, каталога или символьной ссылки.

При создании файла ему тот пользователь, от имени которого он был создан становится его владельцем, а группой устанавливается основная группа владельца. Но владельца файла и группу можно менять, для этого используются команды chown и chgrp. В этой статье будет рассмотрена команда chown linux, а также основные примеры её использования.

Чтобы изменить владельца файла, достаточно выполнить:

`$ chown имя_пользователя имя_файла`

Чтобы изменить как владельца, так и группу файла, вызовите:

`$ chown имя_пользователя:имя_группы имя_файла`

Используйте опцию `-R`, чтобы рекурсивно обработать все файлы и каталоги в заданном каталоге:

`$ chown -R имя_пользователя:имя_группы имя_каталога`

Давайте изменим владельца папки dir1 на root:

`chown root ./dir1`

Если вы хотите поменять сразу владельца и группу каталога или файла запишите их через двоеточие, например, изменим пользователя и группу для каталога dir2 на root:

`chown root:root ./dir2`

Если вы хотите чтобы изменения применялись не только к этому каталогу, но и ко всем его подкаталогам, добавьте опцию -R:

`chown -R root:root ./dir3`

Дальше давайте изменим группу и владельца на www-data только для тех каталогов и файлов, у которых владелец и группа root в каталоге /dir3:

`chown --from=root:root www-data:www-data -cR ./`

---

## sudo/su

sudo — это важная для понимания утилита, она позволяет временно поднимать привилегии и выполнять задачи администрирования системы. Суть в том, что в каждом дистрибутиве Linux есть пользователь root, имеющий максимальные права.

Однако во имя безопасности его часто отключают, поскольку он действительно может делать все что угодно в рамках системы. А Linux, как известно, не спрашивает, хотите ли вы точно-точно-точно удалить самый важный файл — система просто молча удаляет его, после чего начинается веселый квест с восстановлением.
Потому, как сказано выше, учетная запись root по дефолту отключена, чтобы неопытные пользователи не смогли нарушить работу системы. А для некоторых административных задач, где требуются повышенные привилегии, используется временное решение — sudo.

**Команда** **sudo** (от англ. _«**S**ubstitute **U**ser and **do**«_ = _«подменить пользователя и выполнить»_) позволяет запускать программы от имени другого пользователя (по умолчанию, пользователя _root__)_. Использование команды `sudo`, вместо входа в систему под учетной записью пользователя _root,_ более безопасно, поскольку вы можете предоставить ограниченные административные привилегии отдельным пользователям, не зная пароля пользователя _root_.

Чтобы использовать `sudo`, просто добавьте префикс `sudo` перед именем команды:

`$ sudo имя_команды`


**Многие удивляются, когда узнают, что**

**sudo*** — не единственная утилита, которая позволяет выполнять программы с повышенными привилегиями.  На самом деле, есть две команды, позволяющие временно получать привилегии суперпользователя в системе. Это не только sudo, но еще и su. Однако между ними есть разница, которую нужно понимать. 

Так, sudo позволяет выполнить одну или несколько команд от имени текущего пользователя. В этом случае нужен пароль как раз текущего пользователя, которому система временно повышает привилегии, а после выполнения команды — снова снижает их. Ввод дополнительных команд не требуется. 

А вот команда su требует пароль уже целевого пользователя. Фактически, эта команда включает режим суперпользователя и позволяет выполнять все действия с повышенными привилегиями, так что можно ненамеренно «уронить» систему. Важно, что здесь нужно принудительно выходить из su — набрать exit, logout или нажать комбинацию горячих клавиш Ctrl-D. 

Само собой, что безопаснее использовать именно sudo , ведь эта команда выполняет только конкретные задачи с повышенными привилегиями, а не все. Также в этом случае вводится пароль текущего пользователя, а не root . В общем, правило «_Не работай под root’ом_» остается справедливым и здесь. К слову, в Debian-подобных дистрибутивах есть хитрость — если вы хотите ввести несколько команд, но не вводить sudo перед каждой, то можно ввести sudo su. Просто не забудьте потом выйти с помощью exit, logout или Ctrl-D. _Коротко резюмируем теорию, прежде чем двинуться дальше к практике:_


**Заключение

Su и sudo - это два способа выполнить одну и ту же задачу: запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы. Я писал про [права суперпользователя](https://losst.pro/prava-superpolzovatelya-linux) в этой статье.


---

# Окружения пользователя

---

## export

Еще одна команда для объявления переменных. Все объявленные с помощью нее переменные экспортируются во внешнее окружение среды и будут доступны всем скриптам и программам. С помощью опции -p вы можете посмотреть экспортированные на данный момент переменные.

`export VAR=test`
`echo $VAR

`test

---

## enable

Команда enable позволяет включать или отключать встроенные команды bash. Для включения встроенной команды достаточно передать ее в параметрах. Если вы хотите отключить команду, используйте опцию -n, после этого вместо встроенной команды, будет выполняться утилита из файловой системы.

`enable -n echo`

---

## exit

Универсальная команда, которая позволяет закрыть сеанс оболочки, выйти из терминала или завершить текущую сессию.

---

## dirs

Команда dirs отображает историю смены текущей папки. Каждая предыдущая папка отображается с новой строки. С помощью опции -n можно указать, сколько последних элементов выводить.

`dirs`

---

## alias

Alias Linux - это, по сути, ярлыки команд Linux. Команда alias позволяет пользователю запускать любую команду или даже группу команд, в том числе с опциями, параметрами и файлами, вводом одного слова или даже символа. Это очень удобно во многих ситуациях, например чтобы не вводить полностью команду при обновлении или же очень быстро перемещаться по каталогам.

Команда alias - это очень удобный инструмент для тех, кто часто работает в командной строке. При правильных установках она поможет вам быстрее вводить команды, а также исправлять опечатки. alias - это встроенная команда оболочки, поэтому инсталлировать ее не требуется. В данной статье мы подробно расскажем об использовании команды alias в операционной системе Linux и покажем на примерах.

alias используется для создания альтернативных версий обычных команд, присваивая им новые названия, а также чтобы избежать необходимости запоминать длинные и сложные команды. Кроме того, вы можете задать опции по умолчанию, которые используются каждый раз при запуске команды alias.

**Использование

Чтобы посмотреть какие псевдонимы linux команд уже заданны в вашей системе просто выполните:

`alias`


Команда покажет все alias команд linux определенные для текущего пользователя. Вывод очень сильно зависит от вашего дистрибутива. Общий синтаксис команды выглядит следующим образом:

**$ alias имя="значение"**

**$ alias имя="команда аргумент1 аргумент2"**

**$ alias имя="/путь/к/исполняемому/файлу"**

Вы можете создавать новые псевдонимы, просто выполняя эту команду в терминале. Но созданные таким образом алиасы linux будут работать только в этом терминале и только до его закрытия.

Сколько раз вам случалось набирать sl вместо ls, получая в результате сообщение об ошибке:

``$ sl

``-bash: sl: command not found

Давайте на базе приведенного выше примера покажем, как создавать алиасы в Linux, чтобы избежать появления этого сообщения об ошибке. Чтобы создать алиас, используется команда alias со следующим синтаксисом:

``$ alias alias_command_name='commands'

Мы можем создать новый алиас "sl", который будет являться альтернативной командой для ls.

`#ls

``./  ../  alias.txt

``$ sl

``-bash: sl: command not found

``$ alias sl=ls
``$ sl

``./  ../  alias.txt

Из приведенного выше примера вы можете видеть, что мы создали новый алиас "sl", при выполнении которого запускается команда ls. Это простой пример создания алиаса. Вы также можете включать в алиас опции или несколько команд, используя одинарные кавычки. Для примера давайте создадим алиас, который будет показывать наш внешний IP-адрес:

``$ alias myip='wget -qO myip http://www.ipchicken.com/;
`grep -o "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}" myip;  rm myip'

Запустите вышеприведенную команду одной строкой, чтобы создать новый алиас myip, который будет показывать ваш внешний IP:

``$ myip
`67.64.74.223

Необходимо отметить, что с помощью команды alias вы создаете алиас только для текущей сессии командной оболочки. Это значит, что как только вы разлогинитесь, или откроете новый терминал, созданные вами алиасы уже не будут работать. В следующем разделе мы узнаем, как создавать постоянные алиасы.

Давайте для примера создадим alias linux для такой часто используемой команды, как clear (очистить вывод терминала):

`alias c='clear'`

Теперь, чтобы очистить терминал достаточно выполнить:

`с`

Удалить созданный alias можно с помощью команды unalias:

`unalias c`

Но как я уже сказал, такие alias команд linux сохраняются только до закрытия терминала. Поэтому их необходимо создавать в начале каждой терминальной сессии. Для этого можно записать все нужные команды в **~/.bashrc**. При запуске терминала, каждый раз выполняется этот скрипт, чтобы установить переменные окружения и подготовить оболочку. Таким образом добавив нужные строки в конец файла мы получим работающие alias linux в каждом терминале.

Продолжим создание alias для команды clear:

`vi ~/.bashrc`

Добавьте эту строку в конец файла:

`alias c='clear'`

Затем сохраните и закройте редактор (:wq). Чтобы проверить работоспособность запустите новый терминал. Если вы хотите чтобы ваши алиасы linux были доступны для всех пользователей, необходимо использовать файл /etc/bashrc.

Поскольку **.bashrc**, это обычный bash скрипт, перед нами открываются большие возможности. Например мы можем добавить alias команд с использованием sudo, если текущий пользователь не root:

`if [ $UID -ne 0 ]; then   
`alias reboot='sudo reboot'  
`alias update='sudo apt-get upgrade'   fi`

Ещё мы можем менять команды алиасов в зависимости от дистрибутива:

`_myos="$(uname)"  
`case $_myos in   
`Linux) alias foo='/path/to/linux/bin/foo';;  
`FreeBSD|OpenBSD) alias foo='/path/to/bsd/bin/foo' ;;  
`SunOS) alias foo='/path/to/sunos/bin/foo' ;; 
``*) ;; 
`esac`

Чтобы удалить alias достаточно просто удалить запись о нем, из того файла в который вы её добавили. Мы рассмотрели основы добавления alias linux, теперь давайте перейдем к списку полезных алиасов linux.

Чтобы просмотреть список всех доступных алиасов, просто выполните команду alias без аргументов (в некоторых системах используется опция -p):

``$ alias -p


---


# Управление пользователями и группами

  

---

## whoami

это команда позволяет пользователям Linux видеть текущего пользователя, вошедшего в систему. Вывод отображает имя пользователя эффективного пользователя в текущей оболочке.

При работе **`whoami`**без каких-либо параметров вывод показывает имя текущего пользователя, вошедшего в систему.

Чтобы проверить команду, откройте терминал и введите:

```
whoami
```

Использовать **`whoami`**команда для проверки наличия у пользователя **`sudo`**привилегии. Для этого выполните команду с помощью [sudo](https://phoenixnap.com/kb/linux-sudo-command) и введите пароль :

```
sudo whoami
```

Если у вас более одной учетной записи, используйте **`whoami`**для проверки имени пользователя после перехода на другую учетную запись.

Например, переключитесь на другого пользователя с помощью команды [su](https://phoenixnap.com/kb/su-command-linux-examples) :

```
su [account name]
```

Затем запустите **`whoami`**команда для проверки эффективного пользователя.

---

## id

Команда Linux **id** используется для печати подлинного и эффективного идентификатора пользователя и идентификатора группы. Идентификатор пользователя (UID) — это конкретный идентификатор пользователя, тогда как идентификаторы групп (GID) могут содержать более одного идентификатора пользователя. Эта команда является полезным инструментом для управления пользователями.

Простыми словами, **команда** **id** используется для получения информации по текущему пользователю.

Команду id можно использовать без аргументов. Выполните команду следующим образом:

`id`

Из приведенной выше команды выходные данные будут использовать активного пользователя.

Чтобы получить идентификатор конкретного пользователя, используйте параметр **«-u** ».

`id -u alex

Ну и аосмотрите справку для лучшего понимания.

---

## uname

**Команда** **uname** с опцией `-a` выведет подробную информацию о вашей системе: имя машины, версия операционной системы, ядра и т.д.

`$ uname -a`

Результат:

`Linux debian 5.10.0-6-amd64 #1 SMP Debian 5.10.28-1 (2021-04-09) x86_64 GNU/Linux`

---

## useradd и passwd

**Команда useradd** позволяет создавать новых пользователей. Чтобы создать новую учетную запись пользователя, вызовите команду `useradd` вместе с именем нового пользователя:

`$ useradd newuser`

После создания пользователя установите ему пароль, выполнив **команду passwd**:

`$ passwd newuser`

Программа **passwd** изменяет пароли пользовательских учётных записей. Обычный пользователь  может изменить пароль только своей учётной записи, суперпользователь может изменить пароль любой учётной записи. Программа **passwd** также изменяет информацию об учётной записи или
срок действия пароля.

---

## userdel

**Команда** **userdel** используется для удаления учетной записи пользователя:

`$ userdel имя_пользователя`

Опция `-r` удаляет домашний каталог пользователя и связанные с ним данные:

`$ userdel -r имя_пользователя`

---

## Команды groupadd и groupdel

**Команда** **groupadd** используется для создания новой группы. Просто укажите название группы в качестве параметра:

`$ groupadd mygroup`

Чтобы удалить группу, используйте **команду groupdel** с именем группы в качестве параметра:

`$ groupdel mygroup`

---

## Команда usermod

Чтобы добавить существующего пользователя в группу, используйте **команду usermod** с опцией `-G` и именем группы:

`$ usermod -a -G sudo ravesligroup`

---

# Управление процессами

---

## top

**Команда** **top** отображает в режиме реального времени список запущенных процессов, их числовые идентификаторы (сокр. _**«PID»**_ от англ. _«_**_P_**_rocess_ **_ID_**_entificator»_) и насколько сильно каждый из них нагружает CPU:

`$ top`

---

## ps

Утилита ps одна из самых простых и в то же время часто используемых программ для просмотра списка процессов в Linux. Она не поддерживает интерактивный режим, зато имеет множество опций для настройки вывода тех или иных параметров процессов в Linux.

Чтобы понять что отображает команда ps сначала надо разобратся что такое процесс. Процесс Linux - это экземпляр программы, запущенный в памяти. Все процессы можно разделить на обычные и фоновые. Более подробно об этом написано в статье [управление процессами Linux](https://losst.pro/upravlenie-protsessami-v-linux). Linux - это многопользовательская система, каждый пользователь может запускать одни и те же программы, и даже один пользователь может захотеть запустить несколько экземпляров одной программы, поэтому ядру нужно как-то идентифицировать такие однотипные процессы. Для этого каждому процессу присваивается PID (Proccess Identificator).

Каждый из процессов может находиться в одном из таких состояний:

-   **Запуск** - процесс либо уже работает, либо готов к работе и ждет, когда ему будет дано процессорное время;
-   **Ожидание** - процессы в этом состоянии ожидают какого-либо события или освобождения системного ресурса. [[AA. Ядро linux | Ядро]] делит такие процессы на два типа - те, которые ожидают освобождения аппаратных средств и приостановление с помощью сигнала;
-   **Остановлено** - обычно, в этом состоянии находятся процессы, которые были остановлены с помощью сигнала;
-   **Зомби** - это мертвые процессы, они были остановлены и больше не выполняются, но для них есть запись в таблице процессов, возможно, из-за того, что у процесса остались дочерние процессы.

А теперь давайте перейдем ближе к практике.

**Команда ps в Linux

Команда ps, сокращение от Process Status, представляет собой утилиту командной строки, которая используется для **отображения или просмотра информации, связанной с процессами, запущенными в системе Linux** . Как мы все знаем, Linux — это многозадачная и многопроцессорная система. Таким образом, несколько процессов могут работать одновременно, не влияя друг на друга. Команда ps выводит список текущих запущенных процессов вместе с их PID и другими атрибутами. В этом руководстве мы сосредоточимся на использовании команды ps. Он извлекает информацию о процессах из виртуальных файлов, расположенных в файловой системе /proc.

начала рассмотрим общий синтаксис команды, здесь все очень просто:

**$ ps опции**

**$ ps опции | grep параметр**

Во втором варианте мы используем утилиту grep для того, чтобы отобрать нужные нам процессы по определенному критерию. Теперь рассмотрим опции утилиты. Они делятся на два типа - те, которые идут с дефисом Unix и те, которые используются без дефиса - BSD. Лучше пользоваться только опциями Unix, но мы рассмотрим и одни и другие. Заметьте, что при использовании опций BSD, вывод утилиты будет организован в BSD стиле.

-   **-A, -e, (a)** - выбрать все процессы;
-   **-a** - выбрать все процессы, кроме фоновых;
-   **-d, (g)** - выбрать все процессы, даже фоновые, кроме процессов сессий;
-   **-N** - выбрать все процессы кроме указанных;
-   **-С** - выбирать процессы по имени команды;
-   **-G** - выбрать процессы по ID группы;
-   **-p, (p)** - выбрать процессы PID;
-   **--ppid** - выбрать процессы по PID родительского процесса;
-   **-s** - выбрать процессы по ID сессии;
-   **-t, (t)** - выбрать процессы по tty;
-   **-u, (U)** - выбрать процессы пользователя.

Опции форматирования:

-   **-с** - отображать информацию планировщика;
-   **-f** - вывести максимум доступных данных, например, количество потоков;
-   **-F** - аналогично -f, только выводит ещё больше данных;
-   **-l** - длинный формат вывода;
-   **-j, (j)** - вывести процессы в стиле Jobs, минимум информации;
-   **-M, (Z)** - добавить информацию о безопасности;
-   **-o, (o)** - позволяет определить свой формат вывода;
-   **--sort, (k)** - выполнять сортировку по указанной колонке;
-   **-L, (H)**- отображать потоки процессов в колонках LWP и NLWP;
-   **-m, (m)** - вывести потоки после процесса;
-   **-V, (V)** - вывести информацию о версии;
-   **-H** - отображать дерево процессов;

Теперь, когда вы знаете синтаксис и опции, можно перейти ближе к практике. Чтобы просто посмотреть процессы в текущей оболочке используется такая команда терминала ps:

`ps`

Вывод состоит из четырех столбцов `PID`- Это уникальный идентификатор процесса. `TTY`- Это тип терминала, в который вошел пользователь. `TIME`- Это время в минутах и секундах, в течение которого выполнялся процесс. `CMD`- Команда, запустившая процесс.

Все процессы, кроме лидеров групп, в том же режиме отображения:

`ps -A`

Все процессы, включая фоновые и лидеры групп:

`ps -d`

Чтобы вывести больше информации о процессах используйте опцию **-f**:

`ps -f`

Для просмотра процессов, связанных с терминалом, запустите `ps -T` .

Для просмотра всех процессов, за исключением процессов, связанных с терминалом и руководителями сеансов, выполните `ps -a`Лидер сеанса — это процесс, который запускает другие процессы.

Чтобы просмотреть все текущие процессы, выполните:

```
ps -ax
```

`-a` флаг обозначает все процессы `-x` отобразит все процессы, даже те, которые не связаны с текущим tty.


Если вы хотите отображать процессы в формате BSD, выполните

```
ps au 
```

ИЛИ ЖЕ

```
ps aux
```

Если вы хотите перечислить процессы, связанные с конкретным пользователем, используйте `-u`флаг, как показано

```
ps -u user
```

Например

```
ps -u jamie
```


Скорее всего, обычно не знают PID процесса. Вы можете искать PID процесса, запустив

```
ps -C process_name
```

Например

```
ps -C bash
```


Чтобы отсортировать выходные данные, используйте следующие обозначения:

`ps -ef --sort <sortcolumns>`

Доступны следующие форматы: cmd, pcpu, flags, pgrp, cutime, cstime, utime, pid, ppid, size, uid, user и многие другие, ознакомиться с ними в разделе помощи man.

Пример команды сортировки выглядит следующим образом:

`ps -ef --sort user,pid`

---
## kill

**Сигналы:

Сигналы являются программными прерываниями, которые посылаются процессу, когда случается некоторое событие. Сигналы могут возникать синхронно с ошибкой в приложении, например SIGFPE (ошибка вычислений с плавающей запятой) и SIGSEGV (ошибка адресации), но большинство сигналов является асинхронными. Сигналы могут посылаться процессу, если система обнаруживает программное событие, например, когда пользователь дает команду прервать или остановить выполнение, или получен сигнал на завершение от другого процесса. Сигналы могут прийти непосредственно от ядра ОС, когда возникает сбой аппаратных средств ЭВМ. Система определяет набор сигналов, которые могут быть отправлены процессу. В Linux применяется около 30 различных сигналов. При этом каждый сигнал имеет целочисленное значение и приводит к строго определенным действиям.

Механизм передачи сигналов состоит из следующих частей:

-   установление и обозначение сигналов в форме целочисленных значений;
-   маркер в строке таблицы процессов для прибывших сигналов;
-   таблица с адресами функций, которые определяют реакцию на прибывающие сигналы.

Отдельные сигналы подразделяются на три класса:

-   системные сигналы (ошибка аппаратуры, системная ошибка и т.д.);
-   сигналы от устройств;
-   сигналы, определенные пользователем.

Как только сигнал приходит, он отмечается записью в таблице процессов. Если этот сигнал предназначен для процесса, то по таблице указателей функций в структуре описания процесса выясняется, как нужно реагировать на этот сигнал. При этом номер сигнала служит индексом таблицы.

Известно три варианта реакции на сигналы:

-   вызов собственной функции обработки;
-   игнорирование сигнала (не работает для SIGKILL);
-   использование предварительно установленной функции обработки по умолчанию.

Чтобы реагировать на разные сигналы, необходимо знать концепции их обработки. Процесс должен организовать так называемый обработчик сигнала в случае его прихода. Для этого используется функция signal():

#include <signal.h>

void(*signal(int signr, void(*sighandler)(int)))(int);

Такой прототип очень сложен для понимания. Следует упростить его, определив тип для функции обработки:

typedef void signalfunction(int);

После этого прототип функции примет вид:

signalfunction *signal(int signr,

      signalfunction *sighandler);

signr устанавливает номер сигнала, для которого устанавливается обработчик. В заголовочном файле <signal.h> определены следующие сигналы (табл. [1](https://www.opennet.ru/docs/RUS/linux_parallel/node10.html#tabl1)).  

Таблица 1. Сигналы ОС Linux.

|Номер |Значение |Реакция программы по умолчанию|
|:----|:----|:----|
|SIGABRT |Ненормальное завершение (abort()) |Завершение|
|SIGALRM |Окончание кванта времени |Завершение|
|SIGBUS |Аппаратная ошибка |Завершение|
|SIGCHLD |Изменение состояния потомка |Игнорирование|
|SIGCONT |Продолжение прерванной программы |Продолжение / игнорирование|
|SIGEMT |Аппаратная ошибка |Завершение|
|SIGFPE |Ошибка вычислений с плавающей запятой |Завершение|
|SIGILL |Неразрешенная аппаратная команда |Завершение|
|SIGINT |Прерывание с терминала |Завершение|
|SIGIO |Асинхронный ввод/вывод |Игнорирование|
|SIGKILL |Завершение программы |Завершение|
|SIGPIPE |Запись в канал без чтения |Завершение|
|SIGPWR |Сбой питания |Игнорирование|
|SIGQUIT |Прерывание с клавиатуры |Завершение|
|SIGSEGV |Ошибка адресации |Завершение|
|SIGSTOP |Остановка процесса |Остановка|
|SIGTTIN |Попытка чтения из фонового процесса |Остановка|
|SIGTTOU |Попытка записи в фоновый процесс |Остановка|
|SIGUSR1 |Пользовательский сигнал |Завершение|
|SIGUSR2 |Пользовательский сигнал |Завершение|
|SIGXCPU |Превышение лимита времени CPU |Завершение|
|SIGXFSZ |Превышение пространства памяти (4GB) |Завершение|
|SIGURG |Срочное событие |Игнорирование|
|SIGWINCH |Изменение размера окна |Игнорирование|


**Как происходит завершение процесса?

Управление процессами в операционной системе Linux осуществляется с помощью сигналов. В том числе и завершение любого процесса. Сигналы передает система, но также их может передавать пользователь с помощью специальных команд или даже сочетаний клавиш в терминале. Когда процессу приходит сигнал о необходимости завершиться, он должен выполнить некоторые подготовительные действия.

Необходимо завершить дочерние процессы, удалить временные файлы, сокеты и так далее. Но в зависимости от сложности ситуации процесс может реагировать не на все сигналы. Рассмотрим основные сигналы, которые используются для завершения процесса:

-   **SIGINT** - самый безобидный сигнал завершения, означает Interrupt. Он отправляется процессу, запущенному из терминала с помощью сочетания 
   клавиш Ctrl+C. Процесс правильно завершает все свои действия и возвращает управление;

-   **SIGQUIT -** это еще один сигнал, который отправляется с помощью сочетания клавиш, программе, запущенной в терминале. Он сообщает ей что нужно завершиться и программа может выполнить корректное завершение или проигнорировать сигнал. В отличие от предыдущего, она генерирует дамп памяти. Сочетание клавиш Ctrl+/;

-   **SIGHUP** - сообщает процессу, что соединение с управляющим терминалом разорвано, отправляется, в основном, системой при разрыве соединения с интернетом;

-   **SIGTERM** - немедленно завершает процесс, но обрабатывается программой, поэтому позволяет ей завершить дочерние процессы и освободить все ресурсы;

-   **SIGKILL** - тоже немедленно завершает процесс, но, в отличие от предыдущего варианта, он не передается самому процессу, а обрабатывается ядром. Поэтому ресурсы и дочерние процессы остаются запущенными.

Важно понимать, что нужно дать процессу возможность завершиться корректно. Желательно, чтобы порты и сокеты были освобождены, закрыты и удаленны временные файлы. Поэтому никогда не передавайте сразу SIGKILL. Передавайте сигналы завершения в последовательности, как они перечислены выше.

Сначала **Ctrl+C**, если это возможно, затем SIGTERM - он хоть и завершает процесс, но делает эту культурно, и только в крайнем случае SIGKILL. А теперь рассмотрим как убить процесс по pid Linux на практике. 

**Как убить процесс Linux?

Для передачи сигналов процессам в Linux используется утилита kill. Ее синтаксис очень прост:

>**$ kill -сигнал pid_процесса**

Сигнал представляет собой один из выше перечисленных сигналов для завершения процесса. По умолчанию, если этот параметр не указан, используется сигнал SIGTERM, что является очень правильно. Также нам нужно указать какой процесс нужно завершить. Для этого используется уникальный идентификатор процесса - PID.

**Отправка сигнала SIGTERM

Пошлем сигнал _SIGTERM_ процессу с PID 3012:

```
kill 3012
```

**Отправка сигнала KILL (завершение процесса)

Пошлем сигнал _KILL_ процессу с PID 3121, чтобы принудительно завершить процесс:

```
kill -KILL 3121
```

Или можно использовать числовое значение сигнала:

```
kill -9 3121
```

**Отправка сигнала нескольким процессам

Выполним отправку сигнала _KILL_ сразу нескольким процессам. Для этого необходимо перечислить их идентификаторы:

```
kill -9 2903 2977 3012
```


`kill -s SIGKILL 14371`

Исполнение процесса должно завершиться в любом случае.

**Приостановка и продолжение исполнения процесса

Для приостановки и продолжения исполнения процессов следует использовать сигналы **SIGSTOP** и **SIGCONT** соответственно. Да, как вы наверняка уже догадались, ранее рассмотренная команда:

`kill 14371`

Превратится в команду для приостановки исполнения процесса:

`kill -s SIGSTOP 14371`

Или команду для продолжения исполнения процесса:

`kill -s SIGCONT 14371`

Если у вас есть зависшая программа, то вы можете вручную завершить её работу, послав с помощью **команды kill** соответствующий сигнал.

Всего существует 64 различных сигнала, но самыми популярными являются два:

   **SIGTERM** **(15)** — сигнал завершения работы программы, при котором ей дается некоторое время, чтобы сохранить свой прогресс и данные.

   **SIGKILL** **(9)** — сигнал, требующий от программы немедленного завершения. Все несохраненные данные при этом будут потеряны.

Например, зная PID нужного вам процесса, послать ему сигнал можно следующим образом:

`$ kill -9 3501`

В этом примере параметр `-9` отвечает за сигнал SIGKILL (9), а `3501` — это идентификатор (PID) нужного вам процесса.

---

## pkill

Утилита pkill - это оболочка для kill, она ведет себя точно так же, и имеет тот же синтаксис, только в качестве идентификатора процесса ей нужно передать его имя. Утилита сканирует директорию proc и находит PID первого процесса с таким именем, затем отправляет ему SIGTERM. Таким образом, вы можете убить процесс по имени Linux. Например, если мы хотим завершить тот же ping:

`pkill ping`

Также можно вручную задать тип сигнала:

`pkill -TERM ping`

---

## killall

Но если вам программа создала несколько процессов, например, браузер chromium или firefox создают отдельный процесс для каждой из вкладок, то эта утилита мало чем поможет. Тут нужен следующий вариант.

killall работает аналогично двум предыдущим утилитам. Она тоже приминает имя процесса в качестве параметра и ищет его PID в директории /proc. Но эта утилита обнаружит все процессы, с таким именем и завершит их. Например:

`killall ping`

То есть если мы с нескольких терминалов запустм одну программу (даже если у них разные PID), то killall завершает из всех. Напрмер, если мы с нескольких терминалов запустим команду ping, то выщеупомянутая команда завершает их всех.


---

## pidof

Эта утилита ищет PID конкретного процесса по его имени. Никаких вхождений, имя процесса должно только совпадать с искомым:

`pidof apache2`

С помощью опции **-s** можно попросить утилиту выводить только один PID:

`pidof -s apache2`

Самый распространённый способ узнать PID Linux - использовать утилиту **ps**:

`ps aux | grep имя_процесса`

Кроме нужного нам процесса, утилита также выведет PID для grep, ведь процесс был запущен во время поиска. Чтобы его убрать, добавляем такой фильтр:

`ps aux | grep имя_процесса | grep -v grep`

Например, узнаём PID всех процессов, имя которых содержит слово "Apache":

`ps aux | grep apache | grep -v grep`


---

## w

`w` — это утилита командной строки, которая отображает информацию о пользователях, вошедших в систему в данный момент, и о том, что каждый из них делает. Он также дает информацию о том, как долго работает система, текущее время и средняя загрузка системы.

Синтаксис команды `w` следующий:

```sh
w [OPTIONS] [USER]
```

Когда `w` вызывается без какой-либо опции или аргумента, вывод выглядит примерно так:

```output
 21:41:07 up 12 days, 10:08,  2 users,  load average: 0.28, 0.20, 0.10
USER      TTY      FROM        LOGIN@   IDLE   JCPU   PCPU WHAT
root      pts/0    10.10.0.2   20:59    1.00s  0.02s  0.00s w
linuxize  pts/1    10.10.0.8   21:41    7.00s  0.00s  0.00s bash
```

Первая строка предоставляет ту же информацию, что и команда [`uptime`](https://routerus.com/linux-uptime-command/) . Он содержит следующие столбцы:

-   `21:41:07` — Текущее системное время.
-   `up 12 days, 10:08` — Продолжительность работы системы.
-   `2 users` — количество вошедших в систему пользователей.
-   `load average: 0.28, 0.20, 0.10` — `load average: 0.28, 0.20, 0.10` системы за последние 1, 5 и 15 минут. Средняя загрузка системы — это измерение количества заданий, которые в настоящее время выполняются или ожидают ввода-вывода на диск. Он в основном сообщает вам, насколько загружена ваша система в течение заданного интервала.

Вторая строка включает следующие поля:

-   `USER` — Имя зарегистрированного пользователя.
-   `TTY` — имя терминала, используемого пользователем.
-   `FROM` — Имя хоста или IP-адрес, с которого пользователь вошел в систему.
-   `LOGIN@` — время, когда пользователь вошел в систему.
-   `IDLE` — время с момента последнего взаимодействия пользователя с терминалом. Время простоя.
-   `JCPU` — время, используемое всеми процессами, подключенными к tty.
-   `PCPU` — время, используемое текущим процессом пользователя. Тот, который отображается в поле `WHAT` .
-   `WHAT` — текущий процесс пользователя и параметры / аргументы.

Затем команда выводит список всех пользователей, которые в настоящее время вошли в систему, и информацию, связанную с ними.

Если вы передадите одно или несколько имен пользователей в качестве аргументов команды `w` , вывод будет ограничен указанными пользователями:

```
w linuxize
```

```output
 22:08:55 up 12 days, 10:35,  2 users,  load average: 0.00, 0.06, 0.12
USER      TTY      FROM        LOGIN@   IDLE   JCPU   PCPU WHAT
linuxize  pts/1    10.10.0.8   21:41    27:55   0.00s  0.00s bash
```

`w` извлекает информацию о вошедших в систему пользователях из файла `/var/run/utmp` .

`w` принимает несколько редко используемых опций.

Опция `-h` , `--no-header` указывает `w` не печатать заголовок:

```
w -h
```

Распечатывается только информация о авторизованных пользователях:

```output
root      pts/0    10.10.0.2   20:59    1.00s  0.02s  0.00s w -h
linuxize  pts/1    10.10.0.8   21:41    7.00s  0.00s  0.00s bash
```

Параметр `-f` , `--from` переключает поле `FROM` . Отображение или скрытие этого поля по умолчанию зависит от используемого вами дистрибутива.

```
w -f
```

```output
 22:48:39 up 12 days, 11:15,  2 users,  load average: 0.03, 0.02, 0.00
USER      TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root      pts/0     20:59    5.00s  0.03s  0.01s bash
linuxize  pts/1     21:41    1.00s  0.02s  0.00s w -f
```

Параметр `-o` , `--old-style` указывает `w` использовать вывод в старом стиле. Когда используется эта опция, команда печатает пустое пространство, когда время `IDLE` , `JCPU` и `PCPU` меньше одной минуты.

```
w -o
```

```output
 22:50:33 up 12 days, 11:17,  2 users,  load average: 0.14, 0.04, 0.01
USER      TTY      FROM        LOGIN@   IDLE   JCPU   PCPU WHAT
root      pts/0    10.10.0.2   20:59    1:59m               bash
linuxize  pts/1    10.10.0.8   21:41                        w -o
```

Опция `-s` , `--short` указывает `w` использовать вывод в коротком стиле. Когда используется эта опция, поля `LOGIN@` , `JCPU` и `PCPU` не печатаются.

```
w -s
```

```output
 22:51:48 up 12 days, 11:18,  2 users,  load average: 0.04, 0.03, 0.00
USER      TTY      FROM         IDLE WHAT
root      pts/0    10.10.0.2    3:14  bash
linuxize  pts/1    10.10.0.8    2.00s w -s
```

Параметр `-i` , `--ip-addr` заставляет `w` всегда показывать IP-адрес вместо имени хоста в поле `FROM` .

```
w -i
```


---

# Работа с сетью

---

## ping

**Команда ping** применяется в тех случаях, когда необходимо проверить состояние подключения к серверу. Например:

`$ ping ravesli.com`

Данная команда проверит, сможете ли вы подключиться к сайту Ravesli, а также измерит и отобразит время отклика.

---

## wget

**Команда** **wget** пригодится вам, если вы собираетесь загрузить из Интернета какие-либо файлы (или страницы сайтов). Она поддерживает протоколы HTTP, HTTPS, FTP, а также работу через прокси-серверы. Для загрузки нужного вам файла просто передайте его адрес в качестве параметра команде `wget`:

`$ wget https://ravesli.com/wallpapers/image.jpg`

---

## hostname

**Команда** **hostname** используется для проверки имени вашего хоста. Добавление опции `-I` в её конец покажет его IP-адрес.

`$ hostname –I`

---

# Работа с текстом

---

## head

**Команда head** используется для просмотра первых строк любого текстового файла. По умолчанию она будет показывать первые десять строк, но с помощью опции `-n` вы можете изменить это число. Например, для отображения только первых пяти строк, введите:

`$ head -n 5 filename.txt`

---

## tail

**Команда** **tail** отображает последние десять строк текстового файла:

`$ tail -n filename.txt`

---

## sort

Это утилита для вывода текстовых строк в определенном порядке. Проще говоря, для сортировки. Ее можно использовать для сортировки текста из одного или нескольких файлов или c помощью нее может быть выполнена сортировка вывода linux для какой-либо команды. Это может быть полезно во многих случаях. Например, отсортировать файлы по размеру в выводе команды du или собрать частотность использования команд из истории.

Уже по традиции подобных статей, сначала рассмотрим общий синтаксис команды:

>**$ sort опции файл**

Или

>**$ команда | sort опции**

**Опции:

Теперь рассмотрим основные опции утилиты sort.

-   **-b** - не учитывать пробелы
-   **-d** - использовать для сортировки только буквы и цифры
-   **-i** - сортировать только по ASCII символах
-   **-n** - сортировка строк linux по числовому значению
-   **-r** - сортировать в обратном порядке
-   **-с** - проверить был ли отсортирован файл
-   **-o** - вывести результат в файл
-   **-u** - игнорировать повторяющиеся строки
-   **-m** - объединение ранее отсортированных файлов
-   **-k** - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.
-   **-f** - использовать в качестве разделителя полей ваш символ вместо пробела.

Я понимаю, что многое из всего этого может быть непонятно, но на примерах все станет намного яснее.

**Примеры использования sort:

Наконец-то мы добрались к теме примеры sort Linux. Давайте сначала создадим файл с несколькими строками, на котором и будем проверять возможности утилиты.

`nano test.txt`

`computer 
`mouse
`LAPTOP
`data
`RedHat 
`laptop
`debian
`laptop`

Также можно воспользоваться вот такой командой:

`echo -e "computer\nmouse\nLAPTOP\ndata\nRedHat\nlaptop\ndebian\nlaptop" > test.txt`

Опция -e указывает команде, что нужно обрабатывать спецсимволы, а \n, если кто не знает, не что иное как спецсимвол перевода строки в Linux.

**1. Сортировка

Теперь давайте выполним сортировку строк linux в нашем файле:

`sort test.txt`

`computer
`data 
`debian 
`laptop   
`laptop 
`LAPTOP
`mouse
`RedHat`

Вот несколько принципов, по которым команда sort linux сортирует строки:

-   Строки с цифрами размещаются выше других строк
-   Строки, начинающиеся с букв нижнего регистра размещаются выше
-   Сортировка выполняется в соответствии алфавиту
-   Строки сначала сортируются по алфавиту, а уже вторично по другим правилам.

**2. Обратная сортировка

Отсортируем файл в обратном порядке:

`sort -r test.txt`

`RedHat 
`mouse
`LAPTOP 
`laptop
`laptop
`debian  
`data 
`computer`

**3. Сортировка по колонке

Отсортируем вывод команды ls по девятой колонке, то есть по имени файла или папки. Колонку укажем опцией -k:

`ls -l | sort -k9`

`drwxr-xr-x 6 user user 4096 дек 6 14:29  Android
`drwx------ 3 user user 4096 янв 14 22:18 Desktop  
`drwxr-xr-x 12 user user 4096 янв 14 21:49 Documents 
`drwx------ 5 user user 12288 янв 15 14:59 Downloads
`drwxr-xr-x 7 user user 4096 янв 13 11:42 Lightworks`

Сортировка вывода Linux выполняется так же просто как и строк из файла.

**4. Сортировка по номеру

Отсортируем вывод команды ls по второй колонке. Для сортировки по числовому значению используется опция -n:

 `ls -l | sort -nk2`

`drwx------ 5 user user 12288 янв 15 14:59 Downloads  
`drwxr-xr-x 6 user user 4096 дек 6 14:29 Android  
`drwxr-xr-x 7 user user 4096 июн 10 2015 Sources  
`drwxr-xr-x 7 user user 4096 окт 31 15:08 VirtualBox 
`drwxr-xr-x 7 user user 4096 янв 13 11:42 Lightworks   drwxr-xr-x 8 user user 12288 янв 11 12:33 Pictures`

**5. Удаление дубликатов

Команда sort Linux позволяет не только сортировать строки, но и удалять дубликаты. Для этого есть опция -u:

`sort -u test.txt`

`computer   
`data
`debian   
`laptop 
`LAPTOP
`mouse   
`RedHat`

Теперь строчка laptop не повторяется.

**6. Сортировка по нескольким полям

Мы можем сортировать данные по нескольким полям. Например, отсортируем вывод ls по второму первично и вторично девятому полях:

`ls -l | sort -t "," -nk2,5 -k9`

×

`drwxr-xr-x 2 seriyyy95 seriyyy95 4096 дек 6 14:32 Links 
`drwxr-xr-x 2 seriyyy95 seriyyy95 4096 янв 13 10:43 tmp
`drwx------ 3 seriyyy95 seriyyy95 4096 янв 14 22:18 Desktop 
`drwxr-xr-x 3 seriyyy95 seriyyy95 4096 мар 28 2015 Журналы 
`drwx------ 4 seriyyy95 seriyyy95 12288 янв 15 15:42 Загрузки`

---

## diff

**Команда** **diff** (от англ. _«**diff**erence»_) производит построчное сравнение содержимого двух файлов. После анализа файлов, выводится список несовпадающих строк. Программисты часто используют данную команду, когда им нужно внести некоторые изменения в исходный код программы:

`$ diff file1.txt file2.txt`

---

## grep

**Команда** **grep** (от англ. _«search **g**lobally for lines matching the **r**egular **e**xpression, and **p**rint them»_) позволяет искать указанный текст в указанном файле.

Иногда может понадобится найти файл, в котором содержится определённая строка или найти строку в файле, где есть нужное слово. В Linux всё это делается с помощью одной очень простой, но в то же время мощной утилиты **grep**. С её помощью можно искать не только строки в файлах, но и фильтровать вывод команд, и много чего ещё.

Команда **grep** (расшифровывается как global regular expression print) - одна из самых востребованных команд в терминале Linux, которая входит в состав проекта GNU. Секрет популярности - её мощь, она даёт возможность пользователям сортировать и фильтровать текст на основе сложных правил.

Утилита grep решает множество задач, в основном она используется для поиска строк, соответствующих строке в тексте или содержимому файлов. Также она может находить по шаблону или регулярным выражениям. Команда в считанные секунды найдёт файл  с нужной строчкой, текст в файле или отфильтрует из вывода только пару нужных строк. А теперь давайте рассмотрим, как ей пользоваться.

Синтаксис команды выглядит следующим образом:

**$ grep [опции] шаблон [имя файла...]**

Или:

**$ команда | grep [опции] шаблон**

-   **Опции** - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода, например количество строк или режим инверсии.
-   **Шаблон** - это любая строка или регулярное выражение, по которому будет вестись поиск
-   **Файл и команда** - это то место, где будет вестись поиск. Как вы увидите дальше, **grep** позволяет искать в нескольких файлах и даже в каталоге, используя рекурсивный режим.

Возможность фильтровать стандартный вывод пригодится,например, когда нужно выбрать только ошибки из логов или найти PID процесса в многочисленном отчёте утилиты **ps**.

**Опции:

Давайте рассмотрим самые основные опции утилиты, которые помогут более эффективно выполнять поиск текста в файлах **grep**:

-   **-b** - показывать номер блока перед строкой;
-   **-c** - подсчитать количество вхождений шаблона;
-   **-h** - не выводить имя файла в результатах поиска внутри файлов Linux;
-   **-i** - не учитывать регистр;
-   **- l** - отобразить только имена файлов, в которых найден шаблон;
-   **-n** - показывать номер строки в файле;
-   **-s** - не показывать сообщения об ошибках;
-   **-v** - инвертировать поиск, выдавать все строки кроме тех, что содержат шаблон;
-   **-w** - искать шаблон как слово, окружённое пробелами;
-   **-e** - использовать регулярные выражения при поиске;
-   **-An** - показать вхождение и n строк до него;
-   **-Bn** - показать вхождение и n строк после него;
-   **-Cn** - показать n строк до и после вхождения;

Все самые основные опции рассмотрели и даже больше, теперь перейдём к примерам работы команды **grep** Linux.

**Примеры использования:

С теорией покончено, теперь перейдём к практике. Рассмотрим несколько основных примеров поиска внутри файлов Linux с помощью **grep**, которые могут вам понадобиться в повседневной жизни.

**Поиск текста в файлах

В первом примере мы будем искать пользователя User в файле паролей Linux. Чтобы выполнить поиск текста **grep** в файле /etc/passwd введите следующую команду:

`grep User /etc/passwd`

В результате вы получите что-то вроде этого, если, конечно, существует такой пользователь:

`User:x:1000:1000:User,,,:/home/User:/bin/bash`

А теперь не будем учитывать регистр во время поиска. Тогда комбинации ABC, abc и Abc с точки зрения программы будут одинаковы:

`grep -i "user" /etc/passwd`

1.  Найдите любую строку, которая содержит слово в имени файла в Linux:  
    **grep 'word' filename**
2.  Выполните поиск слова «bar» без учета регистра в Linux и Unix:  
    **grep -i 'bar' file1**
3.  Найдите во всех файлах в текущем каталоге и во всех его подкаталогах в Linux слово «httpd»:  
    **grep -R 'httpd' .**
4.  Найдите и отобразите общее количество раз, когда строка «nixcraft» появляется в файле с именем frontpage.md:  
    **grep -c 'nixcraft' frontpage.md**
5. Вышеприведенная команда будет искать слово blue в файле notepad.txt и выведет все строки, в которых содержится искомое слово.
    **grep blue notepad.txt**
    

**Вывести несколько строк

Например, мы хотим выбрать все ошибки из лог-файла, но знаем, что в следующей строчке после ошибки может содержаться полезная информация, тогда с помощью grep отобразим несколько строк. Ошибки будем искать в Xorg.log по шаблону "EE":

`grep -A4 "EE" /var/log/xorg.0.log`

Выведет строку с вхождением и 4 строчки после неё:

`grep -B4 "EE" /var/log/xorg.0.log`

Выведет целевую строку и 4 строчки до неё:

`grep -C2 "EE" /var/log/xorg.0.log`

Выведет по две строки с верху и снизу от вхождения.

**Регулярные выражения в grep

Регулярные выражения **grep** - очень мощный инструмент в разы расширяющий возможности поиска текста в файлах. Для активации этого режима используйте опцию **-e**. Рассмотрим несколько примеров:

Поиск вхождения в начале строки с помощью спецсимвола "^", например, выведем все сообщения за ноябрь:

`grep "^Nov 10" messages.1`

`Nov 10 01:12:55 gs123 ntpd[2241]: time reset +0.177479 s 
`Nov 10 01:17:17 gs123 ntpd[2241]: synchronized to LOCAL(0), stratum 10`

Поиск в конце строки - спецсимвол "$":

`grep "terminating.$" messages`

`Jul 12 17:01:09 cloneme kernel: Kernel log daemon terminating.
`Oct 28 06:29:54 cloneme kernel: Kernel log daemon terminating.`

Найдём все строки, которые содержат цифры:

`grep "[0-9]" /var/log/Xorg.0.log`

Вообще, регулярные выражения **grep** - это очень обширная тема, в этой статье я лишь показал несколько примеров. Как вы увидели, поиск текста в файлах grep становиться ещё эффективнее. Но на полное объяснение этой темы нужна целая статья, поэтому пока пропустим её и пойдем дальше.

**Рекурсивное использование grep

Если вам нужно провести поиск текста в нескольких файлах, размещённых в одном каталоге или подкаталогах, например в файлах конфигурации Apache - /etc/apache2/, используйте рекурсивный поиск. Для включения рекурсивного поиска в **grep** есть опция **-r**. Следующая команда займётся поиском текста в файлах Linux во всех подкаталогах /etc/apache2 на предмет вхождения строки mydomain.com:

`grep -r "mydomain.com" /etc/apache2/`

В выводе вы получите:

`grep -r "zendsite" /etc/apache2/  

``/etc/apache2/vhosts.d/zendsite_vhost.conf: ServerName zendsite.localhost 
``/etc/apache2/vhosts.d/zendsite_vhost.conf: DocumentRoot /var/www/localhost/htdocs/zendsite   /etc/apache2/vhosts.d/zendsite_vhost.conf: <Directory /var/www/localhost/htdocs/zendsite>`

Здесь перед найденной строкой указано имя файла, в котором она была найдена. Вывод имени файла легко отключить с помощью опции **-h**:

`grep -h -r "zendsite" /etc/apache2/`

`ServerName zendsite.localhost   
`DocumentRoot /var/www/localhost/htdocs/zendsite 
``<Directory /var/www/localhost/htdocs/zendsite>`

**Поиск слов в grep

Когда вы ищете строку abc, **grep** будет выводить также kbabc, abc123, aafrabc32 и тому подобные комбинации. Вы можете заставить утилиту искать по содержимому файлов в Linux только те строки, которые выключают искомые слова с помощью опции **-w**:

`grep -w "abc" имя_файла`

**Поиск двух слов

Можно искать по содержимому файла не одно слово, а два сразу:

`egrep -w 'word1|word2' /path/to/file`

**Количество вхождений строки

Утилита **g****rep** может сообщить, сколько раз определённая строка была найдена в каждом файле. Для этого используется опция **-c** (счетчик):

`grep -c 'word' /path/to/file`

C помощью опции **-n** можно выводить номер строки, в которой найдено вхождение, например:

`grep -n 'root' /etc/passwd`

Получим:

`1:root:x:0:0:root:/root:/bin/bash`

**Инвертированный поиск в grep

Команда **grep** Linux может быть использована для поиска строк в файле, которые не содержат указанное слово. Например, вывести только те строки, которые не содержат слово пар:

`grep -v пар /path/to/file`

**Вывод имени файла

Вы можете указать **grep** выводить только имя файла, в котором было найдено заданное слово с помощью опции **-l**. Например, следующая команда выведет все имена файлов, при поиске по содержимому которых было обнаружено вхождение primary:

`grep -l 'primary' *.c`

**Цветной вывод в grep

Также вы можете заставить программу выделять другим цветом вхождения в выводе:

`grep --color root /etc/passwd`


---

## wc

Анализ файлов - неотъемлемая часть работы с ними. Иногда возникает необходимость подсчитать количество строк или слов в тексте. С этой задачей эффективно справляется команда **wc** Linux.

**Синтаксис команды wc

Для запуска утилиты откройте терминал и введите:

`wc`

Терминал будет ожидать ввода данных. После нажатия комбинации клавиш **Ctrl** + **D** командный интерпретатор завершит работу программы и выведет три числа, обозначающих количество строк, слов и байт введённой информации.

Утилита может обрабатывать файлы. Стандартная инструкция выглядит так:


```
wc file
```

-   **wc** — имя утилиты;
-   **file** — название обрабатываемого файла.

Программа также может принимать параметры для анализа отдельных значений. Наиболее используемые из них приведены в таблице ниже:

|Параметр |Длинный вариант |Значение|
|:----|:----|:----|
|-c |--bytes |Отобразить размер объекта в байтах|
|-m |--count |Показать количесто символов в объекте|
|-l |--lines |Вывести количество строк в объекте|
|-w |--words |Отобразить количество слов в объекте|

Под объектом следует понимать файл или данные, полученные на стандартный поток ввода.

Команда может обработать несколько файлов, если указать их через пробел или выбрать по шаблону.

---


**Применение команды wc

Обработка стандартного потока ввода с завершением через **Ctrl** + **D**:

![[Pasted image 20221030165020.png]]

Согласно анализу, было введено 4 строки, содержащих 5 слов, объёмом в 35 байт.

Перенаправление потока вывода на вход **wc**:

![[Pasted image 20221030165053.png]]

Обработка всех файлов с расширением **.sh** в текущем каталоге:

![[Pasted image 20221030165127.png]]

В конце выводится итоговая информация, суммирующая значения для каждого столбца.

Выведем только количество символов и строк двух файлов:

![[Pasted image 20221030165155.png]]

Обратите внимание: порядок указания параметров не влияет на итоговый вид информации. Программа всегда выводит данные в виде **СТРОК — СЛОВ — БАЙТ (СИМВОЛОВ) [— ФАЙЛ]**. Если какой-то параметр будет отсутствовать, его столбец просто проигнорируется, не задевая остальные. Количество символов будет стоять первым, если в команде содержался и вывод байт.

---


## echo

**Команда** **echo** используется для вывода в терминал строки, указанной ей в качестве параметра. Часто команда `echo` применяется для перемещения некоторых данных в файл. Например, если вы хотите добавить строку _«Hello, world!»_ в файл с именем _name.txt_, выполните:

`$ echo "Hello, world!" >> name.txt`

---

## printf

Эта команда похожа на echo по своему назначению  похожа на echo. Она позволяет вывести в терминал строку, но перед выводом вы можете настроить ее форматирование. Синтаксис форматирования очень похож на тот, что используется в популярных языках программирования, таких как Си или PHP. Например, с помощью этой команды bash вы можете подставить значения переменных в произвольные места строки:

`printf "Var: %s\n" "$VAR"`

---

## read

С помощью команды read, вы можете прочитать строку из стандартного ввода или файла в переменную. Есть подобные ей команды оболочки bash, которые позволяют считывать строку в массив. Команде можно передать файл для считывания, а также несколько переменных:

`read VAR`

Чтобы проиллюстрировать, как работает команда, откройте терминал, введите `read var1 var2` и нажмите «Enter». Команда будет ждать, пока пользователь введет данные. Введите два слова и нажмите «Enter».

```
read var1 var2
```

Слова присваиваются именам, которые передаются команде `read` качестве аргументов. Используйте [`echo`](https://routerus.com/echo-command-in-linux-with-examples/) или [`printf`](https://routerus.com/bash-printf-command/) чтобы проверить это:

```
echo $var1
```

```output
Hello,
World!
```

Вот пример использования строки здесь и `printf` :

```
read -r var1 var2 <<< "Hello, World!"
```

```output
Var1: Hello, 
Var2: World! 
```


---

## cat

**Команда** **cat** (от англ. _«con**cat**enate»_) отображает содержимое одного или нескольких файлов. Чтобы отобразить содержимое файла, необходимо указать его имя в качестве параметра команды `cat`:

`$ cat /etc/hosts`


Чтобы вывести несколько файлов достаточно просто передать их в параметрах:

`cat file file1`

Также вы можете нумеровать все строки в файле:

`cat -n file`

Опция -s позволяет удалить повторяющиеся пустые строки:

`cat -s file`

Если вы не передадите никакого файла в параметрах утилите, то она будет пытаться читать данные из стандартного ввода:

`cat`

Для завершения записи нажмите Ctrl+D. Таким образом можно получить очень примитивный текстовый редактор - прочитаем ввод и перенаправим его вместо вывода на экран в файл:

`cat > file2 
``cat file2`



---

# Установка и удаление пакетов

**Менеджер пакетов** — это инструмент, который позволяет устанавливать, обновлять, удалять и иным образом управлять пакетами программного обеспечения, специфичными для дистрибутива Linux. Различные [**дистрибутивы Linux**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Обзор дистрибутивов Linux. Какой выбрать?") имеют различные менеджеры и форматы пакетов.

Только _root_ или пользователь с привилегиями _sudo_ может устанавливать и удалять пакеты.

---

## dpkg

В Debian и его производных, таких как Ubuntu и Linux Mint, менеджер пакетов dpkg используется для управления пакетами. Dpkg, установленный по умолчанию в Debian, и его производные можно использовать для установки, сборки и удаления пакетов .deb. `dpkg`— это базовая команда для обработки пакетов Debian в системе. Если у вас есть `.deb` пакеты, это `dpkg` что позволяет устанавливать или анализировать их содержимое.

По сути, [справочная страница](https://man7.org/linux/man-pages/man1/dpkg.1.html) описывает это так: «dpkg — это инструмент для установки, сборки, удаления и управления пакетами Debian».

Мы используем команду dpkg для взаимодействия с пакетами в нашей системе. Он полностью управляется с помощью параметров командной строки, и первый параметр называется параметром действия, который используется для указания того, что делать. За этим параметром может или не может следовать какой-либо другой параметр.

Позже был разработан новый инструмент под названием aptitude, чтобы предоставить пользователям более удобный интерактивный интерфейс для управления пакетами без такой сложности, как _команда dpkg_ . Он взаимодействует с интерфейсом dpkg от имени пользователя.

Вот как выглядит основной синтаксис команды dpkg:

```
dpkg [options] [.deb package name]
```

Команда dpkg предоставляет длинный список параметров для настройки данных, которые мы получаем при анализе нашей сети. Вот список некоторых наиболее популярных опций dpkg:

| Вариант          | Функция                                                                                                                                                                                                                   |
|:---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -i ИЛИ --install | Установите пакет с помощью команды dpkg. Команда извлечет все управляющие файлы для указанного пакета, удалит все ранее установленные старые экземпляры пакета и установит новый пакет в нашей системе.                   |
| -r ИЛИ --remove  | Удалите установленный пакет из нашей системы. Он удаляет все файлы, принадлежащие конкретному пакету, кроме файлов конфигурации. Это можно рассматривать как вариант удаления.                                            |
| -P ИЛИ --purge   | Альтернативный способ удалить установленный пакет из нашей системы. Он полностью удаляет все файлы, принадлежащие конкретному пакету, включая файлы конфигурации. Это можно рассматривать как вариант «полного удаления». |
| --update-avail   | Uhe информация команды dpkg о доступных пакетах в ее репозиториях. Если доступны новые пакеты они синхронизируются с официальными репозиториями.                                                                          |
| --merge-avail    | Объедините информацию команды dpkg о доступных пакетах в ее репозиториях с ранее доступной информацией. Обычно она запускается сразу после предыдущей команды.                                                            |
| --help           | Откройте страницу справки для команды dpkg и выйдите.                                                                                                                                                                     |

Это некоторые из наиболее часто используемых параметров команды dpkg, и вы можете узнать больше, отобразив параметры справки в своем терминале. 

**Установка пакета

Самое простое использование команды dpkg в Ubuntu — это установка пакета. Мы можем установить пакет deb в Ubuntu или Debian, используя `dpkg -i` командный вариант.

Вот как вы можете установить пакет.

```
sudo dpkg -i [package name]
```

Вы также можете установить несколько пакетов одновременно, указав имена пакетов, разделенные пробелами.

**Удаление пакета

Когда вам больше не нужна программа или служба в вашей системе, нет смысла ее хранить.

Здесь нам также поможет команда dpkg.

Мы можем удалить программу или службу из нашей системы, используя `dpkg -r`вариант.

Давайте удалим проигрыватель VLC, который мы установили для этой демонстрации.

```
sudo dpkg -r [package name]
```

**Полное удаление пакета debian-cd**

`dpkg -r debian-cd`

`dpkg -P debian-cd


**Обновление ваших репозиториев

В репозитории dpkg хранятся все пакеты, доступные для установки в вашем дистрибутиве Ubuntu или Debian Linux.

Однако, поскольку эти пакеты хранятся локально, у вас часто могут оказаться старые версии пакетов для программы, хотя новые версии уже выпущены. Это вызывает необходимость в методе обновления ваших репозиториев.

Угадай, что? `dpkg --update-avail`опция вас покрыла.

Он проверяет онлайн-репозитории и загружает все обновленные пакеты в ваш локальный репозиторий.

Давайте обновим наши локальные репозитории до последней версии:

```
sudo dpkg --update-avail
```

Установка также может быть произведена в два этапа: сначала распаковка, затем настройка. `apt`использует это в своих интересах, ограничивая количество обращений к `dpkg`( т.к. каждый вызов затратен, из-за загрузки базы в память, особенно списка уже установленных файлов).

**Раздельная распаковка и настройка**

```
dpkg --unpack man-db_2.9.4-2_amd64.deb`

(Reading database ... 227466 files and directories currently installed.) 
Preparing to unpack man-db_2.9.4-2_amd64.deb ...
Unpacking man-db (2.9.4-2) over (2.9.4-2) ... 
Processing triggers for mailcap (3.69) ... 

dpkg --configure man-db

`Setting up man-db (2.9.4-2) ... 
Updating database of manual pages ... 
man-db.service is a disabled or a static unit not running, not starting it.`
```

Команда dpkg устанавливает только указанный пакет без каких-либо зависимостей. В случае, если вы устанавливаете пакет, который требует некоторых зависимостей, вы получите сообщение об ошибке, подобное этому:

>dpkg: error processing package

Кроме того, dpkg не установит пакет и оставит его в ненастраиваемом и сломанном состоянии.

Чтобы устранить эту ошибку, выполните следующую команду в Терминале:

`sudo apt -f install

Эта команда исправит сломанный пакет и установит необходимые зависимости, если они доступны в системном репозитории.

**Проверка установки пакета с помощью Dpkg

Хотя вы можете проверить установку пакета, выполнив поиск в меню Ubuntu. Если он доступен там, это подтверждает, что пакет установлен.

Однако dpkg также позволяет проверить установку пакета. Просто введите dpkg с опцией –status или –s, чтобы проверить установку пакета:

`dpkg --status [ имя-пакета ]


---

## apt (Ubuntu и Debian)



**apt** (от англ. _«**A**dvanced **P**ackage **T**ool»_) — это система управления пакетами, используемая дистрибутивами на базе Debian. В дистрибутивах на базе [**Debian**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/#toc-9) существует несколько инструментов управления пакетами с помощью командной строки, причем наиболее часто используются **apt** и **apt-****get**.

Перед установкой нового пакета сначала необходимо обновить информацию о пакетах:

`$ apt update`

Индекс `apt` — это база данных, содержащая записи доступных в репозиториях пакетов, подключенных в вашей системе.

Чтобы обновить установленные пакеты до последних версий, выполните:

`$ apt upgrade`

Установка пакетов так же проста:

`$ apt install имя_пакета`

Чтобы удалить установленный пакет, введите:

`$ apt remove имя_пакета`

**APT** (**Advanced Packaging Tool**) — это набор утилит командной строки, с помощью которых вы можете взаимодействовать с системой управления пакетов dpkg, применяемой в Debian и других, основанных на Debian, [**дистрибутивах**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/ "Обзор дистрибутивов Linux. Какой выбрать?").

Такие утилиты, как apt, apt-get, apt-cache, apt-config и aptitude (графический интерфейс к APT), взаимодействуют с APT для выполнения различных действий над пакетом (установка, обновление и удаление).  

**Утилита apt

**apt** — это утилита командной строки для установки, обновления и удаления пакетов в Ubuntu, Debian и производных дистрибутивах. Она сочетает в себе функционал apt-get, apt-cache и dpkg. Утилита apt создавалась с намерением исправить недостатки, присутствовавшие в apt-get, и не содержит некоторый функционал утилиты apt-get.  

**Утилита apt-get

**apt-get** — это консольная утилита управления пакетами, которая широко используется в системах на базе Debian. Команда apt-get позволяет устанавливать, обновлять и удалять пакеты. Для поиска новых пакетов применяется команда apt-cache.

apt-get можно рассматривать как более низкоуровневую надстройку для APT.  

**Что не так с apt-get?

Утилита apt-get неэффективна и не имеет определенных функций, которые должны существовать в пакетном менеджере. Например, для установки приложения применяется команда `apt-get install`, но когда вы хотите выполнить поиск нужного пакета, то не получится просто ввести `apt-get search`. Необходимо использовать команду `apt-cache search`.

Аналогично, если вы хотите перечислить все пакеты, установленные в системе, команда будет совершенно другой — `dpkg --get-selections`. Начинающий пользователь просто запутается в них и захочет уйти еще до того, как начнется его [**путешествие по изучению Linux**](https://ravesli.com/uroki-po-linux/ "Уроки по Linux").

Функционал команд, которые заменяет утилита apt, следующий:

   **apt-****get** — используется для установки, обновления и удаления пакетов;

   **apt-****cache** — используется для поиска пакетов;

   **dpkg -l** — используется для перечисления всех пакетов, установленных в системе.

**Как apt решает эту проблему?

Утилита apt объединяет в одной команде функциональные возможности apt-get (включая apt-cache и dpkg), упрощая взаимодействие с APT.

![[Pasted image 20221108055643.png]]


**Получается, apt-get устарел?

Нет никакой официальной информации о прекращении поддержки apt-get. И этого не произойдет в ближайшем будущем, т.к. apt-get по-прежнему предлагает больше функционала, чем apt.

Команда apt-get продолжит использоваться для выполнения всякого рода низкоуровневых операций, написания скриптов и пр. А команда apt просто является более удобной утилитой для конечного пользователя, упрощая взаимодействие с системой Linux.  

**В чем разница между apt и apt-get?

Существует 5 основных различий между apt и apt-get:

   - apt имеет красивую шкалу прогресса;

   - apt отображает список пакетов, которые могут быть обновлены;

   - apt объединяет в себе функции apt-get, apt-cache и dpkg -l;

   - apt имеет новые команды;

   - различный синтаксис команд apt и apt-get.

**apt имеет красивую шкалу прогресса

При установке или удалении пакета с помощью команды apt, отображается шкала прогресса, показывающая в процентах ход выполнения текущей задачи.

**apt отображает список пакетов, которые могут быть обновлены

При обновлении базы данных репозиториев, отображается дополнительная строка с информацией о количестве пакетов, которые могут быть обновлены - команда `sudo apt update`.

После этого вы можете запросить список этих пакетов, выполнив команду `apt list --upgradable`. Обратите внимание на улучшенный цветовой дизайн, помогающий более точно расставить акценты на необходимых вам элементах:

**apt объединяет в себе функции apt-get, apt-cache и dpkg -l

До Ubuntu 16.04 пользователи взаимодействовали с APT, в основном, только через apt-get, apt-config и apt-cache. Эти утилиты поддерживают множество различных дополнительных команд (например, _apt-get install/remove/update/upgrade/help_ и пр.), и пользователи вынуждены были их запоминать. В связи с этим встал вопрос о создании более простого инструмента управления пакетной базой, который бы состоял только из самых необходимых команд.

С выпуском Ubuntu 16.04 и Debian 8 таким инструментом стал apt, объединивший в себе возможности apt-get и apt-cache. Утилита apt более удобна в использовании по сравнению с существующими инструментами из набора APT. Кроме того, теперь вам больше не требуется переключаться между apt-get и apt-cache.

**apt имеет новые команды

Помимо упрощения существующих команд, у apt добавилось несколько новых:

|Команда apt |Назначение команды|
|:----|:----|
|apt list |Вывод списка установленных и доступных для обновления пакетов.|
|apt edit-sources |Редактирование файла /etc/apt/sources.list, содержащего список репозиториев, из которых могут быть скачаны пакеты.|

**Различный синтаксис команд apt и apt-get

Хотя утилита apt и сочетает в себе функционал утилит apt-get и apt-cache, но не все её команды имеют обратную совместимость с apt-get. По этой причине, вы не всегда сможете заменить команду apt-get командой apt. В следующей таблице приведено небольшое сравнение команд apt и apt-get:

|apt |apt-get |Назначение команды|
|:----|:----|:----|
|apt update |apt-get update |Обновление списка доступных пакетов.|
|apt install [имя_пакета] |apt-get install [имя_пакета] |Установка пакета.|
|apt upgrade |apt-get upgrade |Установка более новых версий пакетов.|
|apt full-upgrade |apt-get dist-upgrade |Обновление всех пакетов и удаление ненужных зависимостей.|
|apt remove [имя_пакета] |apt-get remove [имя_пакета] |Удаление пакета.|
|apt purge [имя_пакета] |apt-get purge [имя_пакета] |Полное удаление пакета вместе со всеми его конфигурационными файлами.|
|apt autoremove |apt-get autoremove |Удаление ненужных зависимостей.|
|apt search [имя_пакета] |apt-cache search [имя_пакета] |Поиск пакета по его имени.|
|apt show [имя_пакета] |apt-cache show [имя_пакета] |Вывод информации о пакете.|
|apt policy |apt-cache policy |Вывод информации об используемых репозиториях, а также их приоритете.|
|apt policy [имя_пакета] |apt-cache policy [имя_пакета] |Вывод информации о версии установленного пакета и доступной для обновления версии пакета.|
**Так что же мне следует использовать: apt или apt-get?

Команду apt рекомендуют к использованию сами дистрибутивы Linux. Она предоставляет необходимые возможности для управления пакетами, и её проще использовать из-за меньшего количества опций, которые, тем не менее, легко запоминаются.

Команда apt-get остается активной для обеспечения обратной совместимости и используется в тех специфических случаях, где функционала команды apt не хватает.


---

## dnf (CentOS и Fedora)

**rpm** (сокр. от англ. _«**R**ed Hat **P**ackage **M**anager»_) — это мощная система управления пакетами, используемая в дистрибутивах от [**Red Hat**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/#toc-12) и производных дистрибутивах, таких как: [**CentOS**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/#toc-13) и [**Fedora**](https://ravesli.com/obzor-distributivov-linux-kakoj-vybrat/#toc-14). С rpm также связаны **команда rpm** и _.rpm-_формат пакетов.

Чтобы установить новый пакет в дистрибутивах от Red Hat, вы можете использовать **команду yum** или **dnf**:

`$ dnf install имя_пакета`

Начиная с CentOS 8, `dnf` заменил `yum` в качестве менеджера пакетов по умолчанию, при этом `dnf` обратно совместим с `yum`.

Чтобы обновить установленные пакеты до последних версий, введите:

`$ dnf update`

Удаление пакетов так же просто, как:

`$ dnf remove имя_пакета`

---

# Справка

---

## Параметр help

Большинство команд имеют параметр `--help`, при помощи которого выводится короткое сообщение о том, как использовать указанную команду:

`$ имя_команды --help`

---

## Команда man

Почти все команды в Linux распространяются вместе с **_man_**-страницами (от англ. _«**man**ual»_) — документацией, которая объясняет, что делает команда, приводит примеры того, как следует применять команду и какие параметры и опции она поддерживает.

**Команда man** применяется для отображения страницы руководства по заданной команде:

`$ man имя_команды`

Например, чтобы открыть главную страницу справки по команде `cd`, вы должны ввести:

`$ man cd`

Для навигации по справочным страницам используйте клавиши со стрелочками вверх и вниз. Также вы можете нажать:

   клавишу `Enter` для перемещения на одну строку за раз;

   клавишу  (_Пробел_) для перехода к следующему экрану;

   клавишу `b` для возврата на один экран назад;

   клавишу `q` для выхода из справочной страницы.

---

## Команда history

Если вы используете Linux в течение определенного периода времени, вы быстро заметите, что можете выполнять десятки (если не сотни) команд каждый день. Таким образом, запуск **команды** **history** особенно полезен, если вы хотите просмотреть ранее введенные команды:

`$ history`

---

## Команда whereis

**Команда** **whereis** отображает полный путь к исполняемому файлу программы (или к исходным файлам, если они присутствуют в системе). Например:

`$ whereis gcc`

Результат:

`gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc`

---

## Команда whatis

Это команда, которая помогает получить краткое объяснение любой командной строки. Он просматривает руководства по всем командам и отображает краткое описание данного ключевого слова. Мы рассмотрели использование команды «whatis» и ее нескольких опций.

Страницы man являются одним из самых полезных ресурсов, когда дело доходит до понимания утилит командной строки. Однако на странице руководства содержится много информации о команде. Могут быть моменты, когда вы хотите быстро узнать – может быть в небольшой строке или около того – что делает инструмент командной строки. Хорошо, вы будете рады узнать, что существует команда whatis, специально построенная для этой цели. 

**Синтаксис:

Синтаксис команды «whatis»:

>whatis [ command ]

**Как использовать команду whatis:

Если вы хотите узнать о какой-либо команде в Linux, введите имя инструмента или команды в качестве параметра:

``$ whatis cp

**Как получить информацию о нескольких командах:

Если вы хотите узнать подробности о нескольких командах одновременно, введите все имена в качестве входных данных:

``$ whatis ps rm touch mv more mkdir

---
