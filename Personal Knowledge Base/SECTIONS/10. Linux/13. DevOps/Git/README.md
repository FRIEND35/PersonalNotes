# Источники

- https://proglib.io/p/git-for-half-an-hour
- https://selectel.ru/blog/tutorials/git-setup-and-common-commands/
- https://javarush.com/groups/posts/2683-nachalo-rabotih-s-git-podrobnihy-gayd-dlja-novichkov
- https://losst.pro/kak-polzovatsya-git-dlya-nachinayushhih
- https://www.w3schools.com/git/default.asp?remote=github
- https://www.tutorialspoint.com/git/index.htm
- https://www.javatpoint.com/git
- https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/GitHub-SSH-Key-Setup-Config-Ubuntu-Linux
- https://bard.google.com/
- https://docs.github.com/en/authentication/connecting-to-github-with-ssh/about-ssh
- https://www.freecodecamp.org/news/git-ssh-how-to/
- https://jdblischak.github.io/2014-09-18-chicago/novice/git/05-sshkeys.html
- https://selectel.ru/blog/tutorials/how-to-generate-ssh/

# Введение

Git — это система контроля версий, которая позволяет отслеживать изменения в файлах и каталогах. Это похоже на то, как если бы вы хранили снимки вашего рабочего стола в течение определенного времени. Если вы что-то испортили, вы можете вернуться к более ранней версии.

Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.

Для чего он нужен? Ну во-первых, чтобы отследить изменения, произошедшие с проектом, со временем. Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать. Часто бывают ситуации, когда, во вполне себе работающий код, вам нужно внести определенные правки или улучшить какой-то функционал, по желанию заказчика. Однако после внедрения нововведений, вы с ужасом понимаете, что все сломалось. У вас начинается судорожно дергаться глаз, а в воздухе повисает немой вопрос: “Что делать?” Без системы контроля версий, вам надо было бы долго напряженно просматривать код, чтобы понять как было до того, как все перестало работать. С Гитом же, все что нужно сделать - это откатиться на коммит назад.

Во-вторых он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github и bitbucket.

Вот несколько основных понятий Git:

- **Репозиторий:** Это место, где хранятся ваши файлы и история изменений. Вы можете создать локальный репозиторий на своем компьютере или удаленный репозиторий на сервере.

- **Файлы:** Это то, что вы хотите отслеживать. Вы можете отслеживать как отдельные файлы, так и каталоги.

- **Коммиты:** Это отдельные точки в истории изменений. Каждый коммит представляет собой набор изменений, которые вы сделали в своих файлах.

- **Ветки:** Это ветви истории изменений. Вы можете создавать ветки для отслеживания различных версий проекта или для экспериментов.Ветки в Git - это версии вашего проекта, которые развиваются независимо друг от друга. Когда вы создаете новую ветку, вы можете вносить изменения в проект, не затрагивая основную версию. Позже вы можете объединить изменения из ветки обратно в основную версию. Это позволяет удобно управлять различными функциями и исправлениями в проекте.

Git используется в различных целях, включая:

- **Управление проектами:** Git может помочь вам отслеживать изменения в проекте и управлять версиями программного обеспечения.
- **Сотрудничество:** Git позволяет нескольким людям работать над одним и тем же проектом одновременно.
- **Восстановление:** Git позволяет вам восстановить проект из более ранней версии в случае возникновения проблем.

Git — это мощный инструмент, который может быть полезен для любого, кто работает с файлами. Если вы хотите узнать больше о Git, вы можете найти множество ресурсов в Интернете и в библиотеках.

**Git — это инструмент, который помогает вам отслеживать изменения в файлах и каталогах.**

Представьте, что вы пишете код для программы. Вы работаете над ним несколько недель, и постепенно вносите в него изменения. В какой-то момент вы можете обнаружить, что сделали ошибку, или что вам нужно вернуться к более ранней версии кода.

Git позволяет вам делать это, сохраняя историю изменений ваших файлов. Каждый раз, когда вы вносите изменение в файл, Git сохраняет новую версию этого файла. Вы можете просматривать историю изменений, чтобы увидеть, что вы изменили, и вернуться к любой из предыдущих версий.

Вот как это работает:

- **Вы создаете репозиторий Git.** Репозиторий — это место, где хранятся ваши файлы и история изменений.
- **Вы добавляете файлы в репозиторий.** Git будет отслеживать изменения, которые вы вносите в эти файлы.
- **Вы делаете коммит.** Коммит — это точка в истории изменений. Каждый коммит представляет собой набор изменений, которые вы сделали в своих файлах.

Чтобы вернуться к более ранней версии файла, вы можете выполнить `git checkout`. Это вернет ваш файл к состоянию, в котором он был в момент совершения указанного вами коммита.

**Git также может использоваться для совместной работы над проектами.** Если вы работаете с другими людьми над одним и тем же проектом, вы можете использовать Git для совместной работы над изменениями.

Вот как это работает:

- **Вы создаете удаленный репозиторий.** Удаленный репозиторий — это репозиторий, который находится на сервере.
- **Вы отправляете свои изменения в удаленный репозиторий.** Другие люди могут затем загрузить ваши изменения из удаленного репозитория.

**Git — это мощный инструмент, который может быть полезен для любого, кто работает с файлами.** Он может помочь вам отслеживать изменения в ваших проектах, сотрудничать с другими людьми и восстанавливать проекты из более ранних версий.

Вот несколько конкретных примеров того, как можно использовать Git:

- **Вы можете использовать Git для отслеживания изменений в своем веб-сайте.** Это может помочь вам вернуть сайт к состоянию, в котором он был до того, как вы что-то испортили.
- **Вы можете использовать Git для совместной работы над проектом с друзьями или коллегами.** Это может помочь вам избежать конфликтов и обеспечить согласованность изменений.
- **Вы можете использовать Git для хранения резервных копий своих файлов.** Это может помочь вам восстановить файлы в случае потери или повреждения.

# Установка

Установить git на свою машину очень просто:

Linux — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть следующим образом:

```bash
sudo apt-get install git
```

Windows — мы рекомендуем git for windows, так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.
OS X — проще всего воспользоваться homebrew. После его установки запустите в терминале:

```bash
brew install git
```

Если вы новичок, клиент с графическим интерфейсом(например GitHub Desktop и Sourcetree) будет полезен, но, тем не менее, знать команды очень важно.

# Настройка 

Итак, мы установили git, теперь нужно добавить немного настроек. Есть довольно много опций, с которыми можно играть, но мы настроим самые важные: наше имя пользователя и адрес электронной почты. Откройте терминал и запустите команды:

```bash
git config --global user.name "My Name"
git config --global user.email myEmail@example.com
```

Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.  

Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.  

Для того, чтобы посмотреть все настройки системы, используйте команду:

```bash
git config --list
```

Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом, для этого нужно прописать в консоли:

```bash
git config --global color.ui true
git config --global color.status auto
git config --global color.branch auto
```

Если вы не до конца настроили систему для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, если тот запутался, например:

1. Команда git --help - выводит общую документацию по git
2. Если введем git log --help - он предоставит нам документацию по какой-то определенной команде (в данном случае это - log)
3. Если вы вдруг сделали опечатку - система подскажет вам нужную команду
4. После выполнения любой команды - отчитается о том, что вы натворили
5. Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше

Тут стоит отметить, что подсказывать система будет на английском, но не волнуйтесь, со временем вы изучите несложный алгоритм ее работы и будете разговаривать с ней на одном языке.

# Создание нового репозитория

Как мы отметили ранее, git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.  

Создайте на рабочем столе папку под названием git_exercise. Для этого в окне терминала введите:

```bash
mkdir Desktop/git_exercise/
cd Desktop/git_exercise/
```

## Инициализировать Git

Перейдя в нужную папку, вы можете инициализировать Git в этой папке:

```bash
git init
```

Командная строка должна вернуть что-то вроде:

```
Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/
```

Это значит, что наш репозиторий был успешно создан, но пока что пуст. Теперь создайте текстовый файл под названием hello.txt и сохраните его в директории git_exercise.

>**Примечание.** Теперь Git знает, что ему следует следить за папкой, в которой вы его инициировали.
>
Git создает скрытую папку для отслеживания изменений.

# Определение состояния

status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск git status на нашем свежесозданном репозитории должен выдать:

```bash
git status
```

Вывод юудет вот таким:

```
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
```

Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

# Подготовка файлов

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой commit.  
В нашем случае у нас только один файл, так что добавим его:

```bash
git add hello.txt
```

Если нам нужно добавить все, что находится в директории, мы можем использовать

```bash
git add -A
```

Все три команды имеют одинаковую функцию

```bash
git add -A
git add --all
git add .
```

Проверим статус снова, на этот раз мы должны получить другой ответ:

```bash
git status
```

Вывод:

```
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt
```

Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

# Фиксация изменений

Git отслеживает изменения с помощью коммитов. Когда вы вносите изменения в файлы в своем репозитории, Git позволяет вам добавить эти изменения в индекс с помощью команды "git add". Затем, когда вы готовы сохранить эти изменения, вы делаете коммит с помощью команды "git commit".

Когда вы делаете коммит, Git сохраняет состояние всех измененных файлов в этот момент времени. Этот коммит получает уникальный идентификатор, который вы можете использовать, чтобы вернуться к этому состоянию в будущем.

Давайте рассмотрим пример. У вас есть файл "index.html" в вашем репозитории, и вы вносите изменения, добавляете новые строки кода и удаляете некоторые другие. После того, как вы добавили изменения в индекс с помощью "git add", вы делаете коммит с помощью "git commit". Теперь Git сохранит это состояние файла "index.html" в виде коммита, и вы сможете вернуться к этому состоянию в любой момент времени.

Таким образом, Git отслеживает изменения с помощью коммитов, позволяя вам сохранять и возвращаться к различным состояниям вашего проекта.

Git отслеживает изменения в файлах с помощью своей внутренней структуры данных, называемой "снимками" (snapshots). Когда вы создаете коммит, Git фиксирует текущее состояние всех файлов в репозитории, сохраняя их снимок. Это позволяет Git отслеживать, какие конкретно изменения были внесены в каждом файле.

Когда вы вносите изменения в файлы и выполняете команду git add, Git добавляет эти изменения в "индекс" (index), который представляет собой промежуточную область, где вы указываете Git, какие изменения должны быть включены в следующий коммит. Когда вы создаете коммит с помощью команды git commit, Git фиксирует состояние файлов из индекса и сохраняет их снимок в своей базе данных. Это позволяет отслеживать историю изменений, восстанавливать предыдущие версии файлов и сравнивать различные версии кода.

Кроме того, Git использует хеш-суммы для отслеживания изменений. Каждый коммит имеет уникальный хеш, который зависит от содержимого коммита. Это позволяет Git эффективно определять изменения между коммитами и обеспечивать целостность данных. 

Давайте представим, что ваш проект - это книга, а Git - это ваш личный редактор. Каждый раз, когда вы вносите изменения в свою книгу, вы говорите редактору: "Пожалуйста, запиши эти изменения". Редактор пишет их на отдельном листе бумаги, чтобы не испортить оригинал.

Когда вы решаете, что глава книги готова, вы говорите редактору: "Пожалуйста, добавь эту главу в книгу". Редактор берет изменения с листа бумаги и вставляет их в книгу.

Когда вы заканчиваете работу над книгой, редактор делает копию окончательной версии книги и кладет ее в специальный архив, чтобы вы могли всегда вернуться к этой версии, если что-то пойдет не так.

Теперь давайте посмотрим на пример с использованием Git:

1. Вы вносите изменения в файлы вашего проекта.
2. Вы говорите Git: "Пожалуйста, добавь эти изменения в индекс".
3. Затем вы говорите Git: "Пожалуйста, создай коммит с этими изменениями".
4. Git сохраняет этот коммит в своей базе данных, как окончательную версию вашего проекта.

Теперь у вас есть возможность вернуться к предыдущим версиям проекта или сравнить изменения между разными версиями.

## Как сделать коммит

В терминологии программирования "commit" означает сохранение изменений в репозитории контроля версий, таком как Git. Когда разработчик выполняет "commit", он фиксирует текущее состояние файлов в репозитории, делая их доступными для других членов команды. Это также создает точку восстановления, которая позволяет вернуться к предыдущему состоянию проекта, если это необходимо.

При выполнении коммита разработчик обычно добавляет краткое описание того, что было изменено или добавлено. Это сообщение коммита помогает другим членам команды и будущим разработчикам понять суть внесенных изменений.

Коммиты также играют важную роль в отслеживании истории изменений проекта. Поскольку каждый коммит сохраняет состояние файлов на определенный момент времени, разработчики могут просматривать и анализировать изменения, которые были внесены в проект на различных этапах его развития.

В целом, "commit" является важной частью процесса разработки программного обеспечения, обеспечивая контроль версий, отслеживание изменений и сотрудничество в команде разработчиков.

Представим, что нам нужно добавить пару новых блоков в html-разметку (index.html) и стилизовать их в файле style.css. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды git add, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:

```bash
git add index.html
```

```bash
git add css/style.css
```

или вместе - всё сразу:

```bash
git add .
```

Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды

```bash
git reset:
```

```bash
git reset css/style.css
```

Теперь создадим непосредственно сам коммит

```bash
git commit -m 'Add some code'
```

Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

Поскольку мы завершили нашу работу, мы готовы перейти `stage`к `commit` нашему репо.

Добавление коммитов позволяет отслеживать наш прогресс и изменения во время работы. Git учитывает каждую `commit`точку изменения или «точку сохранения». Это точка в проекте, к которой вы можете вернуться, если обнаружите ошибку или захотите внести изменения.

Когда мы `commit`, мы **всегда** должны включать **сообщение** .

Добавляя четкие сообщения к каждому элементу `commit`, вы (и другие) сможете легко увидеть, что и когда изменилось.

```shell
git commit -m "First release of Hello World!"
[master (root-commit) 221ec6e] First release of Hello World!
 3 files changed, 26 insertions(+)
 create mode 100644 README.md
 create mode 100644 bluestyle.css
 create mode 100644 index.html
```

Команда `commit` выполняет фиксацию и добавляет сообщение.`-m "_message_"`

Промежуточная среда была добавлена ​​в наш репозиторий с сообщением:  `«First release of Hello World!»

## Как посмотреть коммиты

Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:

```bash
git log
```

В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :

```bash
git show [hash_commit]
```

Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:

```bash
git commit --amend -m 'Новый комментарий'
```

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

# Github

## Удаленные репозитории

Сейчас наш коммит является локальным — существует только в директории .git на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

### Что такое удаленный репозиторий

Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.  
Клонирование  
Клонирование - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него. В нашем руководстве мы будем использовать адрес https://github.com/tutorialzine/awesome-project, но вам посоветуем, попробовать создать свой репозиторий в GitHub, BitBucket или любом другом сервисе:

```bash
git clone https://github.com/tutorialzine/awesome-project
```

При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория .git, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию, например:

```bash
git clone https://github.com/tutorialzine/awesome-project new-folder
```

### Подключение к удаленному репозиторию

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.  

Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

```
# This is only an example. Replace the URI with your own repository address.
```

```bash
git remote add origin https://github.com/tutorialzine/awesome-project.git
```

Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

```shell
git remote add origin https://github.com/w3schools-test/hello-world.git
```

`git remote add origin _URL_`указывает, что вы добавляете удаленный репозиторий с указанным `URL`в качестве `origin`локального репозитория Git.

Теперь мы собираемся перенести нашу главную ветку на исходный URL-адрес и установить ее в качестве удаленной ветки по умолчанию:


```shell
git push --set-upstream origin master
Enumerating objects: 22, done.
Counting objects: 100% (22/22), done.
Delta compression using up to 16 threads
Compressing objects: 100% (22/22), done.
Writing objects: 100% (22/22), 92.96 KiB | 23.24 MiB/s, done.
Total 22 (delta 11), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (11/11), done.
To https://github.com/w3schools-test/hello-world.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
```

>**Примечание.** Поскольку вы подключаетесь к GitHub впервые, вы получите какое-то уведомление для аутентификации этого соединения.

Теперь вернитесь в GitHub и убедитесь, что репозиторий обновлен.

### Отправка изменений на сервер

Давайте попробуем внести некоторые изменения в наш локальный git и отправить их на GitHub. Сначло вносим изминение, после зафиксируем изминение (закоммитем его) - Зафиксируйте изменения:

```bash
git commit -a -m "Updated file что-то что-то"
```

И проверьте статус:

```bash
git status
```

Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.  

Теперь отправьте наши изменения в наш удаленный источник. Команда, предназначенная для этого - push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).

```bash
git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
```

Эта команда немного похожа на git fetch, с той лишь разницей, что при помощи fetch мы импортируем коммиты в локальную ветку, а применив push, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте git remote. Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. 

А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать git push - командой выгрузки, а git pull и git fetch - командами загрузки или скачивания. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния git merge.  

В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл hello.txt

### Проверка логов 

Чтобы показать логи:

```bash
git log
```

Определённой репозиторий (в нашем случае origin):

```bash
git log origin/master
```

Показать последное изминение:

```bash
git log origin/master HEAD
```

### Запрос изменений с сервера

Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды pull.

`pull`представляет собой комбинацию `fetch`и `merge`. Он используется для переноса всех изменений из удаленного репозитория в ветку, над которой вы работаете.

```bash
git pull origin master
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.
```

Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

Используйте `pull`для обновления нашего локального Git:

```shell
git pull origin
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 794 bytes | 1024 bytes/s, done.
From https://github.com/w3schools-test/hello-world
   a7cdd4b..ab6b4ed  master       -> origin/master
Updating a7cdd4b..ab6b4ed
Fast-forward
 README.md | 2 ++
 1 file changed, 2 insertions(+)
```

Таким образом вы обновляете свой локальный Git из удаленного репозитория. В следующей главе мы подробнее рассмотрим, как `push`работает GitHub.

**Возврат к более ранней версии**

Чтобы вернуться к более ранней версии файла, выполните следующую команду:

```bash 
git checkout <коммит> <файл>
```

Эта команда вернет файл к состоянию, в котором он был в момент совершения указанного вами коммита.

**Сотрудничество над проектом**

Чтобы сотрудничать над проектом с другими людьми, вам необходимо создать удаленный репозиторий. Удаленный репозиторий — это репозиторий, который находится на сервере.

Чтобы создать удаленный репозиторий, выполните следующую команду:

```bash
git remote add <имя> <URL>
```

Эта команда создаст новый удаленный репозиторий с указанным именем и URL-адресом.

Чтобы отправить свои изменения в удаленный репозиторий, выполните следующую команду:

```bash
git push <имя> <ветка>
```

Эта команда отправит указанные ветви в удаленный репозиторий.

Чтобы загрузить изменения из удаленного репозитория, выполните следующую команду:

```bash
git pull <имя> <ветка>
```

Эта команда загрузит указанные ветви из удаленного репозитория.

**Дополнительные команды**

Вот некоторые дополнительные команды Git, которые могут быть вам полезны:

- `git status` — показывает текущий статус репозитория.
- `git diff` — показывает различия между двумя версиями файла.
- `git stash` — позволяет сохранить локальные изменения, чтобы вы могли вернуться к ним позже.
- `git reset` — позволяет отменить изменения, сделанные в локальном репозитории.
## Как удалить локальный репозиторий

Вам не понравился один из ваших локальных Git-репозиториев и вы хотите стереть его со своей машины. Для этого вам всего лишь надо удалить скрытую папку «.git» в корневом каталоге репозитория. Сделать это можно 3 способами:

1. Проще всего вручную удалить эту папку «.git» в корневом каталоге «Git Local Warehouse».
2. Также удалить, не устраивающий вас, репозиторий можно на github. Открываете нужный вам объект и переходите в пункт меню Настройки. Там, прокрутив ползунок вниз, вы попадете в зону опасности, где один из пунктов будет называться «удаление этого хранилища».
3. Последний метод удаления локального хранилища через командную строку, для этого в терминале необходимо ввести следующую команду:

```
cd repository-path/
rm -r .git
```

# Ветвление

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

- Уже рабочая, стабильная версия кода сохраняется.
- Различные новые функции могут разрабатываться параллельно разными программистами.
- Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
- В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

## Создание новой ветки

Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch `<name>

```bash
git branch amazing_new_feature
```

Это создаст новую ветку, пока что точную копию ветки master.

## 2. Переключение между ветками

Сейчас, если мы запустим branch, мы увидим две доступные опции:

```bash
git branch
amazing_new_feature
* master
```

master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.

```bash
git checkout amazing_new_feature
```

В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды git stash, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

## Слияние веток

Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:

```bash
git add feature.txt
git commit -m "New feature complete.”
```

Изменения завершены, теперь мы можем переключиться обратно на ветку master.

```bash
git checkout master
```

Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла feature.txt, потому что мы переключились обратно на ветку master, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться merge для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта).

```bash
git merge amazing_new_feature
```

Теперь ветка master актуальна. Ветка amazing_new_feature больше не нужна, и ее можно удалить.

```bash
git branch -d awesome_new_feature
```

Если хотите создать копию удаленного репозитория - используйте git clone. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните следующую команду в соответствующем репозитории:


```bash
git checkout -b <имя ветки> origin/<имя ветки>
```

После этого, новая ветка создается на машине автоматически.

# Как удалять ветки в Git?

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?  
Для локально расположенных веток существует команда:

```bash
git branch -d local_branch_name
```

где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а local_branch_name – название ненужной нам ветки.  
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:

```
Error: Cannot delete branch local_branch_name checked out at название_директории
```

Так что при удалении ветвей, обязательно переключитесь на другой branch.

# Дополнительно

В последней части этого руководства мы расскажем о некоторых дополнительных трюках, которые могут вам помочь.

## 1. Отслеживание изменений, сделанных в коммитах

У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду log:  


```bash
git log
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date: Mon May 30 17:15:28 2016 +0300
New feature complete
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date: Sat May 28 17:52:14 2016 +0300
Initial commit
```


Как вы можете заметить, идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой show [commit]  


```bash
git show b10cc123
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
```


Чтобы увидеть разницу между двумя коммитами, используется команда diff (с указанием промежутка между коммитами):  


```bash
git diff 09bd8cc..ba25c0ff
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
```


Мы сравнили первый коммит с последним, чтобы увидеть все изменения, которые были когда-либо сделаны. Обычно проще использовать git difftool, так как эта команда запускает графический клиент, в котором наглядно сопоставляет все изменения.

## 2. Возвращение файла к предыдущему состоянию

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой checkout, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).  
В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:

```bash
git checkout 09bd8cc1 hello.txt
```

## 3. Исправление коммита

Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.  
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.  
Самый последний коммит может быть доступен по алиасу HEAD:

```bash
git revert HEAD
```

Для остальных будем использовать идентификаторы:

```bash
git revert b10cc123
```

При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

## 4. Разрешение конфликтов при слиянии

Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.  
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.  
Джон использует цикл:

```
// Use a for loop to console.log contents.
for(var i=0; i<arr.length; i++) {
console.log(arr[i]);
}
```

Тим предпочитает forEach:

```
// Use forEach to console.log contents.
arr.forEach(function(item) {
console.log(item);
});
```

Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

```bash
git merge tim_branch
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
```

Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:  


```
<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.
```


Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

```
// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());
```

Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

```bash
git add -A
git commit -m "Array printing conflict resolved."
```

Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).

## 5. Настройка .gitignore

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

1. Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
2. Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
3. Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

Вот хорошие примеры файлов, которые нужно игнорировать:

- Логи
- Артефакты систем сборки
- Папки node_modules в проектах node.js
- Папки, созданные IDE, например, Netbeans или IntelliJ
- Разнообразные заметки разработчика.

Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:

```
*.log
build/
node_modules/
.idea/
my_notes.txt
```

Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

# Git bash и git.io

Руководствуясь часто встречающимися, при изучении системы, вопросами новичков, разберем еще несколько непонятных словосочетаний.

- Git Bash(Bourne Again Shell) — это приложение, являющееся эмулятором командной строки и предоставляющее, операционной системе, некоторые распространенные утилиты bash и собственно саму систему Git. Это терминал, используемый для взаимодействия с персональным компьютером, посредством письменных команд.
- URL-адреса хранилищ на Гитхабе могут быть довольно длинными, из-за больших имен репозиториев и файлов. Работать с такими ссылками очень не удобно. Поэтому сайт github.io создал git.io — неплохой сервис по преобразованию этих длинных и беспорядочных URL-адресов в более короткие и понятные. Сайт был создан в 2011 году и вплоть до недавнего времени отлично справлялся со своими обязанностями. Однако в начале этого года компания Гитхаб, из-за участившихся попыток хакеров использовать сайт в злонамеренных целях, остановила работу сервиса, а чем известила пользователей в [своем блоге](https://github.blog/changelog/2022-01-11-git-io-no-longer-accepts-new-urls/). Разработчики популярного ресурса рекомендуют пользоваться другими URL-cutter’ами, пока работа сервиса не будет налажена.

# Допустим ты работаешь

А теперь давай представим, что ты работаешь в большой компании. Тут тебе скорее всего придется стянуть проект себе на комп. Ты сделаешь это при помощи команды:

```bash
git clone
```

С указанием адреса удаленного репозитория, того самого, где режет код проекта. И тут тебе уже придется работать с ветками. После клонирования у тебя будут доступны все ветки проекта, а по умолчанию ты будешь находиться в главной. Чтобы создать новую используя команду:

```bash
git branch <имя ветки>
```

а затем чтобы переключиться на нее:

```bash
git checkout <имя ветки>
```

А вот после того как ты все сделал кажется что нужно использовать команду **`git merge <имя ветки>`** чтобы слить все твои изменения в главную ветку. Во-Во, cтоп а поддержи коней их приличном обществе так не делают. А как делают? Смотря кто спрашивает, я спрашиваю, а ты кто? Смотря кто спрашивает. Простите заговорился.

Так дело в том, что обычно перед тем, как вливать код, нужно пройти **`code review`**. Это когда другие разработчики проверяют код, который ты написал на предмет ошибок. В соответствии стандартам и могут предлагать свои доработки. Так вот, чтобы пройти **`code review`**, тебе сначала нужно сделать так называемый **`PULL EWQUESTS`**. Иногда он называется **`MERGE REQUESTS`**, но суть лягушенок одна и та же.
# Заключение

Вот и все! Наше руководство окончено. Мы очень старались собрать всю самую важную информацию и изложить ее как можно более сжато и кратко.  
Git довольно сложен, и в нем есть еще много функций и трюков. Если вы хотите с ними познакомиться, вот некоторые ресурсы, которые мы рекомендуем:

- Официальная документация, включающая книгу и видеоуроки – [тут](https://git-scm.com/doc).
- “Getting git right” – Коллекция руководств и статей от Atlassian – [тут](https://www.atlassian.com/git).
- Список клиентов с графическим интерфейсом – [тут](https://www.git-scm.com/downloads/guis).
- Онлайн утилита для генерации .gitignore файлов – [тут](https://www.gitignore.io/).

Это лишь краткое введение в Git. Для получения более подробной информации вы можете обратиться к официальной документации Git или к одному из многих обучающих ресурсов, доступных в Интернете.